From bd7ed4ade9bf7cbf1c42432585a213ff336d1397 Mon Sep 17 00:00:00 2001
From: Felicitas Pojtinger <felicitas@pojtinger.com>
Date: Fri, 17 Oct 2025 20:48:29 -0700
Subject: [PATCH] GIR: Rework lookup logic to instead rely on name resolution in `findSo` etc.

Signed-off-by: Felicitas Pojtinger <felicitas@pojtinger.com>
---
diff --git a/internal/core/core.go b/internal/core/core.go
index ac276334bc2a456a04d5e784302389fcaed0614d..7fdb6b424648667850d50640fd8bb8174aaedf90 100644
--- a/internal/core/core.go
+++ b/internal/core/core.go
@@ -65,25 +65,26 @@ 		names[libName] = sharedLibs
 	}
 }
 
-// findSo tries to find a shared object from a path and a library name
-// It does this by mapping the library name to a suitable shared object filename and then trying some suffixes
-func findSo(path string, name string) string {
+// findSos tries to find all shared objects from a path and a library name
+// It does this by mapping the library name to all suitable shared object filenames and then trying some suffixes
+func findSos(path string, name string) []string {
+	sos := []string{}
 	for _, n := range names[name] {
 		suffixes := []string{"", ".0", ".1", ".2"}
 		fn := filepath.Join(path, n)
 		for _, s := range suffixes {
 			if _, err := os.Stat(fn + s); err == nil {
-				return fn + s
+				sos = append(sos, fn+s)
 			}
 		}
 	}
-	return ""
+	return sos
 }
 
-// findPkgConf finds a shared object file with pkg-config
+// findPkgConf finds all shared object files with pkg-config
 // it does this by running pkg-config --libs-only-L libname
-// and then it loops over the directories returned and finds a suitable one
-func findPkgConf(name string) string {
+// and then it loops over the directories returned and finds all suitable ones
+func findPkgConf(name string) []string {
 	cmd := exec.Command("pkg-config", "--libs-only-L", pkgConfNames[name])
 	var out, outerr bytes.Buffer
 	cmd.Stdout = &out
@@ -91,7 +92,7 @@ 	cmd.Stderr = &outerr
 	err := cmd.Run()
 	if err != nil {
 		fmt.Fprintf(os.Stderr, "pkg-config, failed with: %v and stderr: %s\n", err, outerr.String())
-		return ""
+		return []string{}
 	}
 	outs := strings.Split(out.String(), "-L")
 	for _, v := range outs {
@@ -99,15 +100,15 @@ 		c := strings.TrimSpace(v)
 		if c == "" {
 			continue
 		}
-		g := findSo(c, name)
-		if g != "" {
+		g := findSos(c, name)
+		if len(g) > 0 {
 			return g
 		}
 	}
-	return ""
+	return []string{}
 }
 
-// getPath gets a shared object file from a library name
+// GetPaths gets all shared object files from a library name
 // it does it in the following order
 // see if PUREGOTK_LIBNAME_PATH is set (full path to the lib)
 // - e.g. PUREGOTK_GTK_PATH
@@ -117,18 +118,18 @@ // find a library name with pkg-config
 // panic if failed
 // TODO: Hardcore a library shared object with linker -X flag
 // This is useful for packaging
-func getPath(name string) string {
+func GetPaths(name string) []string {
 	// try to get from env var
 	ev := fmt.Sprintf("PUREGOTK_%s_PATH", name)
 	if v := os.Getenv(ev); v != "" {
-		return v
+		return []string{v}
 	}
 
 	// Or if a general folder is set where everywhere is located, return that
 	ep := os.Getenv("PUREGOTK_LIB_FOLDER")
 	if ep != "" {
-		g := findSo(ep, name)
-		if g == "" {
+		g := findSos(ep, name)
+		if len(g) == 0 {
 			panic(fmt.Sprintf("Could not find lib: %s, at path: %s with env: %s", name, ep, "PUREGOTK_FOLDER"))
 		}
 		return g
@@ -139,8 +140,8 @@ 	gp, ok := paths[runtime.GOARCH]
 	if ok {
 		// try to loop over paths
 		for _, p := range gp {
-			g := findSo(p, name)
-			if g != "" {
+			g := findSos(p, name)
+			if len(g) > 0 {
 				return g
 			}
 
@@ -148,7 +149,7 @@ 		}
 	}
 	// last effort: pkg-config
 	g := findPkgConf(name)
-	if g != "" {
+	if len(g) > 0 {
 		return g
 	}
 
@@ -172,68 +173,3 @@ 		length++
 	}
 	return string(unsafe.Slice((*byte)(ptr), length))
 }
-
-// GetPaths gets all shared object file paths for a library name that may have multiple libraries.
-// This is used when a package needs to load multiple shared libraries (e.g., GLIB needs both libgobject and libglib).
-// Returns a slice of full paths to all libraries for this package.
-func GetPaths(name string) []string {
-	libNames, ok := names[name]
-	if !ok || len(libNames) == 0 {
-		// Fallback to single GetPath for backward compatibility
-		return []string{getPath(name)}
-	}
-
-	// If only one library, use the original GetPath logic
-	if len(libNames) == 1 {
-		return []string{getPath(name)}
-	}
-
-	var result []string
-	for _, libName := range libNames {
-		// Try PUREGOTK_LIB_FOLDER first
-		ep := os.Getenv("PUREGOTK_LIB_FOLDER")
-		if ep != "" {
-			suffixes := []string{"", ".0", ".1", ".2"}
-			found := false
-			for _, s := range suffixes {
-				fullPath := filepath.Join(ep, libName+s)
-				if _, err := os.Stat(fullPath); err == nil {
-					result = append(result, fullPath)
-					found = true
-					break
-				}
-			}
-			if found {
-				continue
-			}
-		}
-
-		// Try hardcoded paths
-		gp, pathsOk := paths[runtime.GOARCH]
-		if pathsOk {
-			found := false
-			for _, p := range gp {
-				suffixes := []string{"", ".0", ".1", ".2"}
-				fn := filepath.Join(p, libName)
-				for _, s := range suffixes {
-					if _, err := os.Stat(fn + s); err == nil {
-						result = append(result, fn+s)
-						found = true
-						break
-					}
-				}
-				if found {
-					break
-				}
-			}
-			if found {
-				continue
-			}
-		}
-
-		// If we get here, we couldn't find this library
-		panic(fmt.Sprintf("Path for library %s (package %s) not found. Please set PUREGOTK_LIB_FOLDER or ensure the library is in standard paths", libName, name))
-	}
-
-	return result
-}

