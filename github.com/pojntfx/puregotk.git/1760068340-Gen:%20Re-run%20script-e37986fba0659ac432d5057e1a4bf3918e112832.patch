From e37986fba0659ac432d5057e1a4bf3918e112832 Mon Sep 17 00:00:00 2001
From: Felicitas Pojtinger <felicitas@pojtinger.com>
Date: Thu, 09 Oct 2025 20:52:20 -0700
Subject: [PATCH] Gen: Re-run script

Signed-off-by: Felicitas Pojtinger <felicitas@pojtinger.com>
---
diff --git a/v4/adw/adw-about-dialog.go b/v4/adw/adw-about-dialog.go
index a8094c9383c0cfa7066b169ebdf752737e3b6b1d..cbdad8b9d618bf92437988e21bc22400d7accd0a 100644
--- a/v4/adw/adw-about-dialog.go
+++ b/v4/adw/adw-about-dialog.go
@@ -962,6 +962,488 @@ func (c *AboutDialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The name of the application icon.
+//
+// The icon is displayed at the top of the main page.
+
+func (x *AboutDialog) SetPropertyApplicationIcon(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("application-icon", &v)
+}
+
+func (x *AboutDialog) GetPropertyApplicationIcon() string {
+	var v gobject.Value
+	x.GetProperty("application-icon", &v)
+	return v.GetString()
+}
+
+// The name of the application.
+//
+// The name is displayed at the top of the main page.
+
+func (x *AboutDialog) SetPropertyApplicationName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("application-name", &v)
+}
+
+func (x *AboutDialog) GetPropertyApplicationName() string {
+	var v gobject.Value
+	x.GetProperty("application-name", &v)
+	return v.GetString()
+}
+
+// The list of artists of the application.
+//
+// It will be displayed on the Credits page.
+//
+// Each name may contain email addresses and URLs, see the introduction for
+// more details.
+//
+// See also:
+//
+// * [property@AboutDialog:developers]
+// * [property@AboutDialog:designers]
+// * [property@AboutDialog:documenters]
+// * [property@AboutDialog:translator-credits]
+// * [method@AboutDialog.add_credit_section]
+// * [method@AboutDialog.add_acknowledgement_section]
+
+func (x *AboutDialog) SetPropertyArtists(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *AboutDialog) GetPropertyArtists() []string {
+	var v gobject.Value
+	x.GetProperty("artists", &v)
+	return nil
+}
+
+// The comments about the application.
+//
+// Comments will be shown on the Details page, above links.
+//
+// Unlike [property@Gtk.AboutDialog:comments], this string can be long and
+// detailed. It can also contain links and Pango markup.
+
+func (x *AboutDialog) SetPropertyComments(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("comments", &v)
+}
+
+func (x *AboutDialog) GetPropertyComments() string {
+	var v gobject.Value
+	x.GetProperty("comments", &v)
+	return v.GetString()
+}
+
+// The copyright information.
+//
+// This should be a short string of one or two lines, for example:
+// `Â© 2022 Example`.
+//
+// The copyright information will be displayed on the Legal page, above the
+// application license.
+//
+// [method@AboutDialog.add_legal_section] can be used to add copyright
+// information for the application dependencies or other components.
+
+func (x *AboutDialog) SetPropertyCopyright(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("copyright", &v)
+}
+
+func (x *AboutDialog) GetPropertyCopyright() string {
+	var v gobject.Value
+	x.GetProperty("copyright", &v)
+	return v.GetString()
+}
+
+// The debug information.
+//
+// Debug information will be shown on the Troubleshooting page. It's intended
+// to be attached to issue reports when reporting issues against the
+// application.
+//
+// `AdwAboutDialog` provides a quick way to save debug information to a file.
+// When saving, [property@AboutDialog:debug-info-filename] would be used as
+// the suggested filename.
+//
+// Debug information cannot contain markup or links.
+
+func (x *AboutDialog) SetPropertyDebugInfo(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("debug-info", &v)
+}
+
+func (x *AboutDialog) GetPropertyDebugInfo() string {
+	var v gobject.Value
+	x.GetProperty("debug-info", &v)
+	return v.GetString()
+}
+
+// The debug information filename.
+//
+// It will be used as the suggested filename when saving debug information to
+// a file.
+//
+// See [property@AboutDialog:debug-info].
+
+func (x *AboutDialog) SetPropertyDebugInfoFilename(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("debug-info-filename", &v)
+}
+
+func (x *AboutDialog) GetPropertyDebugInfoFilename() string {
+	var v gobject.Value
+	x.GetProperty("debug-info-filename", &v)
+	return v.GetString()
+}
+
+// The list of designers of the application.
+//
+// It will be displayed on the Credits page.
+//
+// Each name may contain email addresses and URLs, see the introduction for
+// more details.
+//
+// See also:
+//
+// * [property@AboutDialog:developers]
+// * [property@AboutDialog:artists]
+// * [property@AboutDialog:documenters]
+// * [property@AboutDialog:translator-credits]
+// * [method@AboutDialog.add_credit_section]
+// * [method@AboutDialog.add_acknowledgement_section]
+
+func (x *AboutDialog) SetPropertyDesigners(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *AboutDialog) GetPropertyDesigners() []string {
+	var v gobject.Value
+	x.GetProperty("designers", &v)
+	return nil
+}
+
+// The developer name.
+//
+// The developer name is displayed on the main page, under the application
+// name.
+//
+// If the application is developed by multiple people, the developer name can
+// be set to values like "AppName team", "AppName developers" or
+// "The AppName project", and the individual contributors can be listed on the
+// Credits page, with [property@AboutDialog:developers] and related
+// properties.
+
+func (x *AboutDialog) SetPropertyDeveloperName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("developer-name", &v)
+}
+
+func (x *AboutDialog) GetPropertyDeveloperName() string {
+	var v gobject.Value
+	x.GetProperty("developer-name", &v)
+	return v.GetString()
+}
+
+// The list of developers of the application.
+//
+// It will be displayed on the Credits page.
+//
+// Each name may contain email addresses and URLs, see the introduction for
+// more details.
+//
+// See also:
+//
+// * [property@AboutDialog:designers]
+// * [property@AboutDialog:artists]
+// * [property@AboutDialog:documenters]
+// * [property@AboutDialog:translator-credits]
+// * [method@AboutDialog.add_credit_section]
+// * [method@AboutDialog.add_acknowledgement_section]
+
+func (x *AboutDialog) SetPropertyDevelopers(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *AboutDialog) GetPropertyDevelopers() []string {
+	var v gobject.Value
+	x.GetProperty("developers", &v)
+	return nil
+}
+
+// The list of documenters of the application.
+//
+// It will be displayed on the Credits page.
+//
+// Each name may contain email addresses and URLs, see the introduction for
+// more details.
+//
+// See also:
+//
+// * [property@AboutDialog:developers]
+// * [property@AboutDialog:designers]
+// * [property@AboutDialog:artists]
+// * [property@AboutDialog:translator-credits]
+// * [method@AboutDialog.add_credit_section]
+// * [method@AboutDialog.add_acknowledgement_section]
+
+func (x *AboutDialog) SetPropertyDocumenters(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *AboutDialog) GetPropertyDocumenters() []string {
+	var v gobject.Value
+	x.GetProperty("documenters", &v)
+	return nil
+}
+
+// The URL for the application's issue tracker.
+//
+// The issue tracker link is displayed on the main page.
+
+func (x *AboutDialog) SetPropertyIssueUrl(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("issue-url", &v)
+}
+
+func (x *AboutDialog) GetPropertyIssueUrl() string {
+	var v gobject.Value
+	x.GetProperty("issue-url", &v)
+	return v.GetString()
+}
+
+// The license text.
+//
+// This can be used to set a custom text for the license if it can't be set
+// via [property@AboutDialog:license-type].
+//
+// When set, [property@AboutDialog:license-type] will be set to
+// `GTK_LICENSE_CUSTOM`.
+//
+// The license text will be displayed on the Legal page, below the copyright
+// information.
+//
+// License text can contain Pango markup and links.
+//
+// [method@AboutDialog.add_legal_section] can be used to add license
+// information for the application dependencies or other components.
+
+func (x *AboutDialog) SetPropertyLicense(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("license", &v)
+}
+
+func (x *AboutDialog) GetPropertyLicense() string {
+	var v gobject.Value
+	x.GetProperty("license", &v)
+	return v.GetString()
+}
+
+// The license type.
+//
+// Allows to set the application's license froma list of known licenses.
+//
+// If the application's license is not in the list,
+// [property@AboutDialog:license] can be used instead. The license type will
+// be automatically set to `GTK_LICENSE_CUSTOM` in that case.
+//
+// If set to `GTK_LICENSE_UNKNOWN`, no information will be displayed.
+//
+// If the license type is different from `GTK_LICENSE_CUSTOM`.
+// [property@AboutDialog:license] will be cleared out.
+//
+// The license description will be displayed on the Legal page, below the
+// copyright information.
+//
+// [method@AboutDialog.add_legal_section] can be used to add license
+// information for the application dependencies or other components.
+
+func (x *AboutDialog) SetPropertyLicenseType(value gtk.License) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("license-type", &v)
+}
+
+func (x *AboutDialog) GetPropertyLicenseType() gtk.License {
+	var v gobject.Value
+	x.GetProperty("license-type", &v)
+	return gtk.License(v.GetEnum())
+}
+
+// The release notes of the application.
+//
+// Release notes are displayed on the the What's New page.
+//
+// Release notes are formatted the same way as
+// [AppStream descriptions](https://freedesktop.org/software/appstream/docs/chap-Metadata.html#tag-description).
+//
+// The supported formatting options are:
+//
+// * Paragraph (`&lt;p&gt;`)
+// * Ordered list (`&lt;ol&gt;`), with list items (`&lt;li&gt;`)
+// * Unordered list (`&lt;ul&gt;`), with list items (`&lt;li&gt;`)
+//
+// Within paragraphs and list items, emphasis (`&lt;em&gt;`) and inline code
+// (`&lt;code&gt;`) text styles are supported. The emphasis is rendered in italic,
+// while inline code is shown in a monospaced font.
+//
+// Any text outside paragraphs or list items is ignored.
+//
+// Nested lists are not supported.
+//
+// `AdwAboutDialog` displays the version above the release notes. If set, the
+// [property@AboutDialog:release-notes-version] of the property will be used
+// as the version; otherwise, [property@AboutDialog:version] is used.
+
+func (x *AboutDialog) SetPropertyReleaseNotes(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("release-notes", &v)
+}
+
+func (x *AboutDialog) GetPropertyReleaseNotes() string {
+	var v gobject.Value
+	x.GetProperty("release-notes", &v)
+	return v.GetString()
+}
+
+// The version described by the application's release notes.
+//
+// The release notes version is displayed on the What's New page, above the
+// release notes.
+//
+// If not set, [property@AboutDialog:version] will be used instead.
+//
+// For example, an application with the current version 2.0.2 might want to
+// keep the release notes from 2.0.0, and set the release notes version
+// accordingly.
+//
+// See [property@AboutDialog:release-notes].
+
+func (x *AboutDialog) SetPropertyReleaseNotesVersion(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("release-notes-version", &v)
+}
+
+func (x *AboutDialog) GetPropertyReleaseNotesVersion() string {
+	var v gobject.Value
+	x.GetProperty("release-notes-version", &v)
+	return v.GetString()
+}
+
+// The URL of the application's support page.
+//
+// The support page link is displayed on the main page.
+
+func (x *AboutDialog) SetPropertySupportUrl(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("support-url", &v)
+}
+
+func (x *AboutDialog) GetPropertySupportUrl() string {
+	var v gobject.Value
+	x.GetProperty("support-url", &v)
+	return v.GetString()
+}
+
+// The translator credits string.
+//
+// It will be displayed on the Credits page.
+//
+// This string should be `"translator-credits"` or `"translator_credits"` and
+// should be marked as translatable.
+//
+// The string may contain email addresses and URLs, see the introduction for
+// more details.
+//
+// See also:
+//
+// * [property@AboutDialog:developers]
+// * [property@AboutDialog:designers]
+// * [property@AboutDialog:artists]
+// * [property@AboutDialog:documenters]
+// * [method@AboutDialog.add_credit_section]
+// * [method@AboutDialog.add_acknowledgement_section]
+
+func (x *AboutDialog) SetPropertyTranslatorCredits(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("translator-credits", &v)
+}
+
+func (x *AboutDialog) GetPropertyTranslatorCredits() string {
+	var v gobject.Value
+	x.GetProperty("translator-credits", &v)
+	return v.GetString()
+}
+
+// The version of the application.
+//
+// The version is displayed on the main page.
+//
+// If [property@AboutDialog:release-notes-version] is not set, the version
+// will also be displayed above the release notes on the What's New page.
+
+func (x *AboutDialog) SetPropertyVersion(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("version", &v)
+}
+
+func (x *AboutDialog) GetPropertyVersion() string {
+	var v gobject.Value
+	x.GetProperty("version", &v)
+	return v.GetString()
+}
+
+// The URL of the application's website.
+//
+// Website is displayed on the Details page, below comments, or on the main
+// page if the Details page doesn't have any other content.
+//
+// Applications can add other links below, see [method@AboutDialog.add_link].
+
+func (x *AboutDialog) SetPropertyWebsite(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("website", &v)
+}
+
+func (x *AboutDialog) GetPropertyWebsite() string {
+	var v gobject.Value
+	x.GetProperty("website", &v)
+	return v.GetString()
+}
+
 // Emitted when a URL is activated.
 //
 // Applications may connect to it to override the default behavior, which is
diff --git a/v4/adw/adw-about-window.go b/v4/adw/adw-about-window.go
index d00fd848e6afe736f8f6f1f86ebf5e021901729e..134634bd251be3aed9c56a1c0bc98db86f148570 100644
--- a/v4/adw/adw-about-window.go
+++ b/v4/adw/adw-about-window.go
@@ -964,6 +964,488 @@ func (c *AboutWindow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The name of the application icon.
+//
+// The icon is displayed at the top of the main page.
+
+func (x *AboutWindow) SetPropertyApplicationIcon(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("application-icon", &v)
+}
+
+func (x *AboutWindow) GetPropertyApplicationIcon() string {
+	var v gobject.Value
+	x.GetProperty("application-icon", &v)
+	return v.GetString()
+}
+
+// The name of the application.
+//
+// The name is displayed at the top of the main page.
+
+func (x *AboutWindow) SetPropertyApplicationName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("application-name", &v)
+}
+
+func (x *AboutWindow) GetPropertyApplicationName() string {
+	var v gobject.Value
+	x.GetProperty("application-name", &v)
+	return v.GetString()
+}
+
+// The list of artists of the application.
+//
+// It will be displayed on the Credits page.
+//
+// Each name may contain email addresses and URLs, see the introduction for
+// more details.
+//
+// See also:
+//
+// * [property@AboutWindow:developers]
+// * [property@AboutWindow:designers]
+// * [property@AboutWindow:documenters]
+// * [property@AboutWindow:translator-credits]
+// * [method@AboutWindow.add_credit_section]
+// * [method@AboutWindow.add_acknowledgement_section]
+
+func (x *AboutWindow) SetPropertyArtists(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *AboutWindow) GetPropertyArtists() []string {
+	var v gobject.Value
+	x.GetProperty("artists", &v)
+	return nil
+}
+
+// The comments about the application.
+//
+// Comments will be shown on the Details page, above links.
+//
+// Unlike [property@Gtk.AboutDialog:comments], this string can be long and
+// detailed. It can also contain links and Pango markup.
+
+func (x *AboutWindow) SetPropertyComments(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("comments", &v)
+}
+
+func (x *AboutWindow) GetPropertyComments() string {
+	var v gobject.Value
+	x.GetProperty("comments", &v)
+	return v.GetString()
+}
+
+// The copyright information.
+//
+// This should be a short string of one or two lines, for example:
+// `Â© 2022 Example`.
+//
+// The copyright information will be displayed on the Legal page, above the
+// application license.
+//
+// [method@AboutWindow.add_legal_section] can be used to add copyright
+// information for the application dependencies or other components.
+
+func (x *AboutWindow) SetPropertyCopyright(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("copyright", &v)
+}
+
+func (x *AboutWindow) GetPropertyCopyright() string {
+	var v gobject.Value
+	x.GetProperty("copyright", &v)
+	return v.GetString()
+}
+
+// The debug information.
+//
+// Debug information will be shown on the Troubleshooting page. It's intended
+// to be attached to issue reports when reporting issues against the
+// application.
+//
+// `AdwAboutWindow` provides a quick way to save debug information to a file.
+// When saving, [property@AboutWindow:debug-info-filename] would be used as
+// the suggested filename.
+//
+// Debug information cannot contain markup or links.
+
+func (x *AboutWindow) SetPropertyDebugInfo(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("debug-info", &v)
+}
+
+func (x *AboutWindow) GetPropertyDebugInfo() string {
+	var v gobject.Value
+	x.GetProperty("debug-info", &v)
+	return v.GetString()
+}
+
+// The debug information filename.
+//
+// It will be used as the suggested filename when saving debug information to
+// a file.
+//
+// See [property@AboutWindow:debug-info].
+
+func (x *AboutWindow) SetPropertyDebugInfoFilename(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("debug-info-filename", &v)
+}
+
+func (x *AboutWindow) GetPropertyDebugInfoFilename() string {
+	var v gobject.Value
+	x.GetProperty("debug-info-filename", &v)
+	return v.GetString()
+}
+
+// The list of designers of the application.
+//
+// It will be displayed on the Credits page.
+//
+// Each name may contain email addresses and URLs, see the introduction for
+// more details.
+//
+// See also:
+//
+// * [property@AboutWindow:developers]
+// * [property@AboutWindow:artists]
+// * [property@AboutWindow:documenters]
+// * [property@AboutWindow:translator-credits]
+// * [method@AboutWindow.add_credit_section]
+// * [method@AboutWindow.add_acknowledgement_section]
+
+func (x *AboutWindow) SetPropertyDesigners(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *AboutWindow) GetPropertyDesigners() []string {
+	var v gobject.Value
+	x.GetProperty("designers", &v)
+	return nil
+}
+
+// The developer name.
+//
+// The developer name is displayed on the main page, under the application
+// name.
+//
+// If the application is developed by multiple people, the developer name can
+// be set to values like "AppName team", "AppName developers" or
+// "The AppName project", and the individual contributors can be listed on the
+// Credits page, with [property@AboutWindow:developers] and related
+// properties.
+
+func (x *AboutWindow) SetPropertyDeveloperName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("developer-name", &v)
+}
+
+func (x *AboutWindow) GetPropertyDeveloperName() string {
+	var v gobject.Value
+	x.GetProperty("developer-name", &v)
+	return v.GetString()
+}
+
+// The list of developers of the application.
+//
+// It will be displayed on the Credits page.
+//
+// Each name may contain email addresses and URLs, see the introduction for
+// more details.
+//
+// See also:
+//
+// * [property@AboutWindow:designers]
+// * [property@AboutWindow:artists]
+// * [property@AboutWindow:documenters]
+// * [property@AboutWindow:translator-credits]
+// * [method@AboutWindow.add_credit_section]
+// * [method@AboutWindow.add_acknowledgement_section]
+
+func (x *AboutWindow) SetPropertyDevelopers(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *AboutWindow) GetPropertyDevelopers() []string {
+	var v gobject.Value
+	x.GetProperty("developers", &v)
+	return nil
+}
+
+// The list of documenters of the application.
+//
+// It will be displayed on the Credits page.
+//
+// Each name may contain email addresses and URLs, see the introduction for
+// more details.
+//
+// See also:
+//
+// * [property@AboutWindow:developers]
+// * [property@AboutWindow:designers]
+// * [property@AboutWindow:artists]
+// * [property@AboutWindow:translator-credits]
+// * [method@AboutWindow.add_credit_section]
+// * [method@AboutWindow.add_acknowledgement_section]
+
+func (x *AboutWindow) SetPropertyDocumenters(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *AboutWindow) GetPropertyDocumenters() []string {
+	var v gobject.Value
+	x.GetProperty("documenters", &v)
+	return nil
+}
+
+// The URL for the application's issue tracker.
+//
+// The issue tracker link is displayed on the main page.
+
+func (x *AboutWindow) SetPropertyIssueUrl(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("issue-url", &v)
+}
+
+func (x *AboutWindow) GetPropertyIssueUrl() string {
+	var v gobject.Value
+	x.GetProperty("issue-url", &v)
+	return v.GetString()
+}
+
+// The license text.
+//
+// This can be used to set a custom text for the license if it can't be set
+// via [property@AboutWindow:license-type].
+//
+// When set, [property@AboutWindow:license-type] will be set to
+// `GTK_LICENSE_CUSTOM`.
+//
+// The license text will be displayed on the Legal page, below the copyright
+// information.
+//
+// License text can contain Pango markup and links.
+//
+// [method@AboutWindow.add_legal_section] can be used to add license
+// information for the application dependencies or other components.
+
+func (x *AboutWindow) SetPropertyLicense(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("license", &v)
+}
+
+func (x *AboutWindow) GetPropertyLicense() string {
+	var v gobject.Value
+	x.GetProperty("license", &v)
+	return v.GetString()
+}
+
+// The license type.
+//
+// Allows to set the application's license froma list of known licenses.
+//
+// If the application's license is not in the list,
+// [property@AboutWindow:license] can be used instead. The license type will
+// be automatically set to `GTK_LICENSE_CUSTOM` in that case.
+//
+// If set to `GTK_LICENSE_UNKNOWN`, no information will be displayed.
+//
+// If the license type is different from `GTK_LICENSE_CUSTOM`.
+// [property@AboutWindow:license] will be cleared out.
+//
+// The license description will be displayed on the Legal page, below the
+// copyright information.
+//
+// [method@AboutWindow.add_legal_section] can be used to add license
+// information for the application dependencies or other components.
+
+func (x *AboutWindow) SetPropertyLicenseType(value gtk.License) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("license-type", &v)
+}
+
+func (x *AboutWindow) GetPropertyLicenseType() gtk.License {
+	var v gobject.Value
+	x.GetProperty("license-type", &v)
+	return gtk.License(v.GetEnum())
+}
+
+// The release notes of the application.
+//
+// Release notes are displayed on the the What's New page.
+//
+// Release notes are formatted the same way as
+// [AppStream descriptions](https://freedesktop.org/software/appstream/docs/chap-Metadata.html#tag-description).
+//
+// The supported formatting options are:
+//
+// * Paragraph (`&lt;p&gt;`)
+// * Ordered list (`&lt;ol&gt;`), with list items (`&lt;li&gt;`)
+// * Unordered list (`&lt;ul&gt;`), with list items (`&lt;li&gt;`)
+//
+// Within paragraphs and list items, emphasis (`&lt;em&gt;`) and inline code
+// (`&lt;code&gt;`) text styles are supported. The emphasis is rendered in italic,
+// while inline code is shown in a monospaced font.
+//
+// Any text outside paragraphs or list items is ignored.
+//
+// Nested lists are not supported.
+//
+// `AdwAboutWindow` displays the version above the release notes. If set, the
+// [property@AboutWindow:release-notes-version] of the property will be used
+// as the version; otherwise, [property@AboutWindow:version] is used.
+
+func (x *AboutWindow) SetPropertyReleaseNotes(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("release-notes", &v)
+}
+
+func (x *AboutWindow) GetPropertyReleaseNotes() string {
+	var v gobject.Value
+	x.GetProperty("release-notes", &v)
+	return v.GetString()
+}
+
+// The version described by the application's release notes.
+//
+// The release notes version is displayed on the What's New page, above the
+// release notes.
+//
+// If not set, [property@AboutWindow:version] will be used instead.
+//
+// For example, an application with the current version 2.0.2 might want to
+// keep the release notes from 2.0.0, and set the release notes version
+// accordingly.
+//
+// See [property@AboutWindow:release-notes].
+
+func (x *AboutWindow) SetPropertyReleaseNotesVersion(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("release-notes-version", &v)
+}
+
+func (x *AboutWindow) GetPropertyReleaseNotesVersion() string {
+	var v gobject.Value
+	x.GetProperty("release-notes-version", &v)
+	return v.GetString()
+}
+
+// The URL of the application's support page.
+//
+// The support page link is displayed on the main page.
+
+func (x *AboutWindow) SetPropertySupportUrl(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("support-url", &v)
+}
+
+func (x *AboutWindow) GetPropertySupportUrl() string {
+	var v gobject.Value
+	x.GetProperty("support-url", &v)
+	return v.GetString()
+}
+
+// The translator credits string.
+//
+// It will be displayed on the Credits page.
+//
+// This string should be `"translator-credits"` or `"translator_credits"` and
+// should be marked as translatable.
+//
+// The string may contain email addresses and URLs, see the introduction for
+// more details.
+//
+// See also:
+//
+// * [property@AboutWindow:developers]
+// * [property@AboutWindow:designers]
+// * [property@AboutWindow:artists]
+// * [property@AboutWindow:documenters]
+// * [method@AboutWindow.add_credit_section]
+// * [method@AboutWindow.add_acknowledgement_section]
+
+func (x *AboutWindow) SetPropertyTranslatorCredits(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("translator-credits", &v)
+}
+
+func (x *AboutWindow) GetPropertyTranslatorCredits() string {
+	var v gobject.Value
+	x.GetProperty("translator-credits", &v)
+	return v.GetString()
+}
+
+// The version of the application.
+//
+// The version is displayed on the main page.
+//
+// If [property@AboutWindow:release-notes-version] is not set, the version
+// will also be displayed above the release notes on the What's New page.
+
+func (x *AboutWindow) SetPropertyVersion(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("version", &v)
+}
+
+func (x *AboutWindow) GetPropertyVersion() string {
+	var v gobject.Value
+	x.GetProperty("version", &v)
+	return v.GetString()
+}
+
+// The URL of the application's website.
+//
+// Website is displayed on the Details page, below comments, or on the main
+// page if the Details page doesn't have any other content.
+//
+// Applications can add other links below, see [method@AboutWindow.add_link].
+
+func (x *AboutWindow) SetPropertyWebsite(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("website", &v)
+}
+
+func (x *AboutWindow) GetPropertyWebsite() string {
+	var v gobject.Value
+	x.GetProperty("website", &v)
+	return v.GetString()
+}
+
 // Emitted when a URL is activated.
 //
 // Applications may connect to it to override the default behavior, which is
diff --git a/v4/adw/adw-action-row.go b/v4/adw/adw-action-row.go
index feb27c6a34f840a8760d6a996a029138802f1df5..02c5ec4b1e5d638ebc21d95e0e8299258c561a13 100644
--- a/v4/adw/adw-action-row.go
+++ b/v4/adw/adw-action-row.go
@@ -320,6 +320,120 @@ func (c *ActionRow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The widget to activate when the row is activated.
+//
+// The row can be activated either by clicking on it, calling
+// [method@ActionRow.activate], or via mnemonics in the title.
+// See the [property@PreferencesRow:use-underline] property to enable
+// mnemonics.
+//
+// The target widget will be activated by emitting the
+// [signal@Gtk.Widget::mnemonic-activate] signal on it.
+
+func (x *ActionRow) SetPropertyActivatableWidget(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("activatable-widget", &v)
+}
+
+func (x *ActionRow) GetPropertyActivatableWidget() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("activatable-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The icon name for this row.
+
+func (x *ActionRow) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *ActionRow) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// The subtitle for this row.
+//
+// The subtitle is interpreted as Pango markup unless
+// [property@PreferencesRow:use-markup] is set to `FALSE`.
+
+func (x *ActionRow) SetPropertySubtitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("subtitle", &v)
+}
+
+func (x *ActionRow) GetPropertySubtitle() string {
+	var v gobject.Value
+	x.GetProperty("subtitle", &v)
+	return v.GetString()
+}
+
+// The number of lines at the end of which the subtitle label will be
+// ellipsized.
+//
+// If the value is 0, the number of lines won't be limited.
+
+func (x *ActionRow) SetPropertySubtitleLines(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("subtitle-lines", &v)
+}
+
+func (x *ActionRow) GetPropertySubtitleLines() int {
+	var v gobject.Value
+	x.GetProperty("subtitle-lines", &v)
+	return v.GetInt()
+}
+
+// Whether the user can copy the subtitle from the label.
+//
+// See also [property@Gtk.Label:selectable].
+
+func (x *ActionRow) SetPropertySubtitleSelectable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("subtitle-selectable", &v)
+}
+
+func (x *ActionRow) GetPropertySubtitleSelectable() bool {
+	var v gobject.Value
+	x.GetProperty("subtitle-selectable", &v)
+	return v.GetBoolean()
+}
+
+// The number of lines at the end of which the title label will be ellipsized.
+//
+// If the value is 0, the number of lines won't be limited.
+
+func (x *ActionRow) SetPropertyTitleLines(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("title-lines", &v)
+}
+
+func (x *ActionRow) GetPropertyTitleLines() int {
+	var v gobject.Value
+	x.GetProperty("title-lines", &v)
+	return v.GetInt()
+}
+
 // This signal is emitted after the row has been activated.
 func (x *ActionRow) ConnectActivated(cb *func(ActionRow)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/adw/adw-alert-dialog.go b/v4/adw/adw-alert-dialog.go
index 97dcf56965d97eed6dcca7af5a69ccb9e40a79e8..d4b91f74ce7cb48b5ba05a5499eff10190ec9491 100644
--- a/v4/adw/adw-alert-dialog.go
+++ b/v4/adw/adw-alert-dialog.go
@@ -682,6 +682,153 @@ func (c *AlertDialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The body text of the dialog.
+
+func (x *AlertDialog) SetPropertyBody(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("body", &v)
+}
+
+func (x *AlertDialog) GetPropertyBody() string {
+	var v gobject.Value
+	x.GetProperty("body", &v)
+	return v.GetString()
+}
+
+// Whether the body text includes Pango markup.
+//
+// See [func@Pango.parse_markup].
+
+func (x *AlertDialog) SetPropertyBodyUseMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("body-use-markup", &v)
+}
+
+func (x *AlertDialog) GetPropertyBodyUseMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("body-use-markup", &v)
+	return v.GetBoolean()
+}
+
+// The ID of the close response.
+//
+// It will be passed to [signal@AlertDialog::response] if the dialog is
+// closed by pressing &lt;kbd&gt;Escape&lt;/kbd&gt; or with a system action.
+//
+// It doesn't have to correspond to any of the responses in the dialog.
+//
+// The default close response is `close`.
+
+func (x *AlertDialog) SetPropertyCloseResponse(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("close-response", &v)
+}
+
+func (x *AlertDialog) GetPropertyCloseResponse() string {
+	var v gobject.Value
+	x.GetProperty("close-response", &v)
+	return v.GetString()
+}
+
+// The response ID of the default response.
+//
+// If set, pressing &lt;kbd&gt;Enter&lt;/kbd&gt; will activate the corresponding button.
+//
+// If set to `NULL` or a non-existent response ID, pressing &lt;kbd&gt;Enter&lt;/kbd&gt;
+// will do nothing.
+
+func (x *AlertDialog) SetPropertyDefaultResponse(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("default-response", &v)
+}
+
+func (x *AlertDialog) GetPropertyDefaultResponse() string {
+	var v gobject.Value
+	x.GetProperty("default-response", &v)
+	return v.GetString()
+}
+
+// The child widget.
+//
+// Displayed below the heading and body.
+
+func (x *AlertDialog) SetPropertyExtraChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("extra-child", &v)
+}
+
+func (x *AlertDialog) GetPropertyExtraChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("extra-child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The heading of the dialog.
+
+func (x *AlertDialog) SetPropertyHeading(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("heading", &v)
+}
+
+func (x *AlertDialog) GetPropertyHeading() string {
+	var v gobject.Value
+	x.GetProperty("heading", &v)
+	return v.GetString()
+}
+
+// Whether the heading includes Pango markup.
+//
+// See [func@Pango.parse_markup].
+
+func (x *AlertDialog) SetPropertyHeadingUseMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("heading-use-markup", &v)
+}
+
+func (x *AlertDialog) GetPropertyHeadingUseMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("heading-use-markup", &v)
+	return v.GetBoolean()
+}
+
+// Whether to prefer wide layout.
+//
+// Prefer horizontal button layout when possible, and wider dialog width
+// otherwise.
+
+func (x *AlertDialog) SetPropertyPreferWideLayout(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("prefer-wide-layout", &v)
+}
+
+func (x *AlertDialog) GetPropertyPreferWideLayout() bool {
+	var v gobject.Value
+	x.GetProperty("prefer-wide-layout", &v)
+	return v.GetBoolean()
+}
+
 // This signal is emitted when the dialog is closed.
 //
 // @response will be set to the response ID of the button that had been
diff --git a/v4/adw/adw-animation-target.go b/v4/adw/adw-animation-target.go
index ba944a3e472b13009714b18196aac3fb41bb56b1..b07c0b11c2989dcb020c836ffd27f634e56e9750 100644
--- a/v4/adw/adw-animation-target.go
+++ b/v4/adw/adw-animation-target.go
@@ -214,6 +214,52 @@ func (c *PropertyAnimationTarget) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The object whose property will be animated.
+//
+// The `AdwPropertyAnimationTarget` instance does not hold a strong reference
+// on the object; make sure the object is kept alive throughout the target's
+// lifetime.
+
+func (x *PropertyAnimationTarget) SetPropertyObject(value *gobject.Object) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("object", &v)
+}
+
+func (x *PropertyAnimationTarget) GetPropertyObject() *gobject.Object {
+	var v gobject.Value
+	x.GetProperty("object", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gobject.Object{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GParamSpec` of the property to be animated.
+
+func (x *PropertyAnimationTarget) SetPropertyPspec(value *gobject.ParamSpec) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("pspec", &v)
+}
+
+func (x *PropertyAnimationTarget) GetPropertyPspec() *gobject.ParamSpec {
+	var v gobject.Value
+	x.GetProperty("pspec", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gobject.ParamSpec{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("ADW", "libadwaita-1")
diff --git a/v4/adw/adw-animation.go b/v4/adw/adw-animation.go
index 17892ba7f9cc7852919e5a95508ee3b9274a18b3..2b18f2821cd6f04102426c7b5bebf4fa5d044e38 100644
--- a/v4/adw/adw-animation.go
+++ b/v4/adw/adw-animation.go
@@ -302,6 +302,97 @@ func (c *Animation) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to skip the animation when animations are globally disabled.
+//
+// The default behavior is to skip the animation. Set to `FALSE` to disable
+// this behavior.
+//
+// This can be useful for cases where animation is essential, like spinners,
+// or in demo applications. Most other animations should keep it enabled.
+//
+// See [property@Gtk.Settings:gtk-enable-animations].
+
+func (x *Animation) SetPropertyFollowEnableAnimationsSetting(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("follow-enable-animations-setting", &v)
+}
+
+func (x *Animation) GetPropertyFollowEnableAnimationsSetting() bool {
+	var v gobject.Value
+	x.GetProperty("follow-enable-animations-setting", &v)
+	return v.GetBoolean()
+}
+
+// The animation state.
+//
+// The state indicates whether the animation is currently playing, paused,
+// finished or hasn't been started yet.
+
+func (x *Animation) GetPropertyState() AnimationState {
+	var v gobject.Value
+	x.GetProperty("state", &v)
+	return AnimationState(v.GetEnum())
+}
+
+// The target to animate.
+
+func (x *Animation) SetPropertyTarget(value *AnimationTarget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("target", &v)
+}
+
+func (x *Animation) GetPropertyTarget() *AnimationTarget {
+	var v gobject.Value
+	x.GetProperty("target", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &AnimationTarget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The current value of the animation.
+
+func (x *Animation) GetPropertyValue() float64 {
+	var v gobject.Value
+	x.GetProperty("value", &v)
+	return v.GetDouble()
+}
+
+// The animation widget.
+//
+// It provides the frame clock for the animation. It's not strictly necessary
+// for this widget to be same as the one being animated.
+//
+// The widget must be mapped in order for the animation to work. If it's not
+// mapped, or if it gets unmapped during an ongoing animation, the animation
+// will be automatically skipped.
+
+func (x *Animation) SetPropertyWidget(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("widget", &v)
+}
+
+func (x *Animation) GetPropertyWidget() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
 // This signal is emitted when the animation has been completed, either on its
 // own or via calling [method@Animation.skip].
 func (x *Animation) ConnectDone(cb *func(Animation)) uint32 {
diff --git a/v4/adw/adw-application-window.go b/v4/adw/adw-application-window.go
index 22ff677aeb96b4821aa777b84b626badfddfbd9a..4878fb91107565e60c803e2ae4f7b8031416e32c 100644
--- a/v4/adw/adw-application-window.go
+++ b/v4/adw/adw-application-window.go
@@ -198,6 +198,71 @@ func (c *ApplicationWindow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The content widget.
+//
+// This property should always be used instead of [property@Gtk.Window:child].
+
+func (x *ApplicationWindow) SetPropertyContent(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("content", &v)
+}
+
+func (x *ApplicationWindow) GetPropertyContent() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("content", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The current breakpoint.
+
+func (x *ApplicationWindow) GetPropertyCurrentBreakpoint() *Breakpoint {
+	var v gobject.Value
+	x.GetProperty("current-breakpoint", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Breakpoint{}
+	result.Ptr = ptr
+	return result
+}
+
+// The open dialogs.
+
+func (x *ApplicationWindow) GetPropertyDialogs() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("dialogs", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The currently visible dialog
+
+func (x *ApplicationWindow) GetPropertyVisibleDialog() *Dialog {
+	var v gobject.Value
+	x.GetProperty("visible-dialog", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Dialog{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emits the #GActionGroup::action-added signal on @action_group.
 //
 // This function should only be called by #GActionGroup implementations.
diff --git a/v4/adw/adw-application.go b/v4/adw/adw-application.go
index 3e73f6e7aea0ef613ca99b6db986d7e491d06e74..4c86a85f6f493574264ec86148a965cb6e7ab9d5 100644
--- a/v4/adw/adw-application.go
+++ b/v4/adw/adw-application.go
@@ -121,6 +121,23 @@ func (c *Application) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The style manager for this application.
+//
+// This is a convenience property allowing to access `AdwStyleManager` through
+// property bindings or expressions.
+
+func (x *Application) GetPropertyStyleManager() *StyleManager {
+	var v gobject.Value
+	x.GetProperty("style-manager", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &StyleManager{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emits the #GActionGroup::action-added signal on @action_group.
 //
 // This function should only be called by #GActionGroup implementations.
diff --git a/v4/adw/adw-avatar.go b/v4/adw/adw-avatar.go
index 40c2b8d0f9d0a3cac224275e821e7eccc1f55efb..445dad8f8f7798c4386dd948615cf1c21b4e6c76 100644
--- a/v4/adw/adw-avatar.go
+++ b/v4/adw/adw-avatar.go
@@ -217,6 +217,96 @@ func (c *Avatar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// A custom image paintable.
+//
+// Custom image is displayed instead of initials or icon.
+
+func (x *Avatar) SetPropertyCustomImage(value gdk.Paintable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("custom-image", &v)
+}
+
+func (x *Avatar) GetPropertyCustomImage() gdk.Paintable {
+	var v gobject.Value
+	x.GetProperty("custom-image", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.PaintableBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of an icon to use as a fallback.
+//
+// If no name is set, `avatar-default-symbolic` will be used.
+
+func (x *Avatar) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *Avatar) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// Whether initials are used instead of an icon on the fallback avatar.
+//
+// See [property@Avatar:icon-name] for how to change the fallback icon.
+
+func (x *Avatar) SetPropertyShowInitials(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-initials", &v)
+}
+
+func (x *Avatar) GetPropertyShowInitials() bool {
+	var v gobject.Value
+	x.GetProperty("show-initials", &v)
+	return v.GetBoolean()
+}
+
+// The size of the avatar.
+
+func (x *Avatar) SetPropertySize(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("size", &v)
+}
+
+func (x *Avatar) GetPropertySize() int {
+	var v gobject.Value
+	x.GetProperty("size", &v)
+	return v.GetInt()
+}
+
+// Sets the text used to generate the fallback initials and color.
+//
+// It's only used to generate the color if [property@Avatar:show-initials] is
+// `FALSE`.
+
+func (x *Avatar) SetPropertyText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("text", &v)
+}
+
+func (x *Avatar) GetPropertyText() string {
+	var v gobject.Value
+	x.GetProperty("text", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Avatar) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-banner.go b/v4/adw/adw-banner.go
index 15c8f91ae597e4aeb45f41bf3880a5d1b37f5387..a69833f41d59b395f30bc5d12068dca48ef602f7 100644
--- a/v4/adw/adw-banner.go
+++ b/v4/adw/adw-banner.go
@@ -172,6 +172,75 @@ func (c *Banner) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The label to show on the button.
+//
+// If set to `""` or `NULL`, the button won't be shown.
+//
+// The button can be used with a `GAction`, or with the
+// [signal@Banner::button-clicked] signal.
+
+func (x *Banner) SetPropertyButtonLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("button-label", &v)
+}
+
+func (x *Banner) GetPropertyButtonLabel() string {
+	var v gobject.Value
+	x.GetProperty("button-label", &v)
+	return v.GetString()
+}
+
+// Whether the banner is currently revealed.
+
+func (x *Banner) SetPropertyRevealed(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("revealed", &v)
+}
+
+func (x *Banner) GetPropertyRevealed() bool {
+	var v gobject.Value
+	x.GetProperty("revealed", &v)
+	return v.GetBoolean()
+}
+
+// The title for this banner.
+//
+// See also: [property@Banner:use-markup].
+
+func (x *Banner) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *Banner) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// Whether to use Pango markup for the banner title.
+//
+// See also [func@Pango.parse_markup].
+
+func (x *Banner) SetPropertyUseMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-markup", &v)
+}
+
+func (x *Banner) GetPropertyUseMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("use-markup", &v)
+	return v.GetBoolean()
+}
+
 // This signal is emitted after the action button has been clicked.
 //
 // It can be used as an alternative to setting an action.
diff --git a/v4/adw/adw-bin.go b/v4/adw/adw-bin.go
index fa0143caaefdb4ccf594d2bb6e669f48f38425c3..d70f9ae552a4f1ca5624f8442023a2b0692f746f 100644
--- a/v4/adw/adw-bin.go
+++ b/v4/adw/adw-bin.go
@@ -106,6 +106,27 @@ func (c *Bin) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget of the `AdwBin`.
+
+func (x *Bin) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *Bin) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Bin) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-bottom-sheet.go b/v4/adw/adw-bottom-sheet.go
index 5b10da18364bb70a86d87ef1b1c2ac3163dd7c8c..4843e7deaf02d2b84bc96153bed08f644759dfa8 100644
--- a/v4/adw/adw-bottom-sheet.go
+++ b/v4/adw/adw-bottom-sheet.go
@@ -405,6 +405,234 @@ func (c *BottomSheet) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Horizontal alignment of the bottom sheet.
+//
+// 0 means the bottom sheet is flush with the start edge, 1 means it's flush
+// with the end edge. 0.5 means it's centered.
+//
+// Only used when [property@BottomSheet:full-width] is set to `FALSE`.
+
+func (x *BottomSheet) SetPropertyAlign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("align", &v)
+}
+
+func (x *BottomSheet) GetPropertyAlign() float32 {
+	var v gobject.Value
+	x.GetProperty("align", &v)
+	return v.GetFloat()
+}
+
+// The bottom bar widget.
+//
+// Shown when [property@BottomSheet:open] is `FALSE`. When open, morphs into
+// the [property@BottomSheet:sheet].
+
+func (x *BottomSheet) SetPropertyBottomBar(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("bottom-bar", &v)
+}
+
+func (x *BottomSheet) GetPropertyBottomBar() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("bottom-bar", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The current bottom bar height.
+//
+// It can be used to shift the content upwards permanently to accommodate for
+// the bottom bar.
+
+func (x *BottomSheet) GetPropertyBottomBarHeight() int {
+	var v gobject.Value
+	x.GetProperty("bottom-bar-height", &v)
+	return v.GetInt()
+}
+
+// Whether the bottom sheet can be closed by user.
+//
+// It can be closed via the close button, swiping down, pressing
+// &lt;kbd&gt;Escape&lt;/kbd&gt; or clicking the content dimming (when modal).
+//
+// Bottom sheet can still be closed using [property@BottomSheet:open].
+
+func (x *BottomSheet) SetPropertyCanClose(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-close", &v)
+}
+
+func (x *BottomSheet) GetPropertyCanClose() bool {
+	var v gobject.Value
+	x.GetProperty("can-close", &v)
+	return v.GetBoolean()
+}
+
+// Whether the bottom sheet can be opened by user.
+//
+// It can be opened via clicking or swiping up from the bottom bar.
+//
+// Does nothing if [property@BottomSheet:bottom-bar] is not set.
+//
+// Bottom sheet can still be opened using [property@BottomSheet:open].
+
+func (x *BottomSheet) SetPropertyCanOpen(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-open", &v)
+}
+
+func (x *BottomSheet) GetPropertyCanOpen() bool {
+	var v gobject.Value
+	x.GetProperty("can-open", &v)
+	return v.GetBoolean()
+}
+
+// The content widget.
+//
+// It's always shown, and the bottom sheet is overlaid over it.
+
+func (x *BottomSheet) SetPropertyContent(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("content", &v)
+}
+
+func (x *BottomSheet) GetPropertyContent() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("content", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the bottom sheet takes the full width.
+//
+// When full width, [property@BottomSheet:align] is ignored.
+
+func (x *BottomSheet) SetPropertyFullWidth(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("full-width", &v)
+}
+
+func (x *BottomSheet) GetPropertyFullWidth() bool {
+	var v gobject.Value
+	x.GetProperty("full-width", &v)
+	return v.GetBoolean()
+}
+
+// Whether the bottom sheet is modal.
+//
+// When modal, [property@BottomSheet:content] will be dimmed when the bottom
+// sheet is open, and clicking it will close the bottom sheet. It also cannot
+// be focused with keyboard.
+//
+// Otherwise, the content is accessible even when the bottom sheet is open.
+
+func (x *BottomSheet) SetPropertyModal(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("modal", &v)
+}
+
+func (x *BottomSheet) GetPropertyModal() bool {
+	var v gobject.Value
+	x.GetProperty("modal", &v)
+	return v.GetBoolean()
+}
+
+// Whether the bottom sheet is open.
+
+func (x *BottomSheet) SetPropertyOpen(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("open", &v)
+}
+
+func (x *BottomSheet) GetPropertyOpen() bool {
+	var v gobject.Value
+	x.GetProperty("open", &v)
+	return v.GetBoolean()
+}
+
+// The bottom sheet widget.
+//
+// Only shown when [property@BottomSheet:open] is `TRUE`.
+
+func (x *BottomSheet) SetPropertySheet(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("sheet", &v)
+}
+
+func (x *BottomSheet) GetPropertySheet() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("sheet", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The current bottom sheet height.
+//
+// It can be used to shift the content upwards when the bottom sheet is open.
+
+func (x *BottomSheet) GetPropertySheetHeight() int {
+	var v gobject.Value
+	x.GetProperty("sheet-height", &v)
+	return v.GetInt()
+}
+
+// Whether to overlay a drag handle in the bottom sheet.
+//
+// The handle will be overlaid over [property@BottomSheet:sheet].
+//
+// When the handle is shown, [class@HeaderBar] will hide its default title,
+// and [class@ToolbarView] will reserve space if there are no top bars.
+//
+// Showing drag handle also allows to swipe the bottom sheet down (and to
+// swipe the bottom bar up) with a pointer, instead of just touchscreen.
+
+func (x *BottomSheet) SetPropertyShowDragHandle(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-drag-handle", &v)
+}
+
+func (x *BottomSheet) GetPropertyShowDragHandle() bool {
+	var v gobject.Value
+	x.GetProperty("show-drag-handle", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when the close button or shortcut is used while
 // [property@Dialog:can-close] is set to `FALSE`.
 func (x *BottomSheet) ConnectCloseAttempt(cb *func(BottomSheet)) uint32 {
diff --git a/v4/adw/adw-breakpoint-bin.go b/v4/adw/adw-breakpoint-bin.go
index 69ba3bc9fbe5b417acd41fac5466a85565fe6750..a6864b74da2f988915709107fc489e87770e0ec2 100644
--- a/v4/adw/adw-breakpoint-bin.go
+++ b/v4/adw/adw-breakpoint-bin.go
@@ -246,6 +246,41 @@ func (c *BreakpointBin) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *BreakpointBin) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *BreakpointBin) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The current breakpoint.
+
+func (x *BreakpointBin) GetPropertyCurrentBreakpoint() *Breakpoint {
+	var v gobject.Value
+	x.GetProperty("current-breakpoint", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Breakpoint{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *BreakpointBin) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-breakpoint.go b/v4/adw/adw-breakpoint.go
index d790b3a0eb7f50e201897a55fabbf3e3a951c74e..9d5937f6fa9c47866246f2b9bdfb75ec7aeb84c4 100644
--- a/v4/adw/adw-breakpoint.go
+++ b/v4/adw/adw-breakpoint.go
@@ -431,6 +431,21 @@ func (c *Breakpoint) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The breakpoint's condition.
+
+func (x *Breakpoint) SetPropertyCondition(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("condition", &v)
+}
+
+func (x *Breakpoint) GetPropertyCondition() uintptr {
+	var v gobject.Value
+	x.GetProperty("condition", &v)
+	return v.GetPointer()
+}
+
 // Emitted when the breakpoint is applied.
 //
 // This signal is emitted after the setters have been applied.
diff --git a/v4/adw/adw-button-content.go b/v4/adw/adw-button-content.go
index b4b2b4155221324bfcf4ac82f5917e6bb9efeaba..337a61ee1ad898282ad14f8d165152f488a54d59 100644
--- a/v4/adw/adw-button-content.go
+++ b/v4/adw/adw-button-content.go
@@ -201,6 +201,76 @@ func (c *ButtonContent) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the button can be smaller than the natural size of its contents.
+//
+// If set to `TRUE`, the label will ellipsize.
+//
+// See [property@Gtk.Button:can-shrink].
+
+func (x *ButtonContent) SetPropertyCanShrink(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-shrink", &v)
+}
+
+func (x *ButtonContent) GetPropertyCanShrink() bool {
+	var v gobject.Value
+	x.GetProperty("can-shrink", &v)
+	return v.GetBoolean()
+}
+
+// The name of the displayed icon.
+//
+// If empty, the icon is not shown.
+
+func (x *ButtonContent) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *ButtonContent) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// The displayed label.
+
+func (x *ButtonContent) SetPropertyLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("label", &v)
+}
+
+func (x *ButtonContent) GetPropertyLabel() string {
+	var v gobject.Value
+	x.GetProperty("label", &v)
+	return v.GetString()
+}
+
+// Whether an underline in the text indicates a mnemonic.
+//
+// The mnemonic can be used to activate the parent button.
+//
+// See [property@ButtonContent:label].
+
+func (x *ButtonContent) SetPropertyUseUnderline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-underline", &v)
+}
+
+func (x *ButtonContent) GetPropertyUseUnderline() bool {
+	var v gobject.Value
+	x.GetProperty("use-underline", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ButtonContent) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-button-row.go b/v4/adw/adw-button-row.go
index 55b2182f3895c8724bb6ef457d5dc866c896966a..d94ac6d7e4adf56adce4dd4b8abb571c9b4f5f64 100644
--- a/v4/adw/adw-button-row.go
+++ b/v4/adw/adw-button-row.go
@@ -153,6 +153,36 @@ func (c *ButtonRow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The icon name to show after the title.
+
+func (x *ButtonRow) SetPropertyEndIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("end-icon-name", &v)
+}
+
+func (x *ButtonRow) GetPropertyEndIconName() string {
+	var v gobject.Value
+	x.GetProperty("end-icon-name", &v)
+	return v.GetString()
+}
+
+// The icon name to show before the title.
+
+func (x *ButtonRow) SetPropertyStartIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("start-icon-name", &v)
+}
+
+func (x *ButtonRow) GetPropertyStartIconName() string {
+	var v gobject.Value
+	x.GetProperty("start-icon-name", &v)
+	return v.GetString()
+}
+
 // This signal is emitted after the row has been activated.
 func (x *ButtonRow) ConnectActivated(cb *func(ButtonRow)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/adw/adw-carousel-indicator-dots.go b/v4/adw/adw-carousel-indicator-dots.go
index 8b735c1ec3073afcf83fcfec94b0ae75fade92dc..46e9becba91c945e7a6964bee124d62274902866 100644
--- a/v4/adw/adw-carousel-indicator-dots.go
+++ b/v4/adw/adw-carousel-indicator-dots.go
@@ -112,6 +112,27 @@ func (c *CarouselIndicatorDots) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The displayed carousel.
+
+func (x *CarouselIndicatorDots) SetPropertyCarousel(value *Carousel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("carousel", &v)
+}
+
+func (x *CarouselIndicatorDots) GetPropertyCarousel() *Carousel {
+	var v gobject.Value
+	x.GetProperty("carousel", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Carousel{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *CarouselIndicatorDots) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-carousel-indicator-lines.go b/v4/adw/adw-carousel-indicator-lines.go
index 738ade9bf7ad599cc0ee7f9d516c17619315cace..ac88ed3903a2732624ef19b8108ed7d4b9b49bd4 100644
--- a/v4/adw/adw-carousel-indicator-lines.go
+++ b/v4/adw/adw-carousel-indicator-lines.go
@@ -111,6 +111,27 @@ func (c *CarouselIndicatorLines) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The displayed carousel.
+
+func (x *CarouselIndicatorLines) SetPropertyCarousel(value *Carousel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("carousel", &v)
+}
+
+func (x *CarouselIndicatorLines) GetPropertyCarousel() *Carousel {
+	var v gobject.Value
+	x.GetProperty("carousel", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Carousel{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *CarouselIndicatorLines) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-carousel.go b/v4/adw/adw-carousel.go
index 275a56de91c6002a4cbe76a52025ac74b6424e09..ffe0c7c1a4197cc191c12ae22b1bd00c13ac164c 100644
--- a/v4/adw/adw-carousel.go
+++ b/v4/adw/adw-carousel.go
@@ -329,6 +329,146 @@ func (c *Carousel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to allow swiping for more than one page at a time.
+//
+// If the value is `FALSE`, each swipe can only move to the adjacent pages.
+
+func (x *Carousel) SetPropertyAllowLongSwipes(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-long-swipes", &v)
+}
+
+func (x *Carousel) GetPropertyAllowLongSwipes() bool {
+	var v gobject.Value
+	x.GetProperty("allow-long-swipes", &v)
+	return v.GetBoolean()
+}
+
+// Sets whether the `AdwCarousel` can be dragged with mouse pointer.
+//
+// If the value is `FALSE`, dragging is only available on touch.
+
+func (x *Carousel) SetPropertyAllowMouseDrag(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-mouse-drag", &v)
+}
+
+func (x *Carousel) GetPropertyAllowMouseDrag() bool {
+	var v gobject.Value
+	x.GetProperty("allow-mouse-drag", &v)
+	return v.GetBoolean()
+}
+
+// Whether the widget will respond to scroll wheel events.
+//
+// If the value is `FALSE`, wheel events will be ignored.
+
+func (x *Carousel) SetPropertyAllowScrollWheel(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-scroll-wheel", &v)
+}
+
+func (x *Carousel) GetPropertyAllowScrollWheel() bool {
+	var v gobject.Value
+	x.GetProperty("allow-scroll-wheel", &v)
+	return v.GetBoolean()
+}
+
+// Whether the carousel can be navigated.
+//
+// This can be used to temporarily disable the carousel to only allow
+// navigating it in a certain state.
+
+func (x *Carousel) SetPropertyInteractive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("interactive", &v)
+}
+
+func (x *Carousel) GetPropertyInteractive() bool {
+	var v gobject.Value
+	x.GetProperty("interactive", &v)
+	return v.GetBoolean()
+}
+
+// The number of pages in a `AdwCarousel`.
+
+func (x *Carousel) GetPropertyNPages() uint {
+	var v gobject.Value
+	x.GetProperty("n-pages", &v)
+	return v.GetUint()
+}
+
+// Current scrolling position, unitless.
+//
+// 1 matches 1 page. Use [method@Carousel.scroll_to] for changing it.
+
+func (x *Carousel) GetPropertyPosition() float64 {
+	var v gobject.Value
+	x.GetProperty("position", &v)
+	return v.GetDouble()
+}
+
+// Page reveal duration, in milliseconds.
+//
+// Reveal duration is used when animating adding or removing pages.
+
+func (x *Carousel) SetPropertyRevealDuration(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("reveal-duration", &v)
+}
+
+func (x *Carousel) GetPropertyRevealDuration() uint {
+	var v gobject.Value
+	x.GetProperty("reveal-duration", &v)
+	return v.GetUint()
+}
+
+// Scroll animation spring parameters.
+//
+// The default value is equivalent to:
+//
+// ```c
+// adw_spring_params_new (1, 0.5, 500)
+// ```
+
+func (x *Carousel) SetPropertyScrollParams(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("scroll-params", &v)
+}
+
+func (x *Carousel) GetPropertyScrollParams() uintptr {
+	var v gobject.Value
+	x.GetProperty("scroll-params", &v)
+	return v.GetPointer()
+}
+
+// Spacing between pages in pixels.
+
+func (x *Carousel) SetPropertySpacing(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("spacing", &v)
+}
+
+func (x *Carousel) GetPropertySpacing() uint {
+	var v gobject.Value
+	x.GetProperty("spacing", &v)
+	return v.GetUint()
+}
+
 // This signal is emitted after a page has been changed.
 //
 // It can be used to implement "infinite scrolling" by amending the pages
diff --git a/v4/adw/adw-clamp-layout.go b/v4/adw/adw-clamp-layout.go
index 3e2f2bf69f19967098417c5f6f268979daa675e0..ccf30da27b84498a1dc2e670fecbbf1723865295 100644
--- a/v4/adw/adw-clamp-layout.go
+++ b/v4/adw/adw-clamp-layout.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 	"github.com/jwijenbergh/puregotk/v4/gtk"
 )
@@ -160,6 +161,69 @@ }
 
 func (c *ClampLayout) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The maximum size to allocate to the children.
+//
+// It is the width if the layout is horizontal, or the height if it is
+// vertical.
+
+func (x *ClampLayout) SetPropertyMaximumSize(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("maximum-size", &v)
+}
+
+func (x *ClampLayout) GetPropertyMaximumSize() int {
+	var v gobject.Value
+	x.GetProperty("maximum-size", &v)
+	return v.GetInt()
+}
+
+// The size above which the children are clamped.
+//
+// Starting from this size, the layout will tighten its grip on the children,
+// slowly allocating less and less of the available size up to the maximum
+// allocated size. Below that threshold and below the maximum size, the
+// children will be allocated all the available size.
+//
+// If the threshold is greater than the maximum size to allocate to the
+// children, they will be allocated the whole size up to the maximum. If the
+// threshold is lower than the minimum size to allocate to the children, that
+// size will be used as the tightening threshold.
+//
+// Effectively, tightening the grip on a child before it reaches its maximum
+// size makes transitions to and from the maximum size smoother when resizing.
+
+func (x *ClampLayout) SetPropertyTighteningThreshold(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("tightening-threshold", &v)
+}
+
+func (x *ClampLayout) GetPropertyTighteningThreshold() int {
+	var v gobject.Value
+	x.GetProperty("tightening-threshold", &v)
+	return v.GetInt()
+}
+
+// The length unit for maximum size and tightening threshold.
+//
+// Allows the sizes to vary depending on the text scale factor.
+
+func (x *ClampLayout) SetPropertyUnit(value LengthUnit) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("unit", &v)
+}
+
+func (x *ClampLayout) GetPropertyUnit() LengthUnit {
+	var v gobject.Value
+	x.GetProperty("unit", &v)
+	return LengthUnit(v.GetEnum())
 }
 
 // Retrieves the orientation of the @orientable.
diff --git a/v4/adw/adw-clamp-scrollable.go b/v4/adw/adw-clamp-scrollable.go
index 9a134713e2319ddf112b20a85655b79296f4bafa..936710657144f9394138dafda281f387f6805117 100644
--- a/v4/adw/adw-clamp-scrollable.go
+++ b/v4/adw/adw-clamp-scrollable.go
@@ -172,6 +172,89 @@ func (c *ClampScrollable) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget of the `AdwClampScrollable`.
+
+func (x *ClampScrollable) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *ClampScrollable) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The maximum size allocated to the child.
+//
+// It is the width if the clamp is horizontal, or the height if it is vertical.
+
+func (x *ClampScrollable) SetPropertyMaximumSize(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("maximum-size", &v)
+}
+
+func (x *ClampScrollable) GetPropertyMaximumSize() int {
+	var v gobject.Value
+	x.GetProperty("maximum-size", &v)
+	return v.GetInt()
+}
+
+// The size above which the child is clamped.
+//
+// Starting from this size, the clamp will tighten its grip on the child,
+// slowly allocating less and less of the available size up to the maximum
+// allocated size. Below that threshold and below the maximum width, the child
+// will be allocated all the available size.
+//
+// If the threshold is greater than the maximum size to allocate to the child,
+// the child will be allocated all the width up to the maximum.
+// If the threshold is lower than the minimum size to allocate to the child,
+// that size will be used as the tightening threshold.
+//
+// Effectively, tightening the grip on the child before it reaches its maximum
+// size makes transitions to and from the maximum size smoother when resizing.
+
+func (x *ClampScrollable) SetPropertyTighteningThreshold(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("tightening-threshold", &v)
+}
+
+func (x *ClampScrollable) GetPropertyTighteningThreshold() int {
+	var v gobject.Value
+	x.GetProperty("tightening-threshold", &v)
+	return v.GetInt()
+}
+
+// The length unit for maximum size and tightening threshold.
+//
+// Allows the sizes to vary depending on the text scale factor.
+
+func (x *ClampScrollable) SetPropertyUnit(value LengthUnit) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("unit", &v)
+}
+
+func (x *ClampScrollable) GetPropertyUnit() LengthUnit {
+	var v gobject.Value
+	x.GetProperty("unit", &v)
+	return LengthUnit(v.GetEnum())
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ClampScrollable) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-clamp.go b/v4/adw/adw-clamp.go
index 10d6c8330825810870d8e39904d796b7fd48807e..8fdb7d9c6180bfe01e14f55dc691417c99568493 100644
--- a/v4/adw/adw-clamp.go
+++ b/v4/adw/adw-clamp.go
@@ -194,6 +194,89 @@ func (c *Clamp) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget of the `AdwClamp`.
+
+func (x *Clamp) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *Clamp) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The maximum size allocated to the child.
+//
+// It is the width if the clamp is horizontal, or the height if it is vertical.
+
+func (x *Clamp) SetPropertyMaximumSize(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("maximum-size", &v)
+}
+
+func (x *Clamp) GetPropertyMaximumSize() int {
+	var v gobject.Value
+	x.GetProperty("maximum-size", &v)
+	return v.GetInt()
+}
+
+// The size above which the child is clamped.
+//
+// Starting from this size, the clamp will tighten its grip on the child,
+// slowly allocating less and less of the available size up to the maximum
+// allocated size. Below that threshold and below the maximum size, the child
+// will be allocated all the available size.
+//
+// If the threshold is greater than the maximum size to allocate to the child,
+// the child will be allocated all the size up to the maximum.
+// If the threshold is lower than the minimum size to allocate to the child,
+// that size will be used as the tightening threshold.
+//
+// Effectively, tightening the grip on the child before it reaches its maximum
+// size makes transitions to and from the maximum size smoother when resizing.
+
+func (x *Clamp) SetPropertyTighteningThreshold(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("tightening-threshold", &v)
+}
+
+func (x *Clamp) GetPropertyTighteningThreshold() int {
+	var v gobject.Value
+	x.GetProperty("tightening-threshold", &v)
+	return v.GetInt()
+}
+
+// The length unit for maximum size and tightening threshold.
+//
+// Allows the sizes to vary depending on the text scale factor.
+
+func (x *Clamp) SetPropertyUnit(value LengthUnit) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("unit", &v)
+}
+
+func (x *Clamp) GetPropertyUnit() LengthUnit {
+	var v gobject.Value
+	x.GetProperty("unit", &v)
+	return LengthUnit(v.GetEnum())
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Clamp) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-combo-row.go b/v4/adw/adw-combo-row.go
index a3a7f94336ad2dabafcee99196f46139289bb3ed..e219d8305c57facb125331e9a5fd7213ae63a672 100644
--- a/v4/adw/adw-combo-row.go
+++ b/v4/adw/adw-combo-row.go
@@ -369,6 +369,212 @@ func (c *ComboRow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to show a search entry in the popup.
+//
+// If set to `TRUE`, a search entry will be shown in the popup that
+// allows to search for items in the list.
+//
+// Search requires [property@ComboRow:expression] to be set.
+
+func (x *ComboRow) SetPropertyEnableSearch(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-search", &v)
+}
+
+func (x *ComboRow) GetPropertyEnableSearch() bool {
+	var v gobject.Value
+	x.GetProperty("enable-search", &v)
+	return v.GetBoolean()
+}
+
+// An expression used to obtain strings from items.
+//
+// The expression must have a value type of `G_TYPE_STRING`.
+//
+// It's used to bind strings to labels produced by the default factory if
+// [property@ComboRow:factory] is not set, or when
+// [property@ComboRow:use-subtitle] is set to `TRUE`.
+
+func (x *ComboRow) SetPropertyExpression(value *gtk.Expression) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("expression", &v)
+}
+
+func (x *ComboRow) GetPropertyExpression() *gtk.Expression {
+	var v gobject.Value
+	x.GetProperty("expression", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Expression{}
+	result.Ptr = ptr
+	return result
+}
+
+// Factory for populating list items.
+//
+// This factory is always used for the item in the row. It is also used for
+// items in the popup unless [property@ComboRow:list-factory] is set.
+
+func (x *ComboRow) SetPropertyFactory(value *gtk.ListItemFactory) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("factory", &v)
+}
+
+func (x *ComboRow) GetPropertyFactory() *gtk.ListItemFactory {
+	var v gobject.Value
+	x.GetProperty("factory", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.ListItemFactory{}
+	result.Ptr = ptr
+	return result
+}
+
+// The factory for creating header widgets for the popup.
+
+func (x *ComboRow) SetPropertyHeaderFactory(value *gtk.ListItemFactory) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("header-factory", &v)
+}
+
+func (x *ComboRow) GetPropertyHeaderFactory() *gtk.ListItemFactory {
+	var v gobject.Value
+	x.GetProperty("header-factory", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.ListItemFactory{}
+	result.Ptr = ptr
+	return result
+}
+
+// The factory for populating list items in the popup.
+//
+// If this is not set, [property@ComboRow:factory] is used.
+
+func (x *ComboRow) SetPropertyListFactory(value *gtk.ListItemFactory) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("list-factory", &v)
+}
+
+func (x *ComboRow) GetPropertyListFactory() *gtk.ListItemFactory {
+	var v gobject.Value
+	x.GetProperty("list-factory", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.ListItemFactory{}
+	result.Ptr = ptr
+	return result
+}
+
+// The model that provides the displayed items.
+
+func (x *ComboRow) SetPropertyModel(value gio.ListModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *ComboRow) GetPropertyModel() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The match mode for the search filter.
+
+func (x *ComboRow) SetPropertySearchMatchMode(value gtk.StringFilterMatchMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("search-match-mode", &v)
+}
+
+func (x *ComboRow) GetPropertySearchMatchMode() gtk.StringFilterMatchMode {
+	var v gobject.Value
+	x.GetProperty("search-match-mode", &v)
+	return gtk.StringFilterMatchMode(v.GetEnum())
+}
+
+// The position of the selected item.
+//
+// If no item is selected, the property has the value
+// [const@Gtk.INVALID_LIST_POSITION]
+
+func (x *ComboRow) SetPropertySelected(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("selected", &v)
+}
+
+func (x *ComboRow) GetPropertySelected() uint {
+	var v gobject.Value
+	x.GetProperty("selected", &v)
+	return v.GetUint()
+}
+
+// The selected item.
+
+func (x *ComboRow) GetPropertySelectedItem() *gobject.Object {
+	var v gobject.Value
+	x.GetProperty("selected-item", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gobject.Object{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to use the current value as the subtitle.
+//
+// If you use a custom list item factory, you will need to give the row a
+// name conversion expression with [property@ComboRow:expression].
+//
+// If set to `TRUE`, you should not access [property@ActionRow:subtitle].
+//
+// The subtitle is interpreted as Pango markup if
+// [property@PreferencesRow:use-markup] is set to `TRUE`.
+
+func (x *ComboRow) SetPropertyUseSubtitle(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-subtitle", &v)
+}
+
+func (x *ComboRow) GetPropertyUseSubtitle() bool {
+	var v gobject.Value
+	x.GetProperty("use-subtitle", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ComboRow) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-dialog.go b/v4/adw/adw-dialog.go
index 454a8093fef891bafd4db7200ac467cffd956063..3a4b429fa7a9b7f1d06c8ed79b6dc397fe6f0c96 100644
--- a/v4/adw/adw-dialog.go
+++ b/v4/adw/adw-dialog.go
@@ -494,6 +494,204 @@ func (c *Dialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the dialog can be closed.
+//
+// If set to `FALSE`, the close button, shortcuts and
+// [method@Dialog.close] will result in [signal@Dialog::close-attempt] being
+// emitted instead, and bottom sheet close swipe will be disabled.
+// [method@Dialog.force_close] still works.
+
+func (x *Dialog) SetPropertyCanClose(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-close", &v)
+}
+
+func (x *Dialog) GetPropertyCanClose() bool {
+	var v gobject.Value
+	x.GetProperty("can-close", &v)
+	return v.GetBoolean()
+}
+
+// The child widget of the `AdwDialog`.
+
+func (x *Dialog) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *Dialog) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The height of the dialog's contents.
+//
+// Set it to -1 to reset it to the content's natural height.
+//
+// See also: [property@Gtk.Window:default-height]
+
+func (x *Dialog) SetPropertyContentHeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("content-height", &v)
+}
+
+func (x *Dialog) GetPropertyContentHeight() int {
+	var v gobject.Value
+	x.GetProperty("content-height", &v)
+	return v.GetInt()
+}
+
+// The width of the dialog's contents.
+//
+// Set it to -1 to reset it to the content's natural width.
+//
+// See also: [property@Gtk.Window:default-width]
+
+func (x *Dialog) SetPropertyContentWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("content-width", &v)
+}
+
+func (x *Dialog) GetPropertyContentWidth() int {
+	var v gobject.Value
+	x.GetProperty("content-width", &v)
+	return v.GetInt()
+}
+
+// The current breakpoint.
+
+func (x *Dialog) GetPropertyCurrentBreakpoint() *Breakpoint {
+	var v gobject.Value
+	x.GetProperty("current-breakpoint", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Breakpoint{}
+	result.Ptr = ptr
+	return result
+}
+
+// The default widget.
+//
+// It's activated when the user presses Enter.
+
+func (x *Dialog) SetPropertyDefaultWidget(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("default-widget", &v)
+}
+
+func (x *Dialog) GetPropertyDefaultWidget() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("default-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The focus widget.
+
+func (x *Dialog) SetPropertyFocusWidget(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("focus-widget", &v)
+}
+
+func (x *Dialog) GetPropertyFocusWidget() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("focus-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to size content automatically.
+//
+// If set to `TRUE`, always use the content's natural size instead of
+// [property@Dialog:content-width] and [property@Dialog:content-height]. If
+// the content resizes, the dialog will immediately resize as well.
+//
+// See also: [property@Gtk.Window:resizable]
+
+func (x *Dialog) SetPropertyFollowsContentSize(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("follows-content-size", &v)
+}
+
+func (x *Dialog) GetPropertyFollowsContentSize() bool {
+	var v gobject.Value
+	x.GetProperty("follows-content-size", &v)
+	return v.GetBoolean()
+}
+
+// The dialog's presentation mode.
+//
+// When set to `ADW_DIALOG_AUTO`, the dialog appears as a bottom sheet when
+// the following condition is met: `max-width: 450px or max-height: 360px`,
+// and as a floating window otherwise.
+//
+// Set it to `ADW_DIALOG_FLOATING` or `ADW_DIALOG_BOTTOM_SHEET` to always
+// present it a floating window or a bottom sheet respectively, regardless of
+// available size.
+//
+// Presentation mode does nothing for dialogs presented as a window.
+
+func (x *Dialog) SetPropertyPresentationMode(value DialogPresentationMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("presentation-mode", &v)
+}
+
+func (x *Dialog) GetPropertyPresentationMode() DialogPresentationMode {
+	var v gobject.Value
+	x.GetProperty("presentation-mode", &v)
+	return DialogPresentationMode(v.GetEnum())
+}
+
+// The title of the dialog.
+
+func (x *Dialog) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *Dialog) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
 // Emitted when the close button or shortcut is used, or
 // [method@Dialog.close] is called while [property@Dialog:can-close] is set to
 // `FALSE`.
diff --git a/v4/adw/adw-entry-row.go b/v4/adw/adw-entry-row.go
index 1310a43275dfbb875eee8ce63a795ec7fb9ecfc8..150cd0342cade84e37f351c0d55e5a5263ec4635 100644
--- a/v4/adw/adw-entry-row.go
+++ b/v4/adw/adw-entry-row.go
@@ -296,6 +296,138 @@ func (c *EntryRow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether activating the embedded entry can activate the default widget.
+
+func (x *EntryRow) SetPropertyActivatesDefault(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activates-default", &v)
+}
+
+func (x *EntryRow) GetPropertyActivatesDefault() bool {
+	var v gobject.Value
+	x.GetProperty("activates-default", &v)
+	return v.GetBoolean()
+}
+
+// A list of Pango attributes to apply to the text of the embedded entry.
+//
+// The [struct@Pango.Attribute]'s `start_index` and `end_index` must refer to
+// the [class@Gtk.EntryBuffer] text, i.e. without the preedit string.
+
+func (x *EntryRow) SetPropertyAttributes(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("attributes", &v)
+}
+
+func (x *EntryRow) GetPropertyAttributes() uintptr {
+	var v gobject.Value
+	x.GetProperty("attributes", &v)
+	return v.GetPointer()
+}
+
+// Whether to suggest emoji replacements on the entry row.
+//
+// Emoji replacement is done with :-delimited names, like `:heart:`.
+
+func (x *EntryRow) SetPropertyEnableEmojiCompletion(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-emoji-completion", &v)
+}
+
+func (x *EntryRow) GetPropertyEnableEmojiCompletion() bool {
+	var v gobject.Value
+	x.GetProperty("enable-emoji-completion", &v)
+	return v.GetBoolean()
+}
+
+// Additional input hints for the entry row.
+//
+// Input hints allow input methods to fine-tune their behavior.
+//
+// See also: [property@Adw.EntryRow:input-purpose]
+
+func (x *EntryRow) SetPropertyInputHints(value gtk.InputHints) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("input-hints", &v)
+}
+
+func (x *EntryRow) GetPropertyInputHints() gtk.InputHints {
+	var v gobject.Value
+	x.GetProperty("input-hints", &v)
+	return gtk.InputHints(v.GetFlags())
+}
+
+// The input purpose of the entry row.
+//
+// The input purpose can be used by input methods to adjust their behavior.
+
+func (x *EntryRow) SetPropertyInputPurpose(value gtk.InputPurpose) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("input-purpose", &v)
+}
+
+func (x *EntryRow) GetPropertyInputPurpose() gtk.InputPurpose {
+	var v gobject.Value
+	x.GetProperty("input-purpose", &v)
+	return gtk.InputPurpose(v.GetEnum())
+}
+
+// Maximum number of characters for the entry.
+
+func (x *EntryRow) SetPropertyMaxLength(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-length", &v)
+}
+
+func (x *EntryRow) GetPropertyMaxLength() int {
+	var v gobject.Value
+	x.GetProperty("max-length", &v)
+	return v.GetInt()
+}
+
+// Whether to show the apply button.
+//
+// When set to `TRUE`, typing text in the entry will reveal an apply button.
+// Clicking it or pressing the &lt;kbd&gt;Enter&lt;/kbd&gt; key will hide the button and
+// emit the [signal@EntryRow::apply] signal.
+//
+// This is useful if changing the entry contents can trigger an expensive
+// operation, e.g. network activity, to avoid triggering it after typing every
+// character.
+
+func (x *EntryRow) SetPropertyShowApplyButton(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-apply-button", &v)
+}
+
+func (x *EntryRow) GetPropertyShowApplyButton() bool {
+	var v gobject.Value
+	x.GetProperty("show-apply-button", &v)
+	return v.GetBoolean()
+}
+
+// The length of the text in the entry row.
+
+func (x *EntryRow) GetPropertyTextLength() uint {
+	var v gobject.Value
+	x.GetProperty("text-length", &v)
+	return v.GetUint()
+}
+
 // Emitted when the apply button is pressed.
 //
 // See [property@EntryRow:show-apply-button].
diff --git a/v4/adw/adw-enum-list-model.go b/v4/adw/adw-enum-list-model.go
index d38d7c90dbef6e94ad6a579c5ceb68906170bed7..84bbd35e31c727e016d52e57e4962e8ae594ebcb 100644
--- a/v4/adw/adw-enum-list-model.go
+++ b/v4/adw/adw-enum-list-model.go
@@ -87,6 +87,30 @@ func (c *EnumListItem) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The enum value name.
+
+func (x *EnumListItem) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// The enum value nick.
+
+func (x *EnumListItem) GetPropertyNick() string {
+	var v gobject.Value
+	x.GetProperty("nick", &v)
+	return v.GetString()
+}
+
+// The enum value.
+
+func (x *EnumListItem) GetPropertyValue() int {
+	var v gobject.Value
+	x.GetProperty("value", &v)
+	return v.GetInt()
+}
+
 // A [iface@Gio.ListModel] representing values of a given enum.
 //
 // `AdwEnumListModel` contains objects of type [class@EnumListItem].
@@ -151,6 +175,21 @@ }
 
 func (c *EnumListModel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The type of the enum represented by the model.
+
+func (x *EnumListModel) SetPropertyEnumType(value types.GType) {
+	var v gobject.Value
+	v.Init(gobject.TypeGtypeVal)
+	v.SetGtype(value)
+	x.SetProperty("enum-type", &v)
+}
+
+func (x *EnumListModel) GetPropertyEnumType() types.GType {
+	var v gobject.Value
+	x.GetProperty("enum-type", &v)
+	return v.GetGtype()
 }
 
 // Get the item at @position.
diff --git a/v4/adw/adw-expander-row.go b/v4/adw/adw-expander-row.go
index 8a2cd014046a72626c4a08e76804c87128ea3e1f..5c897614f800d1ee2ab6d3144a7c131467ee11db 100644
--- a/v4/adw/adw-expander-row.go
+++ b/v4/adw/adw-expander-row.go
@@ -292,6 +292,119 @@ func (c *ExpanderRow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether expansion is enabled.
+
+func (x *ExpanderRow) SetPropertyEnableExpansion(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-expansion", &v)
+}
+
+func (x *ExpanderRow) GetPropertyEnableExpansion() bool {
+	var v gobject.Value
+	x.GetProperty("enable-expansion", &v)
+	return v.GetBoolean()
+}
+
+// Whether the row is expanded.
+
+func (x *ExpanderRow) SetPropertyExpanded(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("expanded", &v)
+}
+
+func (x *ExpanderRow) GetPropertyExpanded() bool {
+	var v gobject.Value
+	x.GetProperty("expanded", &v)
+	return v.GetBoolean()
+}
+
+// The icon name for this row.
+
+func (x *ExpanderRow) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *ExpanderRow) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// Whether the switch enabling the expansion is visible.
+
+func (x *ExpanderRow) SetPropertyShowEnableSwitch(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-enable-switch", &v)
+}
+
+func (x *ExpanderRow) GetPropertyShowEnableSwitch() bool {
+	var v gobject.Value
+	x.GetProperty("show-enable-switch", &v)
+	return v.GetBoolean()
+}
+
+// The subtitle for this row.
+//
+// The subtitle is interpreted as Pango markup unless
+// [property@PreferencesRow:use-markup] is set to `FALSE`.
+
+func (x *ExpanderRow) SetPropertySubtitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("subtitle", &v)
+}
+
+func (x *ExpanderRow) GetPropertySubtitle() string {
+	var v gobject.Value
+	x.GetProperty("subtitle", &v)
+	return v.GetString()
+}
+
+// The number of lines at the end of which the subtitle label will be
+// ellipsized.
+//
+// If the value is 0, the number of lines won't be limited.
+
+func (x *ExpanderRow) SetPropertySubtitleLines(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("subtitle-lines", &v)
+}
+
+func (x *ExpanderRow) GetPropertySubtitleLines() int {
+	var v gobject.Value
+	x.GetProperty("subtitle-lines", &v)
+	return v.GetInt()
+}
+
+// The number of lines at the end of which the title label will be ellipsized.
+//
+// If the value is 0, the number of lines won't be limited.
+
+func (x *ExpanderRow) SetPropertyTitleLines(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("title-lines", &v)
+}
+
+func (x *ExpanderRow) GetPropertyTitleLines() int {
+	var v gobject.Value
+	x.GetProperty("title-lines", &v)
+	return v.GetInt()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ExpanderRow) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-flap.go b/v4/adw/adw-flap.go
index 10f58e4b0deb7b2545d2d43f7df0d7c069c3127a..bca2e79927b6b0e9fc5096a851bde777ad1b1bec 100644
--- a/v4/adw/adw-flap.go
+++ b/v4/adw/adw-flap.go
@@ -519,6 +519,299 @@ func (c *Flap) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The content widget.
+//
+// It's always displayed when unfolded, and partially visible when folded.
+
+func (x *Flap) SetPropertyContent(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("content", &v)
+}
+
+func (x *Flap) GetPropertyContent() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("content", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The flap widget.
+//
+// It's only visible when [property@Flap:reveal-progress] is greater than 0.
+
+func (x *Flap) SetPropertyFlap(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("flap", &v)
+}
+
+func (x *Flap) GetPropertyFlap() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("flap", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The flap position.
+//
+// If it's set to `GTK_PACK_START`, the flap is displayed before the content,
+// if `GTK_PACK_END`, it's displayed after the content.
+
+func (x *Flap) SetPropertyFlapPosition(value gtk.PackType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("flap-position", &v)
+}
+
+func (x *Flap) GetPropertyFlapPosition() gtk.PackType {
+	var v gobject.Value
+	x.GetProperty("flap-position", &v)
+	return gtk.PackType(v.GetEnum())
+}
+
+// The fold transition animation duration, in milliseconds.
+
+func (x *Flap) SetPropertyFoldDuration(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("fold-duration", &v)
+}
+
+func (x *Flap) GetPropertyFoldDuration() uint {
+	var v gobject.Value
+	x.GetProperty("fold-duration", &v)
+	return v.GetUint()
+}
+
+// The fold policy for the flap.
+
+func (x *Flap) SetPropertyFoldPolicy(value FlapFoldPolicy) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("fold-policy", &v)
+}
+
+func (x *Flap) GetPropertyFoldPolicy() FlapFoldPolicy {
+	var v gobject.Value
+	x.GetProperty("fold-policy", &v)
+	return FlapFoldPolicy(v.GetEnum())
+}
+
+// Determines when the flap will fold.
+//
+// If set to `ADW_FOLD_THRESHOLD_POLICY_MINIMUM`, flap will only fold when
+// the children cannot fit anymore. With `ADW_FOLD_THRESHOLD_POLICY_NATURAL`,
+// it will fold as soon as children don't get their natural size.
+//
+// This can be useful if you have a long ellipsizing label and want to let it
+// ellipsize instead of immediately folding.
+
+func (x *Flap) SetPropertyFoldThresholdPolicy(value FoldThresholdPolicy) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("fold-threshold-policy", &v)
+}
+
+func (x *Flap) GetPropertyFoldThresholdPolicy() FoldThresholdPolicy {
+	var v gobject.Value
+	x.GetProperty("fold-threshold-policy", &v)
+	return FoldThresholdPolicy(v.GetEnum())
+}
+
+// Whether the flap is currently folded.
+//
+// See [property@Flap:fold-policy].
+
+func (x *Flap) GetPropertyFolded() bool {
+	var v gobject.Value
+	x.GetProperty("folded", &v)
+	return v.GetBoolean()
+}
+
+// Whether the flap is locked.
+//
+// If `FALSE`, folding when the flap is revealed automatically closes it, and
+// unfolding it when the flap is not revealed opens it. If `TRUE`,
+// [property@Flap:reveal-flap] value never changes on its own.
+
+func (x *Flap) SetPropertyLocked(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("locked", &v)
+}
+
+func (x *Flap) GetPropertyLocked() bool {
+	var v gobject.Value
+	x.GetProperty("locked", &v)
+	return v.GetBoolean()
+}
+
+// Whether the flap is modal.
+//
+// If `TRUE`, clicking the content widget while flap is revealed, as well as
+// pressing the &lt;kbd&gt;Esc&lt;/kbd&gt; key, will close the flap. If `FALSE`, clicks
+// are passed through to the content widget.
+
+func (x *Flap) SetPropertyModal(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("modal", &v)
+}
+
+func (x *Flap) GetPropertyModal() bool {
+	var v gobject.Value
+	x.GetProperty("modal", &v)
+	return v.GetBoolean()
+}
+
+// Whether the flap widget is revealed.
+
+func (x *Flap) SetPropertyRevealFlap(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reveal-flap", &v)
+}
+
+func (x *Flap) GetPropertyRevealFlap() bool {
+	var v gobject.Value
+	x.GetProperty("reveal-flap", &v)
+	return v.GetBoolean()
+}
+
+// The reveal animation spring parameters.
+//
+// The default value is equivalent to:
+//
+// ```c
+// adw_spring_params_new (1, 0.5, 500)
+// ```
+
+func (x *Flap) SetPropertyRevealParams(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("reveal-params", &v)
+}
+
+func (x *Flap) GetPropertyRevealParams() uintptr {
+	var v gobject.Value
+	x.GetProperty("reveal-params", &v)
+	return v.GetPointer()
+}
+
+// The current reveal transition progress.
+//
+// 0 means fully hidden, 1 means fully revealed.
+//
+// See [property@Flap:reveal-flap].
+
+func (x *Flap) GetPropertyRevealProgress() float64 {
+	var v gobject.Value
+	x.GetProperty("reveal-progress", &v)
+	return v.GetDouble()
+}
+
+// The separator widget.
+//
+// It's displayed between content and flap when there's no shadow to display.
+// When exactly it's visible depends on the [property@Flap:transition-type]
+// value.
+
+func (x *Flap) SetPropertySeparator(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("separator", &v)
+}
+
+func (x *Flap) GetPropertySeparator() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("separator", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the flap can be closed with a swipe gesture.
+//
+// The area that can be swiped depends on the [property@Flap:transition-type]
+// value.
+
+func (x *Flap) SetPropertySwipeToClose(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("swipe-to-close", &v)
+}
+
+func (x *Flap) GetPropertySwipeToClose() bool {
+	var v gobject.Value
+	x.GetProperty("swipe-to-close", &v)
+	return v.GetBoolean()
+}
+
+// Whether the flap can be opened with a swipe gesture.
+//
+// The area that can be swiped depends on the [property@Flap:transition-type]
+// value.
+
+func (x *Flap) SetPropertySwipeToOpen(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("swipe-to-open", &v)
+}
+
+func (x *Flap) GetPropertySwipeToOpen() bool {
+	var v gobject.Value
+	x.GetProperty("swipe-to-open", &v)
+	return v.GetBoolean()
+}
+
+// the type of animation used for reveal and fold transitions.
+//
+// [property@Flap:flap] is transparent by default, which means the content
+// will be seen through it with `ADW_FLAP_TRANSITION_TYPE_OVER` transitions;
+// add the [`.background`](style-classes.html#background) style class to it if
+// this is unwanted.
+
+func (x *Flap) SetPropertyTransitionType(value FlapTransitionType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("transition-type", &v)
+}
+
+func (x *Flap) GetPropertyTransitionType() FlapTransitionType {
+	var v gobject.Value
+	x.GetProperty("transition-type", &v)
+	return FlapTransitionType(v.GetEnum())
+}
+
 // Gets the progress @self will snap back to after the gesture is canceled.
 func (x *Flap) GetCancelProgress() float64 {
 
diff --git a/v4/adw/adw-header-bar.go b/v4/adw/adw-header-bar.go
index d90befe54ca0d8d92013a7a80661b445a706252e..631c66252c758b74dbb95018b28ee7d5973bc34e 100644
--- a/v4/adw/adw-header-bar.go
+++ b/v4/adw/adw-header-bar.go
@@ -388,6 +388,160 @@ func (c *HeaderBar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The policy for aligning the center widget.
+
+func (x *HeaderBar) SetPropertyCenteringPolicy(value CenteringPolicy) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("centering-policy", &v)
+}
+
+func (x *HeaderBar) GetPropertyCenteringPolicy() CenteringPolicy {
+	var v gobject.Value
+	x.GetProperty("centering-policy", &v)
+	return CenteringPolicy(v.GetEnum())
+}
+
+// The decoration layout for buttons.
+//
+// If this property is not set, the
+// [property@Gtk.Settings:gtk-decoration-layout] setting is used.
+//
+// The format of the string is button names, separated by commas. A colon
+// separates the buttons that should appear at the start from those at the
+// end. Recognized button names are minimize, maximize, close and icon (the
+// window icon).
+//
+// For example, âicon:minimize,maximize,closeâ specifies an icon at the start,
+// and minimize, maximize and close buttons at the end.
+
+func (x *HeaderBar) SetPropertyDecorationLayout(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("decoration-layout", &v)
+}
+
+func (x *HeaderBar) GetPropertyDecorationLayout() string {
+	var v gobject.Value
+	x.GetProperty("decoration-layout", &v)
+	return v.GetString()
+}
+
+// Whether the header bar can show the back button.
+//
+// The back button will never be shown unless the header bar is placed inside an
+// [class@NavigationView]. Usually, there is no reason to set this to `FALSE`.
+
+func (x *HeaderBar) SetPropertyShowBackButton(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-back-button", &v)
+}
+
+func (x *HeaderBar) GetPropertyShowBackButton() bool {
+	var v gobject.Value
+	x.GetProperty("show-back-button", &v)
+	return v.GetBoolean()
+}
+
+// Whether to show title buttons at the end of the header bar.
+//
+// See [property@HeaderBar:show-start-title-buttons] for the other side.
+//
+// Which buttons are actually shown and where is determined by the
+// [property@HeaderBar:decoration-layout] property, and by the state of the
+// window (e.g. a close button will not be shown if the window can't be
+// closed).
+
+func (x *HeaderBar) SetPropertyShowEndTitleButtons(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-end-title-buttons", &v)
+}
+
+func (x *HeaderBar) GetPropertyShowEndTitleButtons() bool {
+	var v gobject.Value
+	x.GetProperty("show-end-title-buttons", &v)
+	return v.GetBoolean()
+}
+
+// Whether to show title buttons at the start of the header bar.
+//
+// See [property@HeaderBar:show-end-title-buttons] for the other side.
+//
+// Which buttons are actually shown and where is determined by the
+// [property@HeaderBar:decoration-layout] property, and by the state of the
+// window (e.g. a close button will not be shown if the window can't be
+// closed).
+
+func (x *HeaderBar) SetPropertyShowStartTitleButtons(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-start-title-buttons", &v)
+}
+
+func (x *HeaderBar) GetPropertyShowStartTitleButtons() bool {
+	var v gobject.Value
+	x.GetProperty("show-start-title-buttons", &v)
+	return v.GetBoolean()
+}
+
+// Whether the title widget should be shown.
+
+func (x *HeaderBar) SetPropertyShowTitle(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-title", &v)
+}
+
+func (x *HeaderBar) GetPropertyShowTitle() bool {
+	var v gobject.Value
+	x.GetProperty("show-title", &v)
+	return v.GetBoolean()
+}
+
+// The title widget to display.
+//
+// When set to `NULL`, the header bar will display the title of the window it
+// is contained in.
+//
+// To use a different title, use [class@WindowTitle]:
+//
+// ```xml
+// &lt;object class="AdwHeaderBar"&gt;
+//   &lt;property name="title-widget"&gt;
+//     &lt;object class="AdwWindowTitle"&gt;
+//       &lt;property name="title" translatable="yes"&gt;Title&lt;/property&gt;
+//     &lt;/object&gt;
+//   &lt;/property&gt;
+// &lt;/object&gt;
+// ```
+
+func (x *HeaderBar) SetPropertyTitleWidget(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("title-widget", &v)
+}
+
+func (x *HeaderBar) GetPropertyTitleWidget() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("title-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *HeaderBar) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-layout-slot.go b/v4/adw/adw-layout-slot.go
index 804d27b11a14d17347ceb272ec8d77e786039a24..32a913f2d7514e330ada952d53eee678b2edaf88 100644
--- a/v4/adw/adw-layout-slot.go
+++ b/v4/adw/adw-layout-slot.go
@@ -81,6 +81,23 @@ func (c *LayoutSlot) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The slot ID.
+//
+// See [method@MultiLayoutView.set_child].
+
+func (x *LayoutSlot) SetPropertyId(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("id", &v)
+}
+
+func (x *LayoutSlot) GetPropertyId() string {
+	var v gobject.Value
+	x.GetProperty("id", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *LayoutSlot) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-layout.go b/v4/adw/adw-layout.go
index e4e6de4e3ee330ad8e2b27195c25c68593aa8462..a6d58a37947703b1062597ed8077c564d08041a6 100644
--- a/v4/adw/adw-layout.go
+++ b/v4/adw/adw-layout.go
@@ -101,6 +101,42 @@ func (c *Layout) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The content widget.
+
+func (x *Layout) SetPropertyContent(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("content", &v)
+}
+
+func (x *Layout) GetPropertyContent() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("content", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the layout.
+
+func (x *Layout) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *Layout) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
 // Gets the ID of the @buildable object.
 //
 // `GtkBuilder` sets the name based on the ID attribute
diff --git a/v4/adw/adw-leaflet.go b/v4/adw/adw-leaflet.go
index db1bd254bb61c22dab0dfd17d01c259dfd601920..32da57cf77f9a22ac5525785074fa5c9dfca1699 100644
--- a/v4/adw/adw-leaflet.go
+++ b/v4/adw/adw-leaflet.go
@@ -572,6 +572,259 @@ func (c *Leaflet) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether gestures and shortcuts for navigating backward are enabled.
+//
+// The supported gestures are:
+//
+// - One-finger swipe on touchscreens
+// - Horizontal scrolling on touchpads (usually two-finger swipe)
+// - Back/forward mouse buttons
+//
+// The keyboard back/forward keys are also supported, as well as the
+// &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;â&lt;/kbd&gt; shortcut for horizontal orientation, or
+// &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;â&lt;/kbd&gt; for vertical orientation.
+//
+// If the orientation is horizontal, for right-to-left locales, gestures and
+// shortcuts are reversed.
+//
+// Only children that have [property@LeafletPage:navigatable] set to `TRUE`
+// can be navigated to.
+
+func (x *Leaflet) SetPropertyCanNavigateBack(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-navigate-back", &v)
+}
+
+func (x *Leaflet) GetPropertyCanNavigateBack() bool {
+	var v gobject.Value
+	x.GetProperty("can-navigate-back", &v)
+	return v.GetBoolean()
+}
+
+// Whether gestures and shortcuts for navigating forward are enabled.
+//
+// The supported gestures are:
+//
+// - One-finger swipe on touchscreens
+// - Horizontal scrolling on touchpads (usually two-finger swipe)
+// - Back/forward mouse buttons
+//
+// The keyboard back/forward keys are also supported, as well as the
+// &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;â&lt;/kbd&gt; shortcut for horizontal orientation, or
+// &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;â&lt;/kbd&gt; for vertical orientation.
+//
+// If the orientation is horizontal, for right-to-left locales, gestures and
+// shortcuts are reversed.
+//
+// Only children that have [property@LeafletPage:navigatable] set to `TRUE`
+// can be navigated to.
+
+func (x *Leaflet) SetPropertyCanNavigateForward(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-navigate-forward", &v)
+}
+
+func (x *Leaflet) GetPropertyCanNavigateForward() bool {
+	var v gobject.Value
+	x.GetProperty("can-navigate-forward", &v)
+	return v.GetBoolean()
+}
+
+// Whether or not the leaflet can unfold.
+
+func (x *Leaflet) SetPropertyCanUnfold(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-unfold", &v)
+}
+
+func (x *Leaflet) GetPropertyCanUnfold() bool {
+	var v gobject.Value
+	x.GetProperty("can-unfold", &v)
+	return v.GetBoolean()
+}
+
+// The child transition spring parameters.
+//
+// The default value is equivalent to:
+//
+// ```c
+// adw_spring_params_new (1, 0.5, 500)
+// ```
+
+func (x *Leaflet) SetPropertyChildTransitionParams(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("child-transition-params", &v)
+}
+
+func (x *Leaflet) GetPropertyChildTransitionParams() uintptr {
+	var v gobject.Value
+	x.GetProperty("child-transition-params", &v)
+	return v.GetPointer()
+}
+
+// Whether a child transition is currently running.
+
+func (x *Leaflet) GetPropertyChildTransitionRunning() bool {
+	var v gobject.Value
+	x.GetProperty("child-transition-running", &v)
+	return v.GetBoolean()
+}
+
+// Determines when the leaflet will fold.
+//
+// If set to `ADW_FOLD_THRESHOLD_POLICY_MINIMUM`, it will only fold when the
+// children cannot fit anymore. With `ADW_FOLD_THRESHOLD_POLICY_NATURAL`, it
+// will fold as soon as children don't get their natural size.
+//
+// This can be useful if you have a long ellipsizing label and want to let it
+// ellipsize instead of immediately folding.
+
+func (x *Leaflet) SetPropertyFoldThresholdPolicy(value FoldThresholdPolicy) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("fold-threshold-policy", &v)
+}
+
+func (x *Leaflet) GetPropertyFoldThresholdPolicy() FoldThresholdPolicy {
+	var v gobject.Value
+	x.GetProperty("fold-threshold-policy", &v)
+	return FoldThresholdPolicy(v.GetEnum())
+}
+
+// Whether the leaflet is folded.
+//
+// The leaflet will be folded if the size allocated to it is smaller than the
+// sum of the minimum or natural sizes of the children (see
+// [property@Leaflet:fold-threshold-policy]), it will be unfolded otherwise.
+
+func (x *Leaflet) GetPropertyFolded() bool {
+	var v gobject.Value
+	x.GetProperty("folded", &v)
+	return v.GetBoolean()
+}
+
+// Whether the leaflet allocates the same size for all children when folded.
+//
+// If set to `FALSE`, different children can have different size along the
+// opposite orientation.
+
+func (x *Leaflet) SetPropertyHomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("homogeneous", &v)
+}
+
+func (x *Leaflet) GetPropertyHomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("homogeneous", &v)
+	return v.GetBoolean()
+}
+
+// The mode transition animation duration, in milliseconds.
+
+func (x *Leaflet) SetPropertyModeTransitionDuration(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("mode-transition-duration", &v)
+}
+
+func (x *Leaflet) GetPropertyModeTransitionDuration() uint {
+	var v gobject.Value
+	x.GetProperty("mode-transition-duration", &v)
+	return v.GetUint()
+}
+
+// A selection model with the leaflet's pages.
+//
+// This can be used to keep an up-to-date view. The model also implements
+// [iface@Gtk.SelectionModel] and can be used to track and change the visible
+// page.
+
+func (x *Leaflet) GetPropertyPages() gtk.SelectionModel {
+	var v gobject.Value
+	x.GetProperty("pages", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.SelectionModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The type of animation used for transitions between modes and children.
+//
+// The transition type can be changed without problems at runtime, so it is
+// possible to change the animation based on the mode or child that is about
+// to become current.
+
+func (x *Leaflet) SetPropertyTransitionType(value LeafletTransitionType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("transition-type", &v)
+}
+
+func (x *Leaflet) GetPropertyTransitionType() LeafletTransitionType {
+	var v gobject.Value
+	x.GetProperty("transition-type", &v)
+	return LeafletTransitionType(v.GetEnum())
+}
+
+// The widget currently visible when the leaflet is folded.
+//
+// The transition is determined by [property@Leaflet:transition-type] and
+// [property@Leaflet:child-transition-params]. The transition can be cancelled
+// by the user, in which case visible child will change back to the previously
+// visible child.
+
+func (x *Leaflet) SetPropertyVisibleChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("visible-child", &v)
+}
+
+func (x *Leaflet) GetPropertyVisibleChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("visible-child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the widget currently visible when the leaflet is folded.
+//
+// See [property@Leaflet:visible-child].
+
+func (x *Leaflet) SetPropertyVisibleChildName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("visible-child-name", &v)
+}
+
+func (x *Leaflet) GetPropertyVisibleChildName() string {
+	var v gobject.Value
+	x.GetProperty("visible-child-name", &v)
+	return v.GetString()
+}
+
 // Gets the progress @self will snap back to after the gesture is canceled.
 func (x *Leaflet) GetCancelProgress() float64 {
 
@@ -861,6 +1114,63 @@ }
 
 func (c *LeafletPage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The leaflet child to which the page belongs.
+
+func (x *LeafletPage) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *LeafletPage) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the child page.
+
+func (x *LeafletPage) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *LeafletPage) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// Whether the child can be navigated to when folded.
+//
+// If `FALSE`, the child will be ignored by
+// [method@Leaflet.get_adjacent_child], [method@Leaflet.navigate], and swipe
+// gestures.
+//
+// This can be used used to prevent switching to widgets like separators.
+
+func (x *LeafletPage) SetPropertyNavigatable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("navigatable", &v)
+}
+
+func (x *LeafletPage) GetPropertyNavigatable() bool {
+	var v gobject.Value
+	x.GetProperty("navigatable", &v)
+	return v.GetBoolean()
 }
 
 func init() {
diff --git a/v4/adw/adw-message-dialog.go b/v4/adw/adw-message-dialog.go
index 34d8d7c55168b130c28463242b9def867b583984..187799a0be5a6793d407786ce605a24dca86f366 100644
--- a/v4/adw/adw-message-dialog.go
+++ b/v4/adw/adw-message-dialog.go
@@ -645,6 +645,135 @@ func (c *MessageDialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The body text of the dialog.
+
+func (x *MessageDialog) SetPropertyBody(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("body", &v)
+}
+
+func (x *MessageDialog) GetPropertyBody() string {
+	var v gobject.Value
+	x.GetProperty("body", &v)
+	return v.GetString()
+}
+
+// Whether the body text includes Pango markup.
+//
+// See [func@Pango.parse_markup].
+
+func (x *MessageDialog) SetPropertyBodyUseMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("body-use-markup", &v)
+}
+
+func (x *MessageDialog) GetPropertyBodyUseMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("body-use-markup", &v)
+	return v.GetBoolean()
+}
+
+// The ID of the close response.
+//
+// It will be passed to [signal@MessageDialog::response] if the window is
+// closed by pressing &lt;kbd&gt;Escape&lt;/kbd&gt; or with a system action.
+//
+// It doesn't have to correspond to any of the responses in the dialog.
+//
+// The default close response is `close`.
+
+func (x *MessageDialog) SetPropertyCloseResponse(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("close-response", &v)
+}
+
+func (x *MessageDialog) GetPropertyCloseResponse() string {
+	var v gobject.Value
+	x.GetProperty("close-response", &v)
+	return v.GetString()
+}
+
+// The response ID of the default response.
+//
+// If set, pressing &lt;kbd&gt;Enter&lt;/kbd&gt; will activate the corresponding button.
+//
+// If set to `NULL` or a non-existent response ID, pressing &lt;kbd&gt;Enter&lt;/kbd&gt;
+// will do nothing.
+
+func (x *MessageDialog) SetPropertyDefaultResponse(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("default-response", &v)
+}
+
+func (x *MessageDialog) GetPropertyDefaultResponse() string {
+	var v gobject.Value
+	x.GetProperty("default-response", &v)
+	return v.GetString()
+}
+
+// The child widget.
+//
+// Displayed below the heading and body.
+
+func (x *MessageDialog) SetPropertyExtraChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("extra-child", &v)
+}
+
+func (x *MessageDialog) GetPropertyExtraChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("extra-child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The heading of the dialog.
+
+func (x *MessageDialog) SetPropertyHeading(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("heading", &v)
+}
+
+func (x *MessageDialog) GetPropertyHeading() string {
+	var v gobject.Value
+	x.GetProperty("heading", &v)
+	return v.GetString()
+}
+
+// Whether the heading includes Pango markup.
+//
+// See [func@Pango.parse_markup].
+
+func (x *MessageDialog) SetPropertyHeadingUseMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("heading-use-markup", &v)
+}
+
+func (x *MessageDialog) GetPropertyHeadingUseMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("heading-use-markup", &v)
+	return v.GetBoolean()
+}
+
 // This signal is emitted when the dialog is closed.
 //
 // @response will be set to the response ID of the button that had been
diff --git a/v4/adw/adw-multi-layout-view.go b/v4/adw/adw-multi-layout-view.go
index bb36001585636c5b6f0b73d250e4b1d5e40cfcd3..ea34ff1fd9462296c3b47b589e594a4a23f44e6f 100644
--- a/v4/adw/adw-multi-layout-view.go
+++ b/v4/adw/adw-multi-layout-view.go
@@ -259,6 +259,44 @@ func (c *MultiLayoutView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The currently used layout.
+
+func (x *MultiLayoutView) SetPropertyLayout(value *Layout) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("layout", &v)
+}
+
+func (x *MultiLayoutView) GetPropertyLayout() *Layout {
+	var v gobject.Value
+	x.GetProperty("layout", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Layout{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the currently used layout.
+//
+// See [property@Layout:name].
+
+func (x *MultiLayoutView) SetPropertyLayoutName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("layout-name", &v)
+}
+
+func (x *MultiLayoutView) GetPropertyLayoutName() string {
+	var v gobject.Value
+	x.GetProperty("layout-name", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *MultiLayoutView) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-navigation-split-view.go b/v4/adw/adw-navigation-split-view.go
index 0c31ecad69611de159d8a37549db84c25badfbfc..5eabefa42e47f57ba1357e40bc61af01902e3533 100644
--- a/v4/adw/adw-navigation-split-view.go
+++ b/v4/adw/adw-navigation-split-view.go
@@ -404,6 +404,173 @@ func (c *NavigationSplitView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the split view is collapsed.
+//
+// When collapsed, the children are put inside an [class@NavigationView],
+// otherwise they are displayed side by side.
+//
+// The [property@NavigationSplitView:show-content] controls which child is
+// visible while collapsed.
+
+func (x *NavigationSplitView) SetPropertyCollapsed(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("collapsed", &v)
+}
+
+func (x *NavigationSplitView) GetPropertyCollapsed() bool {
+	var v gobject.Value
+	x.GetProperty("collapsed", &v)
+	return v.GetBoolean()
+}
+
+// The content widget.
+
+func (x *NavigationSplitView) SetPropertyContent(value *NavigationPage) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("content", &v)
+}
+
+func (x *NavigationSplitView) GetPropertyContent() *NavigationPage {
+	var v gobject.Value
+	x.GetProperty("content", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &NavigationPage{}
+	result.Ptr = ptr
+	return result
+}
+
+// The maximum sidebar width.
+//
+// Maximum width is affected by
+// [property@NavigationSplitView:sidebar-width-unit].
+//
+// The sidebar widget can still be allocated with larger width if its own
+// minimum width exceeds it.
+
+func (x *NavigationSplitView) SetPropertyMaxSidebarWidth(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("max-sidebar-width", &v)
+}
+
+func (x *NavigationSplitView) GetPropertyMaxSidebarWidth() float64 {
+	var v gobject.Value
+	x.GetProperty("max-sidebar-width", &v)
+	return v.GetDouble()
+}
+
+// The minimum sidebar width.
+//
+// Minimum width is affected by
+// [property@NavigationSplitView:sidebar-width-unit].
+//
+// The sidebar widget can still be allocated with larger width if its own
+// minimum width exceeds it.
+
+func (x *NavigationSplitView) SetPropertyMinSidebarWidth(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("min-sidebar-width", &v)
+}
+
+func (x *NavigationSplitView) GetPropertyMinSidebarWidth() float64 {
+	var v gobject.Value
+	x.GetProperty("min-sidebar-width", &v)
+	return v.GetDouble()
+}
+
+// Determines the visible page when collapsed.
+//
+// If set to `TRUE`, the content widget will be the visible page when
+// [property@NavigationSplitView:collapsed] is `TRUE`; otherwise the sidebar
+// widget will be visible.
+//
+// If the split view is already collapsed, the visible page changes
+// immediately.
+
+func (x *NavigationSplitView) SetPropertyShowContent(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-content", &v)
+}
+
+func (x *NavigationSplitView) GetPropertyShowContent() bool {
+	var v gobject.Value
+	x.GetProperty("show-content", &v)
+	return v.GetBoolean()
+}
+
+// The sidebar widget.
+
+func (x *NavigationSplitView) SetPropertySidebar(value *NavigationPage) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("sidebar", &v)
+}
+
+func (x *NavigationSplitView) GetPropertySidebar() *NavigationPage {
+	var v gobject.Value
+	x.GetProperty("sidebar", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &NavigationPage{}
+	result.Ptr = ptr
+	return result
+}
+
+// The preferred sidebar width as a fraction of the total width.
+//
+// The preferred width is additionally limited by
+// [property@NavigationSplitView:min-sidebar-width] and
+// [property@NavigationSplitView:max-sidebar-width].
+//
+// The sidebar widget can be allocated with larger width if its own minimum
+// width exceeds the preferred width.
+
+func (x *NavigationSplitView) SetPropertySidebarWidthFraction(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("sidebar-width-fraction", &v)
+}
+
+func (x *NavigationSplitView) GetPropertySidebarWidthFraction() float64 {
+	var v gobject.Value
+	x.GetProperty("sidebar-width-fraction", &v)
+	return v.GetDouble()
+}
+
+// The length unit for minimum and maximum sidebar widths.
+//
+// See [property@NavigationSplitView:min-sidebar-width] and
+// [property@NavigationSplitView:max-sidebar-width].
+
+func (x *NavigationSplitView) SetPropertySidebarWidthUnit(value LengthUnit) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("sidebar-width-unit", &v)
+}
+
+func (x *NavigationSplitView) GetPropertySidebarWidthUnit() LengthUnit {
+	var v gobject.Value
+	x.GetProperty("sidebar-width-unit", &v)
+	return LengthUnit(v.GetEnum())
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *NavigationSplitView) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-navigation-view.go b/v4/adw/adw-navigation-view.go
index 18e5e261f2c88138379f9607cc019ac5279977d1..cd9faa4df69b27911f5c66578b0a909af1cfa948 100644
--- a/v4/adw/adw-navigation-view.go
+++ b/v4/adw/adw-navigation-view.go
@@ -325,6 +325,93 @@ func (c *NavigationPage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the page can be popped from navigation stack.
+//
+// Set it to `FALSE` to disable shortcuts and gestures, as well as remove the
+// back button from [class@HeaderBar].
+//
+// Manually calling [method@NavigationView.pop] or using the `navigation.pop`
+// action will still work.
+//
+// See [property@HeaderBar:show-back-button] for removing only the back
+// button, but not shortcuts.
+
+func (x *NavigationPage) SetPropertyCanPop(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-pop", &v)
+}
+
+func (x *NavigationPage) GetPropertyCanPop() bool {
+	var v gobject.Value
+	x.GetProperty("can-pop", &v)
+	return v.GetBoolean()
+}
+
+// The child widget.
+
+func (x *NavigationPage) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *NavigationPage) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The page tag.
+//
+// The tag can be used to retrieve the page with
+// [method@NavigationView.find_page], as well as with
+// [method@NavigationView.push_by_tag], [method@NavigationView.pop_to_tag] or
+// [method@NavigationView.replace_with_tags].
+//
+// Tags must be unique within each [class@NavigationView].
+//
+// The tag also must be set to use the `navigation.push` action.
+
+func (x *NavigationPage) SetPropertyTag(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("tag", &v)
+}
+
+func (x *NavigationPage) GetPropertyTag() string {
+	var v gobject.Value
+	x.GetProperty("tag", &v)
+	return v.GetString()
+}
+
+// The page title.
+//
+// It's displayed in [class@HeaderBar] instead of the window title, and used
+// as the tooltip on the next page's back button, as well as by screen reader.
+
+func (x *NavigationPage) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *NavigationPage) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
 // Emitted when the navigation view transition has been completed and the page
 // is fully hidden.
 //
@@ -1053,6 +1140,73 @@ }
 
 func (c *NavigationView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Whether to animate page transitions.
+//
+// Gesture-based transitions are always animated.
+
+func (x *NavigationView) SetPropertyAnimateTransitions(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("animate-transitions", &v)
+}
+
+func (x *NavigationView) GetPropertyAnimateTransitions() bool {
+	var v gobject.Value
+	x.GetProperty("animate-transitions", &v)
+	return v.GetBoolean()
+}
+
+// A list model that contains the pages in navigation stack.
+//
+// The pages are sorted from root page to visible page.
+//
+// This can be used to keep an up-to-date view.
+
+func (x *NavigationView) GetPropertyNavigationStack() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("navigation-stack", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether pressing Escape pops the current page.
+//
+// Applications using `AdwNavigationView` to implement a browser may want to
+// disable it.
+
+func (x *NavigationView) SetPropertyPopOnEscape(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("pop-on-escape", &v)
+}
+
+func (x *NavigationView) GetPropertyPopOnEscape() bool {
+	var v gobject.Value
+	x.GetProperty("pop-on-escape", &v)
+	return v.GetBoolean()
+}
+
+// The currently visible page.
+
+func (x *NavigationView) GetPropertyVisiblePage() *NavigationPage {
+	var v gobject.Value
+	x.GetProperty("visible-page", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &NavigationPage{}
+	result.Ptr = ptr
+	return result
 }
 
 // Emitted when a push shortcut or a gesture is triggered.
diff --git a/v4/adw/adw-overlay-split-view.go b/v4/adw/adw-overlay-split-view.go
index 9919834bb5fb2744de3708b91ac2270112483728..40f05a493685e28165938dd695d0ebaaf0628a9a 100644
--- a/v4/adw/adw-overlay-split-view.go
+++ b/v4/adw/adw-overlay-split-view.go
@@ -474,6 +474,234 @@ func (c *OverlaySplitView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the split view is collapsed.
+//
+// When collapsed, the sidebar widget is presented as an overlay above the
+// content widget, otherwise they are displayed side by side.
+
+func (x *OverlaySplitView) SetPropertyCollapsed(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("collapsed", &v)
+}
+
+func (x *OverlaySplitView) GetPropertyCollapsed() bool {
+	var v gobject.Value
+	x.GetProperty("collapsed", &v)
+	return v.GetBoolean()
+}
+
+// The content widget.
+
+func (x *OverlaySplitView) SetPropertyContent(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("content", &v)
+}
+
+func (x *OverlaySplitView) GetPropertyContent() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("content", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the sidebar can be closed with a swipe gesture.
+//
+// Only touchscreen swipes are supported.
+
+func (x *OverlaySplitView) SetPropertyEnableHideGesture(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-hide-gesture", &v)
+}
+
+func (x *OverlaySplitView) GetPropertyEnableHideGesture() bool {
+	var v gobject.Value
+	x.GetProperty("enable-hide-gesture", &v)
+	return v.GetBoolean()
+}
+
+// Whether the sidebar can be opened with an edge swipe gesture.
+//
+// Only touchscreen swipes are supported.
+
+func (x *OverlaySplitView) SetPropertyEnableShowGesture(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-show-gesture", &v)
+}
+
+func (x *OverlaySplitView) GetPropertyEnableShowGesture() bool {
+	var v gobject.Value
+	x.GetProperty("enable-show-gesture", &v)
+	return v.GetBoolean()
+}
+
+// The maximum sidebar width.
+//
+// Maximum width is affected by
+// [property@OverlaySplitView:sidebar-width-unit].
+//
+// The sidebar widget can still be allocated with larger width if its own
+// minimum width exceeds it.
+
+func (x *OverlaySplitView) SetPropertyMaxSidebarWidth(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("max-sidebar-width", &v)
+}
+
+func (x *OverlaySplitView) GetPropertyMaxSidebarWidth() float64 {
+	var v gobject.Value
+	x.GetProperty("max-sidebar-width", &v)
+	return v.GetDouble()
+}
+
+// The minimum sidebar width.
+//
+// Minimum width is affected by
+// [property@OverlaySplitView:sidebar-width-unit].
+//
+// The sidebar widget can still be allocated with larger width if its own
+// minimum width exceeds it.
+
+func (x *OverlaySplitView) SetPropertyMinSidebarWidth(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("min-sidebar-width", &v)
+}
+
+func (x *OverlaySplitView) GetPropertyMinSidebarWidth() float64 {
+	var v gobject.Value
+	x.GetProperty("min-sidebar-width", &v)
+	return v.GetDouble()
+}
+
+// Whether the sidebar widget is pinned.
+//
+// By default, collapsing @self automatically hides the sidebar widget, and
+// uncollapsing it shows the sidebar. If set to `TRUE`, sidebar visibility
+// never changes on its own.
+
+func (x *OverlaySplitView) SetPropertyPinSidebar(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("pin-sidebar", &v)
+}
+
+func (x *OverlaySplitView) GetPropertyPinSidebar() bool {
+	var v gobject.Value
+	x.GetProperty("pin-sidebar", &v)
+	return v.GetBoolean()
+}
+
+// Whether the sidebar widget is shown.
+
+func (x *OverlaySplitView) SetPropertyShowSidebar(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-sidebar", &v)
+}
+
+func (x *OverlaySplitView) GetPropertyShowSidebar() bool {
+	var v gobject.Value
+	x.GetProperty("show-sidebar", &v)
+	return v.GetBoolean()
+}
+
+// The sidebar widget.
+
+func (x *OverlaySplitView) SetPropertySidebar(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("sidebar", &v)
+}
+
+func (x *OverlaySplitView) GetPropertySidebar() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("sidebar", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The sidebar position.
+//
+// If it's set to `GTK_PACK_START`, the sidebar is displayed before the content,
+// if `GTK_PACK_END`, it's displayed after the content.
+
+func (x *OverlaySplitView) SetPropertySidebarPosition(value gtk.PackType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("sidebar-position", &v)
+}
+
+func (x *OverlaySplitView) GetPropertySidebarPosition() gtk.PackType {
+	var v gobject.Value
+	x.GetProperty("sidebar-position", &v)
+	return gtk.PackType(v.GetEnum())
+}
+
+// The preferred sidebar width as a fraction of the total width.
+//
+// The preferred width is additionally limited by
+// [property@OverlaySplitView:min-sidebar-width] and
+// [property@OverlaySplitView:max-sidebar-width].
+//
+// The sidebar widget can be allocated with larger width if its own minimum
+// width exceeds the preferred width.
+
+func (x *OverlaySplitView) SetPropertySidebarWidthFraction(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("sidebar-width-fraction", &v)
+}
+
+func (x *OverlaySplitView) GetPropertySidebarWidthFraction() float64 {
+	var v gobject.Value
+	x.GetProperty("sidebar-width-fraction", &v)
+	return v.GetDouble()
+}
+
+// The length unit for minimum and maximum sidebar widths.
+//
+// See [property@OverlaySplitView:min-sidebar-width] and
+// [property@OverlaySplitView:max-sidebar-width].
+
+func (x *OverlaySplitView) SetPropertySidebarWidthUnit(value LengthUnit) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("sidebar-width-unit", &v)
+}
+
+func (x *OverlaySplitView) GetPropertySidebarWidthUnit() LengthUnit {
+	var v gobject.Value
+	x.GetProperty("sidebar-width-unit", &v)
+	return LengthUnit(v.GetEnum())
+}
+
 // Gets the progress @self will snap back to after the gesture is canceled.
 func (x *OverlaySplitView) GetCancelProgress() float64 {
 
diff --git a/v4/adw/adw-preferences-dialog.go b/v4/adw/adw-preferences-dialog.go
index a23c410a41b527ed06139b3277b5f7d504ce1025..e69b6788fb06b23b7282c8cfb3b12f2692e65019 100644
--- a/v4/adw/adw-preferences-dialog.go
+++ b/v4/adw/adw-preferences-dialog.go
@@ -203,6 +203,59 @@ func (c *PreferencesDialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether search is enabled.
+
+func (x *PreferencesDialog) SetPropertySearchEnabled(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("search-enabled", &v)
+}
+
+func (x *PreferencesDialog) GetPropertySearchEnabled() bool {
+	var v gobject.Value
+	x.GetProperty("search-enabled", &v)
+	return v.GetBoolean()
+}
+
+// The currently visible page.
+
+func (x *PreferencesDialog) SetPropertyVisiblePage(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("visible-page", &v)
+}
+
+func (x *PreferencesDialog) GetPropertyVisiblePage() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("visible-page", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the currently visible page.
+//
+// See [property@AdwPreferencesDialog:visible-page].
+
+func (x *PreferencesDialog) SetPropertyVisiblePageName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("visible-page-name", &v)
+}
+
+func (x *PreferencesDialog) GetPropertyVisiblePageName() string {
+	var v gobject.Value
+	x.GetProperty("visible-page-name", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *PreferencesDialog) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-preferences-group.go b/v4/adw/adw-preferences-group.go
index b7a97394f88a3edba9773dc527700c7eee61c25b..c4e741eb6e51041982770c89bc555b2ad4f4232a 100644
--- a/v4/adw/adw-preferences-group.go
+++ b/v4/adw/adw-preferences-group.go
@@ -212,6 +212,81 @@ func (c *PreferencesGroup) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The description for this group of preferences.
+
+func (x *PreferencesGroup) SetPropertyDescription(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("description", &v)
+}
+
+func (x *PreferencesGroup) GetPropertyDescription() string {
+	var v gobject.Value
+	x.GetProperty("description", &v)
+	return v.GetString()
+}
+
+// The header suffix widget.
+//
+// Displayed above the list, next to the title and description.
+//
+// Suffixes are commonly used to show a button or a spinner for the whole
+// group.
+
+func (x *PreferencesGroup) SetPropertyHeaderSuffix(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("header-suffix", &v)
+}
+
+func (x *PreferencesGroup) GetPropertyHeaderSuffix() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("header-suffix", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to separate rows.
+//
+// Equivalent to using the
+// [`.boxed-list-separate`](style-classes.html#boxed-lists-cards) style class
+// on a [class@Gtk.ListBox] instead of `.boxed-list`.
+
+func (x *PreferencesGroup) SetPropertySeparateRows(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("separate-rows", &v)
+}
+
+func (x *PreferencesGroup) GetPropertySeparateRows() bool {
+	var v gobject.Value
+	x.GetProperty("separate-rows", &v)
+	return v.GetBoolean()
+}
+
+// The title for this group of preferences.
+
+func (x *PreferencesGroup) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *PreferencesGroup) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *PreferencesGroup) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-preferences-page.go b/v4/adw/adw-preferences-page.go
index 16780ec5e43c151af944df7074956bec1da6e3f8..ac214a7f4fef5d6ec591bf9f5736597df9b5cc20 100644
--- a/v4/adw/adw-preferences-page.go
+++ b/v4/adw/adw-preferences-page.go
@@ -224,6 +224,96 @@ func (c *PreferencesPage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The description to be displayed at the top of the page.
+
+func (x *PreferencesPage) SetPropertyDescription(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("description", &v)
+}
+
+func (x *PreferencesPage) GetPropertyDescription() string {
+	var v gobject.Value
+	x.GetProperty("description", &v)
+	return v.GetString()
+}
+
+// Whether the description should be centered.
+
+func (x *PreferencesPage) SetPropertyDescriptionCentered(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("description-centered", &v)
+}
+
+func (x *PreferencesPage) GetPropertyDescriptionCentered() bool {
+	var v gobject.Value
+	x.GetProperty("description-centered", &v)
+	return v.GetBoolean()
+}
+
+// The icon name for this page.
+
+func (x *PreferencesPage) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *PreferencesPage) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// The name of this page.
+
+func (x *PreferencesPage) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *PreferencesPage) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// The title for this page.
+
+func (x *PreferencesPage) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *PreferencesPage) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// Whether an embedded underline in the title indicates a mnemonic.
+
+func (x *PreferencesPage) SetPropertyUseUnderline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-underline", &v)
+}
+
+func (x *PreferencesPage) GetPropertyUseUnderline() bool {
+	var v gobject.Value
+	x.GetProperty("use-underline", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *PreferencesPage) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-preferences-row.go b/v4/adw/adw-preferences-row.go
index c26d4ced63667eae833adeb8183ffea156567da0..0569127281d98e4f26bc5376defb31bd3af1c518 100644
--- a/v4/adw/adw-preferences-row.go
+++ b/v4/adw/adw-preferences-row.go
@@ -159,6 +159,75 @@ func (c *PreferencesRow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The title of the preference represented by this row.
+//
+// The title is interpreted as Pango markup unless
+// [property@PreferencesRow:use-markup] is set to `FALSE`.
+
+func (x *PreferencesRow) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *PreferencesRow) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// Whether the user can copy the title from the label.
+//
+// See also [property@Gtk.Label:selectable].
+
+func (x *PreferencesRow) SetPropertyTitleSelectable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("title-selectable", &v)
+}
+
+func (x *PreferencesRow) GetPropertyTitleSelectable() bool {
+	var v gobject.Value
+	x.GetProperty("title-selectable", &v)
+	return v.GetBoolean()
+}
+
+// Whether to use Pango markup for the title label.
+//
+// Subclasses may also use it for other labels, such as subtitle.
+//
+// See also [func@Pango.parse_markup].
+
+func (x *PreferencesRow) SetPropertyUseMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-markup", &v)
+}
+
+func (x *PreferencesRow) GetPropertyUseMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("use-markup", &v)
+	return v.GetBoolean()
+}
+
+// Whether an embedded underline in the title indicates a mnemonic.
+
+func (x *PreferencesRow) SetPropertyUseUnderline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-underline", &v)
+}
+
+func (x *PreferencesRow) GetPropertyUseUnderline() bool {
+	var v gobject.Value
+	x.GetProperty("use-underline", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *PreferencesRow) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-preferences-window.go b/v4/adw/adw-preferences-window.go
index 4f07c96fcec01325216c2470d6b0737d8fbf5d84..8ae135dd343cc35476a801ffb8a84584f1869621 100644
--- a/v4/adw/adw-preferences-window.go
+++ b/v4/adw/adw-preferences-window.go
@@ -253,6 +253,88 @@ func (c *PreferencesWindow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether gestures and shortcuts for closing subpages are enabled.
+//
+// The supported gestures are:
+//
+// - One-finger swipe on touchscreens
+// - Horizontal scrolling on touchpads (usually two-finger swipe)
+// - Back mouse button
+//
+// The keyboard back key is also supported, as well as the
+// &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;â&lt;/kbd&gt; shortcut.
+//
+// For right-to-left locales, gestures and shortcuts are reversed.
+//
+// Has no effect for subpages added with
+// [method@PreferencesWindow.push_subpage].
+
+func (x *PreferencesWindow) SetPropertyCanNavigateBack(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-navigate-back", &v)
+}
+
+func (x *PreferencesWindow) GetPropertyCanNavigateBack() bool {
+	var v gobject.Value
+	x.GetProperty("can-navigate-back", &v)
+	return v.GetBoolean()
+}
+
+// Whether search is enabled.
+
+func (x *PreferencesWindow) SetPropertySearchEnabled(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("search-enabled", &v)
+}
+
+func (x *PreferencesWindow) GetPropertySearchEnabled() bool {
+	var v gobject.Value
+	x.GetProperty("search-enabled", &v)
+	return v.GetBoolean()
+}
+
+// The currently visible page.
+
+func (x *PreferencesWindow) SetPropertyVisiblePage(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("visible-page", &v)
+}
+
+func (x *PreferencesWindow) GetPropertyVisiblePage() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("visible-page", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the currently visible page.
+//
+// See [property@PreferencesWindow:visible-page].
+
+func (x *PreferencesWindow) SetPropertyVisiblePageName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("visible-page-name", &v)
+}
+
+func (x *PreferencesWindow) GetPropertyVisiblePageName() string {
+	var v gobject.Value
+	x.GetProperty("visible-page-name", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *PreferencesWindow) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-spin-row.go b/v4/adw/adw-spin-row.go
index 4f9732475714bc5160abc24efc0b5b61377c2980..22ebe36a76bba4ac7083adb0999c8dbf4d88be0b 100644
--- a/v4/adw/adw-spin-row.go
+++ b/v4/adw/adw-spin-row.go
@@ -321,6 +321,134 @@ func (c *SpinRow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The adjustment that holds the value of the spin row.
+
+func (x *SpinRow) SetPropertyAdjustment(value *gtk.Adjustment) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("adjustment", &v)
+}
+
+func (x *SpinRow) GetPropertyAdjustment() *gtk.Adjustment {
+	var v gobject.Value
+	x.GetProperty("adjustment", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Adjustment{}
+	result.Ptr = ptr
+	return result
+}
+
+// The acceleration rate when you hold down a button or key.
+
+func (x *SpinRow) SetPropertyClimbRate(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("climb-rate", &v)
+}
+
+func (x *SpinRow) GetPropertyClimbRate() float64 {
+	var v gobject.Value
+	x.GetProperty("climb-rate", &v)
+	return v.GetDouble()
+}
+
+// The number of decimal places to display.
+
+func (x *SpinRow) SetPropertyDigits(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("digits", &v)
+}
+
+func (x *SpinRow) GetPropertyDigits() uint {
+	var v gobject.Value
+	x.GetProperty("digits", &v)
+	return v.GetUint()
+}
+
+// Whether non-numeric characters should be ignored.
+
+func (x *SpinRow) SetPropertyNumeric(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("numeric", &v)
+}
+
+func (x *SpinRow) GetPropertyNumeric() bool {
+	var v gobject.Value
+	x.GetProperty("numeric", &v)
+	return v.GetBoolean()
+}
+
+// Whether invalid values are snapped to the nearest step increment.
+
+func (x *SpinRow) SetPropertySnapToTicks(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("snap-to-ticks", &v)
+}
+
+func (x *SpinRow) GetPropertySnapToTicks() bool {
+	var v gobject.Value
+	x.GetProperty("snap-to-ticks", &v)
+	return v.GetBoolean()
+}
+
+// The policy for updating the spin row.
+//
+// The options are always, or only when the value is invalid.
+
+func (x *SpinRow) SetPropertyUpdatePolicy(value gtk.SpinButtonUpdatePolicy) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("update-policy", &v)
+}
+
+func (x *SpinRow) GetPropertyUpdatePolicy() gtk.SpinButtonUpdatePolicy {
+	var v gobject.Value
+	x.GetProperty("update-policy", &v)
+	return gtk.SpinButtonUpdatePolicy(v.GetEnum())
+}
+
+// The current value.
+
+func (x *SpinRow) SetPropertyValue(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("value", &v)
+}
+
+func (x *SpinRow) GetPropertyValue() float64 {
+	var v gobject.Value
+	x.GetProperty("value", &v)
+	return v.GetDouble()
+}
+
+// Whether the spin row should wrap upon reaching its limits.
+
+func (x *SpinRow) SetPropertyWrap(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("wrap", &v)
+}
+
+func (x *SpinRow) GetPropertyWrap() bool {
+	var v gobject.Value
+	x.GetProperty("wrap", &v)
+	return v.GetBoolean()
+}
+
 // Emitted to convert the user's input into a double value.
 //
 // The signal handler is expected to use [method@Gtk.Editable.get_text] to
diff --git a/v4/adw/adw-spinner-paintable.go b/v4/adw/adw-spinner-paintable.go
index 23b2b3a57fffd57482d076bd6060fad9ad4b07e6..a357501ad806b7d3713b42e808ef248f94d851d3 100644
--- a/v4/adw/adw-spinner-paintable.go
+++ b/v4/adw/adw-spinner-paintable.go
@@ -125,6 +125,27 @@ func (c *SpinnerPaintable) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The widget the spinner uses for frame clock.
+
+func (x *SpinnerPaintable) SetPropertyWidget(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("widget", &v)
+}
+
+func (x *SpinnerPaintable) GetPropertyWidget() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
 // Compute a concrete size for the `GdkPaintable`.
 //
 // Applies the sizing algorithm outlined in the
diff --git a/v4/adw/adw-split-button.go b/v4/adw/adw-split-button.go
index 00f7c42cc02f10b932bebd64692ae558b8534d7b..42351dbcd415cfe686f26a8bc0e054bae4162680 100644
--- a/v4/adw/adw-split-button.go
+++ b/v4/adw/adw-split-button.go
@@ -362,6 +362,198 @@ func (c *SplitButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the button can be smaller than the natural size of its contents.
+//
+// If set to `TRUE`, the label will ellipsize.
+//
+// See [property@Gtk.Button:can-shrink] and
+// [property@Gtk.MenuButton:can-shrink].
+
+func (x *SplitButton) SetPropertyCanShrink(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-shrink", &v)
+}
+
+func (x *SplitButton) GetPropertyCanShrink() bool {
+	var v gobject.Value
+	x.GetProperty("can-shrink", &v)
+	return v.GetBoolean()
+}
+
+// The child widget.
+//
+// Setting the child widget will set [property@SplitButton:label] and
+// [property@SplitButton:icon-name] to `NULL`.
+
+func (x *SplitButton) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *SplitButton) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The direction in which the popup will be popped up.
+//
+// The dropdown arrow icon will point at the same direction.
+//
+// If the does not fit in the available space in the given direction, GTK will
+// try its best to keep it inside the screen and fully visible.
+//
+// If you pass `GTK_ARROW_NONE`, it's equivalent to `GTK_ARROW_DOWN`.
+
+func (x *SplitButton) SetPropertyDirection(value gtk.ArrowType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("direction", &v)
+}
+
+func (x *SplitButton) GetPropertyDirection() gtk.ArrowType {
+	var v gobject.Value
+	x.GetProperty("direction", &v)
+	return gtk.ArrowType(v.GetEnum())
+}
+
+// The tooltip of the dropdown button.
+//
+// The tooltip can be marked up with the Pango text markup language.
+
+func (x *SplitButton) SetPropertyDropdownTooltip(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("dropdown-tooltip", &v)
+}
+
+func (x *SplitButton) GetPropertyDropdownTooltip() string {
+	var v gobject.Value
+	x.GetProperty("dropdown-tooltip", &v)
+	return v.GetString()
+}
+
+// The name of the icon used to automatically populate the button.
+//
+// Setting the icon name will set [property@SplitButton:label] and
+// [property@SplitButton:child] to `NULL`.
+
+func (x *SplitButton) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *SplitButton) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// The label for the button.
+//
+// Setting the label will set [property@SplitButton:icon-name] and
+// [property@SplitButton:child] to `NULL`.
+
+func (x *SplitButton) SetPropertyLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("label", &v)
+}
+
+func (x *SplitButton) GetPropertyLabel() string {
+	var v gobject.Value
+	x.GetProperty("label", &v)
+	return v.GetString()
+}
+
+// The `GMenuModel` from which the popup will be created.
+//
+// If the menu model is `NULL`, the dropdown is disabled.
+//
+// A [class@Gtk.Popover] will be created from the menu model with
+// [ctor@Gtk.PopoverMenu.new_from_model]. Actions will be connected as
+// documented for this function.
+//
+// If [property@SplitButton:popover] is already set, it will be dissociated
+// from the button, and the property is set to `NULL`.
+
+func (x *SplitButton) SetPropertyMenuModel(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("menu-model", &v)
+}
+
+func (x *SplitButton) GetPropertyMenuModel() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("menu-model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GtkPopover` that will be popped up when the dropdown is clicked.
+//
+// If the popover is `NULL`, the dropdown is disabled.
+//
+// If [property@SplitButton:menu-model] is set, the menu model is dissociated
+// from the button, and the property is set to `NULL`.
+
+func (x *SplitButton) SetPropertyPopover(value *gtk.Popover) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("popover", &v)
+}
+
+func (x *SplitButton) GetPropertyPopover() *gtk.Popover {
+	var v gobject.Value
+	x.GetProperty("popover", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Popover{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether an underline in the text indicates a mnemonic.
+//
+// See [property@SplitButton:label].
+
+func (x *SplitButton) SetPropertyUseUnderline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-underline", &v)
+}
+
+func (x *SplitButton) GetPropertyUseUnderline() bool {
+	var v gobject.Value
+	x.GetProperty("use-underline", &v)
+	return v.GetBoolean()
+}
+
 // Emitted to animate press then release.
 //
 // This is an action signal. Applications should never connect to this signal,
diff --git a/v4/adw/adw-spring-animation.go b/v4/adw/adw-spring-animation.go
index 8d23bb63259e6b1179bae083d5fe0d2f2d990aa8..79a7ebdacdb9fb99c2a0fd10041fed78b1cd6c51 100644
--- a/v4/adw/adw-spring-animation.go
+++ b/v4/adw/adw-spring-animation.go
@@ -279,6 +279,139 @@ func (c *SpringAnimation) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the animation should be clamped.
+//
+// If set to `TRUE`, the animation will abruptly end as soon as it reaches the
+// final value, preventing overshooting.
+//
+// It won't prevent overshooting [property@SpringAnimation:value-from] if a
+// relative negative [property@SpringAnimation:initial-velocity] is set.
+
+func (x *SpringAnimation) SetPropertyClamp(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("clamp", &v)
+}
+
+func (x *SpringAnimation) GetPropertyClamp() bool {
+	var v gobject.Value
+	x.GetProperty("clamp", &v)
+	return v.GetBoolean()
+}
+
+// Precision of the spring.
+//
+// The level of precision used to determine when the animation has come to a
+// rest, that is, when the amplitude of the oscillations becomes smaller than
+// this value.
+//
+// If the epsilon value is too small, the animation will take a long time to
+// stop after the animated value has stopped visibly changing.
+//
+// If the epsilon value is too large, the animation will end prematurely.
+//
+// The default value is 0.001.
+
+func (x *SpringAnimation) SetPropertyEpsilon(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("epsilon", &v)
+}
+
+func (x *SpringAnimation) GetPropertyEpsilon() float64 {
+	var v gobject.Value
+	x.GetProperty("epsilon", &v)
+	return v.GetDouble()
+}
+
+// Estimated duration of the animation, in milliseconds.
+//
+// Can be [const@DURATION_INFINITE] if the spring damping is set to 0.
+
+func (x *SpringAnimation) GetPropertyEstimatedDuration() uint {
+	var v gobject.Value
+	x.GetProperty("estimated-duration", &v)
+	return v.GetUint()
+}
+
+// The initial velocity to start the animation with.
+//
+// Initial velocity affects only the animation curve, but not its duration.
+
+func (x *SpringAnimation) SetPropertyInitialVelocity(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("initial-velocity", &v)
+}
+
+func (x *SpringAnimation) GetPropertyInitialVelocity() float64 {
+	var v gobject.Value
+	x.GetProperty("initial-velocity", &v)
+	return v.GetDouble()
+}
+
+// Physical parameters describing the spring.
+
+func (x *SpringAnimation) SetPropertySpringParams(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("spring-params", &v)
+}
+
+func (x *SpringAnimation) GetPropertySpringParams() uintptr {
+	var v gobject.Value
+	x.GetProperty("spring-params", &v)
+	return v.GetPointer()
+}
+
+// The value to animate from.
+//
+// The animation will start at this value and end at
+// [property@SpringAnimation:value-to].
+
+func (x *SpringAnimation) SetPropertyValueFrom(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("value-from", &v)
+}
+
+func (x *SpringAnimation) GetPropertyValueFrom() float64 {
+	var v gobject.Value
+	x.GetProperty("value-from", &v)
+	return v.GetDouble()
+}
+
+// The value to animate to.
+//
+// The animation will start at [property@SpringAnimation:value-from] and end
+// at this value.
+
+func (x *SpringAnimation) SetPropertyValueTo(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("value-to", &v)
+}
+
+func (x *SpringAnimation) GetPropertyValueTo() float64 {
+	var v gobject.Value
+	x.GetProperty("value-to", &v)
+	return v.GetDouble()
+}
+
+// Current velocity of the animation.
+
+func (x *SpringAnimation) GetPropertyVelocity() float64 {
+	var v gobject.Value
+	x.GetProperty("velocity", &v)
+	return v.GetDouble()
+}
+
 func init() {
 
 	core.SetPackageName("ADW", "libadwaita-1")
diff --git a/v4/adw/adw-squeezer.go b/v4/adw/adw-squeezer.go
index 2ccad1f58c690e744dbe14b897eba6f981b0e3e0..8234a571a9aba6a60f6e18671fc855f7d808ff3c 100644
--- a/v4/adw/adw-squeezer.go
+++ b/v4/adw/adw-squeezer.go
@@ -389,6 +389,203 @@ func (c *Squeezer) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to allow squeezing beyond the last child's minimum size.
+//
+// If set to `TRUE`, the squeezer can shrink to the point where no child can
+// be shown. This is functionally equivalent to appending a widget with 0Ã0
+// minimum size.
+
+func (x *Squeezer) SetPropertyAllowNone(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-none", &v)
+}
+
+func (x *Squeezer) GetPropertyAllowNone() bool {
+	var v gobject.Value
+	x.GetProperty("allow-none", &v)
+	return v.GetBoolean()
+}
+
+// Whether all children have the same size for the opposite orientation.
+//
+// For example, if a squeezer is horizontal and is homogeneous, it will
+// request the same height for all its children. If it isn't, the squeezer may
+// change size when a different child becomes visible.
+
+func (x *Squeezer) SetPropertyHomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("homogeneous", &v)
+}
+
+func (x *Squeezer) GetPropertyHomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("homogeneous", &v)
+	return v.GetBoolean()
+}
+
+// Whether the squeezer interpolates its size when changing the visible child.
+//
+// If `TRUE`, the squeezer will interpolate its size between the one of the
+// previous visible child and the one of the new visible child, according to
+// the set transition duration and the orientation, e.g. if the squeezer is
+// horizontal, it will interpolate the its height.
+
+func (x *Squeezer) SetPropertyInterpolateSize(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("interpolate-size", &v)
+}
+
+func (x *Squeezer) GetPropertyInterpolateSize() bool {
+	var v gobject.Value
+	x.GetProperty("interpolate-size", &v)
+	return v.GetBoolean()
+}
+
+// A selection model with the squeezer's pages.
+//
+// This can be used to keep an up-to-date view. The model also implements
+// [iface@Gtk.SelectionModel] and can be used to track the visible page.
+
+func (x *Squeezer) GetPropertyPages() gtk.SelectionModel {
+	var v gobject.Value
+	x.GetProperty("pages", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.SelectionModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The switch threshold policy.
+//
+// Determines when the squeezer will switch children.
+//
+// If set to `ADW_FOLD_THRESHOLD_POLICY_MINIMUM`, it will only switch when the
+// visible child cannot fit anymore. With `ADW_FOLD_THRESHOLD_POLICY_NATURAL`,
+// it will switch as soon as the visible child doesn't get their natural size.
+//
+// This can be useful if you have a long ellipsizing label and want to let it
+// ellipsize instead of immediately switching.
+
+func (x *Squeezer) SetPropertySwitchThresholdPolicy(value FoldThresholdPolicy) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("switch-threshold-policy", &v)
+}
+
+func (x *Squeezer) GetPropertySwitchThresholdPolicy() FoldThresholdPolicy {
+	var v gobject.Value
+	x.GetProperty("switch-threshold-policy", &v)
+	return FoldThresholdPolicy(v.GetEnum())
+}
+
+// The transition animation duration, in milliseconds.
+
+func (x *Squeezer) SetPropertyTransitionDuration(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("transition-duration", &v)
+}
+
+func (x *Squeezer) GetPropertyTransitionDuration() uint {
+	var v gobject.Value
+	x.GetProperty("transition-duration", &v)
+	return v.GetUint()
+}
+
+// Whether a transition is currently running.
+//
+// If a transition is impossible, the property value will be set to `TRUE` and
+// then immediately to `FALSE`, so it's possible to rely on its notifications
+// to know that a transition has happened.
+
+func (x *Squeezer) GetPropertyTransitionRunning() bool {
+	var v gobject.Value
+	x.GetProperty("transition-running", &v)
+	return v.GetBoolean()
+}
+
+// The type of animation used for transitions between children.
+
+func (x *Squeezer) SetPropertyTransitionType(value SqueezerTransitionType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("transition-type", &v)
+}
+
+func (x *Squeezer) GetPropertyTransitionType() SqueezerTransitionType {
+	var v gobject.Value
+	x.GetProperty("transition-type", &v)
+	return SqueezerTransitionType(v.GetEnum())
+}
+
+// The currently visible child.
+
+func (x *Squeezer) GetPropertyVisibleChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("visible-child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The horizontal alignment, from 0 (start) to 1 (end).
+//
+// This affects the children allocation during transitions, when they exceed
+// the size of the squeezer.
+//
+// For example, 0.5 means the child will be centered, 0 means it will keep the
+// start side aligned and overflow the end side, and 1 means the opposite.
+
+func (x *Squeezer) SetPropertyXalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("xalign", &v)
+}
+
+func (x *Squeezer) GetPropertyXalign() float32 {
+	var v gobject.Value
+	x.GetProperty("xalign", &v)
+	return v.GetFloat()
+}
+
+// The vertical alignment, from 0 (top) to 1 (bottom).
+//
+// This affects the children allocation during transitions, when they exceed
+// the size of the squeezer.
+//
+// For example, 0.5 means the child will be centered, 0 means it will keep the
+// top side aligned and overflow the bottom side, and 1 means the opposite.
+
+func (x *Squeezer) SetPropertyYalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("yalign", &v)
+}
+
+func (x *Squeezer) GetPropertyYalign() float32 {
+	var v gobject.Value
+	x.GetProperty("yalign", &v)
+	return v.GetFloat()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Squeezer) GetAccessibleRole() gtk.AccessibleRole {
 
@@ -616,6 +813,51 @@ }
 
 func (c *SqueezerPage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The the squeezer child to which the page belongs.
+
+func (x *SqueezerPage) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *SqueezerPage) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the child is enabled.
+//
+// If a child is disabled, it will be ignored when looking for the child
+// fitting the available size best.
+//
+// This allows to programmatically and prematurely hide a child even if it
+// fits in the available space.
+//
+// This can be used e.g. to ensure a certain child is hidden below a certain
+// window width, or any other constraint you find suitable.
+
+func (x *SqueezerPage) SetPropertyEnabled(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enabled", &v)
+}
+
+func (x *SqueezerPage) GetPropertyEnabled() bool {
+	var v gobject.Value
+	x.GetProperty("enabled", &v)
+	return v.GetBoolean()
 }
 
 func init() {
diff --git a/v4/adw/adw-status-page.go b/v4/adw/adw-status-page.go
index 027459725e156852365980ac7bbe45960b1697e2..4a57e8164bf827af1e020d210817d242e6957dbf 100644
--- a/v4/adw/adw-status-page.go
+++ b/v4/adw/adw-status-page.go
@@ -214,6 +214,99 @@ func (c *StatusPage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *StatusPage) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *StatusPage) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The description markup to be displayed below the title.
+
+func (x *StatusPage) SetPropertyDescription(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("description", &v)
+}
+
+func (x *StatusPage) GetPropertyDescription() string {
+	var v gobject.Value
+	x.GetProperty("description", &v)
+	return v.GetString()
+}
+
+// The name of the icon to be used.
+//
+// Changing this will set [property@StatusPage:paintable] to `NULL`.
+
+func (x *StatusPage) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *StatusPage) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// The paintable to be used.
+//
+// Changing this will set [property@StatusPage:icon-name] to `NULL`.
+
+func (x *StatusPage) SetPropertyPaintable(value gdk.Paintable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("paintable", &v)
+}
+
+func (x *StatusPage) GetPropertyPaintable() gdk.Paintable {
+	var v gobject.Value
+	x.GetProperty("paintable", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.PaintableBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The title to be displayed below the icon.
+//
+// It is not parsed as Pango markup.
+
+func (x *StatusPage) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *StatusPage) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *StatusPage) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-style-manager.go b/v4/adw/adw-style-manager.go
index 391c0e23e1618193accdc4dcb34c1134a74cb211..61e3d7e622c0a98ce45dd965176e8cd4561754cd 100644
--- a/v4/adw/adw-style-manager.go
+++ b/v4/adw/adw-style-manager.go
@@ -230,6 +230,147 @@ func (c *StyleManager) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The current system accent color.
+//
+// See also [property@StyleManager:accent-color-rgba].
+
+func (x *StyleManager) GetPropertyAccentColor() AccentColor {
+	var v gobject.Value
+	x.GetProperty("accent-color", &v)
+	return AccentColor(v.GetEnum())
+}
+
+// The current system accent color as a `GdkRGBA`.
+//
+// Equivalent to calling [func@AccentColor.to_rgba] on the value of
+// [property@StyleManager:accent-color].
+//
+// This is a background color. The matching foreground color is white.
+
+func (x *StyleManager) GetPropertyAccentColorRgba() uintptr {
+	var v gobject.Value
+	x.GetProperty("accent-color-rgba", &v)
+	return v.GetPointer()
+}
+
+// The requested application color scheme.
+//
+// The effective appearance will be decided based on the application color
+// scheme and the system preferred color scheme. The
+// [property@StyleManager:dark] property can be used to query the current
+// effective appearance.
+//
+// The `ADW_COLOR_SCHEME_PREFER_LIGHT` color scheme results in the application
+// using light appearance unless the system prefers dark colors. This is the
+// default value.
+//
+// The `ADW_COLOR_SCHEME_PREFER_DARK` color scheme results in the application
+// using dark appearance, but can still switch to the light appearance if the
+// system can prefers it, for example, when the high contrast preference is
+// enabled.
+//
+// The `ADW_COLOR_SCHEME_FORCE_LIGHT` and `ADW_COLOR_SCHEME_FORCE_DARK` values
+// ignore the system preference entirely. They are useful if the application
+// wants to match its UI to its content or to provide a separate color scheme
+// switcher.
+//
+// If a per-[class@Gdk.Display] style manager has its color scheme set to
+// `ADW_COLOR_SCHEME_DEFAULT`, it will inherit the color scheme from the
+// default style manager.
+//
+// For the default style manager, `ADW_COLOR_SCHEME_DEFAULT` is equivalent to
+// `ADW_COLOR_SCHEME_PREFER_LIGHT`.
+//
+// The [property@StyleManager:system-supports-color-schemes] property can be
+// used to check if the current environment provides a color scheme
+// preference.
+
+func (x *StyleManager) SetPropertyColorScheme(value ColorScheme) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("color-scheme", &v)
+}
+
+func (x *StyleManager) GetPropertyColorScheme() ColorScheme {
+	var v gobject.Value
+	x.GetProperty("color-scheme", &v)
+	return ColorScheme(v.GetEnum())
+}
+
+// Whether the application is using dark appearance.
+//
+// This property can be used to query the current appearance, as requested via
+// [property@StyleManager:color-scheme].
+
+func (x *StyleManager) GetPropertyDark() bool {
+	var v gobject.Value
+	x.GetProperty("dark", &v)
+	return v.GetBoolean()
+}
+
+// The display the style manager is associated with.
+//
+// The display will be `NULL` for the style manager returned by
+// [func@StyleManager.get_default].
+
+func (x *StyleManager) SetPropertyDisplay(value *gdk.Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *StyleManager) GetPropertyDisplay() *gdk.Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Display{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the application is using high contrast appearance.
+//
+// This cannot be overridden by applications.
+
+func (x *StyleManager) GetPropertyHighContrast() bool {
+	var v gobject.Value
+	x.GetProperty("high-contrast", &v)
+	return v.GetBoolean()
+}
+
+// Whether the system supports accent colors.
+//
+// This property can be used to check if the current environment provides an
+// accent color preference. For example, applications might want to show a
+// preference for choosing accent color if it's set to `FALSE`.
+//
+// See [property@StyleManager:accent-color].
+
+func (x *StyleManager) GetPropertySystemSupportsAccentColors() bool {
+	var v gobject.Value
+	x.GetProperty("system-supports-accent-colors", &v)
+	return v.GetBoolean()
+}
+
+// Whether the system supports color schemes.
+//
+// This property can be used to check if the current environment provides a
+// color scheme preference. For example, applications might want to show a
+// separate appearance switcher if it's set to `FALSE`.
+//
+// See [property@StyleManager:color-scheme].
+
+func (x *StyleManager) GetPropertySystemSupportsColorSchemes() bool {
+	var v gobject.Value
+	x.GetProperty("system-supports-color-schemes", &v)
+	return v.GetBoolean()
+}
+
 var xStyleManagerGetDefault func() uintptr
 
 // Gets the default `AdwStyleManager` instance.
diff --git a/v4/adw/adw-swipe-tracker.go b/v4/adw/adw-swipe-tracker.go
index f989e4219e2786ff4d59f8aecab4cbae36fb25fd..e76f9528b11703ce80591c6d2e22a13699f4ab21 100644
--- a/v4/adw/adw-swipe-tracker.go
+++ b/v4/adw/adw-swipe-tracker.go
@@ -243,6 +243,143 @@ func (c *SwipeTracker) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to allow swiping for more than one snap point at a time.
+//
+// If the value is `FALSE`, each swipe can only move to the adjacent snap
+// points.
+
+func (x *SwipeTracker) SetPropertyAllowLongSwipes(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-long-swipes", &v)
+}
+
+func (x *SwipeTracker) GetPropertyAllowLongSwipes() bool {
+	var v gobject.Value
+	x.GetProperty("allow-long-swipes", &v)
+	return v.GetBoolean()
+}
+
+// Whether to allow dragging with mouse pointer.
+
+func (x *SwipeTracker) SetPropertyAllowMouseDrag(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-mouse-drag", &v)
+}
+
+func (x *SwipeTracker) GetPropertyAllowMouseDrag() bool {
+	var v gobject.Value
+	x.GetProperty("allow-mouse-drag", &v)
+	return v.GetBoolean()
+}
+
+// Whether to allow touchscreen swiping from `GtkWindowHandle`.
+//
+// This will make dragging the window impossible.
+
+func (x *SwipeTracker) SetPropertyAllowWindowHandle(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-window-handle", &v)
+}
+
+func (x *SwipeTracker) GetPropertyAllowWindowHandle() bool {
+	var v gobject.Value
+	x.GetProperty("allow-window-handle", &v)
+	return v.GetBoolean()
+}
+
+// Whether the swipe tracker is enabled.
+//
+// When it's not enabled, no events will be processed. Usually widgets will
+// want to expose this via a property.
+
+func (x *SwipeTracker) SetPropertyEnabled(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enabled", &v)
+}
+
+func (x *SwipeTracker) GetPropertyEnabled() bool {
+	var v gobject.Value
+	x.GetProperty("enabled", &v)
+	return v.GetBoolean()
+}
+
+// Whether to allow swiping past the first available snap point.
+
+func (x *SwipeTracker) SetPropertyLowerOvershoot(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("lower-overshoot", &v)
+}
+
+func (x *SwipeTracker) GetPropertyLowerOvershoot() bool {
+	var v gobject.Value
+	x.GetProperty("lower-overshoot", &v)
+	return v.GetBoolean()
+}
+
+// Whether to reverse the swipe direction.
+//
+// If the swipe tracker is horizontal, it can be used for supporting RTL text
+// direction.
+
+func (x *SwipeTracker) SetPropertyReversed(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reversed", &v)
+}
+
+func (x *SwipeTracker) GetPropertyReversed() bool {
+	var v gobject.Value
+	x.GetProperty("reversed", &v)
+	return v.GetBoolean()
+}
+
+// The widget the swipe tracker is attached to.
+
+func (x *SwipeTracker) SetPropertySwipeable(value Swipeable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("swipeable", &v)
+}
+
+func (x *SwipeTracker) GetPropertySwipeable() Swipeable {
+	var v gobject.Value
+	x.GetProperty("swipeable", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SwipeableBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to allow swiping past the last available snap point.
+
+func (x *SwipeTracker) SetPropertyUpperOvershoot(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("upper-overshoot", &v)
+}
+
+func (x *SwipeTracker) GetPropertyUpperOvershoot() bool {
+	var v gobject.Value
+	x.GetProperty("upper-overshoot", &v)
+	return v.GetBoolean()
+}
+
 // This signal is emitted right before a swipe will be started, after the
 // drag threshold has been passed.
 func (x *SwipeTracker) ConnectBeginSwipe(cb *func(SwipeTracker)) uint32 {
diff --git a/v4/adw/adw-switch-row.go b/v4/adw/adw-switch-row.go
index 029ed0be1fc9916d8ca315220a00ebc9a20eb1e3..837c7235d47b2675c56bfd15bdff3bc9820afaf1 100644
--- a/v4/adw/adw-switch-row.go
+++ b/v4/adw/adw-switch-row.go
@@ -119,6 +119,21 @@ func (c *SwitchRow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the switch row is in the "on" or "off" position.
+
+func (x *SwitchRow) SetPropertyActive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("active", &v)
+}
+
+func (x *SwitchRow) GetPropertyActive() bool {
+	var v gobject.Value
+	x.GetProperty("active", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *SwitchRow) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-tab-bar.go b/v4/adw/adw-tab-bar.go
index 58e9992bf06ca801ebaf9c6332571af54e152280..b2475fc93079a82f8a78b182a9b0696ce4759e20 100644
--- a/v4/adw/adw-tab-bar.go
+++ b/v4/adw/adw-tab-bar.go
@@ -317,6 +317,175 @@ func (c *TabBar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the tabs automatically hide.
+//
+// If set to `TRUE`, the tab bar disappears when [property@TabBar:view] has 0
+// or 1 tab, no pinned tabs, and no tab is being transferred.
+//
+// See [property@TabBar:tabs-revealed].
+
+func (x *TabBar) SetPropertyAutohide(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("autohide", &v)
+}
+
+func (x *TabBar) GetPropertyAutohide() bool {
+	var v gobject.Value
+	x.GetProperty("autohide", &v)
+	return v.GetBoolean()
+}
+
+// The widget shown after the tabs.
+
+func (x *TabBar) SetPropertyEndActionWidget(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("end-action-widget", &v)
+}
+
+func (x *TabBar) GetPropertyEndActionWidget() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("end-action-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether tabs expand to full width.
+//
+// If set to `TRUE`, the tabs will always vary width filling the whole width
+// when possible, otherwise tabs will always have the minimum possible size.
+
+func (x *TabBar) SetPropertyExpandTabs(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("expand-tabs", &v)
+}
+
+func (x *TabBar) GetPropertyExpandTabs() bool {
+	var v gobject.Value
+	x.GetProperty("expand-tabs", &v)
+	return v.GetBoolean()
+}
+
+// The unique action on the `current-drop` of the
+// [signal@TabBar::extra-drag-drop].
+//
+// This property should only be used during a [signal@TabBar::extra-drag-drop]
+// and is always a subset of what was originally passed to
+// [method@TabBar.setup_extra_drop_target].
+
+func (x *TabBar) GetPropertyExtraDragPreferredAction() gdk.DragAction {
+	var v gobject.Value
+	x.GetProperty("extra-drag-preferred-action", &v)
+	return gdk.DragAction(v.GetFlags())
+}
+
+// Whether the drop data should be preloaded on hover.
+//
+// See [property@Gtk.DropTarget:preload].
+
+func (x *TabBar) SetPropertyExtraDragPreload(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("extra-drag-preload", &v)
+}
+
+func (x *TabBar) GetPropertyExtraDragPreload() bool {
+	var v gobject.Value
+	x.GetProperty("extra-drag-preload", &v)
+	return v.GetBoolean()
+}
+
+// Whether tabs use inverted layout.
+//
+// If set to `TRUE`, non-pinned tabs will have the close button at the
+// beginning and the indicator at the end rather than the opposite.
+
+func (x *TabBar) SetPropertyInverted(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("inverted", &v)
+}
+
+func (x *TabBar) GetPropertyInverted() bool {
+	var v gobject.Value
+	x.GetProperty("inverted", &v)
+	return v.GetBoolean()
+}
+
+// Whether the tab bar is overflowing.
+//
+// If `TRUE`, all tabs cannot be displayed at once and require scrolling.
+
+func (x *TabBar) GetPropertyIsOverflowing() bool {
+	var v gobject.Value
+	x.GetProperty("is-overflowing", &v)
+	return v.GetBoolean()
+}
+
+// The widget shown before the tabs.
+
+func (x *TabBar) SetPropertyStartActionWidget(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("start-action-widget", &v)
+}
+
+func (x *TabBar) GetPropertyStartActionWidget() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("start-action-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the tabs are currently revealed.
+//
+// See [property@TabBar:autohide].
+
+func (x *TabBar) GetPropertyTabsRevealed() bool {
+	var v gobject.Value
+	x.GetProperty("tabs-revealed", &v)
+	return v.GetBoolean()
+}
+
+// The tab view the tab bar controls.
+
+func (x *TabBar) SetPropertyView(value *TabView) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("view", &v)
+}
+
+func (x *TabBar) GetPropertyView() *TabView {
+	var v gobject.Value
+	x.GetProperty("view", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TabView{}
+	result.Ptr = ptr
+	return result
+}
+
 // This signal is emitted when content is dropped onto a tab.
 //
 // The content must be of one of the types set up via
diff --git a/v4/adw/adw-tab-button.go b/v4/adw/adw-tab-button.go
index a6eca2018f571cc7853b05f6c086da98c2f310a8..501a551b9533faffad3ba1a4c65c099981ac24c4 100644
--- a/v4/adw/adw-tab-button.go
+++ b/v4/adw/adw-tab-button.go
@@ -125,6 +125,27 @@ func (c *TabButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The view the tab button displays.
+
+func (x *TabButton) SetPropertyView(value *TabView) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("view", &v)
+}
+
+func (x *TabButton) GetPropertyView() *TabView {
+	var v gobject.Value
+	x.GetProperty("view", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TabView{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emitted to animate press then release.
 //
 // This is an action signal. Applications should never connect to this signal,
diff --git a/v4/adw/adw-tab-overview.go b/v4/adw/adw-tab-overview.go
index 232c40eddefc2df415f864eb52e7b0f8e7f82e18..f881b7fd4015b1a6309ec357677f189e11a4d51a 100644
--- a/v4/adw/adw-tab-overview.go
+++ b/v4/adw/adw-tab-overview.go
@@ -395,6 +395,221 @@ func (c *TabOverview) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *TabOverview) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *TabOverview) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to enable new tab button.
+//
+// Connect to the [signal@TabOverview::create-tab] signal to use it.
+
+func (x *TabOverview) SetPropertyEnableNewTab(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-new-tab", &v)
+}
+
+func (x *TabOverview) GetPropertyEnableNewTab() bool {
+	var v gobject.Value
+	x.GetProperty("enable-new-tab", &v)
+	return v.GetBoolean()
+}
+
+// Whether to enable search in tabs.
+//
+// Search matches tab titles and tooltips, as well as keywords, set via
+// [property@TabPage:keyword]. Use keywords to search in e.g. page URLs in a
+// web browser.
+//
+// During search, tab reordering and drag-n-drop are disabled.
+//
+// Use [property@TabOverview:search-active] to check out if search is
+// currently active.
+
+func (x *TabOverview) SetPropertyEnableSearch(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-search", &v)
+}
+
+func (x *TabOverview) GetPropertyEnableSearch() bool {
+	var v gobject.Value
+	x.GetProperty("enable-search", &v)
+	return v.GetBoolean()
+}
+
+// The unique action on the `current-drop` of the
+// [signal@TabOverview::extra-drag-drop].
+//
+// This property should only be used during a
+// [signal@TabOverview::extra-drag-drop] and is always a subset of what was
+// originally passed to [method@TabOverview.setup_extra_drop_target].
+
+func (x *TabOverview) GetPropertyExtraDragPreferredAction() gdk.DragAction {
+	var v gobject.Value
+	x.GetProperty("extra-drag-preferred-action", &v)
+	return gdk.DragAction(v.GetFlags())
+}
+
+// Whether the drop data should be preloaded on hover.
+//
+// See [property@Gtk.DropTarget:preload].
+
+func (x *TabOverview) SetPropertyExtraDragPreload(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("extra-drag-preload", &v)
+}
+
+func (x *TabOverview) GetPropertyExtraDragPreload() bool {
+	var v gobject.Value
+	x.GetProperty("extra-drag-preload", &v)
+	return v.GetBoolean()
+}
+
+// Whether thumbnails use inverted layout.
+//
+// If set to `TRUE`, thumbnails will have the close or unpin buttons at the
+// beginning and the indicator at the end rather than the other way around.
+
+func (x *TabOverview) SetPropertyInverted(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("inverted", &v)
+}
+
+func (x *TabOverview) GetPropertyInverted() bool {
+	var v gobject.Value
+	x.GetProperty("inverted", &v)
+	return v.GetBoolean()
+}
+
+// Whether the overview is open.
+
+func (x *TabOverview) SetPropertyOpen(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("open", &v)
+}
+
+func (x *TabOverview) GetPropertyOpen() bool {
+	var v gobject.Value
+	x.GetProperty("open", &v)
+	return v.GetBoolean()
+}
+
+// Whether search is currently active.
+//
+// See [property@TabOverview:enable-search].
+
+func (x *TabOverview) GetPropertySearchActive() bool {
+	var v gobject.Value
+	x.GetProperty("search-active", &v)
+	return v.GetBoolean()
+}
+
+// The secondary menu model.
+//
+// Use it to add extra actions, e.g. to open a new window or undo closed tab.
+
+func (x *TabOverview) SetPropertySecondaryMenu(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("secondary-menu", &v)
+}
+
+func (x *TabOverview) GetPropertySecondaryMenu() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("secondary-menu", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to show end title buttons in the overview's header bar.
+//
+// See [property@HeaderBar:show-start-title-buttons] for the other side.
+
+func (x *TabOverview) SetPropertyShowEndTitleButtons(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-end-title-buttons", &v)
+}
+
+func (x *TabOverview) GetPropertyShowEndTitleButtons() bool {
+	var v gobject.Value
+	x.GetProperty("show-end-title-buttons", &v)
+	return v.GetBoolean()
+}
+
+// Whether to show start title buttons in the overview's header bar.
+//
+// See [property@HeaderBar:show-end-title-buttons] for the other side.
+
+func (x *TabOverview) SetPropertyShowStartTitleButtons(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-start-title-buttons", &v)
+}
+
+func (x *TabOverview) GetPropertyShowStartTitleButtons() bool {
+	var v gobject.Value
+	x.GetProperty("show-start-title-buttons", &v)
+	return v.GetBoolean()
+}
+
+// The tab view the overview controls.
+//
+// The view must be inside the tab overview, see [property@TabOverview:child].
+
+func (x *TabOverview) SetPropertyView(value *TabView) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("view", &v)
+}
+
+func (x *TabOverview) GetPropertyView() *TabView {
+	var v gobject.Value
+	x.GetProperty("view", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TabView{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emitted when a tab needs to be created.
 //
 // This can happen after the new tab button has been pressed, see
diff --git a/v4/adw/adw-tab-view.go b/v4/adw/adw-tab-view.go
index e22b3ca801a0e6410e8c24ff9c9b02f2aca42599..21a426105bacdb37ee7224f015b0610dcfa71f3b 100644
--- a/v4/adw/adw-tab-view.go
+++ b/v4/adw/adw-tab-view.go
@@ -508,6 +508,350 @@ func (c *TabPage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child of the page.
+
+func (x *TabPage) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *TabPage) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The icon of the page.
+//
+// [class@TabBar] and [class@TabOverview] display the icon next to the title,
+// unless [property@TabPage:loading] is set to `TRUE`.
+//
+// `AdwTabBar` also won't show the icon if the page is pinned and
+// [propertyTabPage:indicator-icon] is set.
+
+func (x *TabPage) SetPropertyIcon(value gio.Icon) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("icon", &v)
+}
+
+func (x *TabPage) GetPropertyIcon() gio.Icon {
+	var v gobject.Value
+	x.GetProperty("icon", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.IconBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the indicator icon is activatable.
+//
+// If set to `TRUE`, [signal@TabView::indicator-activated] will be emitted
+// when the indicator icon is clicked.
+//
+// If [property@TabPage:indicator-icon] is not set, does nothing.
+
+func (x *TabPage) SetPropertyIndicatorActivatable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("indicator-activatable", &v)
+}
+
+func (x *TabPage) GetPropertyIndicatorActivatable() bool {
+	var v gobject.Value
+	x.GetProperty("indicator-activatable", &v)
+	return v.GetBoolean()
+}
+
+// An indicator icon for the page.
+//
+// A common use case is an audio or camera indicator in a web browser.
+//
+// [class@TabBar] will show it at the beginning of the tab, alongside icon
+// representing [property@TabPage:icon] or loading spinner.
+//
+// If the page is pinned, the indicator will be shown instead of icon or
+// spinner.
+//
+// [class@TabOverview] will show it at the at the top part of the thumbnail.
+//
+// [property@TabPage:indicator-tooltip] can be used to set the tooltip on the
+// indicator icon.
+//
+// If [property@TabPage:indicator-activatable] is set to `TRUE`, the
+// indicator icon can act as a button.
+
+func (x *TabPage) SetPropertyIndicatorIcon(value gio.Icon) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("indicator-icon", &v)
+}
+
+func (x *TabPage) GetPropertyIndicatorIcon() gio.Icon {
+	var v gobject.Value
+	x.GetProperty("indicator-icon", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.IconBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The tooltip of the indicator icon.
+//
+// The tooltip can be marked up with the Pango text markup language.
+//
+// See [property@TabPage:indicator-icon].
+
+func (x *TabPage) SetPropertyIndicatorTooltip(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("indicator-tooltip", &v)
+}
+
+func (x *TabPage) GetPropertyIndicatorTooltip() string {
+	var v gobject.Value
+	x.GetProperty("indicator-tooltip", &v)
+	return v.GetString()
+}
+
+// The search keyboard of the page.
+//
+// [class@TabOverview] can search pages by their keywords in addition to their
+// titles and tooltips.
+//
+// Keywords allow to include e.g. page URLs into tab search in a web browser.
+
+func (x *TabPage) SetPropertyKeyword(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("keyword", &v)
+}
+
+func (x *TabPage) GetPropertyKeyword() string {
+	var v gobject.Value
+	x.GetProperty("keyword", &v)
+	return v.GetString()
+}
+
+// Whether to enable live thumbnail for this page.
+//
+// When set to `TRUE`, the page's thumbnail in [class@TabOverview] will update
+// immediately when the page is redrawn or resized.
+//
+// If it's set to `FALSE`, the thumbnail will only be live when the page is
+// selected, and otherwise it will be static and will only update when
+// [method@TabPage.invalidate_thumbnail] or
+// [method@TabView.invalidate_thumbnails] is called.
+
+func (x *TabPage) SetPropertyLiveThumbnail(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("live-thumbnail", &v)
+}
+
+func (x *TabPage) GetPropertyLiveThumbnail() bool {
+	var v gobject.Value
+	x.GetProperty("live-thumbnail", &v)
+	return v.GetBoolean()
+}
+
+// Whether the page is loading.
+//
+// If set to `TRUE`, [class@TabBar] and [class@TabOverview] will display a
+// spinner in place of icon.
+//
+// If the page is pinned and [property@TabPage:indicator-icon] is set,
+// loading status will not be visible with `AdwTabBar`.
+
+func (x *TabPage) SetPropertyLoading(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("loading", &v)
+}
+
+func (x *TabPage) GetPropertyLoading() bool {
+	var v gobject.Value
+	x.GetProperty("loading", &v)
+	return v.GetBoolean()
+}
+
+// Whether the page needs attention.
+//
+// [class@TabBar] will display a line under the tab representing the page if
+// set to `TRUE`. If the tab is not visible, the corresponding edge of the tab
+// bar will be highlighted.
+//
+// [class@TabOverview] will display a dot in the corner of the thumbnail if set
+// to `TRUE`.
+//
+// [class@TabButton] will display a dot if any of the pages that aren't
+// selected have this property set to `TRUE`.
+
+func (x *TabPage) SetPropertyNeedsAttention(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("needs-attention", &v)
+}
+
+func (x *TabPage) GetPropertyNeedsAttention() bool {
+	var v gobject.Value
+	x.GetProperty("needs-attention", &v)
+	return v.GetBoolean()
+}
+
+// The parent page of the page.
+//
+// See [method@TabView.add_page] and [method@TabView.close_page].
+
+func (x *TabPage) SetPropertyParent(value *TabPage) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("parent", &v)
+}
+
+func (x *TabPage) GetPropertyParent() *TabPage {
+	var v gobject.Value
+	x.GetProperty("parent", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TabPage{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the page is pinned.
+//
+// See [method@TabView.set_page_pinned].
+
+func (x *TabPage) GetPropertyPinned() bool {
+	var v gobject.Value
+	x.GetProperty("pinned", &v)
+	return v.GetBoolean()
+}
+
+// Whether the page is selected.
+
+func (x *TabPage) GetPropertySelected() bool {
+	var v gobject.Value
+	x.GetProperty("selected", &v)
+	return v.GetBoolean()
+}
+
+// The horizontal alignment of the page thumbnail.
+//
+// If the page is so wide that [class@TabOverview] can't display it completely
+// and has to crop it, horizontal alignment will determine which part of the
+// page will be visible.
+//
+// For example, 0.5 means the center of the page will be visible, 0 means the
+// start edge will be visible and 1 means the end edge will be visible.
+//
+// The default horizontal alignment is 0.
+
+func (x *TabPage) SetPropertyThumbnailXalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("thumbnail-xalign", &v)
+}
+
+func (x *TabPage) GetPropertyThumbnailXalign() float32 {
+	var v gobject.Value
+	x.GetProperty("thumbnail-xalign", &v)
+	return v.GetFloat()
+}
+
+// The vertical alignment of the page thumbnail.
+//
+// If the page is so tall that [class@TabOverview] can't display it completely
+// and has to crop it, vertical alignment will determine which part of the
+// page will be visible.
+//
+// For example, 0.5 means the center of the page will be visible, 0 means the
+// top edge will be visible and 1 means the bottom edge will be visible.
+//
+// The default vertical alignment is 0.
+
+func (x *TabPage) SetPropertyThumbnailYalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("thumbnail-yalign", &v)
+}
+
+func (x *TabPage) GetPropertyThumbnailYalign() float32 {
+	var v gobject.Value
+	x.GetProperty("thumbnail-yalign", &v)
+	return v.GetFloat()
+}
+
+// The title of the page.
+//
+// [class@TabBar] will display it in the center of the tab unless it's pinned,
+// and will use it as a tooltip unless [property@TabPage:tooltip] is set.
+//
+// [class@TabOverview] will display it below the thumbnail unless it's pinned,
+// or inside the card otherwise, and will use it as a tooltip unless
+// [property@TabPage:tooltip] is set.
+
+func (x *TabPage) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *TabPage) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// The tooltip of the page.
+//
+// The tooltip can be marked up with the Pango text markup language.
+//
+// If not set, [class@TabBar] and [class@TabOverview] will use
+// [property@TabPage:title] as a tooltip instead.
+
+func (x *TabPage) SetPropertyTooltip(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("tooltip", &v)
+}
+
+func (x *TabPage) GetPropertyTooltip() string {
+	var v gobject.Value
+	x.GetProperty("tooltip", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *TabPage) GetAccessibleRole() gtk.AccessibleRole {
 
@@ -1300,6 +1644,157 @@ }
 
 func (c *TabView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Default page icon.
+//
+// If a page doesn't provide its own icon via [property@TabPage:icon], a
+// default icon may be used instead for contexts where having an icon is
+// necessary.
+//
+// [class@TabBar] will use default icon for pinned tabs in case the page is
+// not loading, doesn't have an icon and an indicator. Default icon is never
+// used for tabs that aren't pinned.
+//
+// [class@TabOverview] will use default icon for pages with missing
+// thumbnails.
+//
+// By default, the `adw-tab-icon-missing-symbolic` icon is used.
+
+func (x *TabView) SetPropertyDefaultIcon(value gio.Icon) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("default-icon", &v)
+}
+
+func (x *TabView) GetPropertyDefaultIcon() gio.Icon {
+	var v gobject.Value
+	x.GetProperty("default-icon", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.IconBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether a page is being transferred.
+//
+// This property will be set to `TRUE` when a drag-n-drop tab transfer starts
+// on any `AdwTabView`, and to `FALSE` after it ends.
+//
+// During the transfer, children cannot receive pointer input and a tab can
+// be safely dropped on the tab view.
+
+func (x *TabView) GetPropertyIsTransferringPage() bool {
+	var v gobject.Value
+	x.GetProperty("is-transferring-page", &v)
+	return v.GetBoolean()
+}
+
+// Tab context menu model.
+//
+// When a context menu is shown for a tab, it will be constructed from the
+// provided menu model. Use the [signal@TabView::setup-menu] signal to set up
+// the menu actions for the particular tab.
+
+func (x *TabView) SetPropertyMenuModel(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("menu-model", &v)
+}
+
+func (x *TabView) GetPropertyMenuModel() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("menu-model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// The number of pages in the tab view.
+
+func (x *TabView) GetPropertyNPages() int {
+	var v gobject.Value
+	x.GetProperty("n-pages", &v)
+	return v.GetInt()
+}
+
+// The number of pinned pages in the tab view.
+//
+// See [method@TabView.set_page_pinned].
+
+func (x *TabView) GetPropertyNPinnedPages() int {
+	var v gobject.Value
+	x.GetProperty("n-pinned-pages", &v)
+	return v.GetInt()
+}
+
+// A selection model with the tab view's pages.
+//
+// This can be used to keep an up-to-date view. The model also implements
+// [iface@Gtk.SelectionModel] and can be used to track and change the selected
+// page.
+
+func (x *TabView) GetPropertyPages() gtk.SelectionModel {
+	var v gobject.Value
+	x.GetProperty("pages", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.SelectionModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The currently selected page.
+
+func (x *TabView) SetPropertySelectedPage(value *TabPage) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("selected-page", &v)
+}
+
+func (x *TabView) GetPropertySelectedPage() *TabPage {
+	var v gobject.Value
+	x.GetProperty("selected-page", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TabPage{}
+	result.Ptr = ptr
+	return result
+}
+
+// The enabled shortcuts.
+//
+// See [flags@TabViewShortcuts] for the list of the available shortcuts. All
+// of the shortcuts are enabled by default.
+//
+// [method@TabView.add_shortcuts] and [method@TabView.remove_shortcuts]
+// provide a convenient way to manage individual shortcuts.
+
+func (x *TabView) SetPropertyShortcuts(value TabViewShortcuts) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("shortcuts", &v)
+}
+
+func (x *TabView) GetPropertyShortcuts() TabViewShortcuts {
+	var v gobject.Value
+	x.GetProperty("shortcuts", &v)
+	return TabViewShortcuts(v.GetFlags())
 }
 
 // Emitted after [method@TabView.close_page] has been called for @page.
diff --git a/v4/adw/adw-timed-animation.go b/v4/adw/adw-timed-animation.go
index d13004dd1c2e8fe4a7937afb95bf5351afe8708f..d110b2f322c5e44b221d6370c560e6ed3e725bb5 100644
--- a/v4/adw/adw-timed-animation.go
+++ b/v4/adw/adw-timed-animation.go
@@ -225,6 +225,134 @@ func (c *TimedAnimation) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the animation changes direction on every iteration.
+
+func (x *TimedAnimation) SetPropertyAlternate(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("alternate", &v)
+}
+
+func (x *TimedAnimation) GetPropertyAlternate() bool {
+	var v gobject.Value
+	x.GetProperty("alternate", &v)
+	return v.GetBoolean()
+}
+
+// Duration of the animation, in milliseconds.
+//
+// Describes how much time the animation will take.
+//
+// If the animation repeats more than once, describes the duration of one
+// iteration.
+
+func (x *TimedAnimation) SetPropertyDuration(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("duration", &v)
+}
+
+func (x *TimedAnimation) GetPropertyDuration() uint {
+	var v gobject.Value
+	x.GetProperty("duration", &v)
+	return v.GetUint()
+}
+
+// Easing function used in the animation.
+//
+// Describes the curve the value is interpolated on.
+//
+// See [enum@Easing] for the description of specific easing functions.
+
+func (x *TimedAnimation) SetPropertyEasing(value Easing) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("easing", &v)
+}
+
+func (x *TimedAnimation) GetPropertyEasing() Easing {
+	var v gobject.Value
+	x.GetProperty("easing", &v)
+	return Easing(v.GetEnum())
+}
+
+// Number of times the animation will play.
+//
+// If set to 0, the animation will repeat endlessly.
+
+func (x *TimedAnimation) SetPropertyRepeatCount(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("repeat-count", &v)
+}
+
+func (x *TimedAnimation) GetPropertyRepeatCount() uint {
+	var v gobject.Value
+	x.GetProperty("repeat-count", &v)
+	return v.GetUint()
+}
+
+// Whether the animation plays backwards.
+
+func (x *TimedAnimation) SetPropertyReverse(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reverse", &v)
+}
+
+func (x *TimedAnimation) GetPropertyReverse() bool {
+	var v gobject.Value
+	x.GetProperty("reverse", &v)
+	return v.GetBoolean()
+}
+
+// The value to animate from.
+//
+// The animation will start at this value and end at
+// [property@TimedAnimation:value-to].
+//
+// If [property@TimedAnimation:reverse] is `TRUE`, the animation will end at
+// this value instead.
+
+func (x *TimedAnimation) SetPropertyValueFrom(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("value-from", &v)
+}
+
+func (x *TimedAnimation) GetPropertyValueFrom() float64 {
+	var v gobject.Value
+	x.GetProperty("value-from", &v)
+	return v.GetDouble()
+}
+
+// The value to animate to.
+//
+// The animation will start at [property@TimedAnimation:value-from] and end at
+// this value.
+//
+// If [property@TimedAnimation:reverse] is `TRUE`, the animation will start
+// at this value instead.
+
+func (x *TimedAnimation) SetPropertyValueTo(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("value-to", &v)
+}
+
+func (x *TimedAnimation) GetPropertyValueTo() float64 {
+	var v gobject.Value
+	x.GetProperty("value-to", &v)
+	return v.GetDouble()
+}
+
 func init() {
 
 	core.SetPackageName("ADW", "libadwaita-1")
diff --git a/v4/adw/adw-toast-overlay.go b/v4/adw/adw-toast-overlay.go
index d58ee1fb18b95f0dfa1a05384c25fa58aa73ea9a..c4a57403068a88ed96a6da8671da43ff8555bb4e 100644
--- a/v4/adw/adw-toast-overlay.go
+++ b/v4/adw/adw-toast-overlay.go
@@ -153,6 +153,27 @@ func (c *ToastOverlay) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *ToastOverlay) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *ToastOverlay) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ToastOverlay) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-toast.go b/v4/adw/adw-toast.go
index 4f172fc376e0dcf2c6b9e945fec537dde3166ede..7a9b47d366329048e4cd7a5392b47b16fb7895ad 100644
--- a/v4/adw/adw-toast.go
+++ b/v4/adw/adw-toast.go
@@ -479,6 +479,169 @@ func (c *Toast) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The name of the associated action.
+//
+// It will be activated when clicking the button.
+//
+// See [property@Toast:action-target].
+
+func (x *Toast) SetPropertyActionName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("action-name", &v)
+}
+
+func (x *Toast) GetPropertyActionName() string {
+	var v gobject.Value
+	x.GetProperty("action-name", &v)
+	return v.GetString()
+}
+
+// The parameter for action invocations.
+
+func (x *Toast) SetPropertyActionTarget(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("action-target", &v)
+}
+
+func (x *Toast) GetPropertyActionTarget() uintptr {
+	var v gobject.Value
+	x.GetProperty("action-target", &v)
+	return v.GetPointer()
+}
+
+// The label to show on the button.
+//
+// Underlines in the button text can be used to indicate a mnemonic.
+//
+// If set to `NULL`, the button won't be shown.
+//
+// See [property@Toast:action-name].
+
+func (x *Toast) SetPropertyButtonLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("button-label", &v)
+}
+
+func (x *Toast) GetPropertyButtonLabel() string {
+	var v gobject.Value
+	x.GetProperty("button-label", &v)
+	return v.GetString()
+}
+
+// The custom title widget.
+//
+// It will be displayed instead of the title if set. In this case,
+// [property@Toast:title] is ignored.
+//
+// Setting a custom title will unset [property@Toast:title].
+
+func (x *Toast) SetPropertyCustomTitle(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("custom-title", &v)
+}
+
+func (x *Toast) GetPropertyCustomTitle() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("custom-title", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The priority of the toast.
+//
+// Priority controls how the toast behaves when another toast is already
+// being displayed.
+//
+// If the priority is `ADW_TOAST_PRIORITY_NORMAL`, the toast will be queued.
+//
+// If the priority is `ADW_TOAST_PRIORITY_HIGH`, the toast will be displayed
+// immediately, pushing the previous toast into the queue instead.
+
+func (x *Toast) SetPropertyPriority(value ToastPriority) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("priority", &v)
+}
+
+func (x *Toast) GetPropertyPriority() ToastPriority {
+	var v gobject.Value
+	x.GetProperty("priority", &v)
+	return ToastPriority(v.GetEnum())
+}
+
+// The timeout of the toast, in seconds.
+//
+// If timeout is 0, the toast is displayed indefinitely until manually
+// dismissed.
+//
+// Toasts cannot disappear while being hovered, pressed (on touchscreen), or
+// have keyboard focus inside them.
+
+func (x *Toast) SetPropertyTimeout(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("timeout", &v)
+}
+
+func (x *Toast) GetPropertyTimeout() uint {
+	var v gobject.Value
+	x.GetProperty("timeout", &v)
+	return v.GetUint()
+}
+
+// The title of the toast.
+//
+// The title can be marked up with the Pango text markup language.
+//
+// Setting a title will unset [property@Toast:custom-title].
+//
+// If [property@Toast:custom-title] is set, it will be used instead.
+
+func (x *Toast) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *Toast) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// Whether to use Pango markup for the toast title.
+//
+// See also [func@Pango.parse_markup].
+
+func (x *Toast) SetPropertyUseMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-markup", &v)
+}
+
+func (x *Toast) GetPropertyUseMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("use-markup", &v)
+	return v.GetBoolean()
+}
+
 // Emitted after the button has been clicked.
 //
 // It can be used as an alternative to setting an action.
diff --git a/v4/adw/adw-toolbar-view.go b/v4/adw/adw-toolbar-view.go
index a86faf31d30c2025caa3398717168ca242821a5e..7ad78f1d2eee892c361d79d2e6512f52c3f73ebe 100644
--- a/v4/adw/adw-toolbar-view.go
+++ b/v4/adw/adw-toolbar-view.go
@@ -505,6 +505,216 @@ func (c *ToolbarView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The current bottom bar height.
+//
+// Bottom bar height does change depending on
+// [property@ToolbarView:reveal-bottom-bars], including during the transition.
+//
+// See [property@ToolbarView:top-bar-height].
+
+func (x *ToolbarView) GetPropertyBottomBarHeight() int {
+	var v gobject.Value
+	x.GetProperty("bottom-bar-height", &v)
+	return v.GetInt()
+}
+
+// Appearance of the bottom bars.
+//
+// If set to `ADW_TOOLBAR_FLAT`, bottom bars are flat and scrolling content
+// has a subtle undershoot shadow when touching them, same as the
+// [`.undershoot-bottom`](style-classes.html#undershoot-indicators)
+// style class. This works well for simple content, e.g. [class@StatusPage] or
+// [class@PreferencesPage], where the background at the bottom of the page is
+// uniform. Additionally, windows with sidebars should always use this style.
+//
+// Undershoot shadow is only present if a bottom bar is actually present and
+// visible. It is also never present if
+// [property@ToolbarView:extend-content-to-bottom-edge] is set to `TRUE`.
+//
+// If set to `ADW_TOOLBAR_RAISED`, bottom bars have an opaque background and a
+// persistent shadow, this is suitable for content such as
+// [utility panes](https://developer.gnome.org/hig/patterns/containers/utility-panes.html),
+// where some elements are directly adjacent to the bottom bars, or
+// [class@TabView], where each page can have a different background.
+//
+// `ADW_TOOLBAR_RAISED_BORDER` is similar to `ADW_TOOLBAR_RAISED`, but the
+// shadow is replaced with a more subtle border. This can be useful for
+// applications like image viewers.
+//
+// See also [property@ToolbarView:top-bar-style].
+
+func (x *ToolbarView) SetPropertyBottomBarStyle(value ToolbarStyle) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("bottom-bar-style", &v)
+}
+
+func (x *ToolbarView) GetPropertyBottomBarStyle() ToolbarStyle {
+	var v gobject.Value
+	x.GetProperty("bottom-bar-style", &v)
+	return ToolbarStyle(v.GetEnum())
+}
+
+// The content widget.
+
+func (x *ToolbarView) SetPropertyContent(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("content", &v)
+}
+
+func (x *ToolbarView) GetPropertyContent() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("content", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the content widget can extend behind bottom bars.
+//
+// This can be used in combination with
+// [property@ToolbarView:reveal-bottom-bars] to show and hide toolbars in
+// fullscreen.
+//
+// See [property@ToolbarView:extend-content-to-top-edge].
+
+func (x *ToolbarView) SetPropertyExtendContentToBottomEdge(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("extend-content-to-bottom-edge", &v)
+}
+
+func (x *ToolbarView) GetPropertyExtendContentToBottomEdge() bool {
+	var v gobject.Value
+	x.GetProperty("extend-content-to-bottom-edge", &v)
+	return v.GetBoolean()
+}
+
+// Whether the content widget can extend behind top bars.
+//
+// This can be used in combination with [property@ToolbarView:reveal-top-bars]
+// to show and hide toolbars in fullscreen.
+//
+// See [property@ToolbarView:extend-content-to-bottom-edge].
+
+func (x *ToolbarView) SetPropertyExtendContentToTopEdge(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("extend-content-to-top-edge", &v)
+}
+
+func (x *ToolbarView) GetPropertyExtendContentToTopEdge() bool {
+	var v gobject.Value
+	x.GetProperty("extend-content-to-top-edge", &v)
+	return v.GetBoolean()
+}
+
+// Whether bottom bars are visible.
+//
+// The transition will be animated.
+//
+// This can be used in combination with
+// [property@ToolbarView:extend-content-to-bottom-edge] to show and hide
+// toolbars in fullscreen.
+//
+// See [property@ToolbarView:reveal-top-bars].
+
+func (x *ToolbarView) SetPropertyRevealBottomBars(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reveal-bottom-bars", &v)
+}
+
+func (x *ToolbarView) GetPropertyRevealBottomBars() bool {
+	var v gobject.Value
+	x.GetProperty("reveal-bottom-bars", &v)
+	return v.GetBoolean()
+}
+
+// Whether top bars are revealed.
+//
+// The transition will be animated.
+//
+// This can be used in combination with
+// [property@ToolbarView:extend-content-to-top-edge] to show and hide toolbars
+// in fullscreen.
+//
+// See [property@ToolbarView:reveal-bottom-bars].
+
+func (x *ToolbarView) SetPropertyRevealTopBars(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reveal-top-bars", &v)
+}
+
+func (x *ToolbarView) GetPropertyRevealTopBars() bool {
+	var v gobject.Value
+	x.GetProperty("reveal-top-bars", &v)
+	return v.GetBoolean()
+}
+
+// The current top bar height.
+//
+// Top bar height does change depending [property@ToolbarView:reveal-top-bars],
+// including during the transition.
+//
+// See [property@ToolbarView:bottom-bar-height].
+
+func (x *ToolbarView) GetPropertyTopBarHeight() int {
+	var v gobject.Value
+	x.GetProperty("top-bar-height", &v)
+	return v.GetInt()
+}
+
+// Appearance of the top bars.
+//
+// If set to `ADW_TOOLBAR_FLAT`, top bars are flat and scrolling content has a
+// subtle undershoot shadow when touching them, same as the
+// [`.undershoot-top`](style-classes.html#undershoot-indicators)
+// style class. This works well for simple content, e.g. [class@StatusPage] or
+// [class@PreferencesPage], where the background at the top of the page is
+// uniform. Additionally, windows with sidebars should always use this style.
+//
+// Undershoot shadow is only present if a top bar is actually present and
+// visible. It is also never present if
+// [property@ToolbarView:extend-content-to-top-edge] is set to `TRUE`.
+//
+// If set to `ADW_TOOLBAR_RAISED`, top bars have an opaque background and a
+// persistent shadow, this is suitable for content such as
+// [utility panes](https://developer.gnome.org/hig/patterns/containers/utility-panes.html),
+// where some elements are directly adjacent to the top bars, or
+// [class@TabView], where each page can have a different background.
+//
+// `ADW_TOOLBAR_RAISED_BORDER` is similar to `ADW_TOOLBAR_RAISED`, but the
+// shadow is replaced with a more subtle border. This can be useful for
+// applications like image viewers.
+//
+// See also [property@ToolbarView:bottom-bar-style].
+
+func (x *ToolbarView) SetPropertyTopBarStyle(value ToolbarStyle) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("top-bar-style", &v)
+}
+
+func (x *ToolbarView) GetPropertyTopBarStyle() ToolbarStyle {
+	var v gobject.Value
+	x.GetProperty("top-bar-style", &v)
+	return ToolbarStyle(v.GetEnum())
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ToolbarView) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-view-stack.go b/v4/adw/adw-view-stack.go
index 2f624b3fcded3222b77a8b46487794ff2d85be6c..3abaf244d9dc9b1a43e1a4454345d6a3783fb997 100644
--- a/v4/adw/adw-view-stack.go
+++ b/v4/adw/adw-view-stack.go
@@ -376,6 +376,104 @@ func (c *ViewStack) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the stack is horizontally homogeneous.
+//
+// If the stack is horizontally homogeneous, it allocates the same width for
+// all children.
+//
+// If it's `FALSE`, the stack may change width when a different child becomes
+// visible.
+
+func (x *ViewStack) SetPropertyHhomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("hhomogeneous", &v)
+}
+
+func (x *ViewStack) GetPropertyHhomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("hhomogeneous", &v)
+	return v.GetBoolean()
+}
+
+// A selection model with the stack's pages.
+//
+// This can be used to keep an up-to-date view. The model also implements
+// [iface@Gtk.SelectionModel] and can be used to track and change the visible
+// page.
+
+func (x *ViewStack) GetPropertyPages() gtk.SelectionModel {
+	var v gobject.Value
+	x.GetProperty("pages", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.SelectionModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the stack is vertically homogeneous.
+//
+// If the stack is vertically homogeneous, it allocates the same height for
+// all children.
+//
+// If it's `FALSE`, the stack may change height when a different child becomes
+// visible.
+
+func (x *ViewStack) SetPropertyVhomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("vhomogeneous", &v)
+}
+
+func (x *ViewStack) GetPropertyVhomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("vhomogeneous", &v)
+	return v.GetBoolean()
+}
+
+// The widget currently visible in the stack.
+
+func (x *ViewStack) SetPropertyVisibleChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("visible-child", &v)
+}
+
+func (x *ViewStack) GetPropertyVisibleChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("visible-child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the widget currently visible in the stack.
+//
+// See [property@ViewStack:visible-child].
+
+func (x *ViewStack) SetPropertyVisibleChildName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("visible-child-name", &v)
+}
+
+func (x *ViewStack) GetPropertyVisibleChildName() string {
+	var v gobject.Value
+	x.GetProperty("visible-child-name", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ViewStack) GetAccessibleRole() gtk.AccessibleRole {
 
@@ -703,6 +801,142 @@ func (c *ViewStackPage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The badge number for this page.
+//
+// [class@ViewSwitcher] can display it as a badge next to the page icon. It is
+// commonly used to display a number of unread items within the page.
+//
+// It can be used together with [property@ViewStack{age}:needs-attention].
+
+func (x *ViewStackPage) SetPropertyBadgeNumber(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("badge-number", &v)
+}
+
+func (x *ViewStackPage) GetPropertyBadgeNumber() uint {
+	var v gobject.Value
+	x.GetProperty("badge-number", &v)
+	return v.GetUint()
+}
+
+// The stack child to which the page belongs.
+
+func (x *ViewStackPage) SetPropertyChild(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *ViewStackPage) GetPropertyChild() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The icon name of the child page.
+
+func (x *ViewStackPage) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *ViewStackPage) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// The name of the child page.
+
+func (x *ViewStackPage) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *ViewStackPage) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// Whether the page requires the user attention.
+//
+// [class@ViewSwitcher] will display it as a dot next to the page icon.
+
+func (x *ViewStackPage) SetPropertyNeedsAttention(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("needs-attention", &v)
+}
+
+func (x *ViewStackPage) GetPropertyNeedsAttention() bool {
+	var v gobject.Value
+	x.GetProperty("needs-attention", &v)
+	return v.GetBoolean()
+}
+
+// The title of the child page.
+
+func (x *ViewStackPage) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *ViewStackPage) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// Whether an embedded underline in the title indicates a mnemonic.
+
+func (x *ViewStackPage) SetPropertyUseUnderline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-underline", &v)
+}
+
+func (x *ViewStackPage) GetPropertyUseUnderline() bool {
+	var v gobject.Value
+	x.GetProperty("use-underline", &v)
+	return v.GetBoolean()
+}
+
+// Whether this page is visible.
+//
+// This is independent from the [property@Gtk.Widget:visible] property of
+// [property@ViewStackPage:child].
+
+func (x *ViewStackPage) SetPropertyVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("visible", &v)
+}
+
+func (x *ViewStackPage) GetPropertyVisible() bool {
+	var v gobject.Value
+	x.GetProperty("visible", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ViewStackPage) GetAccessibleRole() gtk.AccessibleRole {
 
@@ -896,6 +1130,32 @@ }
 
 func (c *ViewStackPages) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The selected [class@ViewStackPage] within the [class@ViewStackPages].
+//
+// This can be used to keep an up-to-date view of the [class@ViewStackPage] for
+// The visible [class@ViewStackPage] within the associated [class@ViewStackPages].
+//
+// This can be used to keep an up-to-date view of the visible child.
+
+func (x *ViewStackPages) SetPropertySelectedPage(value *ViewStackPage) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("selected-page", &v)
+}
+
+func (x *ViewStackPages) GetPropertySelectedPage() *ViewStackPage {
+	var v gobject.Value
+	x.GetProperty("selected-page", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ViewStackPage{}
+	result.Ptr = ptr
+	return result
 }
 
 // Get the item at @position.
diff --git a/v4/adw/adw-view-switcher-bar.go b/v4/adw/adw-view-switcher-bar.go
index 9e2995e3fc2b528d62d72cea770d378096af5cff..4697376d8cc6fd78c748ec43e839a743e9023afc 100644
--- a/v4/adw/adw-view-switcher-bar.go
+++ b/v4/adw/adw-view-switcher-bar.go
@@ -173,6 +173,42 @@ func (c *ViewSwitcherBar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the bar should be revealed or hidden.
+
+func (x *ViewSwitcherBar) SetPropertyReveal(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reveal", &v)
+}
+
+func (x *ViewSwitcherBar) GetPropertyReveal() bool {
+	var v gobject.Value
+	x.GetProperty("reveal", &v)
+	return v.GetBoolean()
+}
+
+// The stack the view switcher controls.
+
+func (x *ViewSwitcherBar) SetPropertyStack(value *ViewStack) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("stack", &v)
+}
+
+func (x *ViewSwitcherBar) GetPropertyStack() *ViewStack {
+	var v gobject.Value
+	x.GetProperty("stack", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ViewStack{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ViewSwitcherBar) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-view-switcher-title.go b/v4/adw/adw-view-switcher-title.go
index e7f3fa8fb03bdd5dd1d794ac2b4b735a61442943..33481171e3763ffdb3d749e136e8d0adda988dc0 100644
--- a/v4/adw/adw-view-switcher-title.go
+++ b/v4/adw/adw-view-switcher-title.go
@@ -233,6 +233,95 @@ func (c *ViewSwitcherTitle) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The stack the view switcher controls.
+
+func (x *ViewSwitcherTitle) SetPropertyStack(value *ViewStack) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("stack", &v)
+}
+
+func (x *ViewSwitcherTitle) GetPropertyStack() *ViewStack {
+	var v gobject.Value
+	x.GetProperty("stack", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ViewStack{}
+	result.Ptr = ptr
+	return result
+}
+
+// The subtitle to display.
+//
+// The subtitle should give the user additional details.
+
+func (x *ViewSwitcherTitle) SetPropertySubtitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("subtitle", &v)
+}
+
+func (x *ViewSwitcherTitle) GetPropertySubtitle() string {
+	var v gobject.Value
+	x.GetProperty("subtitle", &v)
+	return v.GetString()
+}
+
+// The title to display.
+//
+// The title typically identifies the current view or content item, and
+// generally does not use the application name.
+
+func (x *ViewSwitcherTitle) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *ViewSwitcherTitle) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// Whether the title is currently visible.
+//
+// If the title is visible, it means the view switcher is hidden an it may be
+// wanted to show an alternative switcher, e.g. a [class@ViewSwitcherBar].
+
+func (x *ViewSwitcherTitle) GetPropertyTitleVisible() bool {
+	var v gobject.Value
+	x.GetProperty("title-visible", &v)
+	return v.GetBoolean()
+}
+
+// Whether the view switcher is enabled.
+//
+// If it is disabled, the title will be displayed instead. This allows to
+// programmatically hide the view switcher even if it fits in the available
+// space.
+//
+// This can be used e.g. to ensure the view switcher is hidden below a certain
+// window width, or any other constraint you find suitable.
+
+func (x *ViewSwitcherTitle) SetPropertyViewSwitcherEnabled(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("view-switcher-enabled", &v)
+}
+
+func (x *ViewSwitcherTitle) GetPropertyViewSwitcherEnabled() bool {
+	var v gobject.Value
+	x.GetProperty("view-switcher-enabled", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ViewSwitcherTitle) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-view-switcher.go b/v4/adw/adw-view-switcher.go
index 0c815070cc19ca9c15b0eef1af4e5145a26e510c..fc2a3f58f2ceaa53bbacdac3259d6049a0f05149 100644
--- a/v4/adw/adw-view-switcher.go
+++ b/v4/adw/adw-view-switcher.go
@@ -199,6 +199,42 @@ func (c *ViewSwitcher) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The policy to determine which mode to use.
+
+func (x *ViewSwitcher) SetPropertyPolicy(value ViewSwitcherPolicy) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("policy", &v)
+}
+
+func (x *ViewSwitcher) GetPropertyPolicy() ViewSwitcherPolicy {
+	var v gobject.Value
+	x.GetProperty("policy", &v)
+	return ViewSwitcherPolicy(v.GetEnum())
+}
+
+// The stack the view switcher controls.
+
+func (x *ViewSwitcher) SetPropertyStack(value *ViewStack) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("stack", &v)
+}
+
+func (x *ViewSwitcher) GetPropertyStack() *ViewStack {
+	var v gobject.Value
+	x.GetProperty("stack", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ViewStack{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ViewSwitcher) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-window-title.go b/v4/adw/adw-window-title.go
index aa201e79b30317de73acd16282b77ed1d185d518..494a30786aa4c424d7b7721c50e277aa0446de36 100644
--- a/v4/adw/adw-window-title.go
+++ b/v4/adw/adw-window-title.go
@@ -122,6 +122,41 @@ func (c *WindowTitle) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The subtitle to display.
+//
+// The subtitle should give the user additional details.
+
+func (x *WindowTitle) SetPropertySubtitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("subtitle", &v)
+}
+
+func (x *WindowTitle) GetPropertySubtitle() string {
+	var v gobject.Value
+	x.GetProperty("subtitle", &v)
+	return v.GetString()
+}
+
+// The title to display.
+//
+// The title typically identifies the current view or content item, and
+// generally does not use the application name.
+
+func (x *WindowTitle) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *WindowTitle) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *WindowTitle) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/adw/adw-window.go b/v4/adw/adw-window.go
index d4323d19e4edbab5700660d21fa6f44617de8b0a..e45528ff10475e891d4e2901b65bda953259ebd3 100644
--- a/v4/adw/adw-window.go
+++ b/v4/adw/adw-window.go
@@ -241,6 +241,71 @@ func (c *Window) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The content widget.
+//
+// This property should always be used instead of [property@Gtk.Window:child].
+
+func (x *Window) SetPropertyContent(value *gtk.Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("content", &v)
+}
+
+func (x *Window) GetPropertyContent() *gtk.Widget {
+	var v gobject.Value
+	x.GetProperty("content", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gtk.Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The current breakpoint.
+
+func (x *Window) GetPropertyCurrentBreakpoint() *Breakpoint {
+	var v gobject.Value
+	x.GetProperty("current-breakpoint", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Breakpoint{}
+	result.Ptr = ptr
+	return result
+}
+
+// The open dialogs.
+
+func (x *Window) GetPropertyDialogs() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("dialogs", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The currently visible dialog
+
+func (x *Window) GetPropertyVisibleDialog() *Dialog {
+	var v gobject.Value
+	x.GetProperty("visible-dialog", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Dialog{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Window) GetAccessibleRole() gtk.AccessibleRole {
 
diff --git a/v4/gdk/gdkapplaunchcontext.go b/v4/gdk/gdkapplaunchcontext.go
index d84bbf6c087be7f3e0153ca21b9668328033104e..46548331a80ed15de3c4c11a6c285556579550d7 100644
--- a/v4/gdk/gdkapplaunchcontext.go
+++ b/v4/gdk/gdkapplaunchcontext.go
@@ -143,6 +143,27 @@ func (c *AppLaunchContext) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The display that the `GdkAppLaunchContext` is on.
+
+func (x *AppLaunchContext) SetPropertyDisplay(value *Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *AppLaunchContext) GetPropertyDisplay() *Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Display{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GDK", "gtk4")
diff --git a/v4/gdk/gdkclipboard.go b/v4/gdk/gdkclipboard.go
index 084fb51333d44dba36e5d2b5a19396d079f7a237..52373c11df2faece817ac3f2fa6143817a58c8c3 100644
--- a/v4/gdk/gdkclipboard.go
+++ b/v4/gdk/gdkclipboard.go
@@ -372,6 +372,58 @@ func (c *Clipboard) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GdkContentProvider` or %NULL if the clipboard is empty or contents are
+// provided otherwise.
+
+func (x *Clipboard) GetPropertyContent() *ContentProvider {
+	var v gobject.Value
+	x.GetProperty("content", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ContentProvider{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GdkDisplay` that the clipboard belongs to.
+
+func (x *Clipboard) SetPropertyDisplay(value *Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *Clipboard) GetPropertyDisplay() *Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Display{}
+	result.Ptr = ptr
+	return result
+}
+
+// The possible formats that the clipboard can provide its data in.
+
+func (x *Clipboard) GetPropertyFormats() uintptr {
+	var v gobject.Value
+	x.GetProperty("formats", &v)
+	return v.GetPointer()
+}
+
+// %TRUE if the contents of the clipboard are owned by this process.
+
+func (x *Clipboard) GetPropertyLocal() bool {
+	var v gobject.Value
+	x.GetProperty("local", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when the clipboard changes ownership.
 func (x *Clipboard) ConnectChanged(cb *func(Clipboard)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gdk/gdkcontentprovider.go b/v4/gdk/gdkcontentprovider.go
index b45db22773edf68a860b5d8f151d6d7f025d3434..e0d469cca41be635409ae68487ed1959da815f3d 100644
--- a/v4/gdk/gdkcontentprovider.go
+++ b/v4/gdk/gdkcontentprovider.go
@@ -435,6 +435,22 @@ func (c *ContentProvider) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The possible formats that the provider can provide its data in.
+
+func (x *ContentProvider) GetPropertyFormats() uintptr {
+	var v gobject.Value
+	x.GetProperty("formats", &v)
+	return v.GetPointer()
+}
+
+// The subset of formats that clipboard managers should store this provider's data in.
+
+func (x *ContentProvider) GetPropertyStorableFormats() uintptr {
+	var v gobject.Value
+	x.GetProperty("storable-formats", &v)
+	return v.GetPointer()
+}
+
 // Emitted whenever the content provided by this provider has changed.
 func (x *ContentProvider) ConnectContentChanged(cb *func(ContentProvider)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gdk/gdkcursor.go b/v4/gdk/gdkcursor.go
index 9d377d88d0122765da00e0bd5073cecf32c14aab..e884b5c07408f76a3bdff7967c20980c2fb1abbd 100644
--- a/v4/gdk/gdkcursor.go
+++ b/v4/gdk/gdkcursor.go
@@ -199,6 +199,97 @@ func (c *Cursor) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Cursor to fall back to if this cursor cannot be displayed.
+
+func (x *Cursor) SetPropertyFallback(value *Cursor) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("fallback", &v)
+}
+
+func (x *Cursor) GetPropertyFallback() *Cursor {
+	var v gobject.Value
+	x.GetProperty("fallback", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Cursor{}
+	result.Ptr = ptr
+	return result
+}
+
+// X position of the cursor hotspot in the cursor image.
+
+func (x *Cursor) SetPropertyHotspotX(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("hotspot-x", &v)
+}
+
+func (x *Cursor) GetPropertyHotspotX() int {
+	var v gobject.Value
+	x.GetProperty("hotspot-x", &v)
+	return v.GetInt()
+}
+
+// Y position of the cursor hotspot in the cursor image.
+
+func (x *Cursor) SetPropertyHotspotY(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("hotspot-y", &v)
+}
+
+func (x *Cursor) GetPropertyHotspotY() int {
+	var v gobject.Value
+	x.GetProperty("hotspot-y", &v)
+	return v.GetInt()
+}
+
+// Name of this this cursor.
+//
+// The name will be %NULL if the cursor was created from a texture.
+
+func (x *Cursor) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *Cursor) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// The texture displayed by this cursor.
+//
+// The texture will be %NULL if the cursor was created from a name.
+
+func (x *Cursor) SetPropertyTexture(value *Texture) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("texture", &v)
+}
+
+func (x *Cursor) GetPropertyTexture() *Texture {
+	var v gobject.Value
+	x.GetProperty("texture", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Texture{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GDK", "gtk4")
diff --git a/v4/gdk/gdkdevice.go b/v4/gdk/gdkdevice.go
index b2b7617ad31018e4d49c2b463ec980495b51c639..86137cabc4984acd9e1ad38a5367e01f1a158b4e 100644
--- a/v4/gdk/gdkdevice.go
+++ b/v4/gdk/gdkdevice.go
@@ -340,6 +340,227 @@ func (c *Device) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether Caps Lock is on.
+//
+// This is only relevant for keyboard devices.
+
+func (x *Device) GetPropertyCapsLockState() bool {
+	var v gobject.Value
+	x.GetProperty("caps-lock-state", &v)
+	return v.GetBoolean()
+}
+
+// The direction of the current layout.
+//
+// This is only relevant for keyboard devices.
+
+func (x *Device) GetPropertyDirection() pango.Direction {
+	var v gobject.Value
+	x.GetProperty("direction", &v)
+	return pango.Direction(v.GetEnum())
+}
+
+// The `GdkDisplay` the `GdkDevice` pertains to.
+
+func (x *Device) SetPropertyDisplay(value *Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *Device) GetPropertyDisplay() *Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Display{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the device has both right-to-left and left-to-right layouts.
+//
+// This is only relevant for keyboard devices.
+
+func (x *Device) GetPropertyHasBidiLayouts() bool {
+	var v gobject.Value
+	x.GetProperty("has-bidi-layouts", &v)
+	return v.GetBoolean()
+}
+
+// Whether the device is represented by a cursor on the screen.
+
+func (x *Device) SetPropertyHasCursor(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-cursor", &v)
+}
+
+func (x *Device) GetPropertyHasCursor() bool {
+	var v gobject.Value
+	x.GetProperty("has-cursor", &v)
+	return v.GetBoolean()
+}
+
+// The current modifier state of the device.
+//
+// This is only relevant for keyboard devices.
+
+func (x *Device) GetPropertyModifierState() ModifierType {
+	var v gobject.Value
+	x.GetProperty("modifier-state", &v)
+	return ModifierType(v.GetFlags())
+}
+
+// Number of axes in the device.
+
+func (x *Device) GetPropertyNAxes() uint {
+	var v gobject.Value
+	x.GetProperty("n-axes", &v)
+	return v.GetUint()
+}
+
+// The device name.
+
+func (x *Device) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *Device) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// Whether Num Lock is on.
+//
+// This is only relevant for keyboard devices.
+
+func (x *Device) GetPropertyNumLockState() bool {
+	var v gobject.Value
+	x.GetProperty("num-lock-state", &v)
+	return v.GetBoolean()
+}
+
+// The maximal number of concurrent touches on a touch device.
+//
+// Will be 0 if the device is not a touch device or if the number
+// of touches is unknown.
+
+func (x *Device) SetPropertyNumTouches(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("num-touches", &v)
+}
+
+func (x *Device) GetPropertyNumTouches() uint {
+	var v gobject.Value
+	x.GetProperty("num-touches", &v)
+	return v.GetUint()
+}
+
+// Product ID of this device.
+//
+// See [method@Gdk.Device.get_product_id].
+
+func (x *Device) SetPropertyProductId(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("product-id", &v)
+}
+
+func (x *Device) GetPropertyProductId() string {
+	var v gobject.Value
+	x.GetProperty("product-id", &v)
+	return v.GetString()
+}
+
+// Whether Scroll Lock is on.
+//
+// This is only relevant for keyboard devices.
+
+func (x *Device) GetPropertyScrollLockState() bool {
+	var v gobject.Value
+	x.GetProperty("scroll-lock-state", &v)
+	return v.GetBoolean()
+}
+
+// `GdkSeat` of this device.
+
+func (x *Device) SetPropertySeat(value *Seat) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("seat", &v)
+}
+
+func (x *Device) GetPropertySeat() *Seat {
+	var v gobject.Value
+	x.GetProperty("seat", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Seat{}
+	result.Ptr = ptr
+	return result
+}
+
+// Source type for the device.
+
+func (x *Device) SetPropertySource(value InputSource) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("source", &v)
+}
+
+func (x *Device) GetPropertySource() InputSource {
+	var v gobject.Value
+	x.GetProperty("source", &v)
+	return InputSource(v.GetEnum())
+}
+
+// The `GdkDeviceTool` that is currently used with this device.
+
+func (x *Device) GetPropertyTool() *DeviceTool {
+	var v gobject.Value
+	x.GetProperty("tool", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &DeviceTool{}
+	result.Ptr = ptr
+	return result
+}
+
+// Vendor ID of this device.
+//
+// See [method@Gdk.Device.get_vendor_id].
+
+func (x *Device) SetPropertyVendorId(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("vendor-id", &v)
+}
+
+func (x *Device) GetPropertyVendorId() string {
+	var v gobject.Value
+	x.GetProperty("vendor-id", &v)
+	return v.GetString()
+}
+
 // Emitted either when the number of either axes or keys changes.
 //
 // On X11 this will normally happen when the physical device
diff --git a/v4/gdk/gdkdevicetool.go b/v4/gdk/gdkdevicetool.go
index f8f06f8134282f9f3be3824117c11eab52d6f13a..e8d922c44f41206509ee1c44261407e803fe14c8 100644
--- a/v4/gdk/gdkdevicetool.go
+++ b/v4/gdk/gdkdevicetool.go
@@ -115,6 +115,66 @@ func (c *DeviceTool) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The axes of the tool.
+
+func (x *DeviceTool) SetPropertyAxes(value AxisFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("axes", &v)
+}
+
+func (x *DeviceTool) GetPropertyAxes() AxisFlags {
+	var v gobject.Value
+	x.GetProperty("axes", &v)
+	return AxisFlags(v.GetFlags())
+}
+
+// The hardware ID of the tool.
+
+func (x *DeviceTool) SetPropertyHardwareId(value uint64) {
+	var v gobject.Value
+	v.Init(gobject.TypeUint64Val)
+	v.SetUint64(value)
+	x.SetProperty("hardware-id", &v)
+}
+
+func (x *DeviceTool) GetPropertyHardwareId() uint64 {
+	var v gobject.Value
+	x.GetProperty("hardware-id", &v)
+	return v.GetUint64()
+}
+
+// The serial number of the tool.
+
+func (x *DeviceTool) SetPropertySerial(value uint64) {
+	var v gobject.Value
+	v.Init(gobject.TypeUint64Val)
+	v.SetUint64(value)
+	x.SetProperty("serial", &v)
+}
+
+func (x *DeviceTool) GetPropertySerial() uint64 {
+	var v gobject.Value
+	x.GetProperty("serial", &v)
+	return v.GetUint64()
+}
+
+// The type of the tool.
+
+func (x *DeviceTool) SetPropertyToolType(value DeviceToolType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("tool-type", &v)
+}
+
+func (x *DeviceTool) GetPropertyToolType() DeviceToolType {
+	var v gobject.Value
+	x.GetProperty("tool-type", &v)
+	return DeviceToolType(v.GetEnum())
+}
+
 func init() {
 
 	core.SetPackageName("GDK", "gtk4")
diff --git a/v4/gdk/gdkdisplay.go b/v4/gdk/gdkdisplay.go
index 19bc2299a749927572914a8404ba49c96b6c57b6..1a0281abdd954122a015765d761f17ae582f4cbd 100644
--- a/v4/gdk/gdkdisplay.go
+++ b/v4/gdk/gdkdisplay.go
@@ -485,6 +485,30 @@ func (c *Display) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// %TRUE if the display properly composites the alpha channel.
+
+func (x *Display) GetPropertyComposited() bool {
+	var v gobject.Value
+	x.GetProperty("composited", &v)
+	return v.GetBoolean()
+}
+
+// %TRUE if the display supports input shapes.
+
+func (x *Display) GetPropertyInputShapes() bool {
+	var v gobject.Value
+	x.GetProperty("input-shapes", &v)
+	return v.GetBoolean()
+}
+
+// %TRUE if the display supports an alpha channel.
+
+func (x *Display) GetPropertyRgba() bool {
+	var v gobject.Value
+	x.GetProperty("rgba", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when the connection to the windowing system for @display is closed.
 func (x *Display) ConnectClosed(cb *func(Display, bool)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gdk/gdkdisplaymanager.go b/v4/gdk/gdkdisplaymanager.go
index 6907d503fd3340382ae39eff5e3e23009aed64d0..8bdcffca768e25825e079fc9742811682775ff92 100644
--- a/v4/gdk/gdkdisplaymanager.go
+++ b/v4/gdk/gdkdisplaymanager.go
@@ -179,6 +179,27 @@ func (c *DisplayManager) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The default display.
+
+func (x *DisplayManager) SetPropertyDefaultDisplay(value *Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("default-display", &v)
+}
+
+func (x *DisplayManager) GetPropertyDefaultDisplay() *Display {
+	var v gobject.Value
+	x.GetProperty("default-display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Display{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emitted when a display is opened.
 func (x *DisplayManager) ConnectDisplayOpened(cb *func(DisplayManager, uintptr)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gdk/gdkdrag.go b/v4/gdk/gdkdrag.go
index 53f9f4380e9aae75f374a54e3f3d90625fbce07e..b44f7914cff8ff5fdcfd00b9b5e1b48d7afa12bc 100644
--- a/v4/gdk/gdkdrag.go
+++ b/v4/gdk/gdkdrag.go
@@ -229,6 +229,128 @@ func (c *Drag) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The possible actions of this drag.
+
+func (x *Drag) SetPropertyActions(value DragAction) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("actions", &v)
+}
+
+func (x *Drag) GetPropertyActions() DragAction {
+	var v gobject.Value
+	x.GetProperty("actions", &v)
+	return DragAction(v.GetFlags())
+}
+
+// The `GdkContentProvider`.
+
+func (x *Drag) SetPropertyContent(value *ContentProvider) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("content", &v)
+}
+
+func (x *Drag) GetPropertyContent() *ContentProvider {
+	var v gobject.Value
+	x.GetProperty("content", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ContentProvider{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GdkDevice` that is performing the drag.
+
+func (x *Drag) SetPropertyDevice(value *Device) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("device", &v)
+}
+
+func (x *Drag) GetPropertyDevice() *Device {
+	var v gobject.Value
+	x.GetProperty("device", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Device{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GdkDisplay` that the drag belongs to.
+
+func (x *Drag) GetPropertyDisplay() *Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Display{}
+	result.Ptr = ptr
+	return result
+}
+
+// The possible formats that the drag can provide its data in.
+
+func (x *Drag) SetPropertyFormats(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("formats", &v)
+}
+
+func (x *Drag) GetPropertyFormats() uintptr {
+	var v gobject.Value
+	x.GetProperty("formats", &v)
+	return v.GetPointer()
+}
+
+// The currently selected action of the drag.
+
+func (x *Drag) SetPropertySelectedAction(value DragAction) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("selected-action", &v)
+}
+
+func (x *Drag) GetPropertySelectedAction() DragAction {
+	var v gobject.Value
+	x.GetProperty("selected-action", &v)
+	return DragAction(v.GetFlags())
+}
+
+// The surface where the drag originates.
+
+func (x *Drag) SetPropertySurface(value *Surface) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("surface", &v)
+}
+
+func (x *Drag) GetPropertySurface() *Surface {
+	var v gobject.Value
+	x.GetProperty("surface", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Surface{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emitted when the drag operation is cancelled.
 func (x *Drag) ConnectCancel(cb *func(Drag, DragCancelReason)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gdk/gdkdrawcontext.go b/v4/gdk/gdkdrawcontext.go
index 42f216ad0fdb08d9ac60b6671f1d1eae51fff0b0..aeecac04a0d3dad81d2f3c3cad1da7ed914ef772 100644
--- a/v4/gdk/gdkdrawcontext.go
+++ b/v4/gdk/gdkdrawcontext.go
@@ -156,6 +156,48 @@ func (c *DrawContext) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GdkDisplay` used to create the `GdkDrawContext`.
+
+func (x *DrawContext) SetPropertyDisplay(value *Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *DrawContext) GetPropertyDisplay() *Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Display{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GdkSurface` the context is bound to.
+
+func (x *DrawContext) SetPropertySurface(value *Surface) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("surface", &v)
+}
+
+func (x *DrawContext) GetPropertySurface() *Surface {
+	var v gobject.Value
+	x.GetProperty("surface", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Surface{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GDK", "gtk4")
diff --git a/v4/gdk/gdkdrop.go b/v4/gdk/gdkdrop.go
index bb58f3b51305ae605dc78468602bc62a77fdd0d6..af46fcd84dd4726aee22d4f018ef1254de2dc967 100644
--- a/v4/gdk/gdkdrop.go
+++ b/v4/gdk/gdkdrop.go
@@ -259,6 +259,113 @@ func (c *Drop) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The possible actions for this drop
+
+func (x *Drop) SetPropertyActions(value DragAction) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("actions", &v)
+}
+
+func (x *Drop) GetPropertyActions() DragAction {
+	var v gobject.Value
+	x.GetProperty("actions", &v)
+	return DragAction(v.GetFlags())
+}
+
+// The `GdkDevice` performing the drop
+
+func (x *Drop) SetPropertyDevice(value *Device) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("device", &v)
+}
+
+func (x *Drop) GetPropertyDevice() *Device {
+	var v gobject.Value
+	x.GetProperty("device", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Device{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GdkDisplay` that the drop belongs to.
+
+func (x *Drop) GetPropertyDisplay() *Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Display{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GdkDrag` that initiated this drop
+
+func (x *Drop) SetPropertyDrag(value *Drag) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("drag", &v)
+}
+
+func (x *Drop) GetPropertyDrag() *Drag {
+	var v gobject.Value
+	x.GetProperty("drag", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Drag{}
+	result.Ptr = ptr
+	return result
+}
+
+// The possible formats that the drop can provide its data in.
+
+func (x *Drop) SetPropertyFormats(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("formats", &v)
+}
+
+func (x *Drop) GetPropertyFormats() uintptr {
+	var v gobject.Value
+	x.GetProperty("formats", &v)
+	return v.GetPointer()
+}
+
+// The `GdkSurface` the drop happens on
+
+func (x *Drop) SetPropertySurface(value *Surface) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("surface", &v)
+}
+
+func (x *Drop) GetPropertySurface() *Surface {
+	var v gobject.Value
+	x.GetProperty("surface", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Surface{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GDK", "gtk4")
diff --git a/v4/gdk/gdkglcontext.go b/v4/gdk/gdkglcontext.go
index 6cf160e7541be65c8885c959a8affa87c2deb330..80ab8158e81fa70f83a4338e5edad4a8425bc491 100644
--- a/v4/gdk/gdkglcontext.go
+++ b/v4/gdk/gdkglcontext.go
@@ -389,6 +389,53 @@ func (c *GLContext) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The allowed APIs.
+
+func (x *GLContext) SetPropertyAllowedApis(value GLAPI) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("allowed-apis", &v)
+}
+
+func (x *GLContext) GetPropertyAllowedApis() GLAPI {
+	var v gobject.Value
+	x.GetProperty("allowed-apis", &v)
+	return GLAPI(v.GetFlags())
+}
+
+// The API currently in use.
+
+func (x *GLContext) GetPropertyApi() GLAPI {
+	var v gobject.Value
+	x.GetProperty("api", &v)
+	return GLAPI(v.GetFlags())
+}
+
+// Always %NULL
+//
+// As many contexts can share data now and no single shared context exists
+// anymore, this function has been deprecated and now always returns %NULL.
+
+func (x *GLContext) SetPropertySharedContext(value *GLContext) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("shared-context", &v)
+}
+
+func (x *GLContext) GetPropertySharedContext() *GLContext {
+	var v gobject.Value
+	x.GetProperty("shared-context", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &GLContext{}
+	result.Ptr = ptr
+	return result
+}
+
 var xGLContextClearCurrent func()
 
 // Clears the current `GdkGLContext`.
diff --git a/v4/gdk/gdkmonitor.go b/v4/gdk/gdkmonitor.go
index 26c462ea9832a83023822657f559562e6de8a819..c6a0dc488cf6fdb7cc5d93c3e0d9c6214adbaf06 100644
--- a/v4/gdk/gdkmonitor.go
+++ b/v4/gdk/gdkmonitor.go
@@ -213,6 +213,107 @@ func (c *Monitor) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The connector name.
+
+func (x *Monitor) GetPropertyConnector() string {
+	var v gobject.Value
+	x.GetProperty("connector", &v)
+	return v.GetString()
+}
+
+// The `GdkDisplay` of the monitor.
+
+func (x *Monitor) SetPropertyDisplay(value *Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *Monitor) GetPropertyDisplay() *Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Display{}
+	result.Ptr = ptr
+	return result
+}
+
+// The geometry of the monitor.
+
+func (x *Monitor) GetPropertyGeometry() uintptr {
+	var v gobject.Value
+	x.GetProperty("geometry", &v)
+	return v.GetPointer()
+}
+
+// The height of the monitor, in millimeters.
+
+func (x *Monitor) GetPropertyHeightMm() int {
+	var v gobject.Value
+	x.GetProperty("height-mm", &v)
+	return v.GetInt()
+}
+
+// The manufacturer name.
+
+func (x *Monitor) GetPropertyManufacturer() string {
+	var v gobject.Value
+	x.GetProperty("manufacturer", &v)
+	return v.GetString()
+}
+
+// The model name.
+
+func (x *Monitor) GetPropertyModel() string {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	return v.GetString()
+}
+
+// The refresh rate, in milli-Hertz.
+
+func (x *Monitor) GetPropertyRefreshRate() int {
+	var v gobject.Value
+	x.GetProperty("refresh-rate", &v)
+	return v.GetInt()
+}
+
+// The scale factor.
+
+func (x *Monitor) GetPropertyScaleFactor() int {
+	var v gobject.Value
+	x.GetProperty("scale-factor", &v)
+	return v.GetInt()
+}
+
+// The subpixel layout.
+
+func (x *Monitor) GetPropertySubpixelLayout() SubpixelLayout {
+	var v gobject.Value
+	x.GetProperty("subpixel-layout", &v)
+	return SubpixelLayout(v.GetEnum())
+}
+
+// Whether the object is still valid.
+
+func (x *Monitor) GetPropertyValid() bool {
+	var v gobject.Value
+	x.GetProperty("valid", &v)
+	return v.GetBoolean()
+}
+
+// The width of the monitor, in millimeters.
+
+func (x *Monitor) GetPropertyWidthMm() int {
+	var v gobject.Value
+	x.GetProperty("width-mm", &v)
+	return v.GetInt()
+}
+
 // Emitted when the output represented by @monitor gets disconnected.
 func (x *Monitor) ConnectInvalidate(cb *func(Monitor)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gdk/gdkpopup.go b/v4/gdk/gdkpopup.go
index e7e423e555c1db13da623b7cbd6eee6a6ae7c8a8..93035f1fc181945837cf6cfc3ca230e6f10fab83 100644
--- a/v4/gdk/gdkpopup.go
+++ b/v4/gdk/gdkpopup.go
@@ -136,6 +136,46 @@ 	cret := XGdkPopupPresent(x.GoPointer(), WidthVar, HeightVar, LayoutVar)
 	return cret
 }
 
+// Whether to hide on outside clicks.
+
+func (x *PopupBase) SetPropertyAutohide(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("autohide", &v)
+}
+
+func (x *PopupBase) GetPropertyAutohide() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("autohide", &v)
+	return v.GetBoolean()
+}
+
+// The parent surface.
+
+func (x *PopupBase) SetPropertyParent(value *Surface) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("parent", &v)
+}
+
+func (x *PopupBase) GetPropertyParent() *Surface {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("parent", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Surface{}
+	result.Ptr = ptr
+	return result
+}
+
 var XGdkPopupGetAutohide func(uintptr) bool
 var XGdkPopupGetParent func(uintptr) uintptr
 var XGdkPopupGetPositionX func(uintptr) int
diff --git a/v4/gdk/gdkseat.go b/v4/gdk/gdkseat.go
index 128ec4e82070231710c03eda531d5ad8bf275230..fda918b729b245a000e1728dcfa57915aa6b5553 100644
--- a/v4/gdk/gdkseat.go
+++ b/v4/gdk/gdkseat.go
@@ -147,6 +147,27 @@ func (c *Seat) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// `GdkDisplay` of this seat.
+
+func (x *Seat) SetPropertyDisplay(value *Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *Seat) GetPropertyDisplay() *Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Display{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emitted when a new input device is related to this seat.
 func (x *Seat) ConnectDeviceAdded(cb *func(Seat, uintptr)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gdk/gdksurface.go b/v4/gdk/gdksurface.go
index d91ed6d0d937fdc0fa970c90d0d0ea6fc501dd2f..2e77b511d12b76b1a6c9594480fd3209e8c9fe49 100644
--- a/v4/gdk/gdksurface.go
+++ b/v4/gdk/gdksurface.go
@@ -494,6 +494,101 @@ func (c *Surface) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The mouse pointer for the `GdkSurface`.
+
+func (x *Surface) SetPropertyCursor(value *Cursor) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("cursor", &v)
+}
+
+func (x *Surface) GetPropertyCursor() *Cursor {
+	var v gobject.Value
+	x.GetProperty("cursor", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Cursor{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GdkDisplay` connection of the surface.
+
+func (x *Surface) SetPropertyDisplay(value *Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *Surface) GetPropertyDisplay() *Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Display{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GdkFrameClock` of the surface.
+
+func (x *Surface) SetPropertyFrameClock(value *FrameClock) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("frame-clock", &v)
+}
+
+func (x *Surface) GetPropertyFrameClock() *FrameClock {
+	var v gobject.Value
+	x.GetProperty("frame-clock", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &FrameClock{}
+	result.Ptr = ptr
+	return result
+}
+
+// The height of the surface, in pixels.
+
+func (x *Surface) GetPropertyHeight() int {
+	var v gobject.Value
+	x.GetProperty("height", &v)
+	return v.GetInt()
+}
+
+// Whether the surface is mapped.
+
+func (x *Surface) GetPropertyMapped() bool {
+	var v gobject.Value
+	x.GetProperty("mapped", &v)
+	return v.GetBoolean()
+}
+
+// The scale factor of the surface.
+
+func (x *Surface) GetPropertyScaleFactor() int {
+	var v gobject.Value
+	x.GetProperty("scale-factor", &v)
+	return v.GetInt()
+}
+
+// The width of the surface in pixels.
+
+func (x *Surface) GetPropertyWidth() int {
+	var v gobject.Value
+	x.GetProperty("width", &v)
+	return v.GetInt()
+}
+
 // Emitted when @surface starts being present on the monitor.
 func (x *Surface) ConnectEnterMonitor(cb *func(Surface, uintptr)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gdk/gdktexture.go b/v4/gdk/gdktexture.go
index 1a620554e4062456d5e650718024c85cf779bd98..6ea1e010f79a69e5a01e192ff8fa6b7326966c5c 100644
--- a/v4/gdk/gdktexture.go
+++ b/v4/gdk/gdktexture.go
@@ -340,6 +340,36 @@ func (c *Texture) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The height of the texture, in pixels.
+
+func (x *Texture) SetPropertyHeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("height", &v)
+}
+
+func (x *Texture) GetPropertyHeight() int {
+	var v gobject.Value
+	x.GetProperty("height", &v)
+	return v.GetInt()
+}
+
+// The width of the texture, in pixels.
+
+func (x *Texture) SetPropertyWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("width", &v)
+}
+
+func (x *Texture) GetPropertyWidth() int {
+	var v gobject.Value
+	x.GetProperty("width", &v)
+	return v.GetInt()
+}
+
 // Compute a concrete size for the `GdkPaintable`.
 //
 // Applies the sizing algorithm outlined in the
diff --git a/v4/gdk/gdktoplevel.go b/v4/gdk/gdktoplevel.go
index f5d24628587d06b1de592660ac8b6cb261700325..31a1ca8e1319ca51f2a4a1a1954c4403051e6238 100644
--- a/v4/gdk/gdktoplevel.go
+++ b/v4/gdk/gdktoplevel.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -288,6 +289,169 @@ func (x *ToplevelBase) TitlebarGesture(GestureVar TitlebarGesture) bool {
 
 	cret := XGdkToplevelTitlebarGesture(x.GoPointer(), GestureVar)
 	return cret
+}
+
+// Whether the window manager should add decorations.
+
+func (x *ToplevelBase) SetPropertyDecorated(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("decorated", &v)
+}
+
+func (x *ToplevelBase) GetPropertyDecorated() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("decorated", &v)
+	return v.GetBoolean()
+}
+
+// Whether the window manager should allow to close the surface.
+
+func (x *ToplevelBase) SetPropertyDeletable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("deletable", &v)
+}
+
+func (x *ToplevelBase) GetPropertyDeletable() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("deletable", &v)
+	return v.GetBoolean()
+}
+
+// The fullscreen mode of the surface.
+
+func (x *ToplevelBase) SetPropertyFullscreenMode(value FullscreenMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("fullscreen-mode", &v)
+}
+
+func (x *ToplevelBase) GetPropertyFullscreenMode() FullscreenMode {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("fullscreen-mode", &v)
+	return FullscreenMode(v.GetEnum())
+}
+
+// A list of textures to use as icon.
+
+func (x *ToplevelBase) SetPropertyIconList(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("icon-list", &v)
+}
+
+func (x *ToplevelBase) GetPropertyIconList() uintptr {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("icon-list", &v)
+	return v.GetPointer()
+}
+
+// Whether the surface is modal.
+
+func (x *ToplevelBase) SetPropertyModal(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("modal", &v)
+}
+
+func (x *ToplevelBase) GetPropertyModal() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("modal", &v)
+	return v.GetBoolean()
+}
+
+// Whether the surface should inhibit keyboard shortcuts.
+
+func (x *ToplevelBase) GetPropertyShortcutsInhibited() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("shortcuts-inhibited", &v)
+	return v.GetBoolean()
+}
+
+// The startup ID of the surface.
+//
+// See [class@Gdk.AppLaunchContext] for more information about
+// startup feedback.
+
+func (x *ToplevelBase) SetPropertyStartupId(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("startup-id", &v)
+}
+
+func (x *ToplevelBase) GetPropertyStartupId() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("startup-id", &v)
+	return v.GetString()
+}
+
+// The state of the toplevel.
+
+func (x *ToplevelBase) GetPropertyState() ToplevelState {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("state", &v)
+	return ToplevelState(v.GetFlags())
+}
+
+// The title of the surface.
+
+func (x *ToplevelBase) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("title", &v)
+}
+
+func (x *ToplevelBase) GetPropertyTitle() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// The transient parent of the surface.
+
+func (x *ToplevelBase) SetPropertyTransientFor(value *Surface) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("transient-for", &v)
+}
+
+func (x *ToplevelBase) GetPropertyTransientFor() *Surface {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("transient-for", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Surface{}
+	result.Ptr = ptr
+	return result
 }
 
 var XGdkToplevelBeginMove func(uintptr, uintptr, int, float64, float64, uint32)
diff --git a/v4/gdkpixbuf/gdk-pixbuf-simple-anim.go b/v4/gdkpixbuf/gdk-pixbuf-simple-anim.go
index f2151c2bb6cb65d44631f9e0816a960751302e4f..e60980bcfc1209ec100d20503bec730b654b196d 100644
--- a/v4/gdkpixbuf/gdk-pixbuf-simple-anim.go
+++ b/v4/gdkpixbuf/gdk-pixbuf-simple-anim.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -89,6 +90,21 @@ }
 
 func (c *PixbufSimpleAnim) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Whether the animation should loop when it reaches the end.
+
+func (x *PixbufSimpleAnim) SetPropertyLoop(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("loop", &v)
+}
+
+func (x *PixbufSimpleAnim) GetPropertyLoop() bool {
+	var v gobject.Value
+	x.GetProperty("loop", &v)
+	return v.GetBoolean()
 }
 
 func init() {
diff --git a/v4/gdkpixbuf/gdk-pixbuf.go b/v4/gdkpixbuf/gdk-pixbuf.go
index 836a3ec72c68084d719d9cfa2822a8cd63422c71..88474ce6e1872354e74e58b65c568bcdd2b1e4a2 100644
--- a/v4/gdkpixbuf/gdk-pixbuf.go
+++ b/v4/gdkpixbuf/gdk-pixbuf.go
@@ -1350,6 +1350,149 @@ func (c *Pixbuf) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The number of bits per sample.
+//
+// Currently only 8 bit per sample are supported.
+
+func (x *Pixbuf) SetPropertyBitsPerSample(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("bits-per-sample", &v)
+}
+
+func (x *Pixbuf) GetPropertyBitsPerSample() int {
+	var v gobject.Value
+	x.GetProperty("bits-per-sample", &v)
+	return v.GetInt()
+}
+
+// The color space of the pixbuf.
+//
+// Currently, only `GDK_COLORSPACE_RGB` is supported.
+
+func (x *Pixbuf) SetPropertyColorspace(value Colorspace) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("colorspace", &v)
+}
+
+func (x *Pixbuf) GetPropertyColorspace() Colorspace {
+	var v gobject.Value
+	x.GetProperty("colorspace", &v)
+	return Colorspace(v.GetEnum())
+}
+
+// Whether the pixbuf has an alpha channel.
+
+func (x *Pixbuf) SetPropertyHasAlpha(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-alpha", &v)
+}
+
+func (x *Pixbuf) GetPropertyHasAlpha() bool {
+	var v gobject.Value
+	x.GetProperty("has-alpha", &v)
+	return v.GetBoolean()
+}
+
+// The number of rows of the pixbuf.
+
+func (x *Pixbuf) SetPropertyHeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("height", &v)
+}
+
+func (x *Pixbuf) GetPropertyHeight() int {
+	var v gobject.Value
+	x.GetProperty("height", &v)
+	return v.GetInt()
+}
+
+// The number of samples per pixel.
+//
+// Currently, only 3 or 4 samples per pixel are supported.
+
+func (x *Pixbuf) SetPropertyNChannels(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("n-channels", &v)
+}
+
+func (x *Pixbuf) GetPropertyNChannels() int {
+	var v gobject.Value
+	x.GetProperty("n-channels", &v)
+	return v.GetInt()
+}
+
+func (x *Pixbuf) SetPropertyPixelBytes(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("pixel-bytes", &v)
+}
+
+func (x *Pixbuf) GetPropertyPixelBytes() uintptr {
+	var v gobject.Value
+	x.GetProperty("pixel-bytes", &v)
+	return v.GetPointer()
+}
+
+// A pointer to the pixel data of the pixbuf.
+
+func (x *Pixbuf) SetPropertyPixels(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("pixels", &v)
+}
+
+func (x *Pixbuf) GetPropertyPixels() uintptr {
+	var v gobject.Value
+	x.GetProperty("pixels", &v)
+	return v.GetPointer()
+}
+
+// The number of bytes between the start of a row and
+// the start of the next row.
+//
+// This number must (obviously) be at least as large as the
+// width of the pixbuf.
+
+func (x *Pixbuf) SetPropertyRowstride(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("rowstride", &v)
+}
+
+func (x *Pixbuf) GetPropertyRowstride() int {
+	var v gobject.Value
+	x.GetProperty("rowstride", &v)
+	return v.GetInt()
+}
+
+// The number of columns of the pixbuf.
+
+func (x *Pixbuf) SetPropertyWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("width", &v)
+}
+
+func (x *Pixbuf) GetPropertyWidth() int {
+	var v gobject.Value
+	x.GetProperty("width", &v)
+	return v.GetInt()
+}
+
 // Checks if two icons are equal.
 func (x *Pixbuf) Equal(Icon2Var gio.Icon) bool {
 
diff --git a/v4/gio/gaction.go b/v4/gio/gaction.go
index 69f0e430324ed648592ffd49c53911ecab975cf2..de8c0ca398b18819e6d55e9793dfd2758ca8ff23 100644
--- a/v4/gio/gaction.go
+++ b/v4/gio/gaction.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -399,6 +400,58 @@ func (x *ActionBase) GetStateType() *glib.VariantType {
 
 	cret := XGActionGetStateType(x.GoPointer())
 	return cret
+}
+
+// If @action is currently enabled.
+//
+// If the action is disabled then calls to g_action_activate() and
+// g_action_change_state() have no effect.
+
+func (x *ActionBase) GetPropertyEnabled() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("enabled", &v)
+	return v.GetBoolean()
+}
+
+// The name of the action.  This is mostly meaningful for identifying
+// the action once it has been added to a #GActionGroup. It is immutable.
+
+func (x *ActionBase) GetPropertyName() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// The type of the parameter that must be given when activating the
+// action. This is immutable, and may be %NULL if no parameter is needed when
+// activating the action.
+
+func (x *ActionBase) GetPropertyParameterType() uintptr {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("parameter-type", &v)
+	return v.GetPointer()
+}
+
+// The state of the action, or %NULL if the action is stateless.
+
+func (x *ActionBase) GetPropertyState() uintptr {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("state", &v)
+	return v.GetPointer()
+}
+
+// The #GVariantType of the state that the action has, or %NULL if the
+// action is stateless. This is immutable.
+
+func (x *ActionBase) GetPropertyStateType() uintptr {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("state-type", &v)
+	return v.GetPointer()
 }
 
 var XGActionActivate func(uintptr, *glib.Variant)
diff --git a/v4/gio/gapplication.go b/v4/gio/gapplication.go
index e1acfad254ab2082bfaa364b300c8dc52dc576a0..0f984b3c007ae20bddb0c44ba5091107c60bebd9 100644
--- a/v4/gio/gapplication.go
+++ b/v4/gio/gapplication.go
@@ -1294,6 +1294,86 @@ func (c *Application) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *Application) SetPropertyActionGroup(value ActionGroup) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("action-group", &v)
+}
+
+func (x *Application) SetPropertyApplicationId(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("application-id", &v)
+}
+
+func (x *Application) GetPropertyApplicationId() string {
+	var v gobject.Value
+	x.GetProperty("application-id", &v)
+	return v.GetString()
+}
+
+func (x *Application) SetPropertyFlags(value ApplicationFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("flags", &v)
+}
+
+func (x *Application) GetPropertyFlags() ApplicationFlags {
+	var v gobject.Value
+	x.GetProperty("flags", &v)
+	return ApplicationFlags(v.GetFlags())
+}
+
+func (x *Application) SetPropertyInactivityTimeout(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("inactivity-timeout", &v)
+}
+
+func (x *Application) GetPropertyInactivityTimeout() uint {
+	var v gobject.Value
+	x.GetProperty("inactivity-timeout", &v)
+	return v.GetUint()
+}
+
+// Whether the application is currently marked as busy through
+// g_application_mark_busy() or g_application_bind_busy_property().
+
+func (x *Application) GetPropertyIsBusy() bool {
+	var v gobject.Value
+	x.GetProperty("is-busy", &v)
+	return v.GetBoolean()
+}
+
+func (x *Application) GetPropertyIsRegistered() bool {
+	var v gobject.Value
+	x.GetProperty("is-registered", &v)
+	return v.GetBoolean()
+}
+
+func (x *Application) GetPropertyIsRemote() bool {
+	var v gobject.Value
+	x.GetProperty("is-remote", &v)
+	return v.GetBoolean()
+}
+
+func (x *Application) SetPropertyResourceBasePath(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("resource-base-path", &v)
+}
+
+func (x *Application) GetPropertyResourceBasePath() string {
+	var v gobject.Value
+	x.GetProperty("resource-base-path", &v)
+	return v.GetString()
+}
+
 // The ::activate signal is emitted on the primary instance when an
 // activation occurs. See g_application_activate().
 func (x *Application) ConnectActivate(cb *func(Application)) uint32 {
diff --git a/v4/gio/gapplicationcommandline.go b/v4/gio/gapplicationcommandline.go
index 1159b7b49e0328a54b9fd516e3acea2e60ba75fe..be895f3e160cf465f8ddfd3224ce523e4917cbb2 100644
--- a/v4/gio/gapplicationcommandline.go
+++ b/v4/gio/gapplicationcommandline.go
@@ -549,6 +549,33 @@ func (c *ApplicationCommandLine) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *ApplicationCommandLine) SetPropertyArguments(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("arguments", &v)
+}
+
+func (x *ApplicationCommandLine) GetPropertyIsRemote() bool {
+	var v gobject.Value
+	x.GetProperty("is-remote", &v)
+	return v.GetBoolean()
+}
+
+func (x *ApplicationCommandLine) SetPropertyOptions(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("options", &v)
+}
+
+func (x *ApplicationCommandLine) SetPropertyPlatformData(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("platform-data", &v)
+}
+
 func init() {
 
 	core.SetPackageName("GIO", "gio-2.0")
diff --git a/v4/gio/gbufferedinputstream.go b/v4/gio/gbufferedinputstream.go
index 0cb834d3a040e4cfd9603eb9b539e3bdf45c5aee..74c61a89084c748e7fb2a7860174cef659fdacd2 100644
--- a/v4/gio/gbufferedinputstream.go
+++ b/v4/gio/gbufferedinputstream.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -443,6 +444,19 @@ }
 
 func (c *BufferedInputStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+func (x *BufferedInputStream) SetPropertyBufferSize(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("buffer-size", &v)
+}
+
+func (x *BufferedInputStream) GetPropertyBufferSize() uint {
+	var v gobject.Value
+	x.GetProperty("buffer-size", &v)
+	return v.GetUint()
 }
 
 // Tests if the stream supports the #GSeekableIface.
diff --git a/v4/gio/gbufferedoutputstream.go b/v4/gio/gbufferedoutputstream.go
index 9a002e26101432136a426ce60cdcf521a86dfc62..63c881b8cee4853839377c47c610008a16fda56d 100644
--- a/v4/gio/gbufferedoutputstream.go
+++ b/v4/gio/gbufferedoutputstream.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -189,6 +190,32 @@ }
 
 func (c *BufferedOutputStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+func (x *BufferedOutputStream) SetPropertyAutoGrow(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("auto-grow", &v)
+}
+
+func (x *BufferedOutputStream) GetPropertyAutoGrow() bool {
+	var v gobject.Value
+	x.GetProperty("auto-grow", &v)
+	return v.GetBoolean()
+}
+
+func (x *BufferedOutputStream) SetPropertyBufferSize(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("buffer-size", &v)
+}
+
+func (x *BufferedOutputStream) GetPropertyBufferSize() uint {
+	var v gobject.Value
+	x.GetProperty("buffer-size", &v)
+	return v.GetUint()
 }
 
 // Tests if the stream supports the #GSeekableIface.
diff --git a/v4/gio/gcharsetconverter.go b/v4/gio/gcharsetconverter.go
index 689ec90cef7c89a1fcd2f984008b00e13e67e2cb..e99ce89d6e908c926df99a6ceb49a6e7ad38918d 100644
--- a/v4/gio/gcharsetconverter.go
+++ b/v4/gio/gcharsetconverter.go
@@ -99,6 +99,45 @@ func (c *CharsetConverter) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *CharsetConverter) SetPropertyFromCharset(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("from-charset", &v)
+}
+
+func (x *CharsetConverter) GetPropertyFromCharset() string {
+	var v gobject.Value
+	x.GetProperty("from-charset", &v)
+	return v.GetString()
+}
+
+func (x *CharsetConverter) SetPropertyToCharset(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("to-charset", &v)
+}
+
+func (x *CharsetConverter) GetPropertyToCharset() string {
+	var v gobject.Value
+	x.GetProperty("to-charset", &v)
+	return v.GetString()
+}
+
+func (x *CharsetConverter) SetPropertyUseFallback(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-fallback", &v)
+}
+
+func (x *CharsetConverter) GetPropertyUseFallback() bool {
+	var v gobject.Value
+	x.GetProperty("use-fallback", &v)
+	return v.GetBoolean()
+}
+
 // This is the main operation used when converting data. It is to be called
 // multiple times in a loop, and each time it will do some work, i.e.
 // producing some output (in @outbuf) or consuming some input (from @inbuf) or
diff --git a/v4/gio/gconverterinputstream.go b/v4/gio/gconverterinputstream.go
index e50838805091cf769efcc27e028c2a699d69da44..d1b68d1c69885ee98a7c13946178dc914b033c6f 100644
--- a/v4/gio/gconverterinputstream.go
+++ b/v4/gio/gconverterinputstream.go
@@ -220,6 +220,25 @@ func (c *ConverterInputStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *ConverterInputStream) SetPropertyConverter(value Converter) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("converter", &v)
+}
+
+func (x *ConverterInputStream) GetPropertyConverter() Converter {
+	var v gobject.Value
+	x.GetProperty("converter", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ConverterBase{}
+	result.Ptr = ptr
+	return result
+}
+
 // Checks if @stream is actually pollable. Some classes may implement
 // #GPollableInputStream but have only certain instances of that class
 // be pollable. If this method returns %FALSE, then the behavior of
diff --git a/v4/gio/gconverteroutputstream.go b/v4/gio/gconverteroutputstream.go
index 730dcbfaa4c2215dd5e360f08d4f9bb1e410697e..533aec341844d19eec00e52c829d51a337978074 100644
--- a/v4/gio/gconverteroutputstream.go
+++ b/v4/gio/gconverteroutputstream.go
@@ -220,6 +220,25 @@ func (c *ConverterOutputStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *ConverterOutputStream) SetPropertyConverter(value Converter) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("converter", &v)
+}
+
+func (x *ConverterOutputStream) GetPropertyConverter() Converter {
+	var v gobject.Value
+	x.GetProperty("converter", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ConverterBase{}
+	result.Ptr = ptr
+	return result
+}
+
 // Checks if @stream is actually pollable. Some classes may implement
 // #GPollableOutputStream but have only certain instances of that
 // class be pollable. If this method returns %FALSE, then the behavior
diff --git a/v4/gio/gdatainputstream.go b/v4/gio/gdatainputstream.go
index 338d94fd80030ca4869a480648e63e050440d4a3..bd802ccc71cb7a511f0aa39536bd0a22e7fc3cdc 100644
--- a/v4/gio/gdatainputstream.go
+++ b/v4/gio/gdatainputstream.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -584,6 +585,39 @@ }
 
 func (c *DataInputStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The :byte-order property determines the byte ordering that
+// is used when reading multi-byte entities (such as integers)
+// from the stream.
+
+func (x *DataInputStream) SetPropertyByteOrder(value DataStreamByteOrder) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("byte-order", &v)
+}
+
+func (x *DataInputStream) GetPropertyByteOrder() DataStreamByteOrder {
+	var v gobject.Value
+	x.GetProperty("byte-order", &v)
+	return DataStreamByteOrder(v.GetEnum())
+}
+
+// The :newline-type property determines what is considered
+// as a line ending when reading complete lines from the stream.
+
+func (x *DataInputStream) SetPropertyNewlineType(value DataStreamNewlineType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("newline-type", &v)
+}
+
+func (x *DataInputStream) GetPropertyNewlineType() DataStreamNewlineType {
+	var v gobject.Value
+	x.GetProperty("newline-type", &v)
+	return DataStreamNewlineType(v.GetEnum())
 }
 
 // Tests if the stream supports the #GSeekableIface.
diff --git a/v4/gio/gdataoutputstream.go b/v4/gio/gdataoutputstream.go
index 30959a72312e3e83c4f123a263dd900ebc3b01f6..c20c0487ea27ebd9dc65c1622f27b78afcf69f70 100644
--- a/v4/gio/gdataoutputstream.go
+++ b/v4/gio/gdataoutputstream.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -327,6 +328,22 @@ }
 
 func (c *DataOutputStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Determines the byte ordering that is used when writing
+// multi-byte entities (such as integers) to the stream.
+
+func (x *DataOutputStream) SetPropertyByteOrder(value DataStreamByteOrder) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("byte-order", &v)
+}
+
+func (x *DataOutputStream) GetPropertyByteOrder() DataStreamByteOrder {
+	var v gobject.Value
+	x.GetProperty("byte-order", &v)
+	return DataStreamByteOrder(v.GetEnum())
 }
 
 // Tests if the stream supports the #GSeekableIface.
diff --git a/v4/gio/gdbusinterfaceskeleton.go b/v4/gio/gdbusinterfaceskeleton.go
index 0b46d4dab765551ee4bd8e837520438ec0dc406f..62c04b39b190b64a195419383c79440e6fb02ec4 100644
--- a/v4/gio/gdbusinterfaceskeleton.go
+++ b/v4/gio/gdbusinterfaceskeleton.go
@@ -341,6 +341,21 @@ func (c *DBusInterfaceSkeleton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Flags from the #GDBusInterfaceSkeletonFlags enumeration.
+
+func (x *DBusInterfaceSkeleton) SetPropertyGFlags(value DBusInterfaceSkeletonFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("g-flags", &v)
+}
+
+func (x *DBusInterfaceSkeleton) GetPropertyGFlags() DBusInterfaceSkeletonFlags {
+	var v gobject.Value
+	x.GetProperty("g-flags", &v)
+	return DBusInterfaceSkeletonFlags(v.GetFlags())
+}
+
 // Emitted when a method is invoked by a remote caller and used to
 // determine if the method call is authorized.
 //
diff --git a/v4/gio/gdbusobjectmanagerclient.go b/v4/gio/gdbusobjectmanagerclient.go
index 874c6676d38be3eae3ed874fa1da7f5e5b94c667..200c3846f5cc1160eb3f5e47cc5ec9646622395f 100644
--- a/v4/gio/gdbusobjectmanagerclient.go
+++ b/v4/gio/gdbusobjectmanagerclient.go
@@ -326,6 +326,140 @@ func (c *DBusObjectManagerClient) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If this property is not %G_BUS_TYPE_NONE, then
+// #GDBusObjectManagerClient:connection must be %NULL and will be set to the
+// #GDBusConnection obtained by calling g_bus_get() with the value
+// of this property.
+
+func (x *DBusObjectManagerClient) SetPropertyBusType(value BusType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("bus-type", &v)
+}
+
+// The #GDBusConnection to use.
+
+func (x *DBusObjectManagerClient) SetPropertyConnection(value *DBusConnection) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("connection", &v)
+}
+
+func (x *DBusObjectManagerClient) GetPropertyConnection() *DBusConnection {
+	var v gobject.Value
+	x.GetProperty("connection", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &DBusConnection{}
+	result.Ptr = ptr
+	return result
+}
+
+// Flags from the #GDBusObjectManagerClientFlags enumeration.
+
+func (x *DBusObjectManagerClient) SetPropertyFlags(value DBusObjectManagerClientFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("flags", &v)
+}
+
+func (x *DBusObjectManagerClient) GetPropertyFlags() DBusObjectManagerClientFlags {
+	var v gobject.Value
+	x.GetProperty("flags", &v)
+	return DBusObjectManagerClientFlags(v.GetFlags())
+}
+
+// A #GDestroyNotify for the #gpointer user_data in #GDBusObjectManagerClient:get-proxy-type-user-data.
+
+func (x *DBusObjectManagerClient) SetPropertyGetProxyTypeDestroyNotify(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("get-proxy-type-destroy-notify", &v)
+}
+
+func (x *DBusObjectManagerClient) GetPropertyGetProxyTypeDestroyNotify() uintptr {
+	var v gobject.Value
+	x.GetProperty("get-proxy-type-destroy-notify", &v)
+	return v.GetPointer()
+}
+
+// The #GDBusProxyTypeFunc to use when determining what #GType to
+// use for interface proxies or %NULL.
+
+func (x *DBusObjectManagerClient) SetPropertyGetProxyTypeFunc(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("get-proxy-type-func", &v)
+}
+
+func (x *DBusObjectManagerClient) GetPropertyGetProxyTypeFunc() uintptr {
+	var v gobject.Value
+	x.GetProperty("get-proxy-type-func", &v)
+	return v.GetPointer()
+}
+
+// The #gpointer user_data to pass to #GDBusObjectManagerClient:get-proxy-type-func.
+
+func (x *DBusObjectManagerClient) SetPropertyGetProxyTypeUserData(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("get-proxy-type-user-data", &v)
+}
+
+func (x *DBusObjectManagerClient) GetPropertyGetProxyTypeUserData() uintptr {
+	var v gobject.Value
+	x.GetProperty("get-proxy-type-user-data", &v)
+	return v.GetPointer()
+}
+
+// The well-known name or unique name that the manager is for.
+
+func (x *DBusObjectManagerClient) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *DBusObjectManagerClient) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// The unique name that owns #GDBusObjectManagerClient:name or %NULL if
+// no-one is currently owning the name. Connect to the
+// #GObject::notify signal to track changes to this property.
+
+func (x *DBusObjectManagerClient) GetPropertyNameOwner() string {
+	var v gobject.Value
+	x.GetProperty("name-owner", &v)
+	return v.GetString()
+}
+
+// The object path the manager is for.
+
+func (x *DBusObjectManagerClient) SetPropertyObjectPath(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("object-path", &v)
+}
+
+func (x *DBusObjectManagerClient) GetPropertyObjectPath() string {
+	var v gobject.Value
+	x.GetProperty("object-path", &v)
+	return v.GetString()
+}
+
 // Emitted when one or more D-Bus properties on proxy changes. The
 // local cache has already been updated when this signal fires. Note
 // that both @changed_properties and @invalidated_properties are
diff --git a/v4/gio/gdbusobjectmanagerserver.go b/v4/gio/gdbusobjectmanagerserver.go
index 7bfd04a7574333a0997300dc8a955d02c6568841..9ab1ce58f6689279d73e711ccbe20a6a8ce6247b 100644
--- a/v4/gio/gdbusobjectmanagerserver.go
+++ b/v4/gio/gdbusobjectmanagerserver.go
@@ -182,6 +182,42 @@ func (c *DBusObjectManagerServer) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The #GDBusConnection to export objects on.
+
+func (x *DBusObjectManagerServer) SetPropertyConnection(value *DBusConnection) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("connection", &v)
+}
+
+func (x *DBusObjectManagerServer) GetPropertyConnection() *DBusConnection {
+	var v gobject.Value
+	x.GetProperty("connection", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &DBusConnection{}
+	result.Ptr = ptr
+	return result
+}
+
+// The object path to register the manager object at.
+
+func (x *DBusObjectManagerServer) SetPropertyObjectPath(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("object-path", &v)
+}
+
+func (x *DBusObjectManagerServer) GetPropertyObjectPath() string {
+	var v gobject.Value
+	x.GetProperty("object-path", &v)
+	return v.GetString()
+}
+
 // Gets the interface proxy for @interface_name at @object_path, if
 // any.
 func (x *DBusObjectManagerServer) GetInterface(ObjectPathVar string, InterfaceNameVar string) *DBusInterfaceBase {
diff --git a/v4/gio/gdbusobjectproxy.go b/v4/gio/gdbusobjectproxy.go
index 08691d8118f0f651e6259a888220a4136816db5b..cc17ce58fe4bfbcb4280c247603521e20374e38b 100644
--- a/v4/gio/gdbusobjectproxy.go
+++ b/v4/gio/gdbusobjectproxy.go
@@ -98,6 +98,42 @@ func (c *DBusObjectProxy) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The connection of the proxy.
+
+func (x *DBusObjectProxy) SetPropertyGConnection(value *DBusConnection) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("g-connection", &v)
+}
+
+func (x *DBusObjectProxy) GetPropertyGConnection() *DBusConnection {
+	var v gobject.Value
+	x.GetProperty("g-connection", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &DBusConnection{}
+	result.Ptr = ptr
+	return result
+}
+
+// The object path of the proxy.
+
+func (x *DBusObjectProxy) SetPropertyGObjectPath(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("g-object-path", &v)
+}
+
+func (x *DBusObjectProxy) GetPropertyGObjectPath() string {
+	var v gobject.Value
+	x.GetProperty("g-object-path", &v)
+	return v.GetString()
+}
+
 // Gets the D-Bus interface with name @interface_name associated with
 // @object, if any.
 func (x *DBusObjectProxy) GetInterface(InterfaceNameVar string) *DBusInterfaceBase {
diff --git a/v4/gio/gdbusobjectskeleton.go b/v4/gio/gdbusobjectskeleton.go
index 4c144951577860d1120bfee2ff38ab77cb3b7372..b0b67ec3010024a0d5fc97d1c2df2acdaf4485d6 100644
--- a/v4/gio/gdbusobjectskeleton.go
+++ b/v4/gio/gdbusobjectskeleton.go
@@ -162,6 +162,21 @@ func (c *DBusObjectSkeleton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The object path where the object is exported.
+
+func (x *DBusObjectSkeleton) SetPropertyGObjectPath(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("g-object-path", &v)
+}
+
+func (x *DBusObjectSkeleton) GetPropertyGObjectPath() string {
+	var v gobject.Value
+	x.GetProperty("g-object-path", &v)
+	return v.GetString()
+}
+
 // Emitted when a method is invoked by a remote caller and used to
 // determine if the method call is authorized.
 //
diff --git a/v4/gio/gdbusproxy.go b/v4/gio/gdbusproxy.go
index ce8a185475584a140c610f22edd7f20b2b656819..170b1c8e93f5c202370d6371efc835a75d9f6c27 100644
--- a/v4/gio/gdbusproxy.go
+++ b/v4/gio/gdbusproxy.go
@@ -600,6 +600,169 @@ func (c *DBusProxy) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If this property is not %G_BUS_TYPE_NONE, then
+// #GDBusProxy:g-connection must be %NULL and will be set to the
+// #GDBusConnection obtained by calling g_bus_get() with the value
+// of this property.
+
+func (x *DBusProxy) SetPropertyGBusType(value BusType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("g-bus-type", &v)
+}
+
+// The #GDBusConnection the proxy is for.
+
+func (x *DBusProxy) SetPropertyGConnection(value *DBusConnection) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("g-connection", &v)
+}
+
+func (x *DBusProxy) GetPropertyGConnection() *DBusConnection {
+	var v gobject.Value
+	x.GetProperty("g-connection", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &DBusConnection{}
+	result.Ptr = ptr
+	return result
+}
+
+// The timeout to use if -1 (specifying default timeout) is passed
+// as @timeout_msec in the g_dbus_proxy_call() and
+// g_dbus_proxy_call_sync() functions.
+//
+// This allows applications to set a proxy-wide timeout for all
+// remote method invocations on the proxy. If this property is -1,
+// the default timeout (typically 25 seconds) is used. If set to
+// %G_MAXINT, then no timeout is used.
+
+func (x *DBusProxy) SetPropertyGDefaultTimeout(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("g-default-timeout", &v)
+}
+
+func (x *DBusProxy) GetPropertyGDefaultTimeout() int {
+	var v gobject.Value
+	x.GetProperty("g-default-timeout", &v)
+	return v.GetInt()
+}
+
+// Flags from the #GDBusProxyFlags enumeration.
+
+func (x *DBusProxy) SetPropertyGFlags(value DBusProxyFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("g-flags", &v)
+}
+
+func (x *DBusProxy) GetPropertyGFlags() DBusProxyFlags {
+	var v gobject.Value
+	x.GetProperty("g-flags", &v)
+	return DBusProxyFlags(v.GetFlags())
+}
+
+// Ensure that interactions with this proxy conform to the given
+// interface. This is mainly to ensure that malformed data received
+// from the other peer is ignored. The given #GDBusInterfaceInfo is
+// said to be the "expected interface".
+//
+// The checks performed are:
+// - When completing a method call, if the type signature of
+//   the reply message isn't what's expected, the reply is
+//   discarded and the #GError is set to %G_IO_ERROR_INVALID_ARGUMENT.
+//
+// - Received signals that have a type signature mismatch are dropped and
+//   a warning is logged via g_warning().
+//
+// - Properties received via the initial `GetAll()` call or via the
+//   `::PropertiesChanged` signal (on the
+//   [org.freedesktop.DBus.Properties](http://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces-properties)
+//   interface) or set using g_dbus_proxy_set_cached_property()
+//   with a type signature mismatch are ignored and a warning is
+//   logged via g_warning().
+//
+// Note that these checks are never done on methods, signals and
+// properties that are not referenced in the given
+// #GDBusInterfaceInfo, since extending a D-Bus interface on the
+// service-side is not considered an ABI break.
+
+func (x *DBusProxy) SetPropertyGInterfaceInfo(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("g-interface-info", &v)
+}
+
+func (x *DBusProxy) GetPropertyGInterfaceInfo() uintptr {
+	var v gobject.Value
+	x.GetProperty("g-interface-info", &v)
+	return v.GetPointer()
+}
+
+// The D-Bus interface name the proxy is for.
+
+func (x *DBusProxy) SetPropertyGInterfaceName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("g-interface-name", &v)
+}
+
+func (x *DBusProxy) GetPropertyGInterfaceName() string {
+	var v gobject.Value
+	x.GetProperty("g-interface-name", &v)
+	return v.GetString()
+}
+
+// The well-known or unique name that the proxy is for.
+
+func (x *DBusProxy) SetPropertyGName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("g-name", &v)
+}
+
+func (x *DBusProxy) GetPropertyGName() string {
+	var v gobject.Value
+	x.GetProperty("g-name", &v)
+	return v.GetString()
+}
+
+// The unique name that owns #GDBusProxy:g-name or %NULL if no-one
+// currently owns that name. You may connect to #GObject::notify signal to
+// track changes to this property.
+
+func (x *DBusProxy) GetPropertyGNameOwner() string {
+	var v gobject.Value
+	x.GetProperty("g-name-owner", &v)
+	return v.GetString()
+}
+
+// The object path the proxy is for.
+
+func (x *DBusProxy) SetPropertyGObjectPath(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("g-object-path", &v)
+}
+
+func (x *DBusProxy) GetPropertyGObjectPath() string {
+	var v gobject.Value
+	x.GetProperty("g-object-path", &v)
+	return v.GetString()
+}
+
 // Emitted when one or more D-Bus properties on @proxy changes. The
 // local cache has already been updated when this signal fires. Note
 // that both @changed_properties and @invalidated_properties are
diff --git a/v4/gio/gdebugcontroller.go b/v4/gio/gdebugcontroller.go
index 040eea27bc42458cfdce7f83ee02ae5e1928bb59..6980621449340ef89700ea49f97bb555e0d7863c 100644
--- a/v4/gio/gdebugcontroller.go
+++ b/v4/gio/gdebugcontroller.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -76,6 +77,24 @@ func (x *DebugControllerBase) SetDebugEnabled(DebugEnabledVar bool) {
 
 	XGDebugControllerSetDebugEnabled(x.GoPointer(), DebugEnabledVar)
 
+}
+
+// %TRUE if debug output should be exposed (for example by forwarding it to
+// the journal), %FALSE otherwise.
+
+func (x *DebugControllerBase) SetPropertyDebugEnabled(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("debug-enabled", &v)
+}
+
+func (x *DebugControllerBase) GetPropertyDebugEnabled() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("debug-enabled", &v)
+	return v.GetBoolean()
 }
 
 var XGDebugControllerGetDebugEnabled func(uintptr) bool
diff --git a/v4/gio/gdebugcontrollerdbus.go b/v4/gio/gdebugcontrollerdbus.go
index 2ee6035572a7d56fca6f69c7c76afdfaed401ec0..95d1de4f60db4f932514fa43d4e9aa29c03ffa65 100644
--- a/v4/gio/gdebugcontrollerdbus.go
+++ b/v4/gio/gdebugcontrollerdbus.go
@@ -240,6 +240,31 @@ func (c *DebugControllerDBus) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The D-Bus connection to expose the debugging interface on.
+//
+// Typically this will be the same connection (to the system or session bus)
+// which the rest of the application or serviceâs D-Bus objects are registered
+// on.
+
+func (x *DebugControllerDBus) SetPropertyConnection(value *DBusConnection) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("connection", &v)
+}
+
+func (x *DebugControllerDBus) GetPropertyConnection() *DBusConnection {
+	var v gobject.Value
+	x.GetProperty("connection", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &DBusConnection{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emitted when a D-Bus peer is trying to change the debug settings and used
 // to determine if that is authorized.
 //
diff --git a/v4/gio/gdesktopappinfo.go b/v4/gio/gdesktopappinfo.go
index 629f406bca374f2d2ca31c0db077082f4880292d..15853301e560bac3bfe2e3a2cefacf405ad2268b 100644
--- a/v4/gio/gdesktopappinfo.go
+++ b/v4/gio/gdesktopappinfo.go
@@ -463,6 +463,21 @@ func (c *DesktopAppInfo) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The origin filename of this #GDesktopAppInfo
+
+func (x *DesktopAppInfo) SetPropertyFilename(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("filename", &v)
+}
+
+func (x *DesktopAppInfo) GetPropertyFilename() string {
+	var v gobject.Value
+	x.GetProperty("filename", &v)
+	return v.GetString()
+}
+
 // Adds a content type to the application information to indicate the
 // application is capable of opening files with the given content type.
 func (x *DesktopAppInfo) AddSupportsType(ContentTypeVar string) (bool, error) {
diff --git a/v4/gio/gdtlsclientconnection.go b/v4/gio/gdtlsclientconnection.go
index c5aa6aaf9a9c2626d36777488d135a30b883edb1..c96808cf06439cfd54a85bacdf148f4bc18b2450 100644
--- a/v4/gio/gdtlsclientconnection.go
+++ b/v4/gio/gdtlsclientconnection.go
@@ -110,6 +110,81 @@ 	XGDtlsClientConnectionSetValidationFlags(x.GoPointer(), FlagsVar)
 
 }
 
+// A list of the distinguished names of the Certificate Authorities
+// that the server will accept client certificates signed by. If the
+// server requests a client certificate during the handshake, then
+// this property will be set after the handshake completes.
+//
+// Each item in the list is a #GByteArray which contains the complete
+// subject DN of the certificate authority.
+
+func (x *DtlsClientConnectionBase) GetPropertyAcceptedCas() *glib.List {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("accepted-cas", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	return (*glib.List)(unsafe.Pointer(ptr))
+}
+
+// A #GSocketConnectable describing the identity of the server that
+// is expected on the other end of the connection.
+//
+// If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
+// #GDtlsClientConnection:validation-flags, this object will be used
+// to determine the expected identify of the remote end of the
+// connection; if #GDtlsClientConnection:server-identity is not set,
+// or does not match the identity presented by the server, then the
+// %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
+//
+// In addition to its use in verifying the server certificate,
+// this is also used to give a hint to the server about what
+// certificate we expect, which is useful for servers that serve
+// virtual hosts.
+
+func (x *DtlsClientConnectionBase) SetPropertyServerIdentity(value SocketConnectable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("server-identity", &v)
+}
+
+func (x *DtlsClientConnectionBase) GetPropertyServerIdentity() SocketConnectable {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("server-identity", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SocketConnectableBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// What steps to perform when validating a certificate received from
+// a server. Server certificates that fail to validate in any of the
+// ways indicated here will be rejected unless the application
+// overrides the default via #GDtlsConnection::accept-certificate.
+
+func (x *DtlsClientConnectionBase) SetPropertyValidationFlags(value TlsCertificateFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("validation-flags", &v)
+}
+
+func (x *DtlsClientConnectionBase) GetPropertyValidationFlags() TlsCertificateFlags {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("validation-flags", &v)
+	return TlsCertificateFlags(v.GetFlags())
+}
+
 var XGDtlsClientConnectionGetAcceptedCas func(uintptr) *glib.List
 var XGDtlsClientConnectionGetServerIdentity func(uintptr) uintptr
 var XGDtlsClientConnectionGetValidationFlags func(uintptr) TlsCertificateFlags
diff --git a/v4/gio/gdtlsconnection.go b/v4/gio/gdtlsconnection.go
index 379d4b0a111583cdb7ab63fc6da9e326297be82f..ed9e0a727e47dfcdbe78e46056f9cee35f1ab248 100644
--- a/v4/gio/gdtlsconnection.go
+++ b/v4/gio/gdtlsconnection.go
@@ -773,6 +773,238 @@ 	return cret, cerr
 
 }
 
+// The list of application-layer protocols that the connection
+// advertises that it is willing to speak. See
+// g_dtls_connection_set_advertised_protocols().
+
+func (x *DtlsConnectionBase) SetPropertyAdvertisedProtocols(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *DtlsConnectionBase) GetPropertyAdvertisedProtocols() []string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("advertised-protocols", &v)
+	return nil
+}
+
+// The #GDatagramBased that the connection wraps. Note that this may be any
+// implementation of #GDatagramBased, not just a #GSocket.
+
+func (x *DtlsConnectionBase) SetPropertyBaseSocket(value DatagramBased) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("base-socket", &v)
+}
+
+func (x *DtlsConnectionBase) GetPropertyBaseSocket() DatagramBased {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("base-socket", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &DatagramBasedBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The connection's certificate; see
+// g_dtls_connection_set_certificate().
+
+func (x *DtlsConnectionBase) SetPropertyCertificate(value *TlsCertificate) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("certificate", &v)
+}
+
+func (x *DtlsConnectionBase) GetPropertyCertificate() *TlsCertificate {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("certificate", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TlsCertificate{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the DTLS ciphersuite in use. See g_dtls_connection_get_ciphersuite_name().
+
+func (x *DtlsConnectionBase) GetPropertyCiphersuiteName() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("ciphersuite-name", &v)
+	return v.GetString()
+}
+
+// The certificate database to use when verifying this TLS connection.
+// If no certificate database is set, then the default database will be
+// used. See g_tls_backend_get_default_database().
+//
+// When using a non-default database, #GDtlsConnection must fall back to using
+// the #GTlsDatabase to perform certificate verification using
+// g_tls_database_verify_chain(), which means certificate verification will
+// not be able to make use of TLS session context. This may be less secure.
+// For example, if you create your own #GTlsDatabase that just wraps the
+// default #GTlsDatabase, you might expect that you have not changed anything,
+// but this is not true because you may have altered the behavior of
+// #GDtlsConnection by causing it to use g_tls_database_verify_chain(). See the
+// documentation of g_tls_database_verify_chain() for more details on specific
+// security checks that may not be performed. Accordingly, setting a
+// non-default database is discouraged except for specialty applications with
+// unusual security requirements.
+
+func (x *DtlsConnectionBase) SetPropertyDatabase(value *TlsDatabase) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("database", &v)
+}
+
+func (x *DtlsConnectionBase) GetPropertyDatabase() *TlsDatabase {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("database", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TlsDatabase{}
+	result.Ptr = ptr
+	return result
+}
+
+// A #GTlsInteraction object to be used when the connection or certificate
+// database need to interact with the user. This will be used to prompt the
+// user for passwords where necessary.
+
+func (x *DtlsConnectionBase) SetPropertyInteraction(value *TlsInteraction) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("interaction", &v)
+}
+
+func (x *DtlsConnectionBase) GetPropertyInteraction() *TlsInteraction {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("interaction", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TlsInteraction{}
+	result.Ptr = ptr
+	return result
+}
+
+// The application-layer protocol negotiated during the TLS
+// handshake. See g_dtls_connection_get_negotiated_protocol().
+
+func (x *DtlsConnectionBase) GetPropertyNegotiatedProtocol() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("negotiated-protocol", &v)
+	return v.GetString()
+}
+
+// The connection's peer's certificate, after the TLS handshake has
+// completed or failed. Note in particular that this is not yet set
+// during the emission of #GDtlsConnection::accept-certificate.
+//
+// (You can watch for a #GObject::notify signal on this property to
+// detect when a handshake has occurred.)
+
+func (x *DtlsConnectionBase) GetPropertyPeerCertificate() *TlsCertificate {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("peer-certificate", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TlsCertificate{}
+	result.Ptr = ptr
+	return result
+}
+
+// The errors noticed while verifying
+// #GDtlsConnection:peer-certificate. Normally this should be 0, but
+// it may not be if #GDtlsClientConnection:validation-flags is not
+// %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
+// #GDtlsConnection::accept-certificate overrode the default
+// behavior.
+//
+// GLib guarantees that if certificate verification fails, at least
+// one error will be set, but it does not guarantee that all possible
+// errors will be set. Accordingly, you may not safely decide to
+// ignore any particular type of error. For example, it would be
+// incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
+// expired certificates, because this could potentially be the only
+// error flag set even if other problems exist with the certificate.
+
+func (x *DtlsConnectionBase) GetPropertyPeerCertificateErrors() TlsCertificateFlags {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("peer-certificate-errors", &v)
+	return TlsCertificateFlags(v.GetFlags())
+}
+
+// The DTLS protocol version in use. See g_dtls_connection_get_protocol_version().
+
+func (x *DtlsConnectionBase) GetPropertyProtocolVersion() TlsProtocolVersion {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("protocol-version", &v)
+	return TlsProtocolVersion(v.GetEnum())
+}
+
+// The rehandshaking mode. See
+// g_dtls_connection_set_rehandshake_mode().
+
+func (x *DtlsConnectionBase) SetPropertyRehandshakeMode(value TlsRehandshakeMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("rehandshake-mode", &v)
+}
+
+func (x *DtlsConnectionBase) GetPropertyRehandshakeMode() TlsRehandshakeMode {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("rehandshake-mode", &v)
+	return TlsRehandshakeMode(v.GetEnum())
+}
+
+// Whether or not proper TLS close notification is required.
+// See g_dtls_connection_set_require_close_notify().
+
+func (x *DtlsConnectionBase) SetPropertyRequireCloseNotify(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("require-close-notify", &v)
+}
+
+func (x *DtlsConnectionBase) GetPropertyRequireCloseNotify() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("require-close-notify", &v)
+	return v.GetBoolean()
+}
+
 var XGDtlsConnectionClose func(uintptr, uintptr, **glib.Error) bool
 var XGDtlsConnectionCloseAsync func(uintptr, int, uintptr, uintptr, uintptr)
 var XGDtlsConnectionCloseFinish func(uintptr, uintptr, **glib.Error) bool
diff --git a/v4/gio/gdtlsserverconnection.go b/v4/gio/gdtlsserverconnection.go
index 985378f67187cd183297db76316e9c37ddd48f7e..6463f3a9a5cd9119e1c951f15056f3d7ed4a9bce 100644
--- a/v4/gio/gdtlsserverconnection.go
+++ b/v4/gio/gdtlsserverconnection.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -48,6 +49,25 @@ }
 
 func (x *DtlsServerConnectionBase) SetGoPointer(ptr uintptr) {
 	x.Ptr = ptr
+}
+
+// The #GTlsAuthenticationMode for the server. This can be changed
+// before calling g_dtls_connection_handshake() if you want to
+// rehandshake with a different mode from the initial handshake.
+
+func (x *DtlsServerConnectionBase) SetPropertyAuthenticationMode(value TlsAuthenticationMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("authentication-mode", &v)
+}
+
+func (x *DtlsServerConnectionBase) GetPropertyAuthenticationMode() TlsAuthenticationMode {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("authentication-mode", &v)
+	return TlsAuthenticationMode(v.GetEnum())
 }
 
 var xDtlsServerConnectionNew func(uintptr, uintptr, **glib.Error) uintptr
diff --git a/v4/gio/gemblem.go b/v4/gio/gemblem.go
index 2c905749d8e52f9395e808ef6fada9abdd419f1e..81acf7f7e94dcc965490810431f6c90cd7743a20 100644
--- a/v4/gio/gemblem.go
+++ b/v4/gio/gemblem.go
@@ -111,6 +111,38 @@ func (c *Emblem) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *Emblem) SetPropertyIcon(value *gobject.Object) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("icon", &v)
+}
+
+func (x *Emblem) GetPropertyIcon() *gobject.Object {
+	var v gobject.Value
+	x.GetProperty("icon", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gobject.Object{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *Emblem) SetPropertyOrigin(value EmblemOrigin) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("origin", &v)
+}
+
+func (x *Emblem) GetPropertyOrigin() EmblemOrigin {
+	var v gobject.Value
+	x.GetProperty("origin", &v)
+	return EmblemOrigin(v.GetEnum())
+}
+
 // Checks if two icons are equal.
 func (x *Emblem) Equal(Icon2Var Icon) bool {
 
diff --git a/v4/gio/gemblemedicon.go b/v4/gio/gemblemedicon.go
index 0d6898afb4ddceb29a80d416908236662e417630..bc058dbecfc2857c7c98ce206c79c5c7dd107618 100644
--- a/v4/gio/gemblemedicon.go
+++ b/v4/gio/gemblemedicon.go
@@ -123,6 +123,25 @@ func (c *EmblemedIcon) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *EmblemedIcon) SetPropertyGicon(value Icon) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("gicon", &v)
+}
+
+func (x *EmblemedIcon) GetPropertyGicon() Icon {
+	var v gobject.Value
+	x.GetProperty("gicon", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &IconBase{}
+	result.Ptr = ptr
+	return result
+}
+
 // Checks if two icons are equal.
 func (x *EmblemedIcon) Equal(Icon2Var Icon) bool {
 
diff --git a/v4/gio/gfileenumerator.go b/v4/gio/gfileenumerator.go
index 387c3b7a6093e554f434d47212b56cf5aaac1a0f..d0d4a7513cc7b0597a0c1b8c0f6b69eb1bf7973c 100644
--- a/v4/gio/gfileenumerator.go
+++ b/v4/gio/gfileenumerator.go
@@ -674,6 +674,13 @@ func (c *FileEnumerator) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *FileEnumerator) SetPropertyContainer(value File) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("container", &v)
+}
+
 func init() {
 
 	core.SetPackageName("GIO", "gio-2.0")
diff --git a/v4/gio/gfileicon.go b/v4/gio/gfileicon.go
index d8c9cb417cf1f8d4a87f6950d2f87c64a43b8011..fa783ffcf9b8c2a82e25dc0fb4f2fd2603b0332b 100644
--- a/v4/gio/gfileicon.go
+++ b/v4/gio/gfileicon.go
@@ -82,6 +82,27 @@ func (c *FileIcon) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The file containing the icon.
+
+func (x *FileIcon) SetPropertyFile(value File) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("file", &v)
+}
+
+func (x *FileIcon) GetPropertyFile() File {
+	var v gobject.Value
+	x.GetProperty("file", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &FileBase{}
+	result.Ptr = ptr
+	return result
+}
+
 // Checks if two icons are equal.
 func (x *FileIcon) Equal(Icon2Var Icon) bool {
 
diff --git a/v4/gio/gfilemonitor.go b/v4/gio/gfilemonitor.go
index d2ef94524b288abe138bce6f20da27e861cef09e..63c7f020b2e21134dc0126bad6bf2ab69b3ffda5 100644
--- a/v4/gio/gfilemonitor.go
+++ b/v4/gio/gfilemonitor.go
@@ -289,6 +289,25 @@ func (c *FileMonitor) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *FileMonitor) GetPropertyCancelled() bool {
+	var v gobject.Value
+	x.GetProperty("cancelled", &v)
+	return v.GetBoolean()
+}
+
+func (x *FileMonitor) SetPropertyRateLimit(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("rate-limit", &v)
+}
+
+func (x *FileMonitor) GetPropertyRateLimit() int {
+	var v gobject.Value
+	x.GetProperty("rate-limit", &v)
+	return v.GetInt()
+}
+
 // Emitted when @file has been changed.
 //
 // If using %G_FILE_MONITOR_WATCH_MOVES on a directory monitor, and
diff --git a/v4/gio/gfilterinputstream.go b/v4/gio/gfilterinputstream.go
index cbc6f831a29f3fddf2a6eb4c8249d68534d09731..8b6f13a6f8d407ebb4cbb83e5f7dba48d7fd40c7 100644
--- a/v4/gio/gfilterinputstream.go
+++ b/v4/gio/gfilterinputstream.go
@@ -163,6 +163,38 @@ func (c *FilterInputStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *FilterInputStream) SetPropertyBaseStream(value *InputStream) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("base-stream", &v)
+}
+
+func (x *FilterInputStream) GetPropertyBaseStream() *InputStream {
+	var v gobject.Value
+	x.GetProperty("base-stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &InputStream{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *FilterInputStream) SetPropertyCloseBaseStream(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("close-base-stream", &v)
+}
+
+func (x *FilterInputStream) GetPropertyCloseBaseStream() bool {
+	var v gobject.Value
+	x.GetProperty("close-base-stream", &v)
+	return v.GetBoolean()
+}
+
 func init() {
 
 	core.SetPackageName("GIO", "gio-2.0")
diff --git a/v4/gio/gfilteroutputstream.go b/v4/gio/gfilteroutputstream.go
index 91f4f1abbb2aeb6a885e8f5275896fde4fede4cb..032824b92afc09dc7935b25df468e7ebe6234cb0 100644
--- a/v4/gio/gfilteroutputstream.go
+++ b/v4/gio/gfilteroutputstream.go
@@ -163,6 +163,38 @@ func (c *FilterOutputStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *FilterOutputStream) SetPropertyBaseStream(value *OutputStream) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("base-stream", &v)
+}
+
+func (x *FilterOutputStream) GetPropertyBaseStream() *OutputStream {
+	var v gobject.Value
+	x.GetProperty("base-stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &OutputStream{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *FilterOutputStream) SetPropertyCloseBaseStream(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("close-base-stream", &v)
+}
+
+func (x *FilterOutputStream) GetPropertyCloseBaseStream() bool {
+	var v gobject.Value
+	x.GetProperty("close-base-stream", &v)
+	return v.GetBoolean()
+}
+
 func init() {
 
 	core.SetPackageName("GIO", "gio-2.0")
diff --git a/v4/gio/ginetaddress.go b/v4/gio/ginetaddress.go
index 3dae4ee7b833ce28da6d0ea4cf694cf3be4d15ec..ddcdf95bc85443b33dc62ae12f3330cf08f5cc7c 100644
--- a/v4/gio/ginetaddress.go
+++ b/v4/gio/ginetaddress.go
@@ -324,6 +324,122 @@ func (c *InetAddress) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *InetAddress) SetPropertyBytes(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("bytes", &v)
+}
+
+func (x *InetAddress) GetPropertyBytes() uintptr {
+	var v gobject.Value
+	x.GetProperty("bytes", &v)
+	return v.GetPointer()
+}
+
+func (x *InetAddress) SetPropertyFamily(value SocketFamily) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("family", &v)
+}
+
+func (x *InetAddress) GetPropertyFamily() SocketFamily {
+	var v gobject.Value
+	x.GetProperty("family", &v)
+	return SocketFamily(v.GetEnum())
+}
+
+// Whether this is the "any" address for its family.
+// See g_inet_address_get_is_any().
+
+func (x *InetAddress) GetPropertyIsAny() bool {
+	var v gobject.Value
+	x.GetProperty("is-any", &v)
+	return v.GetBoolean()
+}
+
+// Whether this is a link-local address.
+// See g_inet_address_get_is_link_local().
+
+func (x *InetAddress) GetPropertyIsLinkLocal() bool {
+	var v gobject.Value
+	x.GetProperty("is-link-local", &v)
+	return v.GetBoolean()
+}
+
+// Whether this is the loopback address for its family.
+// See g_inet_address_get_is_loopback().
+
+func (x *InetAddress) GetPropertyIsLoopback() bool {
+	var v gobject.Value
+	x.GetProperty("is-loopback", &v)
+	return v.GetBoolean()
+}
+
+// Whether this is a global multicast address.
+// See g_inet_address_get_is_mc_global().
+
+func (x *InetAddress) GetPropertyIsMcGlobal() bool {
+	var v gobject.Value
+	x.GetProperty("is-mc-global", &v)
+	return v.GetBoolean()
+}
+
+// Whether this is a link-local multicast address.
+// See g_inet_address_get_is_mc_link_local().
+
+func (x *InetAddress) GetPropertyIsMcLinkLocal() bool {
+	var v gobject.Value
+	x.GetProperty("is-mc-link-local", &v)
+	return v.GetBoolean()
+}
+
+// Whether this is a node-local multicast address.
+// See g_inet_address_get_is_mc_node_local().
+
+func (x *InetAddress) GetPropertyIsMcNodeLocal() bool {
+	var v gobject.Value
+	x.GetProperty("is-mc-node-local", &v)
+	return v.GetBoolean()
+}
+
+// Whether this is an organization-local multicast address.
+// See g_inet_address_get_is_mc_org_local().
+
+func (x *InetAddress) GetPropertyIsMcOrgLocal() bool {
+	var v gobject.Value
+	x.GetProperty("is-mc-org-local", &v)
+	return v.GetBoolean()
+}
+
+// Whether this is a site-local multicast address.
+// See g_inet_address_get_is_mc_site_local().
+
+func (x *InetAddress) GetPropertyIsMcSiteLocal() bool {
+	var v gobject.Value
+	x.GetProperty("is-mc-site-local", &v)
+	return v.GetBoolean()
+}
+
+// Whether this is a multicast address.
+// See g_inet_address_get_is_multicast().
+
+func (x *InetAddress) GetPropertyIsMulticast() bool {
+	var v gobject.Value
+	x.GetProperty("is-multicast", &v)
+	return v.GetBoolean()
+}
+
+// Whether this is a site-local address.
+// See g_inet_address_get_is_loopback().
+
+func (x *InetAddress) GetPropertyIsSiteLocal() bool {
+	var v gobject.Value
+	x.GetProperty("is-site-local", &v)
+	return v.GetBoolean()
+}
+
 func init() {
 
 	core.SetPackageName("GIO", "gio-2.0")
diff --git a/v4/gio/ginetaddressmask.go b/v4/gio/ginetaddressmask.go
index 39d9ed42bcee3503ffe7a0b13796ae4c79948f17..446c882c852d7a01d3a6a3be355e574040d57cd7 100644
--- a/v4/gio/ginetaddressmask.go
+++ b/v4/gio/ginetaddressmask.go
@@ -169,6 +169,44 @@ func (c *InetAddressMask) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *InetAddressMask) SetPropertyAddress(value *InetAddress) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("address", &v)
+}
+
+func (x *InetAddressMask) GetPropertyAddress() *InetAddress {
+	var v gobject.Value
+	x.GetProperty("address", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &InetAddress{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *InetAddressMask) GetPropertyFamily() SocketFamily {
+	var v gobject.Value
+	x.GetProperty("family", &v)
+	return SocketFamily(v.GetEnum())
+}
+
+func (x *InetAddressMask) SetPropertyLength(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("length", &v)
+}
+
+func (x *InetAddressMask) GetPropertyLength() uint {
+	var v gobject.Value
+	x.GetProperty("length", &v)
+	return v.GetUint()
+}
+
 // Initializes the object implementing the interface.
 //
 // This method is intended for language bindings. If writing in C,
diff --git a/v4/gio/ginetsocketaddress.go b/v4/gio/ginetsocketaddress.go
index 46a72d31bbfb10ac479b6f43f0ea9741e1d50dee..f1ae79b595b4c749a744138a09bd4cd013fabfae 100644
--- a/v4/gio/ginetsocketaddress.go
+++ b/v4/gio/ginetsocketaddress.go
@@ -139,6 +139,66 @@ func (c *InetSocketAddress) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *InetSocketAddress) SetPropertyAddress(value *InetAddress) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("address", &v)
+}
+
+func (x *InetSocketAddress) GetPropertyAddress() *InetAddress {
+	var v gobject.Value
+	x.GetProperty("address", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &InetAddress{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `sin6_flowinfo` field, for IPv6 addresses.
+
+func (x *InetSocketAddress) SetPropertyFlowinfo(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("flowinfo", &v)
+}
+
+func (x *InetSocketAddress) GetPropertyFlowinfo() uint {
+	var v gobject.Value
+	x.GetProperty("flowinfo", &v)
+	return v.GetUint()
+}
+
+func (x *InetSocketAddress) SetPropertyPort(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("port", &v)
+}
+
+func (x *InetSocketAddress) GetPropertyPort() uint {
+	var v gobject.Value
+	x.GetProperty("port", &v)
+	return v.GetUint()
+}
+
+func (x *InetSocketAddress) SetPropertyScopeId(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("scope-id", &v)
+}
+
+func (x *InetSocketAddress) GetPropertyScopeId() uint {
+	var v gobject.Value
+	x.GetProperty("scope-id", &v)
+	return v.GetUint()
+}
+
 // Creates a #GSocketAddressEnumerator for @connectable.
 func (x *InetSocketAddress) Enumerate() *SocketAddressEnumerator {
 	var cls *SocketAddressEnumerator
diff --git a/v4/gio/gio-2.0.go b/v4/gio/gio-2.0.go
index 674f025accada3f4f5e3d54a275216d448846c26..859f4cd6960281ae7ef336c82f34ab027aa44640 100644
--- a/v4/gio/gio-2.0.go
+++ b/v4/gio/gio-2.0.go
@@ -202,6 +202,21 @@ func (c *BytesIcon) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The bytes containing the icon.
+
+func (x *BytesIcon) SetPropertyBytes(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("bytes", &v)
+}
+
+func (x *BytesIcon) GetPropertyBytes() uintptr {
+	var v gobject.Value
+	x.GetProperty("bytes", &v)
+	return v.GetPointer()
+}
+
 // Checks if two icons are equal.
 func (x *BytesIcon) Equal(Icon2Var Icon) bool {
 
@@ -1936,6 +1951,150 @@ func (c *DBusConnection) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// A D-Bus address specifying potential endpoints that can be used
+// when establishing the connection.
+
+func (x *DBusConnection) SetPropertyAddress(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("address", &v)
+}
+
+// A #GDBusAuthObserver object to assist in the authentication process or %NULL.
+
+func (x *DBusConnection) SetPropertyAuthenticationObserver(value *DBusAuthObserver) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("authentication-observer", &v)
+}
+
+// Flags from the #GDBusCapabilityFlags enumeration
+// representing connection features negotiated with the other peer.
+
+func (x *DBusConnection) GetPropertyCapabilities() DBusCapabilityFlags {
+	var v gobject.Value
+	x.GetProperty("capabilities", &v)
+	return DBusCapabilityFlags(v.GetFlags())
+}
+
+// A boolean specifying whether the connection has been closed.
+
+func (x *DBusConnection) GetPropertyClosed() bool {
+	var v gobject.Value
+	x.GetProperty("closed", &v)
+	return v.GetBoolean()
+}
+
+// A boolean specifying whether the process will be terminated (by
+// calling `raise(SIGTERM)`) if the connection is closed by the
+// remote peer.
+//
+// Note that #GDBusConnection objects returned by g_bus_get_finish()
+// and g_bus_get_sync() will (usually) have this property set to %TRUE.
+
+func (x *DBusConnection) SetPropertyExitOnClose(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("exit-on-close", &v)
+}
+
+func (x *DBusConnection) GetPropertyExitOnClose() bool {
+	var v gobject.Value
+	x.GetProperty("exit-on-close", &v)
+	return v.GetBoolean()
+}
+
+// Flags from the #GDBusConnectionFlags enumeration.
+
+func (x *DBusConnection) SetPropertyFlags(value DBusConnectionFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("flags", &v)
+}
+
+func (x *DBusConnection) GetPropertyFlags() DBusConnectionFlags {
+	var v gobject.Value
+	x.GetProperty("flags", &v)
+	return DBusConnectionFlags(v.GetFlags())
+}
+
+// The GUID of the peer performing the role of server when
+// authenticating.
+//
+// If you are constructing a #GDBusConnection and pass
+// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER in the
+// #GDBusConnection:flags property then you **must** also set this
+// property to a valid guid.
+//
+// If you are constructing a #GDBusConnection and pass
+// %G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT in the
+// #GDBusConnection:flags property you will be able to read the GUID
+// of the other peer here after the connection has been successfully
+// initialized.
+//
+// Note that the
+// [D-Bus specification](https://dbus.freedesktop.org/doc/dbus-specification.html#addresses)
+// uses the term âUUIDâ to refer to this, whereas GLib consistently uses the
+// term âGUIDâ for historical reasons.
+//
+// Despite its name, the format of #GDBusConnection:guid does not follow
+// [RFC 4122](https://datatracker.ietf.org/doc/html/rfc4122) or the Microsoft
+// GUID format.
+
+func (x *DBusConnection) SetPropertyGuid(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("guid", &v)
+}
+
+func (x *DBusConnection) GetPropertyGuid() string {
+	var v gobject.Value
+	x.GetProperty("guid", &v)
+	return v.GetString()
+}
+
+// The underlying #GIOStream used for I/O.
+//
+// If this is passed on construction and is a #GSocketConnection,
+// then the corresponding #GSocket will be put into non-blocking mode.
+//
+// While the #GDBusConnection is active, it will interact with this
+// stream from a worker thread, so it is not safe to interact with
+// the stream directly.
+
+func (x *DBusConnection) SetPropertyStream(value *IOStream) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("stream", &v)
+}
+
+func (x *DBusConnection) GetPropertyStream() *IOStream {
+	var v gobject.Value
+	x.GetProperty("stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &IOStream{}
+	result.Ptr = ptr
+	return result
+}
+
+// The unique name as assigned by the message bus or %NULL if the
+// connection is not open or not a message bus connection.
+
+func (x *DBusConnection) GetPropertyUniqueName() string {
+	var v gobject.Value
+	x.GetProperty("unique-name", &v)
+	return v.GetString()
+}
+
 // Emitted when the connection is closed.
 //
 // # The cause of this event can be
@@ -2845,6 +3004,12 @@ func (c *DBusMessage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *DBusMessage) GetPropertyLocked() bool {
+	var v gobject.Value
+	x.GetProperty("locked", &v)
+	return v.GetBoolean()
+}
+
 var xDBusMessageBytesNeeded func([]byte, uint, **glib.Error) int
 
 // Utility function to calculate how many bytes are needed to
@@ -3325,6 +3490,90 @@ func (c *DBusServer) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the server is currently active.
+
+func (x *DBusServer) GetPropertyActive() bool {
+	var v gobject.Value
+	x.GetProperty("active", &v)
+	return v.GetBoolean()
+}
+
+// The D-Bus address to listen on.
+
+func (x *DBusServer) SetPropertyAddress(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("address", &v)
+}
+
+func (x *DBusServer) GetPropertyAddress() string {
+	var v gobject.Value
+	x.GetProperty("address", &v)
+	return v.GetString()
+}
+
+// A #GDBusAuthObserver object to assist in the authentication process or %NULL.
+
+func (x *DBusServer) SetPropertyAuthenticationObserver(value *DBusAuthObserver) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("authentication-observer", &v)
+}
+
+func (x *DBusServer) GetPropertyAuthenticationObserver() *DBusAuthObserver {
+	var v gobject.Value
+	x.GetProperty("authentication-observer", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &DBusAuthObserver{}
+	result.Ptr = ptr
+	return result
+}
+
+// The D-Bus address that clients can use.
+
+func (x *DBusServer) GetPropertyClientAddress() string {
+	var v gobject.Value
+	x.GetProperty("client-address", &v)
+	return v.GetString()
+}
+
+// Flags from the #GDBusServerFlags enumeration.
+
+func (x *DBusServer) SetPropertyFlags(value DBusServerFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("flags", &v)
+}
+
+func (x *DBusServer) GetPropertyFlags() DBusServerFlags {
+	var v gobject.Value
+	x.GetProperty("flags", &v)
+	return DBusServerFlags(v.GetFlags())
+}
+
+// The GUID of the server.
+//
+// See #GDBusConnection:guid for more details.
+
+func (x *DBusServer) SetPropertyGuid(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("guid", &v)
+}
+
+func (x *DBusServer) GetPropertyGuid() string {
+	var v gobject.Value
+	x.GetProperty("guid", &v)
+	return v.GetString()
+}
+
 // Emitted when a new authenticated connection has been made. Use
 // g_dbus_connection_get_peer_credentials() to figure out what
 // identity (if any), was authenticated.
@@ -4448,6 +4697,98 @@ func (c *PropertyAction) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If @action is currently enabled.
+//
+// If the action is disabled then calls to g_action_activate() and
+// g_action_change_state() have no effect.
+
+func (x *PropertyAction) GetPropertyEnabled() bool {
+	var v gobject.Value
+	x.GetProperty("enabled", &v)
+	return v.GetBoolean()
+}
+
+// If %TRUE, the state of the action will be the negation of the
+// property value, provided the property is boolean.
+
+func (x *PropertyAction) SetPropertyInvertBoolean(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("invert-boolean", &v)
+}
+
+func (x *PropertyAction) GetPropertyInvertBoolean() bool {
+	var v gobject.Value
+	x.GetProperty("invert-boolean", &v)
+	return v.GetBoolean()
+}
+
+// The name of the action.  This is mostly meaningful for identifying
+// the action once it has been added to a #GActionMap.
+
+func (x *PropertyAction) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *PropertyAction) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// The object to wrap a property on.
+//
+// The object must be a non-%NULL #GObject with properties.
+
+func (x *PropertyAction) SetPropertyObject(value *gobject.Object) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("object", &v)
+}
+
+// The type of the parameter that must be given when activating the
+// action.
+
+func (x *PropertyAction) GetPropertyParameterType() uintptr {
+	var v gobject.Value
+	x.GetProperty("parameter-type", &v)
+	return v.GetPointer()
+}
+
+// The name of the property to wrap on the object.
+//
+// The property must exist on the passed-in object and it must be
+// readable and writable (and not construct-only).
+
+func (x *PropertyAction) SetPropertyPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("property-name", &v)
+}
+
+// The state of the action, or %NULL if the action is stateless.
+
+func (x *PropertyAction) GetPropertyState() uintptr {
+	var v gobject.Value
+	x.GetProperty("state", &v)
+	return v.GetPointer()
+}
+
+// The #GVariantType of the state that the action has, or %NULL if the
+// action is stateless.
+
+func (x *PropertyAction) GetPropertyStateType() uintptr {
+	var v gobject.Value
+	x.GetProperty("state-type", &v)
+	return v.GetPointer()
+}
+
 // Activates the action.
 //
 // @parameter must be the correct type of parameter for the action (ie:
@@ -4681,6 +5022,80 @@ func (c *SimpleAction) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If @action is currently enabled.
+//
+// If the action is disabled then calls to g_action_activate() and
+// g_action_change_state() have no effect.
+
+func (x *SimpleAction) SetPropertyEnabled(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enabled", &v)
+}
+
+func (x *SimpleAction) GetPropertyEnabled() bool {
+	var v gobject.Value
+	x.GetProperty("enabled", &v)
+	return v.GetBoolean()
+}
+
+// The name of the action. This is mostly meaningful for identifying
+// the action once it has been added to a #GSimpleActionGroup.
+
+func (x *SimpleAction) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *SimpleAction) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// The type of the parameter that must be given when activating the
+// action.
+
+func (x *SimpleAction) SetPropertyParameterType(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("parameter-type", &v)
+}
+
+func (x *SimpleAction) GetPropertyParameterType() uintptr {
+	var v gobject.Value
+	x.GetProperty("parameter-type", &v)
+	return v.GetPointer()
+}
+
+// The state of the action, or %NULL if the action is stateless.
+
+func (x *SimpleAction) SetPropertyState(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("state", &v)
+}
+
+func (x *SimpleAction) GetPropertyState() uintptr {
+	var v gobject.Value
+	x.GetProperty("state", &v)
+	return v.GetPointer()
+}
+
+// The #GVariantType of the state that the action has, or %NULL if the
+// action is stateless.
+
+func (x *SimpleAction) GetPropertyStateType() uintptr {
+	var v gobject.Value
+	x.GetProperty("state-type", &v)
+	return v.GetPointer()
+}
+
 // Indicates that the action was just activated.
 //
 // @parameter will always be of the expected type, i.e. the parameter type
@@ -4936,6 +5351,44 @@ func (c *SimpleIOStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *SimpleIOStream) SetPropertyInputStream(value *InputStream) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("input-stream", &v)
+}
+
+func (x *SimpleIOStream) GetPropertyInputStream() *InputStream {
+	var v gobject.Value
+	x.GetProperty("input-stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &InputStream{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *SimpleIOStream) SetPropertyOutputStream(value *OutputStream) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("output-stream", &v)
+}
+
+func (x *SimpleIOStream) GetPropertyOutputStream() *OutputStream {
+	var v gobject.Value
+	x.GetProperty("output-stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &OutputStream{}
+	result.Ptr = ptr
+	return result
+}
+
 // #GSimplePermission is a trivial implementation of #GPermission that
 // represents a permission that is either always or never allowed.  The
 // value is given at construction and doesn't change.
@@ -5521,6 +5974,17 @@ func (c *Subprocess) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *Subprocess) SetPropertyArgv(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *Subprocess) SetPropertyFlags(value SubprocessFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("flags", &v)
+}
+
 // Initializes the object implementing the interface.
 //
 // This method is intended for language bindings. If writing in C,
@@ -5955,6 +6419,13 @@ func (c *SubprocessLauncher) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *SubprocessLauncher) SetPropertyFlags(value SubprocessFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("flags", &v)
+}
+
 // A helper class for testing code which uses D-Bus without touching the user's
 // session bus.
 //
@@ -6149,6 +6620,21 @@ }
 
 func (c *TestDBus) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// #GTestDBusFlags specifying the behaviour of the D-Bus session.
+
+func (x *TestDBus) SetPropertyFlags(value TestDBusFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("flags", &v)
+}
+
+func (x *TestDBus) GetPropertyFlags() TestDBusFlags {
+	var v gobject.Value
+	x.GetProperty("flags", &v)
+	return TestDBusFlags(v.GetFlags())
 }
 
 var xTestDBusUnset func()
diff --git a/v4/gio/giostream.go b/v4/gio/giostream.go
index 9ab28920fb70236564a9ae98877af8bc32839dc3..261af003ab079c147d508c10035e762839c60796 100644
--- a/v4/gio/giostream.go
+++ b/v4/gio/giostream.go
@@ -670,6 +670,36 @@ func (c *IOStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *IOStream) GetPropertyClosed() bool {
+	var v gobject.Value
+	x.GetProperty("closed", &v)
+	return v.GetBoolean()
+}
+
+func (x *IOStream) GetPropertyInputStream() *InputStream {
+	var v gobject.Value
+	x.GetProperty("input-stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &InputStream{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *IOStream) GetPropertyOutputStream() *OutputStream {
+	var v gobject.Value
+	x.GetProperty("output-stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &OutputStream{}
+	result.Ptr = ptr
+	return result
+}
+
 var xIOStreamSpliceFinish func(uintptr, **glib.Error) bool
 
 // Finishes an asynchronous io stream splice operation.
diff --git a/v4/gio/gliststore.go b/v4/gio/gliststore.go
index 1b3cee958b03536fcac660fd5571cc29012a3095..907834318f2d36bb81a1f5cc73be6ff92b7b3fb3 100644
--- a/v4/gio/gliststore.go
+++ b/v4/gio/gliststore.go
@@ -195,6 +195,22 @@ func (c *ListStore) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The type of items contained in this list store. Items must be
+// subclasses of #GObject.
+
+func (x *ListStore) SetPropertyItemType(value types.GType) {
+	var v gobject.Value
+	v.Init(gobject.TypeGtypeVal)
+	v.SetGtype(value)
+	x.SetProperty("item-type", &v)
+}
+
+func (x *ListStore) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gio/gmemoryoutputstream.go b/v4/gio/gmemoryoutputstream.go
index 3b5d846b8517502902f373b74324d16da02a0daf..8a331c8c8db65cb9a7f7d314eeda299f0463ae50 100644
--- a/v4/gio/gmemoryoutputstream.go
+++ b/v4/gio/gmemoryoutputstream.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -332,6 +333,44 @@ }
 
 func (c *MemoryOutputStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Pointer to buffer where data will be written.
+
+func (x *MemoryOutputStream) SetPropertyData(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("data", &v)
+}
+
+func (x *MemoryOutputStream) GetPropertyData() uintptr {
+	var v gobject.Value
+	x.GetProperty("data", &v)
+	return v.GetPointer()
+}
+
+// Size of data written to the buffer.
+
+func (x *MemoryOutputStream) GetPropertyDataSize() uint32 {
+	var v gobject.Value
+	x.GetProperty("data-size", &v)
+	return uint32(v.GetPointer())
+}
+
+// Current size of the data buffer.
+
+func (x *MemoryOutputStream) SetPropertySize(value uint32) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetPointer(uintptr(value))
+	x.SetProperty("size", &v)
+}
+
+func (x *MemoryOutputStream) GetPropertySize() uint32 {
+	var v gobject.Value
+	x.GetProperty("size", &v)
+	return uint32(v.GetPointer())
 }
 
 // Checks if @stream is actually pollable. Some classes may implement
diff --git a/v4/gio/gmountoperation.go b/v4/gio/gmountoperation.go
index f5ac101f9041de99511338106105376e76e710e2..76e0e56b775b9c8789da36f7d0a0836e328e1f6a 100644
--- a/v4/gio/gmountoperation.go
+++ b/v4/gio/gmountoperation.go
@@ -643,6 +643,150 @@ func (c *MountOperation) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to use an anonymous user when authenticating.
+
+func (x *MountOperation) SetPropertyAnonymous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("anonymous", &v)
+}
+
+func (x *MountOperation) GetPropertyAnonymous() bool {
+	var v gobject.Value
+	x.GetProperty("anonymous", &v)
+	return v.GetBoolean()
+}
+
+// The index of the user's choice when a question is asked during the
+// mount operation. See the #GMountOperation::ask-question signal.
+
+func (x *MountOperation) SetPropertyChoice(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("choice", &v)
+}
+
+func (x *MountOperation) GetPropertyChoice() int {
+	var v gobject.Value
+	x.GetProperty("choice", &v)
+	return v.GetInt()
+}
+
+// The domain to use for the mount operation.
+
+func (x *MountOperation) SetPropertyDomain(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("domain", &v)
+}
+
+func (x *MountOperation) GetPropertyDomain() string {
+	var v gobject.Value
+	x.GetProperty("domain", &v)
+	return v.GetString()
+}
+
+// Whether the device to be unlocked is a TCRYPT hidden volume.
+// See [the VeraCrypt documentation](https://www.veracrypt.fr/en/Hidden%20Volume.html).
+
+func (x *MountOperation) SetPropertyIsTcryptHiddenVolume(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-tcrypt-hidden-volume", &v)
+}
+
+func (x *MountOperation) GetPropertyIsTcryptHiddenVolume() bool {
+	var v gobject.Value
+	x.GetProperty("is-tcrypt-hidden-volume", &v)
+	return v.GetBoolean()
+}
+
+// Whether the device to be unlocked is a TCRYPT system volume.
+// In this context, a system volume is a volume with a bootloader
+// and operating system installed. This is only supported for Windows
+// operating systems. For further documentation, see
+// [the VeraCrypt documentation](https://www.veracrypt.fr/en/System%20Encryption.html).
+
+func (x *MountOperation) SetPropertyIsTcryptSystemVolume(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-tcrypt-system-volume", &v)
+}
+
+func (x *MountOperation) GetPropertyIsTcryptSystemVolume() bool {
+	var v gobject.Value
+	x.GetProperty("is-tcrypt-system-volume", &v)
+	return v.GetBoolean()
+}
+
+// The password that is used for authentication when carrying out
+// the mount operation.
+
+func (x *MountOperation) SetPropertyPassword(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("password", &v)
+}
+
+func (x *MountOperation) GetPropertyPassword() string {
+	var v gobject.Value
+	x.GetProperty("password", &v)
+	return v.GetString()
+}
+
+// Determines if and how the password information should be saved.
+
+func (x *MountOperation) SetPropertyPasswordSave(value PasswordSave) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("password-save", &v)
+}
+
+func (x *MountOperation) GetPropertyPasswordSave() PasswordSave {
+	var v gobject.Value
+	x.GetProperty("password-save", &v)
+	return PasswordSave(v.GetEnum())
+}
+
+// The VeraCrypt PIM value, when unlocking a VeraCrypt volume. See
+// [the VeraCrypt documentation](https://www.veracrypt.fr/en/Personal%20Iterations%20Multiplier%20(PIM).html).
+
+func (x *MountOperation) SetPropertyPim(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("pim", &v)
+}
+
+func (x *MountOperation) GetPropertyPim() uint {
+	var v gobject.Value
+	x.GetProperty("pim", &v)
+	return v.GetUint()
+}
+
+// The user name that is used for authentication when carrying out
+// the mount operation.
+
+func (x *MountOperation) SetPropertyUsername(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("username", &v)
+}
+
+func (x *MountOperation) GetPropertyUsername() string {
+	var v gobject.Value
+	x.GetProperty("username", &v)
+	return v.GetString()
+}
+
 // Emitted by the backend when e.g. a device becomes unavailable
 // while a mount operation is in progress.
 //
diff --git a/v4/gio/gnetworkaddress.go b/v4/gio/gnetworkaddress.go
index e93b95a92933b12effc9c65c70551c89af2e742c..9856a6e08e85da6079005a9051da8f45a329a588 100644
--- a/v4/gio/gnetworkaddress.go
+++ b/v4/gio/gnetworkaddress.go
@@ -145,6 +145,45 @@ func (c *NetworkAddress) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *NetworkAddress) SetPropertyHostname(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("hostname", &v)
+}
+
+func (x *NetworkAddress) GetPropertyHostname() string {
+	var v gobject.Value
+	x.GetProperty("hostname", &v)
+	return v.GetString()
+}
+
+func (x *NetworkAddress) SetPropertyPort(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("port", &v)
+}
+
+func (x *NetworkAddress) GetPropertyPort() uint {
+	var v gobject.Value
+	x.GetProperty("port", &v)
+	return v.GetUint()
+}
+
+func (x *NetworkAddress) SetPropertyScheme(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("scheme", &v)
+}
+
+func (x *NetworkAddress) GetPropertyScheme() string {
+	var v gobject.Value
+	x.GetProperty("scheme", &v)
+	return v.GetString()
+}
+
 // Creates a #GSocketAddressEnumerator for @connectable.
 func (x *NetworkAddress) Enumerate() *SocketAddressEnumerator {
 	var cls *SocketAddressEnumerator
diff --git a/v4/gio/gnetworkmonitor.go b/v4/gio/gnetworkmonitor.go
index c6942a5eaefb9979c7ebaa5637e0128676cede99..3079c37edeb3bfe6137d27ecd92c9a2c631df7f8 100644
--- a/v4/gio/gnetworkmonitor.go
+++ b/v4/gio/gnetworkmonitor.go
@@ -260,6 +260,67 @@ 	cret := XGNetworkMonitorGetNetworkMetered(x.GoPointer())
 	return cret
 }
 
+// More detailed information about the host's network connectivity.
+// See g_network_monitor_get_connectivity() and
+// #GNetworkConnectivity for more details.
+
+func (x *NetworkMonitorBase) GetPropertyConnectivity() NetworkConnectivity {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("connectivity", &v)
+	return NetworkConnectivity(v.GetEnum())
+}
+
+// Whether the network is considered available. That is, whether the
+// system has a default route for at least one of IPv4 or IPv6.
+//
+// Real-world networks are of course much more complicated than
+// this; the machine may be connected to a wifi hotspot that
+// requires payment before allowing traffic through, or may be
+// connected to a functioning router that has lost its own upstream
+// connectivity. Some hosts might only be accessible when a VPN is
+// active. Other hosts might only be accessible when the VPN is
+// not active. Thus, it is best to use g_network_monitor_can_reach()
+// or g_network_monitor_can_reach_async() to test for reachability
+// on a host-by-host basis. (On the other hand, when the property is
+// %FALSE, the application can reasonably expect that no remote
+// hosts at all are reachable, and should indicate this to the user
+// in its UI.)
+//
+// See also #GNetworkMonitor::network-changed.
+
+func (x *NetworkMonitorBase) GetPropertyNetworkAvailable() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("network-available", &v)
+	return v.GetBoolean()
+}
+
+// Whether the network is considered metered. That is, whether the
+// system has traffic flowing through the default connection that is
+// subject to limitations set by service providers. For example, traffic
+// might be billed by the amount of data transmitted, or there might be a
+// quota on the amount of traffic per month. This is typical with tethered
+// connections (3G and 4G) and in such situations, bandwidth intensive
+// applications may wish to avoid network activity where possible if it will
+// cost the user money or use up their limited quota.
+//
+// If more information is required about specific devices then the
+// system network management API should be used instead (for example,
+// NetworkManager or ConnMan).
+//
+// If this information is not available then no networks will be
+// marked as metered.
+//
+// See also #GNetworkMonitor:network-available.
+
+func (x *NetworkMonitorBase) GetPropertyNetworkMetered() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("network-metered", &v)
+	return v.GetBoolean()
+}
+
 var XGNetworkMonitorCanReach func(uintptr, uintptr, uintptr, **glib.Error) bool
 var XGNetworkMonitorCanReachAsync func(uintptr, uintptr, uintptr, uintptr, uintptr)
 var XGNetworkMonitorCanReachFinish func(uintptr, uintptr, **glib.Error) bool
diff --git a/v4/gio/gnetworkservice.go b/v4/gio/gnetworkservice.go
index d23d9a7157dc465808a6ef0802e7d50e2ed69ebf..34bb9aff3995b53d3dd064537f808a18322da879 100644
--- a/v4/gio/gnetworkservice.go
+++ b/v4/gio/gnetworkservice.go
@@ -131,6 +131,58 @@ func (c *NetworkService) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *NetworkService) SetPropertyDomain(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("domain", &v)
+}
+
+func (x *NetworkService) GetPropertyDomain() string {
+	var v gobject.Value
+	x.GetProperty("domain", &v)
+	return v.GetString()
+}
+
+func (x *NetworkService) SetPropertyProtocol(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("protocol", &v)
+}
+
+func (x *NetworkService) GetPropertyProtocol() string {
+	var v gobject.Value
+	x.GetProperty("protocol", &v)
+	return v.GetString()
+}
+
+func (x *NetworkService) SetPropertyScheme(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("scheme", &v)
+}
+
+func (x *NetworkService) GetPropertyScheme() string {
+	var v gobject.Value
+	x.GetProperty("scheme", &v)
+	return v.GetString()
+}
+
+func (x *NetworkService) SetPropertyService(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("service", &v)
+}
+
+func (x *NetworkService) GetPropertyService() string {
+	var v gobject.Value
+	x.GetProperty("service", &v)
+	return v.GetString()
+}
+
 // Creates a #GSocketAddressEnumerator for @connectable.
 func (x *NetworkService) Enumerate() *SocketAddressEnumerator {
 	var cls *SocketAddressEnumerator
diff --git a/v4/gio/gpermission.go b/v4/gio/gpermission.go
index 398589d203e85c1566b8604c7677f700d613bc4a..793f7cabbc95fb1a72954eb6f50a37d0d4a9c9f0 100644
--- a/v4/gio/gpermission.go
+++ b/v4/gio/gpermission.go
@@ -386,6 +386,33 @@ func (c *Permission) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// %TRUE if the caller currently has permission to perform the action that
+// @permission represents the permission to perform.
+
+func (x *Permission) GetPropertyAllowed() bool {
+	var v gobject.Value
+	x.GetProperty("allowed", &v)
+	return v.GetBoolean()
+}
+
+// %TRUE if it is generally possible to acquire the permission by calling
+// g_permission_acquire().
+
+func (x *Permission) GetPropertyCanAcquire() bool {
+	var v gobject.Value
+	x.GetProperty("can-acquire", &v)
+	return v.GetBoolean()
+}
+
+// %TRUE if it is generally possible to release the permission by calling
+// g_permission_release().
+
+func (x *Permission) GetPropertyCanRelease() bool {
+	var v gobject.Value
+	x.GetProperty("can-release", &v)
+	return v.GetBoolean()
+}
+
 func init() {
 
 	core.SetPackageName("GIO", "gio-2.0")
diff --git a/v4/gio/gpowerprofilemonitor.go b/v4/gio/gpowerprofilemonitor.go
index 587cee7639554733a69b3412c7b4de823946dbb6..5334b2dda50cec80df49cb235b17c7d929dca150 100644
--- a/v4/gio/gpowerprofilemonitor.go
+++ b/v4/gio/gpowerprofilemonitor.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -79,6 +80,15 @@ func (x *PowerProfileMonitorBase) GetPowerSaverEnabled() bool {
 
 	cret := XGPowerProfileMonitorGetPowerSaverEnabled(x.GoPointer())
 	return cret
+}
+
+// Whether âPower Saverâ mode is enabled on the system.
+
+func (x *PowerProfileMonitorBase) GetPropertyPowerSaverEnabled() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("power-saver-enabled", &v)
+	return v.GetBoolean()
 }
 
 var XGPowerProfileMonitorGetPowerSaverEnabled func(uintptr) bool
diff --git a/v4/gio/gproxyaddress.go b/v4/gio/gproxyaddress.go
index 3d91dfc4c1dc7bfb7bbab17d5ddee97b6a975737..0ebffa031559a8256d59f211de18d98626360b5b 100644
--- a/v4/gio/gproxyaddress.go
+++ b/v4/gio/gproxyaddress.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -144,6 +145,103 @@ }
 
 func (c *ProxyAddress) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+func (x *ProxyAddress) SetPropertyDestinationHostname(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("destination-hostname", &v)
+}
+
+func (x *ProxyAddress) GetPropertyDestinationHostname() string {
+	var v gobject.Value
+	x.GetProperty("destination-hostname", &v)
+	return v.GetString()
+}
+
+func (x *ProxyAddress) SetPropertyDestinationPort(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("destination-port", &v)
+}
+
+func (x *ProxyAddress) GetPropertyDestinationPort() uint {
+	var v gobject.Value
+	x.GetProperty("destination-port", &v)
+	return v.GetUint()
+}
+
+// The protocol being spoke to the destination host, or %NULL if
+// the #GProxyAddress doesn't know.
+
+func (x *ProxyAddress) SetPropertyDestinationProtocol(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("destination-protocol", &v)
+}
+
+func (x *ProxyAddress) GetPropertyDestinationProtocol() string {
+	var v gobject.Value
+	x.GetProperty("destination-protocol", &v)
+	return v.GetString()
+}
+
+func (x *ProxyAddress) SetPropertyPassword(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("password", &v)
+}
+
+func (x *ProxyAddress) GetPropertyPassword() string {
+	var v gobject.Value
+	x.GetProperty("password", &v)
+	return v.GetString()
+}
+
+func (x *ProxyAddress) SetPropertyProtocol(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("protocol", &v)
+}
+
+func (x *ProxyAddress) GetPropertyProtocol() string {
+	var v gobject.Value
+	x.GetProperty("protocol", &v)
+	return v.GetString()
+}
+
+// The URI string that the proxy was constructed from (or %NULL
+// if the creator didn't specify this).
+
+func (x *ProxyAddress) SetPropertyUri(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("uri", &v)
+}
+
+func (x *ProxyAddress) GetPropertyUri() string {
+	var v gobject.Value
+	x.GetProperty("uri", &v)
+	return v.GetString()
+}
+
+func (x *ProxyAddress) SetPropertyUsername(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("username", &v)
+}
+
+func (x *ProxyAddress) GetPropertyUsername() string {
+	var v gobject.Value
+	x.GetProperty("username", &v)
+	return v.GetString()
 }
 
 // Creates a #GSocketAddressEnumerator for @connectable.
diff --git a/v4/gio/gproxyaddressenumerator.go b/v4/gio/gproxyaddressenumerator.go
index dd31058ce059b6fc3de21fd9be2f9212b29c46f9..c4550ae19006ceb7aabc2b7aa28df4c00a0db872 100644
--- a/v4/gio/gproxyaddressenumerator.go
+++ b/v4/gio/gproxyaddressenumerator.go
@@ -6,6 +6,7 @@ 	"structs"
 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -238,3 +239,72 @@
 func (c *ProxyAddressEnumerator) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
+
+func (x *ProxyAddressEnumerator) SetPropertyConnectable(value SocketConnectable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("connectable", &v)
+}
+
+func (x *ProxyAddressEnumerator) GetPropertyConnectable() SocketConnectable {
+	var v gobject.Value
+	x.GetProperty("connectable", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SocketConnectableBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The default port to use if #GProxyAddressEnumerator:uri does not
+// specify one.
+
+func (x *ProxyAddressEnumerator) SetPropertyDefaultPort(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("default-port", &v)
+}
+
+func (x *ProxyAddressEnumerator) GetPropertyDefaultPort() uint {
+	var v gobject.Value
+	x.GetProperty("default-port", &v)
+	return v.GetUint()
+}
+
+// The proxy resolver to use.
+
+func (x *ProxyAddressEnumerator) SetPropertyProxyResolver(value ProxyResolver) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("proxy-resolver", &v)
+}
+
+func (x *ProxyAddressEnumerator) GetPropertyProxyResolver() ProxyResolver {
+	var v gobject.Value
+	x.GetProperty("proxy-resolver", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ProxyResolverBase{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *ProxyAddressEnumerator) SetPropertyUri(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("uri", &v)
+}
+
+func (x *ProxyAddressEnumerator) GetPropertyUri() string {
+	var v gobject.Value
+	x.GetProperty("uri", &v)
+	return v.GetString()
+}
diff --git a/v4/gio/gsettings.go b/v4/gio/gsettings.go
index dcb87efa945030a32243ecd1d2344579d6981bfb..26f4771109602aadccac77842e6c14613d333708 100644
--- a/v4/gio/gsettings.go
+++ b/v4/gio/gsettings.go
@@ -1345,6 +1345,120 @@ func (c *Settings) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The name of the context that the settings are stored in.
+
+func (x *Settings) SetPropertyBackend(value *SettingsBackend) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("backend", &v)
+}
+
+func (x *Settings) GetPropertyBackend() *SettingsBackend {
+	var v gobject.Value
+	x.GetProperty("backend", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SettingsBackend{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the #GSettings object is in 'delay-apply' mode. See
+// g_settings_delay() for details.
+
+func (x *Settings) GetPropertyDelayApply() bool {
+	var v gobject.Value
+	x.GetProperty("delay-apply", &v)
+	return v.GetBoolean()
+}
+
+// If this property is %TRUE, the #GSettings object has outstanding
+// changes that will be applied when g_settings_apply() is called.
+
+func (x *Settings) GetPropertyHasUnapplied() bool {
+	var v gobject.Value
+	x.GetProperty("has-unapplied", &v)
+	return v.GetBoolean()
+}
+
+// The path within the backend where the settings are stored.
+
+func (x *Settings) SetPropertyPath(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("path", &v)
+}
+
+func (x *Settings) GetPropertyPath() string {
+	var v gobject.Value
+	x.GetProperty("path", &v)
+	return v.GetString()
+}
+
+// The name of the schema that describes the types of keys
+// for this #GSettings object.
+//
+// The type of this property is *not* #GSettingsSchema.
+// #GSettingsSchema has only existed since version 2.32 and
+// unfortunately this name was used in previous versions to refer to
+// the schema ID rather than the schema itself.  Take care to use the
+// 'settings-schema' property if you wish to pass in a
+// #GSettingsSchema.
+
+func (x *Settings) SetPropertySchema(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("schema", &v)
+}
+
+func (x *Settings) GetPropertySchema() string {
+	var v gobject.Value
+	x.GetProperty("schema", &v)
+	return v.GetString()
+}
+
+// The name of the schema that describes the types of keys
+// for this #GSettings object.
+
+func (x *Settings) SetPropertySchemaId(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("schema-id", &v)
+}
+
+func (x *Settings) GetPropertySchemaId() string {
+	var v gobject.Value
+	x.GetProperty("schema-id", &v)
+	return v.GetString()
+}
+
+// The #GSettingsSchema describing the types of keys for this
+// #GSettings object.
+//
+// Ideally, this property would be called 'schema'.  #GSettingsSchema
+// has only existed since version 2.32, however, and before then the
+// 'schema' property was used to refer to the ID of the schema rather
+// than the schema itself.  Take care.
+
+func (x *Settings) SetPropertySettingsSchema(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("settings-schema", &v)
+}
+
+func (x *Settings) GetPropertySettingsSchema() uintptr {
+	var v gobject.Value
+	x.GetProperty("settings-schema", &v)
+	return v.GetPointer()
+}
+
 // The "change-event" signal is emitted once per change event that
 // affects this settings object.  You should connect to this signal
 // only if you are interested in viewing groups of changes before they
diff --git a/v4/gio/gsimpleproxyresolver.go b/v4/gio/gsimpleproxyresolver.go
index 5ff859a1213081975c10a62eeefc1d910bf18350..2ddfa4b0960e7da870272034547fed433e7b9ca5 100644
--- a/v4/gio/gsimpleproxyresolver.go
+++ b/v4/gio/gsimpleproxyresolver.go
@@ -233,6 +233,72 @@ func (c *SimpleProxyResolver) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The default proxy URI that will be used for any URI that doesn't
+// match #GSimpleProxyResolver:ignore-hosts, and doesn't match any
+// of the schemes set with g_simple_proxy_resolver_set_uri_proxy().
+//
+// Note that as a special case, if this URI starts with
+// "socks://", #GSimpleProxyResolver will treat it as referring
+// to all three of the socks5, socks4a, and socks4 proxy types.
+
+func (x *SimpleProxyResolver) SetPropertyDefaultProxy(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("default-proxy", &v)
+}
+
+func (x *SimpleProxyResolver) GetPropertyDefaultProxy() string {
+	var v gobject.Value
+	x.GetProperty("default-proxy", &v)
+	return v.GetString()
+}
+
+// A list of hostnames and IP addresses that the resolver should
+// allow direct connections to.
+//
+// Entries can be in one of 4 formats:
+//
+// - A hostname, such as "example.com", ".example.com", or
+//   "*.example.com", any of which match "example.com" or
+//   any subdomain of it.
+//
+// - An IPv4 or IPv6 address, such as "192.168.1.1",
+//   which matches only that address.
+//
+// - A hostname or IP address followed by a port, such as
+//   "example.com:80", which matches whatever the hostname or IP
+//   address would match, but only for URLs with the (explicitly)
+//   indicated port. In the case of an IPv6 address, the address
+//   part must appear in brackets: "[::1]:443"
+//
+// - An IP address range, given by a base address and prefix length,
+//   such as "fe80::/10", which matches any address in that range.
+//
+// Note that when dealing with Unicode hostnames, the matching is
+// done against the ASCII form of the name.
+//
+// Also note that hostname exclusions apply only to connections made
+// to hosts identified by name, and IP address exclusions apply only
+// to connections made to hosts identified by address. That is, if
+// example.com has an address of 192.168.1.1, and the :ignore-hosts list
+// contains only "192.168.1.1", then a connection to "example.com"
+// (eg, via a #GNetworkAddress) will use the proxy, and a connection to
+// "192.168.1.1" (eg, via a #GInetSocketAddress) will not.
+//
+// These rules match the "ignore-hosts"/"noproxy" rules most
+// commonly used by other applications.
+
+func (x *SimpleProxyResolver) SetPropertyIgnoreHosts(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *SimpleProxyResolver) GetPropertyIgnoreHosts() []string {
+	var v gobject.Value
+	x.GetProperty("ignore-hosts", &v)
+	return nil
+}
+
 // Checks if @resolver can be used on this system. (This is used
 // internally; g_proxy_resolver_get_default() will only return a proxy
 // resolver that returns %TRUE for this method.)
diff --git a/v4/gio/gsocket.go b/v4/gio/gsocket.go
index ef36fa9e382399a537efc18adea2ac7e14f3c5e1..1fb53bc1ad6d301a358b1ba079c014a917f13d0d 100644
--- a/v4/gio/gsocket.go
+++ b/v4/gio/gsocket.go
@@ -1673,6 +1673,196 @@ func (c *Socket) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *Socket) SetPropertyBlocking(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("blocking", &v)
+}
+
+func (x *Socket) GetPropertyBlocking() bool {
+	var v gobject.Value
+	x.GetProperty("blocking", &v)
+	return v.GetBoolean()
+}
+
+// Whether the socket should allow sending to broadcast addresses.
+
+func (x *Socket) SetPropertyBroadcast(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("broadcast", &v)
+}
+
+func (x *Socket) GetPropertyBroadcast() bool {
+	var v gobject.Value
+	x.GetProperty("broadcast", &v)
+	return v.GetBoolean()
+}
+
+func (x *Socket) SetPropertyFamily(value SocketFamily) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("family", &v)
+}
+
+func (x *Socket) GetPropertyFamily() SocketFamily {
+	var v gobject.Value
+	x.GetProperty("family", &v)
+	return SocketFamily(v.GetEnum())
+}
+
+func (x *Socket) SetPropertyFd(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("fd", &v)
+}
+
+func (x *Socket) GetPropertyFd() int {
+	var v gobject.Value
+	x.GetProperty("fd", &v)
+	return v.GetInt()
+}
+
+func (x *Socket) SetPropertyKeepalive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("keepalive", &v)
+}
+
+func (x *Socket) GetPropertyKeepalive() bool {
+	var v gobject.Value
+	x.GetProperty("keepalive", &v)
+	return v.GetBoolean()
+}
+
+func (x *Socket) SetPropertyListenBacklog(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("listen-backlog", &v)
+}
+
+func (x *Socket) GetPropertyListenBacklog() int {
+	var v gobject.Value
+	x.GetProperty("listen-backlog", &v)
+	return v.GetInt()
+}
+
+func (x *Socket) GetPropertyLocalAddress() *SocketAddress {
+	var v gobject.Value
+	x.GetProperty("local-address", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SocketAddress{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether outgoing multicast packets loop back to the local host.
+
+func (x *Socket) SetPropertyMulticastLoopback(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("multicast-loopback", &v)
+}
+
+func (x *Socket) GetPropertyMulticastLoopback() bool {
+	var v gobject.Value
+	x.GetProperty("multicast-loopback", &v)
+	return v.GetBoolean()
+}
+
+// Time-to-live out outgoing multicast packets
+
+func (x *Socket) SetPropertyMulticastTtl(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("multicast-ttl", &v)
+}
+
+func (x *Socket) GetPropertyMulticastTtl() uint {
+	var v gobject.Value
+	x.GetProperty("multicast-ttl", &v)
+	return v.GetUint()
+}
+
+func (x *Socket) SetPropertyProtocol(value SocketProtocol) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("protocol", &v)
+}
+
+func (x *Socket) GetPropertyProtocol() SocketProtocol {
+	var v gobject.Value
+	x.GetProperty("protocol", &v)
+	return SocketProtocol(v.GetEnum())
+}
+
+func (x *Socket) GetPropertyRemoteAddress() *SocketAddress {
+	var v gobject.Value
+	x.GetProperty("remote-address", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SocketAddress{}
+	result.Ptr = ptr
+	return result
+}
+
+// The timeout in seconds on socket I/O
+
+func (x *Socket) SetPropertyTimeout(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("timeout", &v)
+}
+
+func (x *Socket) GetPropertyTimeout() uint {
+	var v gobject.Value
+	x.GetProperty("timeout", &v)
+	return v.GetUint()
+}
+
+// Time-to-live for outgoing unicast packets
+
+func (x *Socket) SetPropertyTtl(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("ttl", &v)
+}
+
+func (x *Socket) GetPropertyTtl() uint {
+	var v gobject.Value
+	x.GetProperty("ttl", &v)
+	return v.GetUint()
+}
+
+func (x *Socket) SetPropertyType(value SocketType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("type", &v)
+}
+
+func (x *Socket) GetPropertyType() SocketType {
+	var v gobject.Value
+	x.GetProperty("type", &v)
+	return SocketType(v.GetEnum())
+}
+
 // Initializes the object implementing the interface.
 //
 // This method is intended for language bindings. If writing in C,
diff --git a/v4/gio/gsocketaddress.go b/v4/gio/gsocketaddress.go
index 7ac7209602cd8a5e174f186ed2f59dd6d2f98342..7b5aba10ced4def3eed04a7a73572d61a435ee76 100644
--- a/v4/gio/gsocketaddress.go
+++ b/v4/gio/gsocketaddress.go
@@ -183,6 +183,12 @@ func (c *SocketAddress) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *SocketAddress) GetPropertyFamily() SocketFamily {
+	var v gobject.Value
+	x.GetProperty("family", &v)
+	return SocketFamily(v.GetEnum())
+}
+
 // Creates a #GSocketAddressEnumerator for @connectable.
 func (x *SocketAddress) Enumerate() *SocketAddressEnumerator {
 	var cls *SocketAddressEnumerator
diff --git a/v4/gio/gsocketclient.go b/v4/gio/gsocketclient.go
index 1d6486a64a746d991fb887759458ecae91784f3d..a0c16ed0606c9ed9daf944e6c19086c51875d0e5 100644
--- a/v4/gio/gsocketclient.go
+++ b/v4/gio/gsocketclient.go
@@ -800,6 +800,154 @@ func (c *SocketClient) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *SocketClient) SetPropertyEnableProxy(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-proxy", &v)
+}
+
+func (x *SocketClient) GetPropertyEnableProxy() bool {
+	var v gobject.Value
+	x.GetProperty("enable-proxy", &v)
+	return v.GetBoolean()
+}
+
+func (x *SocketClient) SetPropertyFamily(value SocketFamily) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("family", &v)
+}
+
+func (x *SocketClient) GetPropertyFamily() SocketFamily {
+	var v gobject.Value
+	x.GetProperty("family", &v)
+	return SocketFamily(v.GetEnum())
+}
+
+func (x *SocketClient) SetPropertyLocalAddress(value *SocketAddress) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("local-address", &v)
+}
+
+func (x *SocketClient) GetPropertyLocalAddress() *SocketAddress {
+	var v gobject.Value
+	x.GetProperty("local-address", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SocketAddress{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *SocketClient) SetPropertyProtocol(value SocketProtocol) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("protocol", &v)
+}
+
+func (x *SocketClient) GetPropertyProtocol() SocketProtocol {
+	var v gobject.Value
+	x.GetProperty("protocol", &v)
+	return SocketProtocol(v.GetEnum())
+}
+
+// The proxy resolver to use
+
+func (x *SocketClient) SetPropertyProxyResolver(value ProxyResolver) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("proxy-resolver", &v)
+}
+
+func (x *SocketClient) GetPropertyProxyResolver() ProxyResolver {
+	var v gobject.Value
+	x.GetProperty("proxy-resolver", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ProxyResolverBase{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *SocketClient) SetPropertyTimeout(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("timeout", &v)
+}
+
+func (x *SocketClient) GetPropertyTimeout() uint {
+	var v gobject.Value
+	x.GetProperty("timeout", &v)
+	return v.GetUint()
+}
+
+func (x *SocketClient) SetPropertyTls(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("tls", &v)
+}
+
+func (x *SocketClient) GetPropertyTls() bool {
+	var v gobject.Value
+	x.GetProperty("tls", &v)
+	return v.GetBoolean()
+}
+
+// The TLS validation flags used when creating TLS connections. The
+// default value is %G_TLS_CERTIFICATE_VALIDATE_ALL.
+//
+// GLib guarantees that if certificate verification fails, at least one
+// flag will be set, but it does not guarantee that all possible flags
+// will be set. Accordingly, you may not safely decide to ignore any
+// particular type of error. For example, it would be incorrect to mask
+// %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
+// because this could potentially be the only error flag set even if
+// other problems exist with the certificate. Therefore, there is no
+// safe way to use this property. This is not a horrible problem,
+// though, because you should not be attempting to ignore validation
+// errors anyway. If you really must ignore TLS certificate errors,
+// connect to the #GSocketClient::event signal, wait for it to be
+// emitted with %G_SOCKET_CLIENT_TLS_HANDSHAKING, and use that to
+// connect to #GTlsConnection::accept-certificate.
+
+func (x *SocketClient) SetPropertyTlsValidationFlags(value TlsCertificateFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("tls-validation-flags", &v)
+}
+
+func (x *SocketClient) GetPropertyTlsValidationFlags() TlsCertificateFlags {
+	var v gobject.Value
+	x.GetProperty("tls-validation-flags", &v)
+	return TlsCertificateFlags(v.GetFlags())
+}
+
+func (x *SocketClient) SetPropertyType(value SocketType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("type", &v)
+}
+
+func (x *SocketClient) GetPropertyType() SocketType {
+	var v gobject.Value
+	x.GetProperty("type", &v)
+	return SocketType(v.GetEnum())
+}
+
 // Emitted when @client's activity on @connectable changes state.
 // Among other things, this can be used to provide progress
 // information about a network connection in the UI. The meanings of
diff --git a/v4/gio/gsocketconnection.go b/v4/gio/gsocketconnection.go
index 96b86b78988ee233ac320e2c5b9c58d3e6e030bf..a177a1e20e283f8d6e6d0eccff7d57b0fdbb8641 100644
--- a/v4/gio/gsocketconnection.go
+++ b/v4/gio/gsocketconnection.go
@@ -343,6 +343,25 @@ func (c *SocketConnection) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *SocketConnection) SetPropertySocket(value *Socket) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("socket", &v)
+}
+
+func (x *SocketConnection) GetPropertySocket() *Socket {
+	var v gobject.Value
+	x.GetProperty("socket", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Socket{}
+	result.Ptr = ptr
+	return result
+}
+
 var xSocketConnectionFactoryLookupType func(SocketFamily, SocketType, int) types.GType
 
 // Looks up the #GType to be used when creating socket connections on
diff --git a/v4/gio/gsocketlistener.go b/v4/gio/gsocketlistener.go
index 5f5a4debaad6f1dc2bcf172214244fae7c309de3..b2eccebd065a2aa83e784863a120a724632a82f8 100644
--- a/v4/gio/gsocketlistener.go
+++ b/v4/gio/gsocketlistener.go
@@ -530,6 +530,19 @@ func (c *SocketListener) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *SocketListener) SetPropertyListenBacklog(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("listen-backlog", &v)
+}
+
+func (x *SocketListener) GetPropertyListenBacklog() int {
+	var v gobject.Value
+	x.GetProperty("listen-backlog", &v)
+	return v.GetInt()
+}
+
 // Emitted when @listener's activity on @socket changes state.
 // Note that when @listener is used to listen on both IPv4 and
 // IPv6, a separate set of signals will be emitted for each, and
diff --git a/v4/gio/gsocketservice.go b/v4/gio/gsocketservice.go
index ea75a6e96943cc752ff49867a202bf8e8875fac7..7b6831fd4be7db5c91cef3281a0f0f304b35d59c 100644
--- a/v4/gio/gsocketservice.go
+++ b/v4/gio/gsocketservice.go
@@ -331,6 +331,21 @@ func (c *SocketService) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the service is currently accepting connections.
+
+func (x *SocketService) SetPropertyActive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("active", &v)
+}
+
+func (x *SocketService) GetPropertyActive() bool {
+	var v gobject.Value
+	x.GetProperty("active", &v)
+	return v.GetBoolean()
+}
+
 // The ::incoming signal is emitted when a new incoming connection
 // to @service needs to be handled. The handler must initiate the
 // handling of @connection, but may not block; in essence,
diff --git a/v4/gio/gtask.go b/v4/gio/gtask.go
index 607d26dc0fc7ff450cf47de44551ee96c7c24365..d41e59e0e36929ddd68ad466534a7ef2feadd30d 100644
--- a/v4/gio/gtask.go
+++ b/v4/gio/gtask.go
@@ -1102,6 +1102,22 @@ func (c *Task) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the task has completed, meaning its callback (if set) has been
+// invoked. This can only happen after g_task_return_pointer(),
+// g_task_return_error() or one of the other return functions have been called
+// on the task.
+//
+// This property is guaranteed to change from %FALSE to %TRUE exactly once.
+//
+// The #GObject::notify signal for this change is emitted in the same main
+// context as the taskâs callback, immediately after that callback is invoked.
+
+func (x *Task) GetPropertyCompleted() bool {
+	var v gobject.Value
+	x.GetProperty("completed", &v)
+	return v.GetBoolean()
+}
+
 // Gets the user data from a #GAsyncResult.
 func (x *Task) GetUserData() uintptr {
 
diff --git a/v4/gio/gtcpconnection.go b/v4/gio/gtcpconnection.go
index d9b4e16cebc3ead64ae81dfd36506776bc957576..043a9b8164878de49c64277072f361bccd6bc330 100644
--- a/v4/gio/gtcpconnection.go
+++ b/v4/gio/gtcpconnection.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -82,6 +83,19 @@ }
 
 func (c *TcpConnection) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+func (x *TcpConnection) SetPropertyGracefulDisconnect(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("graceful-disconnect", &v)
+}
+
+func (x *TcpConnection) GetPropertyGracefulDisconnect() bool {
+	var v gobject.Value
+	x.GetProperty("graceful-disconnect", &v)
+	return v.GetBoolean()
 }
 
 func init() {
diff --git a/v4/gio/gtcpwrapperconnection.go b/v4/gio/gtcpwrapperconnection.go
index 3468807675375a3e6406e73b0e5ee39d51d191f2..ab9dc5d9bed69481d242c08b589179dc3b3fba69 100644
--- a/v4/gio/gtcpwrapperconnection.go
+++ b/v4/gio/gtcpwrapperconnection.go
@@ -94,6 +94,25 @@ func (c *TcpWrapperConnection) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *TcpWrapperConnection) SetPropertyBaseIoStream(value *IOStream) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("base-io-stream", &v)
+}
+
+func (x *TcpWrapperConnection) GetPropertyBaseIoStream() *IOStream {
+	var v gobject.Value
+	x.GetProperty("base-io-stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &IOStream{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GIO", "gio-2.0")
diff --git a/v4/gio/gthemedicon.go b/v4/gio/gthemedicon.go
index 00c1cd69a4f04948109a4a031e2bbbfdc8981bba..c44d6f66cb6e32875ed8c0414b2cb1cdbc61d759 100644
--- a/v4/gio/gthemedicon.go
+++ b/v4/gio/gthemedicon.go
@@ -150,6 +150,56 @@ func (c *ThemedIcon) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The icon name.
+
+func (x *ThemedIcon) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+// A %NULL-terminated array of icon names.
+
+func (x *ThemedIcon) SetPropertyNames(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *ThemedIcon) GetPropertyNames() []string {
+	var v gobject.Value
+	x.GetProperty("names", &v)
+	return nil
+}
+
+// Whether to use the default fallbacks found by shortening the icon name
+// at '-' characters. If the "names" array has more than one element,
+// ignores any past the first.
+//
+// For example, if the icon name was "gnome-dev-cdrom-audio", the array
+// would become
+// |[&lt;!-- language="C" --&gt;
+// {
+//   "gnome-dev-cdrom-audio",
+//   "gnome-dev-cdrom",
+//   "gnome-dev",
+//   "gnome",
+//   NULL
+// };
+// ]|
+
+func (x *ThemedIcon) SetPropertyUseDefaultFallbacks(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-default-fallbacks", &v)
+}
+
+func (x *ThemedIcon) GetPropertyUseDefaultFallbacks() bool {
+	var v gobject.Value
+	x.GetProperty("use-default-fallbacks", &v)
+	return v.GetBoolean()
+}
+
 // Checks if two icons are equal.
 func (x *ThemedIcon) Equal(Icon2Var Icon) bool {
 
diff --git a/v4/gio/gthreadedsocketservice.go b/v4/gio/gthreadedsocketservice.go
index d83e04ebaf6d21adea39ff8c7f4c1b6c5b23092f..35370875e3d2c87bc9add28b26170dca280d9444 100644
--- a/v4/gio/gthreadedsocketservice.go
+++ b/v4/gio/gthreadedsocketservice.go
@@ -239,6 +239,19 @@ func (c *ThreadedSocketService) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *ThreadedSocketService) SetPropertyMaxThreads(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-threads", &v)
+}
+
+func (x *ThreadedSocketService) GetPropertyMaxThreads() int {
+	var v gobject.Value
+	x.GetProperty("max-threads", &v)
+	return v.GetInt()
+}
+
 // The ::run signal is emitted in a worker thread in response to an
 // incoming connection. This thread is dedicated to handling
 // @connection and may perform blocking IO. The signal handler need
diff --git a/v4/gio/gtlscertificate.go b/v4/gio/gtlscertificate.go
index 768cdf126a2a51062e13ad923e9e56f86514ed83..bd91f513dab0c9886639759251c1dec07fa5066f 100644
--- a/v4/gio/gtlscertificate.go
+++ b/v4/gio/gtlscertificate.go
@@ -421,6 +421,239 @@ func (c *TlsCertificate) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The DER (binary) encoded representation of the certificate.
+// This property and the #GTlsCertificate:certificate-pem property
+// represent the same data, just in different forms.
+
+func (x *TlsCertificate) SetPropertyCertificate(value []byte) {
+	// Slice/array properties not supported
+}
+
+func (x *TlsCertificate) GetPropertyCertificate() []byte {
+	var v gobject.Value
+	x.GetProperty("certificate", &v)
+	return nil
+}
+
+// The PEM (ASCII) encoded representation of the certificate.
+// This property and the #GTlsCertificate:certificate
+// property represent the same data, just in different forms.
+
+func (x *TlsCertificate) SetPropertyCertificatePem(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("certificate-pem", &v)
+}
+
+func (x *TlsCertificate) GetPropertyCertificatePem() string {
+	var v gobject.Value
+	x.GetProperty("certificate-pem", &v)
+	return v.GetString()
+}
+
+// The DNS names from the certificate's Subject Alternative Names (SANs),
+// %NULL if unavailable.
+
+func (x *TlsCertificate) GetPropertyDnsNames() []uintptr {
+	var v gobject.Value
+	x.GetProperty("dns-names", &v)
+	return nil
+}
+
+// The IP addresses from the certificate's Subject Alternative Names (SANs),
+// %NULL if unavailable.
+
+func (x *TlsCertificate) GetPropertyIpAddresses() []uintptr {
+	var v gobject.Value
+	x.GetProperty("ip-addresses", &v)
+	return nil
+}
+
+// A #GTlsCertificate representing the entity that issued this
+// certificate. If %NULL, this means that the certificate is either
+// self-signed, or else the certificate of the issuer is not
+// available.
+//
+// Beware the issuer certificate may not be the same as the
+// certificate that would actually be used to construct a valid
+// certification path during certificate verification.
+// [RFC 4158](https://datatracker.ietf.org/doc/html/rfc4158) explains
+// why an issuer certificate cannot be naively assumed to be part of the
+// the certification path (though GLib's TLS backends may not follow the
+// path building strategies outlined in this RFC). Due to the complexity
+// of certification path building, GLib does not provide any way to know
+// which certification path will actually be used. Accordingly, this
+// property cannot be used to make security-related decisions. Only
+// GLib itself should make security decisions about TLS certificates.
+
+func (x *TlsCertificate) SetPropertyIssuer(value *TlsCertificate) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("issuer", &v)
+}
+
+func (x *TlsCertificate) GetPropertyIssuer() *TlsCertificate {
+	var v gobject.Value
+	x.GetProperty("issuer", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TlsCertificate{}
+	result.Ptr = ptr
+	return result
+}
+
+// The issuer from the certificate,
+// %NULL if unavailable.
+
+func (x *TlsCertificate) GetPropertyIssuerName() string {
+	var v gobject.Value
+	x.GetProperty("issuer-name", &v)
+	return v.GetString()
+}
+
+// The time at which this cert is no longer valid,
+// %NULL if unavailable.
+
+func (x *TlsCertificate) GetPropertyNotValidAfter() uintptr {
+	var v gobject.Value
+	x.GetProperty("not-valid-after", &v)
+	return v.GetPointer()
+}
+
+// The time at which this cert is considered to be valid,
+// %NULL if unavailable.
+
+func (x *TlsCertificate) GetPropertyNotValidBefore() uintptr {
+	var v gobject.Value
+	x.GetProperty("not-valid-before", &v)
+	return v.GetPointer()
+}
+
+// An optional password used when constructed with GTlsCertificate:pkcs12-data.
+
+func (x *TlsCertificate) SetPropertyPassword(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("password", &v)
+}
+
+// A URI referencing the [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
+// objects containing an X.509 certificate and optionally a private key.
+//
+// If %NULL, the certificate is either not backed by PKCS \#11 or the
+// #GTlsBackend does not support PKCS \#11.
+
+func (x *TlsCertificate) SetPropertyPkcs11Uri(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("pkcs11-uri", &v)
+}
+
+func (x *TlsCertificate) GetPropertyPkcs11Uri() string {
+	var v gobject.Value
+	x.GetProperty("pkcs11-uri", &v)
+	return v.GetString()
+}
+
+// The PKCS #12 formatted data used to construct the object.
+//
+// See also: g_tls_certificate_new_from_pkcs12()
+
+func (x *TlsCertificate) SetPropertyPkcs12Data(value []byte) {
+	// Slice/array properties not supported
+}
+
+// The DER (binary) encoded representation of the certificate's
+// private key, in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
+// or unencrypted [PKCS \#8 format.](https://datatracker.ietf.org/doc/html/rfc5208)
+// PKCS \#8 format is supported since 2.32; earlier releases only
+// support PKCS \#1. You can use the `openssl rsa` tool to convert
+// PKCS \#8 keys to PKCS \#1.
+//
+// This property (or the #GTlsCertificate:private-key-pem property)
+// can be set when constructing a key (for example, from a file).
+// Since GLib 2.70, it is now also readable; however, be aware that if
+// the private key is backed by a PKCS \#11 URI â for example, if it
+// is stored on a smartcard â then this property will be %NULL. If so,
+// the private key must be referenced via its PKCS \#11 URI,
+// #GTlsCertificate:private-key-pkcs11-uri. You must check both
+// properties to see if the certificate really has a private key.
+// When this property is read, the output format will be unencrypted
+// PKCS \#8.
+
+func (x *TlsCertificate) SetPropertyPrivateKey(value []byte) {
+	// Slice/array properties not supported
+}
+
+func (x *TlsCertificate) GetPropertyPrivateKey() []byte {
+	var v gobject.Value
+	x.GetProperty("private-key", &v)
+	return nil
+}
+
+// The PEM (ASCII) encoded representation of the certificate's
+// private key in either [PKCS \#1 format](https://datatracker.ietf.org/doc/html/rfc8017)
+// ("`BEGIN RSA PRIVATE KEY`") or unencrypted
+// [PKCS \#8 format](https://datatracker.ietf.org/doc/html/rfc5208)
+// ("`BEGIN PRIVATE KEY`"). PKCS \#8 format is supported since 2.32;
+// earlier releases only support PKCS \#1. You can use the `openssl rsa`
+// tool to convert PKCS \#8 keys to PKCS \#1.
+//
+// This property (or the #GTlsCertificate:private-key property)
+// can be set when constructing a key (for example, from a file).
+// Since GLib 2.70, it is now also readable; however, be aware that if
+// the private key is backed by a PKCS \#11 URI - for example, if it
+// is stored on a smartcard - then this property will be %NULL. If so,
+// the private key must be referenced via its PKCS \#11 URI,
+// #GTlsCertificate:private-key-pkcs11-uri. You must check both
+// properties to see if the certificate really has a private key.
+// When this property is read, the output format will be unencrypted
+// PKCS \#8.
+
+func (x *TlsCertificate) SetPropertyPrivateKeyPem(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("private-key-pem", &v)
+}
+
+func (x *TlsCertificate) GetPropertyPrivateKeyPem() string {
+	var v gobject.Value
+	x.GetProperty("private-key-pem", &v)
+	return v.GetString()
+}
+
+// A URI referencing a [PKCS \#11](https://docs.oasis-open.org/pkcs11/pkcs11-base/v3.0/os/pkcs11-base-v3.0-os.html)
+// object containing a private key.
+
+func (x *TlsCertificate) SetPropertyPrivateKeyPkcs11Uri(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("private-key-pkcs11-uri", &v)
+}
+
+func (x *TlsCertificate) GetPropertyPrivateKeyPkcs11Uri() string {
+	var v gobject.Value
+	x.GetProperty("private-key-pkcs11-uri", &v)
+	return v.GetString()
+}
+
+// The subject from the cert,
+// %NULL if unavailable.
+
+func (x *TlsCertificate) GetPropertySubjectName() string {
+	var v gobject.Value
+	x.GetProperty("subject-name", &v)
+	return v.GetString()
+}
+
 var xTlsCertificateListNewFromFile func(string, **glib.Error) *glib.List
 
 // Creates one or more #GTlsCertificates from the PEM-encoded
diff --git a/v4/gio/gtlsclientconnection.go b/v4/gio/gtlsclientconnection.go
index 8f1de2e44d7454d1722f93ed5fdc98d64b273745..2ceff998c332c15eceec45a1870dda599aac6ba2 100644
--- a/v4/gio/gtlsclientconnection.go
+++ b/v4/gio/gtlsclientconnection.go
@@ -204,6 +204,111 @@ 	XGTlsClientConnectionSetValidationFlags(x.GoPointer(), FlagsVar)
 
 }
 
+// A list of the distinguished names of the Certificate Authorities
+// that the server will accept client certificates signed by. If the
+// server requests a client certificate during the handshake, then
+// this property will be set after the handshake completes.
+//
+// Each item in the list is a #GByteArray which contains the complete
+// subject DN of the certificate authority.
+
+func (x *TlsClientConnectionBase) GetPropertyAcceptedCas() *glib.List {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("accepted-cas", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	return (*glib.List)(unsafe.Pointer(ptr))
+}
+
+// A #GSocketConnectable describing the identity of the server that
+// is expected on the other end of the connection.
+//
+// If the %G_TLS_CERTIFICATE_BAD_IDENTITY flag is set in
+// #GTlsClientConnection:validation-flags, this object will be used
+// to determine the expected identify of the remote end of the
+// connection; if #GTlsClientConnection:server-identity is not set,
+// or does not match the identity presented by the server, then the
+// %G_TLS_CERTIFICATE_BAD_IDENTITY validation will fail.
+//
+// In addition to its use in verifying the server certificate,
+// this is also used to give a hint to the server about what
+// certificate we expect, which is useful for servers that serve
+// virtual hosts.
+
+func (x *TlsClientConnectionBase) SetPropertyServerIdentity(value SocketConnectable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("server-identity", &v)
+}
+
+func (x *TlsClientConnectionBase) GetPropertyServerIdentity() SocketConnectable {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("server-identity", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SocketConnectableBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// SSL 3.0 is no longer supported. See
+// g_tls_client_connection_set_use_ssl3() for details.
+
+func (x *TlsClientConnectionBase) SetPropertyUseSsl3(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("use-ssl3", &v)
+}
+
+func (x *TlsClientConnectionBase) GetPropertyUseSsl3() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("use-ssl3", &v)
+	return v.GetBoolean()
+}
+
+// What steps to perform when validating a certificate received from
+// a server. Server certificates that fail to validate in any of the
+// ways indicated here will be rejected unless the application
+// overrides the default via #GTlsConnection::accept-certificate.
+//
+// GLib guarantees that if certificate verification fails, at least one
+// flag will be set, but it does not guarantee that all possible flags
+// will be set. Accordingly, you may not safely decide to ignore any
+// particular type of error. For example, it would be incorrect to mask
+// %G_TLS_CERTIFICATE_EXPIRED if you want to allow expired certificates,
+// because this could potentially be the only error flag set even if
+// other problems exist with the certificate. Therefore, there is no
+// safe way to use this property. This is not a horrible problem,
+// though, because you should not be attempting to ignore validation
+// errors anyway. If you really must ignore TLS certificate errors,
+// connect to #GTlsConnection::accept-certificate.
+
+func (x *TlsClientConnectionBase) SetPropertyValidationFlags(value TlsCertificateFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("validation-flags", &v)
+}
+
+func (x *TlsClientConnectionBase) GetPropertyValidationFlags() TlsCertificateFlags {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("validation-flags", &v)
+	return TlsCertificateFlags(v.GetFlags())
+}
+
 var XGTlsClientConnectionCopySessionState func(uintptr, uintptr)
 var XGTlsClientConnectionGetAcceptedCas func(uintptr) *glib.List
 var XGTlsClientConnectionGetServerIdentity func(uintptr) uintptr
diff --git a/v4/gio/gtlsconnection.go b/v4/gio/gtlsconnection.go
index 92de57338d03c80ae9d51a208368b19ac1704b60..ec3d0b41778e03340b1a5446d267b189671a3f00 100644
--- a/v4/gio/gtlsconnection.go
+++ b/v4/gio/gtlsconnection.go
@@ -621,6 +621,240 @@ func (c *TlsConnection) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The list of application-layer protocols that the connection
+// advertises that it is willing to speak. See
+// g_tls_connection_set_advertised_protocols().
+
+func (x *TlsConnection) SetPropertyAdvertisedProtocols(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *TlsConnection) GetPropertyAdvertisedProtocols() []string {
+	var v gobject.Value
+	x.GetProperty("advertised-protocols", &v)
+	return nil
+}
+
+// The #GIOStream that the connection wraps. The connection holds a reference
+// to this stream, and may run operations on the stream from other threads
+// throughout its lifetime. Consequently, after the #GIOStream has been
+// constructed, application code may only run its own operations on this
+// stream when no #GIOStream operations are running.
+
+func (x *TlsConnection) SetPropertyBaseIoStream(value *IOStream) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("base-io-stream", &v)
+}
+
+func (x *TlsConnection) GetPropertyBaseIoStream() *IOStream {
+	var v gobject.Value
+	x.GetProperty("base-io-stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &IOStream{}
+	result.Ptr = ptr
+	return result
+}
+
+// The connection's certificate; see
+// g_tls_connection_set_certificate().
+
+func (x *TlsConnection) SetPropertyCertificate(value *TlsCertificate) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("certificate", &v)
+}
+
+func (x *TlsConnection) GetPropertyCertificate() *TlsCertificate {
+	var v gobject.Value
+	x.GetProperty("certificate", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TlsCertificate{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the TLS ciphersuite in use. See g_tls_connection_get_ciphersuite_name().
+
+func (x *TlsConnection) GetPropertyCiphersuiteName() string {
+	var v gobject.Value
+	x.GetProperty("ciphersuite-name", &v)
+	return v.GetString()
+}
+
+// The certificate database to use when verifying this TLS connection.
+// If no certificate database is set, then the default database will be
+// used. See g_tls_backend_get_default_database().
+//
+// When using a non-default database, #GTlsConnection must fall back to using
+// the #GTlsDatabase to perform certificate verification using
+// g_tls_database_verify_chain(), which means certificate verification will
+// not be able to make use of TLS session context. This may be less secure.
+// For example, if you create your own #GTlsDatabase that just wraps the
+// default #GTlsDatabase, you might expect that you have not changed anything,
+// but this is not true because you may have altered the behavior of
+// #GTlsConnection by causing it to use g_tls_database_verify_chain(). See the
+// documentation of g_tls_database_verify_chain() for more details on specific
+// security checks that may not be performed. Accordingly, setting a
+// non-default database is discouraged except for specialty applications with
+// unusual security requirements.
+
+func (x *TlsConnection) SetPropertyDatabase(value *TlsDatabase) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("database", &v)
+}
+
+func (x *TlsConnection) GetPropertyDatabase() *TlsDatabase {
+	var v gobject.Value
+	x.GetProperty("database", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TlsDatabase{}
+	result.Ptr = ptr
+	return result
+}
+
+// A #GTlsInteraction object to be used when the connection or certificate
+// database need to interact with the user. This will be used to prompt the
+// user for passwords where necessary.
+
+func (x *TlsConnection) SetPropertyInteraction(value *TlsInteraction) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("interaction", &v)
+}
+
+func (x *TlsConnection) GetPropertyInteraction() *TlsInteraction {
+	var v gobject.Value
+	x.GetProperty("interaction", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TlsInteraction{}
+	result.Ptr = ptr
+	return result
+}
+
+// The application-layer protocol negotiated during the TLS
+// handshake. See g_tls_connection_get_negotiated_protocol().
+
+func (x *TlsConnection) GetPropertyNegotiatedProtocol() string {
+	var v gobject.Value
+	x.GetProperty("negotiated-protocol", &v)
+	return v.GetString()
+}
+
+// The connection's peer's certificate, after the TLS handshake has
+// completed or failed. Note in particular that this is not yet set
+// during the emission of #GTlsConnection::accept-certificate.
+//
+// (You can watch for a #GObject::notify signal on this property to
+// detect when a handshake has occurred.)
+
+func (x *TlsConnection) GetPropertyPeerCertificate() *TlsCertificate {
+	var v gobject.Value
+	x.GetProperty("peer-certificate", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TlsCertificate{}
+	result.Ptr = ptr
+	return result
+}
+
+// The errors noticed while verifying
+// #GTlsConnection:peer-certificate. Normally this should be 0, but
+// it may not be if #GTlsClientConnection:validation-flags is not
+// %G_TLS_CERTIFICATE_VALIDATE_ALL, or if
+// #GTlsConnection::accept-certificate overrode the default
+// behavior.
+//
+// GLib guarantees that if certificate verification fails, at least
+// one error will be set, but it does not guarantee that all possible
+// errors will be set. Accordingly, you may not safely decide to
+// ignore any particular type of error. For example, it would be
+// incorrect to mask %G_TLS_CERTIFICATE_EXPIRED if you want to allow
+// expired certificates, because this could potentially be the only
+// error flag set even if other problems exist with the certificate.
+
+func (x *TlsConnection) GetPropertyPeerCertificateErrors() TlsCertificateFlags {
+	var v gobject.Value
+	x.GetProperty("peer-certificate-errors", &v)
+	return TlsCertificateFlags(v.GetFlags())
+}
+
+// The TLS protocol version in use. See g_tls_connection_get_protocol_version().
+
+func (x *TlsConnection) GetPropertyProtocolVersion() TlsProtocolVersion {
+	var v gobject.Value
+	x.GetProperty("protocol-version", &v)
+	return TlsProtocolVersion(v.GetEnum())
+}
+
+// The rehandshaking mode. See
+// g_tls_connection_set_rehandshake_mode().
+
+func (x *TlsConnection) SetPropertyRehandshakeMode(value TlsRehandshakeMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("rehandshake-mode", &v)
+}
+
+func (x *TlsConnection) GetPropertyRehandshakeMode() TlsRehandshakeMode {
+	var v gobject.Value
+	x.GetProperty("rehandshake-mode", &v)
+	return TlsRehandshakeMode(v.GetEnum())
+}
+
+// Whether or not proper TLS close notification is required.
+// See g_tls_connection_set_require_close_notify().
+
+func (x *TlsConnection) SetPropertyRequireCloseNotify(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("require-close-notify", &v)
+}
+
+func (x *TlsConnection) GetPropertyRequireCloseNotify() bool {
+	var v gobject.Value
+	x.GetProperty("require-close-notify", &v)
+	return v.GetBoolean()
+}
+
+// Whether or not the system certificate database will be used to
+// verify peer certificates. See
+// g_tls_connection_set_use_system_certdb().
+
+func (x *TlsConnection) SetPropertyUseSystemCertdb(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-system-certdb", &v)
+}
+
+func (x *TlsConnection) GetPropertyUseSystemCertdb() bool {
+	var v gobject.Value
+	x.GetProperty("use-system-certdb", &v)
+	return v.GetBoolean()
+}
+
 // Emitted during the TLS handshake after the peer certificate has
 // been received. You can examine @peer_cert's certification path by
 // calling g_tls_certificate_get_issuer() on it.
diff --git a/v4/gio/gtlsfiledatabase.go b/v4/gio/gtlsfiledatabase.go
index c1bdc86383465e21a3df161acac770eb40cb4768..e134d69bcf449de8b0ee8252d2f83b2edbb29938 100644
--- a/v4/gio/gtlsfiledatabase.go
+++ b/v4/gio/gtlsfiledatabase.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -51,6 +52,26 @@ }
 
 func (x *TlsFileDatabaseBase) SetGoPointer(ptr uintptr) {
 	x.Ptr = ptr
+}
+
+// The path to a file containing PEM encoded certificate authority
+// root anchors. The certificates in this file will be treated as
+// root authorities for the purpose of verifying other certificates
+// via the g_tls_database_verify_chain() operation.
+
+func (x *TlsFileDatabaseBase) SetPropertyAnchors(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("anchors", &v)
+}
+
+func (x *TlsFileDatabaseBase) GetPropertyAnchors() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("anchors", &v)
+	return v.GetString()
 }
 
 var xTlsFileDatabaseNew func(string, **glib.Error) uintptr
diff --git a/v4/gio/gtlspassword.go b/v4/gio/gtlspassword.go
index 1a91bda0c86773da4ce0c178cecb57a33758431f..e588f6543ef4d1b4e2d2e9c4b2ef5d44e126ca57 100644
--- a/v4/gio/gtlspassword.go
+++ b/v4/gio/gtlspassword.go
@@ -255,6 +255,45 @@ func (c *TlsPassword) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *TlsPassword) SetPropertyDescription(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("description", &v)
+}
+
+func (x *TlsPassword) GetPropertyDescription() string {
+	var v gobject.Value
+	x.GetProperty("description", &v)
+	return v.GetString()
+}
+
+func (x *TlsPassword) SetPropertyFlags(value TlsPasswordFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("flags", &v)
+}
+
+func (x *TlsPassword) GetPropertyFlags() TlsPasswordFlags {
+	var v gobject.Value
+	x.GetProperty("flags", &v)
+	return TlsPasswordFlags(v.GetFlags())
+}
+
+func (x *TlsPassword) SetPropertyWarning(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("warning", &v)
+}
+
+func (x *TlsPassword) GetPropertyWarning() string {
+	var v gobject.Value
+	x.GetProperty("warning", &v)
+	return v.GetString()
+}
+
 func init() {
 
 	core.SetPackageName("GIO", "gio-2.0")
diff --git a/v4/gio/gtlsserverconnection.go b/v4/gio/gtlsserverconnection.go
index 08867d2cff6287ff9a46ded486a12e1dc467e104..04a39ba2255d378aae00319f705af248282b2065 100644
--- a/v4/gio/gtlsserverconnection.go
+++ b/v4/gio/gtlsserverconnection.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -48,6 +49,25 @@ }
 
 func (x *TlsServerConnectionBase) SetGoPointer(ptr uintptr) {
 	x.Ptr = ptr
+}
+
+// The #GTlsAuthenticationMode for the server. This can be changed
+// before calling g_tls_connection_handshake() if you want to
+// rehandshake with a different mode from the initial handshake.
+
+func (x *TlsServerConnectionBase) SetPropertyAuthenticationMode(value TlsAuthenticationMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("authentication-mode", &v)
+}
+
+func (x *TlsServerConnectionBase) GetPropertyAuthenticationMode() TlsAuthenticationMode {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("authentication-mode", &v)
+	return TlsAuthenticationMode(v.GetEnum())
 }
 
 var xTlsServerConnectionNew func(uintptr, uintptr, **glib.Error) uintptr
diff --git a/v4/gio/gunixcredentialsmessage.go b/v4/gio/gunixcredentialsmessage.go
index 427c109614704b6f463e66f62995d6c07b2dcc3a..f969640176c751365d6aaf87914652f1885b7f4c 100644
--- a/v4/gio/gunixcredentialsmessage.go
+++ b/v4/gio/gunixcredentialsmessage.go
@@ -175,6 +175,27 @@ func (c *UnixCredentialsMessage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The credentials stored in the message.
+
+func (x *UnixCredentialsMessage) SetPropertyCredentials(value *Credentials) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("credentials", &v)
+}
+
+func (x *UnixCredentialsMessage) GetPropertyCredentials() *Credentials {
+	var v gobject.Value
+	x.GetProperty("credentials", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Credentials{}
+	result.Ptr = ptr
+	return result
+}
+
 var xUnixCredentialsMessageIsSupported func() bool
 
 // Checks if passing #GCredentials on a #GSocket is supported on this platform.
diff --git a/v4/gio/gunixfdmessage.go b/v4/gio/gunixfdmessage.go
index 24673f936ff7c60b0e273b353fb08abb04684483..281c5661fceb4a568c2707f1fa5125520bf83f3f 100644
--- a/v4/gio/gunixfdmessage.go
+++ b/v4/gio/gunixfdmessage.go
@@ -218,6 +218,25 @@ func (c *UnixFDMessage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *UnixFDMessage) SetPropertyFdList(value *UnixFDList) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("fd-list", &v)
+}
+
+func (x *UnixFDMessage) GetPropertyFdList() *UnixFDList {
+	var v gobject.Value
+	x.GetProperty("fd-list", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &UnixFDList{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GIO", "gio-2.0")
diff --git a/v4/gio/gunixinputstream.go b/v4/gio/gunixinputstream.go
index fa99374bc308b66f75689e36c1ff30416429227f..907656a479cee12a952b10cf91d01a639a13693e 100644
--- a/v4/gio/gunixinputstream.go
+++ b/v4/gio/gunixinputstream.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -236,6 +237,36 @@ }
 
 func (c *UnixInputStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Whether to close the file descriptor when the stream is closed.
+
+func (x *UnixInputStream) SetPropertyCloseFd(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("close-fd", &v)
+}
+
+func (x *UnixInputStream) GetPropertyCloseFd() bool {
+	var v gobject.Value
+	x.GetProperty("close-fd", &v)
+	return v.GetBoolean()
+}
+
+// The file descriptor that the stream reads from.
+
+func (x *UnixInputStream) SetPropertyFd(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("fd", &v)
+}
+
+func (x *UnixInputStream) GetPropertyFd() int {
+	var v gobject.Value
+	x.GetProperty("fd", &v)
+	return v.GetInt()
 }
 
 // Checks if @stream is actually pollable. Some classes may implement
diff --git a/v4/gio/gunixoutputstream.go b/v4/gio/gunixoutputstream.go
index 58d1894bd92286044c0039b387e8d8cef03df2ff..243a67f75902bf0de5177f5e64e3612681ee5e55 100644
--- a/v4/gio/gunixoutputstream.go
+++ b/v4/gio/gunixoutputstream.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -236,6 +237,36 @@ }
 
 func (c *UnixOutputStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Whether to close the file descriptor when the stream is closed.
+
+func (x *UnixOutputStream) SetPropertyCloseFd(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("close-fd", &v)
+}
+
+func (x *UnixOutputStream) GetPropertyCloseFd() bool {
+	var v gobject.Value
+	x.GetProperty("close-fd", &v)
+	return v.GetBoolean()
+}
+
+// The file descriptor that the stream writes to.
+
+func (x *UnixOutputStream) SetPropertyFd(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("fd", &v)
+}
+
+func (x *UnixOutputStream) GetPropertyFd() int {
+	var v gobject.Value
+	x.GetProperty("fd", &v)
+	return v.GetInt()
 }
 
 // Checks if @stream is actually pollable. Some classes may implement
diff --git a/v4/gio/gunixsocketaddress.go b/v4/gio/gunixsocketaddress.go
index 533895e94ca9bdc641a486b909cc82be71ea154d..4f1e2c371c753197407fdf96c93fc06259508b63 100644
--- a/v4/gio/gunixsocketaddress.go
+++ b/v4/gio/gunixsocketaddress.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -196,6 +197,57 @@ }
 
 func (c *UnixSocketAddress) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Whether or not this is an abstract address
+
+func (x *UnixSocketAddress) SetPropertyAbstract(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("abstract", &v)
+}
+
+func (x *UnixSocketAddress) GetPropertyAbstract() bool {
+	var v gobject.Value
+	x.GetProperty("abstract", &v)
+	return v.GetBoolean()
+}
+
+func (x *UnixSocketAddress) SetPropertyAddressType(value UnixSocketAddressType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("address-type", &v)
+}
+
+func (x *UnixSocketAddress) GetPropertyAddressType() UnixSocketAddressType {
+	var v gobject.Value
+	x.GetProperty("address-type", &v)
+	return UnixSocketAddressType(v.GetEnum())
+}
+
+func (x *UnixSocketAddress) SetPropertyPath(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("path", &v)
+}
+
+func (x *UnixSocketAddress) GetPropertyPath() string {
+	var v gobject.Value
+	x.GetProperty("path", &v)
+	return v.GetString()
+}
+
+func (x *UnixSocketAddress) SetPropertyPathAsArray(value []byte) {
+	// Slice/array properties not supported
+}
+
+func (x *UnixSocketAddress) GetPropertyPathAsArray() []byte {
+	var v gobject.Value
+	x.GetProperty("path-as-array", &v)
+	return nil
 }
 
 // Creates a #GSocketAddressEnumerator for @connectable.
diff --git a/v4/gio/gzlibcompressor.go b/v4/gio/gzlibcompressor.go
index 0aaf3ef1c3314253d33fbc007a99960dddc3e998..cd8c9ca6fc2e6b99091d303bb86a8b1a16429a6b 100644
--- a/v4/gio/gzlibcompressor.go
+++ b/v4/gio/gzlibcompressor.go
@@ -100,6 +100,55 @@ func (c *ZlibCompressor) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If set to a non-%NULL #GFileInfo object, and #GZlibCompressor:format is
+// %G_ZLIB_COMPRESSOR_FORMAT_GZIP, the compressor will write the file name
+// and modification time from the file info to the GZIP header.
+
+func (x *ZlibCompressor) SetPropertyFileInfo(value *FileInfo) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("file-info", &v)
+}
+
+func (x *ZlibCompressor) GetPropertyFileInfo() *FileInfo {
+	var v gobject.Value
+	x.GetProperty("file-info", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &FileInfo{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *ZlibCompressor) SetPropertyFormat(value ZlibCompressorFormat) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("format", &v)
+}
+
+func (x *ZlibCompressor) GetPropertyFormat() ZlibCompressorFormat {
+	var v gobject.Value
+	x.GetProperty("format", &v)
+	return ZlibCompressorFormat(v.GetEnum())
+}
+
+func (x *ZlibCompressor) SetPropertyLevel(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("level", &v)
+}
+
+func (x *ZlibCompressor) GetPropertyLevel() int {
+	var v gobject.Value
+	x.GetProperty("level", &v)
+	return v.GetInt()
+}
+
 // This is the main operation used when converting data. It is to be called
 // multiple times in a loop, and each time it will do some work, i.e.
 // producing some output (in @outbuf) or consuming some input (from @inbuf) or
diff --git a/v4/gio/gzlibdecompressor.go b/v4/gio/gzlibdecompressor.go
index 3797190fddea6e08471fe96335cf04b36dc4c7a2..07f394bfad422f5e3033e7d7de5ef3ae70f02a49 100644
--- a/v4/gio/gzlibdecompressor.go
+++ b/v4/gio/gzlibdecompressor.go
@@ -88,6 +88,36 @@ func (c *ZlibDecompressor) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// A #GFileInfo containing the information found in the GZIP header
+// of the data stream processed, or %NULL if the header was not yet
+// fully processed, is not present at all, or the compressor's
+// #GZlibDecompressor:format property is not %G_ZLIB_COMPRESSOR_FORMAT_GZIP.
+
+func (x *ZlibDecompressor) GetPropertyFileInfo() *FileInfo {
+	var v gobject.Value
+	x.GetProperty("file-info", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &FileInfo{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *ZlibDecompressor) SetPropertyFormat(value ZlibCompressorFormat) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("format", &v)
+}
+
+func (x *ZlibDecompressor) GetPropertyFormat() ZlibCompressorFormat {
+	var v gobject.Value
+	x.GetProperty("format", &v)
+	return ZlibCompressorFormat(v.GetEnum())
+}
+
 // This is the main operation used when converting data. It is to be called
 // multiple times in a loop, and each time it will do some work, i.e.
 // producing some output (in @outbuf) or consuming some input (from @inbuf) or
diff --git a/v4/gobject/gobject-2.0.go b/v4/gobject/gobject-2.0.go
index 6c1a2b464b5f04b2cc6aa2e89b07d355fee5b64b..1f1306971a5b1c0761a66a4d3a069cd9e6e6e0a7 100644
--- a/v4/gobject/gobject-2.0.go
+++ b/v4/gobject/gobject-2.0.go
@@ -380,6 +380,101 @@ func (c *Binding) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Flags to be used to control the #GBinding
+
+func (x *Binding) SetPropertyFlags(value BindingFlags) {
+	var v Value
+	v.Init(TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("flags", &v)
+}
+
+func (x *Binding) GetPropertyFlags() BindingFlags {
+	var v Value
+	x.GetProperty("flags", &v)
+	return BindingFlags(v.GetFlags())
+}
+
+// The #GObject that should be used as the source of the binding
+
+func (x *Binding) SetPropertySource(value *Object) {
+	var v Value
+	v.Init(TypeObjectVal)
+	v.SetObject(&Object{Ptr: value.GoPointer()})
+	x.SetProperty("source", &v)
+}
+
+func (x *Binding) GetPropertySource() *Object {
+	var v Value
+	x.GetProperty("source", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Object{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the property of #GBinding:source that should be used
+// as the source of the binding.
+//
+// This should be in [canonical form][canonical-parameter-names] to get the
+// best performance.
+
+func (x *Binding) SetPropertySourceProperty(value string) {
+	var v Value
+	v.Init(TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("source-property", &v)
+}
+
+func (x *Binding) GetPropertySourceProperty() string {
+	var v Value
+	x.GetProperty("source-property", &v)
+	return v.GetString()
+}
+
+// The #GObject that should be used as the target of the binding
+
+func (x *Binding) SetPropertyTarget(value *Object) {
+	var v Value
+	v.Init(TypeObjectVal)
+	v.SetObject(&Object{Ptr: value.GoPointer()})
+	x.SetProperty("target", &v)
+}
+
+func (x *Binding) GetPropertyTarget() *Object {
+	var v Value
+	x.GetProperty("target", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Object{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the property of #GBinding:target that should be used
+// as the target of the binding.
+//
+// This should be in [canonical form][canonical-parameter-names] to get the
+// best performance.
+
+func (x *Binding) SetPropertyTargetProperty(value string) {
+	var v Value
+	v.Init(TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("target-property", &v)
+}
+
+func (x *Binding) GetPropertyTargetProperty() string {
+	var v Value
+	x.GetProperty("target-property", &v)
+	return v.GetString()
+}
+
 // The #GBindingGroup can be used to bind multiple properties
 // from an object collectively.
 //
@@ -506,6 +601,27 @@ func (c *BindingGroup) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The source object used for binding properties.
+
+func (x *BindingGroup) SetPropertySource(value *Object) {
+	var v Value
+	v.Init(TypeObjectVal)
+	v.SetObject(&Object{Ptr: value.GoPointer()})
+	x.SetProperty("source", &v)
+}
+
+func (x *BindingGroup) GetPropertySource() *Object {
+	var v Value
+	x.GetProperty("source", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Object{}
+	result.Ptr = ptr
+	return result
+}
+
 // #GSignalGroup manages to simplify the process of connecting
 // many signals to a #GObject as a group. As such there is no API
 // to disconnect a signal from the group.
@@ -688,6 +804,42 @@ }
 
 func (c *SignalGroup) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The target instance used when connecting signals.
+
+func (x *SignalGroup) SetPropertyTarget(value *Object) {
+	var v Value
+	v.Init(TypeObjectVal)
+	v.SetObject(&Object{Ptr: value.GoPointer()})
+	x.SetProperty("target", &v)
+}
+
+func (x *SignalGroup) GetPropertyTarget() *Object {
+	var v Value
+	x.GetProperty("target", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Object{}
+	result.Ptr = ptr
+	return result
+}
+
+// The #GType of the target property.
+
+func (x *SignalGroup) SetPropertyTargetType(value types.GType) {
+	var v Value
+	v.Init(TypeGtypeVal)
+	v.SetGtype(value)
+	x.SetProperty("target-type", &v)
+}
+
+func (x *SignalGroup) GetPropertyTargetType() types.GType {
+	var v Value
+	x.GetProperty("target-type", &v)
+	return v.GetGtype()
 }
 
 // This signal is emitted when #GSignalGroup:target is set to a new value
diff --git a/v4/gobject/more.go b/v4/gobject/more.go
index c86e65c489c6237c1b1057e1dfcdc6e07c3f1ec2..1301175f1a11ee4257a182ba344b3575088fb93c 100644
--- a/v4/gobject/more.go
+++ b/v4/gobject/more.go
@@ -72,3 +72,11 @@ 	TypeReservedBseFirstVal       = 32 << 2
 	TypeReservedBseLastVal        = 48 << 2
 	TypeReservedUserFirstVal      = 49 << 2
 )
+
+// TypeGtypeVal is initialized at runtime via g_gtype_get_type()
+var TypeGtypeVal Type
+
+func init() {
+	// Initialize TypeGtypeVal after purego has registered the function pointer
+	TypeGtypeVal = GtypeGetType()
+}
diff --git a/v4/gsk/gskglshader.go b/v4/gsk/gskglshader.go
index adc129a47ccafbedc35d2084db928721dc02dd69..c1a7106dff16eba5f611ad92e066ef1c6ca3a9b6 100644
--- a/v4/gsk/gskglshader.go
+++ b/v4/gsk/gskglshader.go
@@ -578,6 +578,37 @@ func (c *GLShader) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Resource containing the source code for the shader.
+//
+// If the shader source is not coming from a resource, this
+// will be %NULL.
+
+func (x *GLShader) SetPropertyResource(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("resource", &v)
+}
+
+func (x *GLShader) GetPropertyResource() string {
+	var v gobject.Value
+	x.GetProperty("resource", &v)
+	return v.GetString()
+}
+
+func (x *GLShader) SetPropertySource(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("source", &v)
+}
+
+func (x *GLShader) GetPropertySource() uintptr {
+	var v gobject.Value
+	x.GetProperty("source", &v)
+	return v.GetPointer()
+}
+
 func init() {
 
 	core.SetPackageName("GSK", "gtk4")
diff --git a/v4/gsk/gskrenderer.go b/v4/gsk/gskrenderer.go
index 9481ce3cb9464be2cc2a6f03bd26276f5d39cafa..10b635aafd9d86b03af3dcf9fc59a03ebf6e3011 100644
--- a/v4/gsk/gskrenderer.go
+++ b/v4/gsk/gskrenderer.go
@@ -184,6 +184,28 @@ func (c *Renderer) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the renderer has been associated with a surface or draw context.
+
+func (x *Renderer) GetPropertyRealized() bool {
+	var v gobject.Value
+	x.GetProperty("realized", &v)
+	return v.GetBoolean()
+}
+
+// The surface associated with renderer.
+
+func (x *Renderer) GetPropertySurface() *gdk.Surface {
+	var v gobject.Value
+	x.GetProperty("surface", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Surface{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GSK", "gtk4")
diff --git a/v4/gtk/gtkaboutdialog.go b/v4/gtk/gtkaboutdialog.go
index 32126d7a431ea2faebd395598137fc72ecfbe4fb..26cd394a9f6191881b45e8212a877622c7db3b8e 100644
--- a/v4/gtk/gtkaboutdialog.go
+++ b/v4/gtk/gtkaboutdialog.go
@@ -523,6 +523,307 @@ func (c *AboutDialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The people who contributed artwork to the program, as a `NULL`-terminated
+// array of strings.
+//
+// Each string may contain email addresses and URLs, which will be displayed
+// as links.
+
+func (x *AboutDialog) SetPropertyArtists(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *AboutDialog) GetPropertyArtists() []string {
+	var v gobject.Value
+	x.GetProperty("artists", &v)
+	return nil
+}
+
+// The authors of the program, as a `NULL`-terminated array of strings.
+//
+// Each string may contain email addresses and URLs, which will be displayed
+// as links, see the introduction for more details.
+
+func (x *AboutDialog) SetPropertyAuthors(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *AboutDialog) GetPropertyAuthors() []string {
+	var v gobject.Value
+	x.GetProperty("authors", &v)
+	return nil
+}
+
+// Comments about the program.
+//
+// This string is displayed in a label in the main dialog, thus it
+// should be a short explanation of the main purpose of the program,
+// not a detailed list of features.
+
+func (x *AboutDialog) SetPropertyComments(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("comments", &v)
+}
+
+func (x *AboutDialog) GetPropertyComments() string {
+	var v gobject.Value
+	x.GetProperty("comments", &v)
+	return v.GetString()
+}
+
+// Copyright information for the program.
+
+func (x *AboutDialog) SetPropertyCopyright(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("copyright", &v)
+}
+
+func (x *AboutDialog) GetPropertyCopyright() string {
+	var v gobject.Value
+	x.GetProperty("copyright", &v)
+	return v.GetString()
+}
+
+// The people documenting the program, as a `NULL`-terminated array of strings.
+//
+// Each string may contain email addresses and URLs, which will be displayed
+// as links, see the introduction for more details.
+
+func (x *AboutDialog) SetPropertyDocumenters(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *AboutDialog) GetPropertyDocumenters() []string {
+	var v gobject.Value
+	x.GetProperty("documenters", &v)
+	return nil
+}
+
+// The license of the program, as free-form text.
+//
+// This string is displayed in a text view in a secondary dialog, therefore
+// it is fine to use a long multi-paragraph text. Note that the text is only
+// wrapped in the text view if the "wrap-license" property is set to `TRUE`;
+// otherwise the text itself must contain the intended linebreaks.
+//
+// When setting this property to a non-`NULL` value, the
+// [property@Gtk.AboutDialog:license-type] property is set to
+// `GTK_LICENSE_CUSTOM` as a side effect.
+//
+// The text may contain links in this format `&lt;http://www.some.place/&gt;`
+// and email references in the form `&lt;mail-to@some.body&gt;`, and these will
+// be converted into clickable links.
+
+func (x *AboutDialog) SetPropertyLicense(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("license", &v)
+}
+
+func (x *AboutDialog) GetPropertyLicense() string {
+	var v gobject.Value
+	x.GetProperty("license", &v)
+	return v.GetString()
+}
+
+// The license of the program.
+//
+// The `GtkAboutDialog` will automatically fill out a standard disclaimer
+// and link the user to the appropriate online resource for the license
+// text.
+//
+// If `GTK_LICENSE_UNKNOWN` is used, the link used will be the same
+// specified in the [property@Gtk.AboutDialog:website] property.
+//
+// If `GTK_LICENSE_CUSTOM` is used, the current contents of the
+// [property@Gtk.AboutDialog:license] property are used.
+//
+// For any other [enum@Gtk.License] value, the contents of the
+// [property@Gtk.AboutDialog:license] property are also set by this property as
+// a side effect.
+
+func (x *AboutDialog) SetPropertyLicenseType(value License) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("license-type", &v)
+}
+
+func (x *AboutDialog) GetPropertyLicenseType() License {
+	var v gobject.Value
+	x.GetProperty("license-type", &v)
+	return License(v.GetEnum())
+}
+
+// A logo for the about box.
+//
+// If it is `NULL`, the default window icon set with
+// [id@gtk_window_set_default_icon_name] will be used.
+
+func (x *AboutDialog) SetPropertyLogo(value gdk.Paintable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("logo", &v)
+}
+
+func (x *AboutDialog) GetPropertyLogo() gdk.Paintable {
+	var v gobject.Value
+	x.GetProperty("logo", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.PaintableBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// A named icon to use as the logo for the about box.
+//
+// This property overrides the [property@Gtk.AboutDialog:logo] property.
+
+func (x *AboutDialog) SetPropertyLogoIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("logo-icon-name", &v)
+}
+
+func (x *AboutDialog) GetPropertyLogoIconName() string {
+	var v gobject.Value
+	x.GetProperty("logo-icon-name", &v)
+	return v.GetString()
+}
+
+// The name of the program.
+//
+// If this is not set, it defaults to the value returned by
+// `g_get_application_name()`.
+
+func (x *AboutDialog) SetPropertyProgramName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("program-name", &v)
+}
+
+func (x *AboutDialog) GetPropertyProgramName() string {
+	var v gobject.Value
+	x.GetProperty("program-name", &v)
+	return v.GetString()
+}
+
+// Information about the system on which the program is running.
+//
+// This information is displayed in a separate page, therefore it is fine
+// to use a long multi-paragraph text. Note that the text should contain
+// the intended linebreaks.
+//
+// The text may contain links in this format `&lt;http://www.some.place/&gt;`
+// and email references in the form `&lt;mail-to@some.body&gt;`, and these will
+// be converted into clickable links.
+
+func (x *AboutDialog) SetPropertySystemInformation(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("system-information", &v)
+}
+
+func (x *AboutDialog) GetPropertySystemInformation() string {
+	var v gobject.Value
+	x.GetProperty("system-information", &v)
+	return v.GetString()
+}
+
+// Credits to the translators.
+//
+// This string should be marked as translatable.
+//
+// The string may contain email addresses and URLs, which will be displayed
+// as links, see the introduction for more details.
+
+func (x *AboutDialog) SetPropertyTranslatorCredits(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("translator-credits", &v)
+}
+
+func (x *AboutDialog) GetPropertyTranslatorCredits() string {
+	var v gobject.Value
+	x.GetProperty("translator-credits", &v)
+	return v.GetString()
+}
+
+// The version of the program.
+
+func (x *AboutDialog) SetPropertyVersion(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("version", &v)
+}
+
+func (x *AboutDialog) GetPropertyVersion() string {
+	var v gobject.Value
+	x.GetProperty("version", &v)
+	return v.GetString()
+}
+
+// The URL for the link to the website of the program.
+//
+// This should be a string starting with `http://` or `https://`.
+
+func (x *AboutDialog) SetPropertyWebsite(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("website", &v)
+}
+
+func (x *AboutDialog) GetPropertyWebsite() string {
+	var v gobject.Value
+	x.GetProperty("website", &v)
+	return v.GetString()
+}
+
+// The label for the link to the website of the program.
+
+func (x *AboutDialog) SetPropertyWebsiteLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("website-label", &v)
+}
+
+func (x *AboutDialog) GetPropertyWebsiteLabel() string {
+	var v gobject.Value
+	x.GetProperty("website-label", &v)
+	return v.GetString()
+}
+
+// Whether to wrap the text in the license dialog.
+
+func (x *AboutDialog) SetPropertyWrapLicense(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("wrap-license", &v)
+}
+
+func (x *AboutDialog) GetPropertyWrapLicense() bool {
+	var v gobject.Value
+	x.GetProperty("wrap-license", &v)
+	return v.GetBoolean()
+}
+
 // Emitted every time a URL is activated.
 //
 // Applications may connect to it to override the default behaviour,
diff --git a/v4/gtk/gtkaccessible.go b/v4/gtk/gtkaccessible.go
index 695f19dd56f16ea6e7e22ac9bfc5f5c812fc8e14..f8354f0117d312438b5ad92683b96140a423a74e 100644
--- a/v4/gtk/gtkaccessible.go
+++ b/v4/gtk/gtkaccessible.go
@@ -204,6 +204,25 @@ 	XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)
 
 }
 
+// The accessible role of the given `GtkAccessible` implementation.
+//
+// The accessible role cannot be changed once set.
+
+func (x *AccessibleBase) SetPropertyAccessibleRole(value AccessibleRole) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("accessible-role", &v)
+}
+
+func (x *AccessibleBase) GetPropertyAccessibleRole() AccessibleRole {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("accessible-role", &v)
+	return AccessibleRole(v.GetEnum())
+}
+
 var XGtkAccessibleGetAccessibleRole func(uintptr) AccessibleRole
 var XGtkAccessibleResetProperty func(uintptr, AccessibleProperty)
 var XGtkAccessibleResetRelation func(uintptr, AccessibleRelation)
diff --git a/v4/gtk/gtkactionable.go b/v4/gtk/gtkactionable.go
index 08e22b7f0d9865660e16ecc7a41ed3c5959be199..6a1483911f7866ff1b6d7c1951dad368ec877170 100644
--- a/v4/gtk/gtkactionable.go
+++ b/v4/gtk/gtkactionable.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -248,6 +249,36 @@ func (x *ActionableBase) SetDetailedActionName(DetailedActionNameVar string) {
 
 	XGtkActionableSetDetailedActionName(x.GoPointer(), DetailedActionNameVar)
 
+}
+
+func (x *ActionableBase) SetPropertyActionName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("action-name", &v)
+}
+
+func (x *ActionableBase) GetPropertyActionName() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("action-name", &v)
+	return v.GetString()
+}
+
+func (x *ActionableBase) SetPropertyActionTarget(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("action-target", &v)
+}
+
+func (x *ActionableBase) GetPropertyActionTarget() uintptr {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("action-target", &v)
+	return v.GetPointer()
 }
 
 var XGtkActionableGetActionName func(uintptr) string
diff --git a/v4/gtk/gtkactionbar.go b/v4/gtk/gtkactionbar.go
index 43042220622a2cd0b9d4001742f558cf00a0a5b9..6e432a4304ba1626bdb0a030b810918ff4adc5a1 100644
--- a/v4/gtk/gtkactionbar.go
+++ b/v4/gtk/gtkactionbar.go
@@ -169,6 +169,21 @@ func (c *ActionBar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Controls whether the action bar shows its contents.
+
+func (x *ActionBar) SetPropertyRevealed(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("revealed", &v)
+}
+
+func (x *ActionBar) GetPropertyRevealed() bool {
+	var v gobject.Value
+	x.GetProperty("revealed", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ActionBar) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkadjustment.go b/v4/gtk/gtkadjustment.go
index b4be4bcbd122f470209333963224be467c9489d7..ee238af32bf6e0e11c31014c6f960a9c50135df4 100644
--- a/v4/gtk/gtkadjustment.go
+++ b/v4/gtk/gtkadjustment.go
@@ -415,6 +415,103 @@ func (c *Adjustment) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The minimum value of the adjustment.
+
+func (x *Adjustment) SetPropertyLower(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("lower", &v)
+}
+
+func (x *Adjustment) GetPropertyLower() float64 {
+	var v gobject.Value
+	x.GetProperty("lower", &v)
+	return v.GetDouble()
+}
+
+// The page increment of the adjustment.
+
+func (x *Adjustment) SetPropertyPageIncrement(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("page-increment", &v)
+}
+
+func (x *Adjustment) GetPropertyPageIncrement() float64 {
+	var v gobject.Value
+	x.GetProperty("page-increment", &v)
+	return v.GetDouble()
+}
+
+// The page size of the adjustment.
+//
+// Note that the page-size is irrelevant and should be set to zero
+// if the adjustment is used for a simple scalar value, e.g. in a
+// `GtkSpinButton`.
+
+func (x *Adjustment) SetPropertyPageSize(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("page-size", &v)
+}
+
+func (x *Adjustment) GetPropertyPageSize() float64 {
+	var v gobject.Value
+	x.GetProperty("page-size", &v)
+	return v.GetDouble()
+}
+
+// The step increment of the adjustment.
+
+func (x *Adjustment) SetPropertyStepIncrement(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("step-increment", &v)
+}
+
+func (x *Adjustment) GetPropertyStepIncrement() float64 {
+	var v gobject.Value
+	x.GetProperty("step-increment", &v)
+	return v.GetDouble()
+}
+
+// The maximum value of the adjustment.
+//
+// Note that values will be restricted by `upper - page-size` if the page-size
+// property is nonzero.
+
+func (x *Adjustment) SetPropertyUpper(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("upper", &v)
+}
+
+func (x *Adjustment) GetPropertyUpper() float64 {
+	var v gobject.Value
+	x.GetProperty("upper", &v)
+	return v.GetDouble()
+}
+
+// The value of the adjustment.
+
+func (x *Adjustment) SetPropertyValue(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("value", &v)
+}
+
+func (x *Adjustment) GetPropertyValue() float64 {
+	var v gobject.Value
+	x.GetProperty("value", &v)
+	return v.GetDouble()
+}
+
 // Emitted when one or more of the `GtkAdjustment` properties have been
 // changed.
 //
diff --git a/v4/gtk/gtkappchooser.go b/v4/gtk/gtkappchooser.go
index cf8a3f82895b3183cf95c91afbf2ffe7e63d4e24..6226bfc716afed86310c20768f375014b2087a46 100644
--- a/v4/gtk/gtkappchooser.go
+++ b/v4/gtk/gtkappchooser.go
@@ -5,6 +5,7 @@ import (
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -83,6 +84,25 @@ func (x *AppChooserBase) Refresh() {
 
 	XGtkAppChooserRefresh(x.GoPointer())
 
+}
+
+// The content type of the `GtkAppChooser` object.
+//
+// See `GContentType` for more information about content types.
+
+func (x *AppChooserBase) SetPropertyContentType(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("content-type", &v)
+}
+
+func (x *AppChooserBase) GetPropertyContentType() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("content-type", &v)
+	return v.GetString()
 }
 
 var XGtkAppChooserGetAppInfo func(uintptr) uintptr
diff --git a/v4/gtk/gtkappchooserbutton.go b/v4/gtk/gtkappchooserbutton.go
index b8a3588cb65d92aa6fbf5e42073277ce06d29b5e..58a9a1b09e8005630ae37652908ba0edb8fff712 100644
--- a/v4/gtk/gtkappchooserbutton.go
+++ b/v4/gtk/gtkappchooserbutton.go
@@ -203,6 +203,71 @@ func (c *AppChooserButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The text to show at the top of the dialog that can be
+// opened from the button.
+//
+// The string may contain Pango markup.
+
+func (x *AppChooserButton) SetPropertyHeading(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("heading", &v)
+}
+
+func (x *AppChooserButton) GetPropertyHeading() string {
+	var v gobject.Value
+	x.GetProperty("heading", &v)
+	return v.GetString()
+}
+
+// Whether the app chooser dialog should be modal.
+
+func (x *AppChooserButton) SetPropertyModal(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("modal", &v)
+}
+
+func (x *AppChooserButton) GetPropertyModal() bool {
+	var v gobject.Value
+	x.GetProperty("modal", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the dropdown menu shows the default application
+// on top for the provided content type.
+
+func (x *AppChooserButton) SetPropertyShowDefaultItem(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-default-item", &v)
+}
+
+func (x *AppChooserButton) GetPropertyShowDefaultItem() bool {
+	var v gobject.Value
+	x.GetProperty("show-default-item", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the dropdown menu shows an item to open
+// a `GtkAppChooserDialog`.
+
+func (x *AppChooserButton) SetPropertyShowDialogItem(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-dialog-item", &v)
+}
+
+func (x *AppChooserButton) GetPropertyShowDialogItem() bool {
+	var v gobject.Value
+	x.GetProperty("show-dialog-item", &v)
+	return v.GetBoolean()
+}
+
 // Emitted to when the button is activated.
 //
 // The `::activate` signal on `GtkAppChooserButton` is an action signal and
diff --git a/v4/gtk/gtkappchooserdialog.go b/v4/gtk/gtkappchooserdialog.go
index b6a3d1afda17274fe3fc7a20371c7f103742a1af..19e3210baf31cf687a9ca4eb48e41ff9ac09938f 100644
--- a/v4/gtk/gtkappchooserdialog.go
+++ b/v4/gtk/gtkappchooserdialog.go
@@ -125,6 +125,47 @@ func (c *AppChooserDialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The GFile used by the `GtkAppChooserDialog`.
+//
+// The dialog's `GtkAppChooserWidget` content type will
+// be guessed from the file, if present.
+
+func (x *AppChooserDialog) SetPropertyGfile(value gio.File) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("gfile", &v)
+}
+
+func (x *AppChooserDialog) GetPropertyGfile() gio.File {
+	var v gobject.Value
+	x.GetProperty("gfile", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.FileBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The text to show at the top of the dialog.
+//
+// The string may contain Pango markup.
+
+func (x *AppChooserDialog) SetPropertyHeading(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("heading", &v)
+}
+
+func (x *AppChooserDialog) GetPropertyHeading() string {
+	var v gobject.Value
+	x.GetProperty("heading", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *AppChooserDialog) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkappchooserwidget.go b/v4/gtk/gtkappchooserwidget.go
index eec6fdc01588e12a10953c4eec41596ce630f7a8..647867b454a458e68656efa6ae89e380017e2052 100644
--- a/v4/gtk/gtkappchooserwidget.go
+++ b/v4/gtk/gtkappchooserwidget.go
@@ -200,6 +200,112 @@ func (c *AppChooserWidget) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The text that appears in the widget when there are no applications
+// for the given content type.
+
+func (x *AppChooserWidget) SetPropertyDefaultText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("default-text", &v)
+}
+
+func (x *AppChooserWidget) GetPropertyDefaultText() string {
+	var v gobject.Value
+	x.GetProperty("default-text", &v)
+	return v.GetString()
+}
+
+// If %TRUE, the app chooser presents all applications
+// in a single list, without subsections for default,
+// recommended or related applications.
+
+func (x *AppChooserWidget) SetPropertyShowAll(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-all", &v)
+}
+
+func (x *AppChooserWidget) GetPropertyShowAll() bool {
+	var v gobject.Value
+	x.GetProperty("show-all", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the app chooser should show the default
+// handler for the content type in a separate section.
+//
+// If %FALSE, the default handler is listed among the recommended
+// applications.
+
+func (x *AppChooserWidget) SetPropertyShowDefault(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-default", &v)
+}
+
+func (x *AppChooserWidget) GetPropertyShowDefault() bool {
+	var v gobject.Value
+	x.GetProperty("show-default", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the app chooser should show a section
+// for fallback applications.
+//
+// If %FALSE, the fallback applications are listed among the
+// other applications.
+
+func (x *AppChooserWidget) SetPropertyShowFallback(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-fallback", &v)
+}
+
+func (x *AppChooserWidget) GetPropertyShowFallback() bool {
+	var v gobject.Value
+	x.GetProperty("show-fallback", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the app chooser should show a section
+// for other applications.
+
+func (x *AppChooserWidget) SetPropertyShowOther(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-other", &v)
+}
+
+func (x *AppChooserWidget) GetPropertyShowOther() bool {
+	var v gobject.Value
+	x.GetProperty("show-other", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the app chooser should show a section
+// for recommended applications.
+//
+// If %FALSE, the recommended applications are listed
+// among the other applications.
+
+func (x *AppChooserWidget) SetPropertyShowRecommended(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-recommended", &v)
+}
+
+func (x *AppChooserWidget) GetPropertyShowRecommended() bool {
+	var v gobject.Value
+	x.GetProperty("show-recommended", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when an application item is activated from the widget's list.
 //
 // This usually happens when the user double clicks an item, or an item
diff --git a/v4/gtk/gtkapplication.go b/v4/gtk/gtkapplication.go
index e4d92e37cb7b8a413916a16fcd67d29ac21cd14b..2a6ae302f58a0cf30823c046314c0edb1a2700c9 100644
--- a/v4/gtk/gtkapplication.go
+++ b/v4/gtk/gtkapplication.go
@@ -495,6 +495,74 @@ func (c *Application) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The currently focused window of the application.
+
+func (x *Application) GetPropertyActiveWindow() *Window {
+	var v gobject.Value
+	x.GetProperty("active-window", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Window{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GMenuModel` to be used for the application's menu bar.
+
+func (x *Application) SetPropertyMenubar(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("menubar", &v)
+}
+
+func (x *Application) GetPropertyMenubar() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("menubar", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// Set this property to `TRUE` to register with the session manager.
+//
+// This will make GTK track the session state (such as the
+// [property@Gtk.Application:screensaver-active] property).
+
+func (x *Application) SetPropertyRegisterSession(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("register-session", &v)
+}
+
+func (x *Application) GetPropertyRegisterSession() bool {
+	var v gobject.Value
+	x.GetProperty("register-session", &v)
+	return v.GetBoolean()
+}
+
+// This property is `TRUE` if GTK believes that the screensaver is
+// currently active.
+//
+// GTK only tracks session state (including this) when
+// [property@Gtk.Application:register-session] is set to %TRUE.
+//
+// Tracking the screensaver state is currently only supported on
+// Linux.
+
+func (x *Application) GetPropertyScreensaverActive() bool {
+	var v gobject.Value
+	x.GetProperty("screensaver-active", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when the session manager is about to end the session.
 //
 // This signal is only emitted if [property@Gtk.Application:register-session]
diff --git a/v4/gtk/gtkapplicationwindow.go b/v4/gtk/gtkapplicationwindow.go
index 7e0cacfb3c251568b4b3fdee22b6ad123974d8e5..449933efa0b1e9ba7d96b63449637de390f0457d 100644
--- a/v4/gtk/gtkapplicationwindow.go
+++ b/v4/gtk/gtkapplicationwindow.go
@@ -207,6 +207,27 @@ func (c *ApplicationWindow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If this property is %TRUE, the window will display a menubar
+// unless it is shown by the desktop shell.
+//
+// See [method@Gtk.Application.set_menubar].
+//
+// If %FALSE, the window will not display a menubar, regardless
+// of whether the desktop shell is showing it or not.
+
+func (x *ApplicationWindow) SetPropertyShowMenubar(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-menubar", &v)
+}
+
+func (x *ApplicationWindow) GetPropertyShowMenubar() bool {
+	var v gobject.Value
+	x.GetProperty("show-menubar", &v)
+	return v.GetBoolean()
+}
+
 // Emits the #GActionGroup::action-added signal on @action_group.
 //
 // This function should only be called by #GActionGroup implementations.
diff --git a/v4/gtk/gtkaspectframe.go b/v4/gtk/gtkaspectframe.go
index b4baf6b1d016fe5c0ca6eacfe094eac232a67c83..c4425f59e93d2765c99144048c11045f1dcfa4e2 100644
--- a/v4/gtk/gtkaspectframe.go
+++ b/v4/gtk/gtkaspectframe.go
@@ -165,6 +165,90 @@ func (c *AspectFrame) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *AspectFrame) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *AspectFrame) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the `GtkAspectFrame` should use the aspect ratio of its child.
+
+func (x *AspectFrame) SetPropertyObeyChild(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("obey-child", &v)
+}
+
+func (x *AspectFrame) GetPropertyObeyChild() bool {
+	var v gobject.Value
+	x.GetProperty("obey-child", &v)
+	return v.GetBoolean()
+}
+
+// The aspect ratio to be used by the `GtkAspectFrame`.
+//
+// This property is only used if
+// [property@Gtk.AspectFrame:obey-child] is set to %FALSE.
+
+func (x *AspectFrame) SetPropertyRatio(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("ratio", &v)
+}
+
+func (x *AspectFrame) GetPropertyRatio() float32 {
+	var v gobject.Value
+	x.GetProperty("ratio", &v)
+	return v.GetFloat()
+}
+
+// The horizontal alignment of the child.
+
+func (x *AspectFrame) SetPropertyXalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("xalign", &v)
+}
+
+func (x *AspectFrame) GetPropertyXalign() float32 {
+	var v gobject.Value
+	x.GetProperty("xalign", &v)
+	return v.GetFloat()
+}
+
+// The vertical alignment of the child.
+
+func (x *AspectFrame) SetPropertyYalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("yalign", &v)
+}
+
+func (x *AspectFrame) GetPropertyYalign() float32 {
+	var v gobject.Value
+	x.GetProperty("yalign", &v)
+	return v.GetFloat()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *AspectFrame) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkassistant.go b/v4/gtk/gtkassistant.go
index 6b0650c7f6f7570161d0802ca1edec07c43f0150..525fc50738cd51ba65fd5727bf41cdff04b75c24 100644
--- a/v4/gtk/gtkassistant.go
+++ b/v4/gtk/gtkassistant.go
@@ -422,6 +422,39 @@ func (c *Assistant) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// `GListModel` containing the pages.
+
+func (x *Assistant) GetPropertyPages() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("pages", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// %TRUE if the assistant uses a `GtkHeaderBar` for action buttons
+// instead of the action-area.
+//
+// For technical reasons, this property is declared as an integer
+// property, but you should only set it to %TRUE or %FALSE.
+
+func (x *Assistant) SetPropertyUseHeaderBar(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("use-header-bar", &v)
+}
+
+func (x *Assistant) GetPropertyUseHeaderBar() int {
+	var v gobject.Value
+	x.GetProperty("use-header-bar", &v)
+	return v.GetInt()
+}
+
 // Emitted when the apply button is clicked.
 //
 // The default behavior of the `GtkAssistant` is to switch to the page
@@ -831,6 +864,75 @@ }
 
 func (c *AssistantPage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The child widget.
+
+func (x *AssistantPage) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *AssistantPage) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether all required fields are filled in.
+//
+// GTK uses this information to control the sensitivity
+// of the navigation buttons.
+
+func (x *AssistantPage) SetPropertyComplete(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("complete", &v)
+}
+
+func (x *AssistantPage) GetPropertyComplete() bool {
+	var v gobject.Value
+	x.GetProperty("complete", &v)
+	return v.GetBoolean()
+}
+
+// The type of the assistant page.
+
+func (x *AssistantPage) SetPropertyPageType(value AssistantPageType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("page-type", &v)
+}
+
+func (x *AssistantPage) GetPropertyPageType() AssistantPageType {
+	var v gobject.Value
+	x.GetProperty("page-type", &v)
+	return AssistantPageType(v.GetEnum())
+}
+
+// The title of the page.
+
+func (x *AssistantPage) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *AssistantPage) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
 }
 
 func init() {
diff --git a/v4/gtk/gtkatcontext.go b/v4/gtk/gtkatcontext.go
index 9f49336ad1fc46731b6caa9149d9838b940c0236..dd3072f426da9f4c1e009b3d22d5da4740c56840 100644
--- a/v4/gtk/gtkatcontext.go
+++ b/v4/gtk/gtkatcontext.go
@@ -100,6 +100,66 @@ func (c *ATContext) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GtkAccessible` that created the `GtkATContext` instance.
+
+func (x *ATContext) SetPropertyAccessible(value Accessible) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("accessible", &v)
+}
+
+func (x *ATContext) GetPropertyAccessible() Accessible {
+	var v gobject.Value
+	x.GetProperty("accessible", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &AccessibleBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The accessible role used by the AT context.
+//
+// Depending on the given role, different states and properties can be
+// set or retrieved.
+
+func (x *ATContext) SetPropertyAccessibleRole(value AccessibleRole) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("accessible-role", &v)
+}
+
+func (x *ATContext) GetPropertyAccessibleRole() AccessibleRole {
+	var v gobject.Value
+	x.GetProperty("accessible-role", &v)
+	return AccessibleRole(v.GetEnum())
+}
+
+// The `GdkDisplay` for the `GtkATContext`.
+
+func (x *ATContext) SetPropertyDisplay(value *gdk.Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *ATContext) GetPropertyDisplay() *gdk.Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Display{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emitted when the attributes of the accessible for the
 // `GtkATContext` instance change.
 func (x *ATContext) ConnectStateChange(cb *func(ATContext)) uint32 {
diff --git a/v4/gtk/gtkbookmarklist.go b/v4/gtk/gtkbookmarklist.go
index 0c1243d32977617bbbd0211c571fd4f42068c8f1..07ac7f710e424ca7bb7defef46eaa9157d272930 100644
--- a/v4/gtk/gtkbookmarklist.go
+++ b/v4/gtk/gtkbookmarklist.go
@@ -137,6 +137,75 @@ func (c *BookmarkList) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The attributes to query.
+
+func (x *BookmarkList) SetPropertyAttributes(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("attributes", &v)
+}
+
+func (x *BookmarkList) GetPropertyAttributes() string {
+	var v gobject.Value
+	x.GetProperty("attributes", &v)
+	return v.GetString()
+}
+
+// The bookmark file to load.
+
+func (x *BookmarkList) SetPropertyFilename(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("filename", &v)
+}
+
+func (x *BookmarkList) GetPropertyFilename() string {
+	var v gobject.Value
+	x.GetProperty("filename", &v)
+	return v.GetString()
+}
+
+// Priority used when loading.
+
+func (x *BookmarkList) SetPropertyIoPriority(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("io-priority", &v)
+}
+
+func (x *BookmarkList) GetPropertyIoPriority() int {
+	var v gobject.Value
+	x.GetProperty("io-priority", &v)
+	return v.GetInt()
+}
+
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *BookmarkList) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// %TRUE if files are being loaded.
+
+func (x *BookmarkList) GetPropertyLoading() bool {
+	var v gobject.Value
+	x.GetProperty("loading", &v)
+	return v.GetBoolean()
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *BookmarkList) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtkboolfilter.go b/v4/gtk/gtkboolfilter.go
index 150ba9d2958379e1e19a009e877f7330c104d9ab..ccaed2f75ab1e2edf65cac9aa6543b2947dbb9cb 100644
--- a/v4/gtk/gtkboolfilter.go
+++ b/v4/gtk/gtkboolfilter.go
@@ -114,6 +114,42 @@ func (c *BoolFilter) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The boolean expression to evaluate on item.
+
+func (x *BoolFilter) SetPropertyExpression(value *Expression) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("expression", &v)
+}
+
+func (x *BoolFilter) GetPropertyExpression() *Expression {
+	var v gobject.Value
+	x.GetProperty("expression", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Expression{}
+	result.Ptr = ptr
+	return result
+}
+
+// If the expression result should be inverted.
+
+func (x *BoolFilter) SetPropertyInvert(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("invert", &v)
+}
+
+func (x *BoolFilter) GetPropertyInvert() bool {
+	var v gobject.Value
+	x.GetProperty("invert", &v)
+	return v.GetBoolean()
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkbox.go b/v4/gtk/gtkbox.go
index d896fa8bb94709913ef21d563aa5c58bf72a6a60..16b5f6da2c7ac1d9378f409d1900ca8993fcbf60 100644
--- a/v4/gtk/gtkbox.go
+++ b/v4/gtk/gtkbox.go
@@ -216,6 +216,51 @@ func (c *Box) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The position of the baseline aligned widgets if extra space is available.
+
+func (x *Box) SetPropertyBaselinePosition(value BaselinePosition) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("baseline-position", &v)
+}
+
+func (x *Box) GetPropertyBaselinePosition() BaselinePosition {
+	var v gobject.Value
+	x.GetProperty("baseline-position", &v)
+	return BaselinePosition(v.GetEnum())
+}
+
+// Whether the children should all be the same size.
+
+func (x *Box) SetPropertyHomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("homogeneous", &v)
+}
+
+func (x *Box) GetPropertyHomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("homogeneous", &v)
+	return v.GetBoolean()
+}
+
+// The amount of space between children.
+
+func (x *Box) SetPropertySpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("spacing", &v)
+}
+
+func (x *Box) GetPropertySpacing() int {
+	var v gobject.Value
+	x.GetProperty("spacing", &v)
+	return v.GetInt()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Box) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkboxlayout.go b/v4/gtk/gtkboxlayout.go
index aa48cb4513227b8052a303ddfcb1c00cb01d540e..ab54ffd33c7ee526d36f832a57fd0b09e57f87ad 100644
--- a/v4/gtk/gtkboxlayout.go
+++ b/v4/gtk/gtkboxlayout.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -136,6 +137,56 @@ }
 
 func (c *BoxLayout) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The position of the allocated baseline within the extra space
+// allocated to each child.
+//
+// This property is only relevant for horizontal layouts containing
+// at least one child with a baseline alignment.
+
+func (x *BoxLayout) SetPropertyBaselinePosition(value BaselinePosition) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("baseline-position", &v)
+}
+
+func (x *BoxLayout) GetPropertyBaselinePosition() BaselinePosition {
+	var v gobject.Value
+	x.GetProperty("baseline-position", &v)
+	return BaselinePosition(v.GetEnum())
+}
+
+// Whether the box layout should distribute the available space
+// equally among the children.
+
+func (x *BoxLayout) SetPropertyHomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("homogeneous", &v)
+}
+
+func (x *BoxLayout) GetPropertyHomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("homogeneous", &v)
+	return v.GetBoolean()
+}
+
+// The space to put between the children.
+
+func (x *BoxLayout) SetPropertySpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("spacing", &v)
+}
+
+func (x *BoxLayout) GetPropertySpacing() int {
+	var v gobject.Value
+	x.GetProperty("spacing", &v)
+	return v.GetInt()
 }
 
 // Retrieves the orientation of the @orientable.
diff --git a/v4/gtk/gtkbuilder.go b/v4/gtk/gtkbuilder.go
index 896c540f31f07bce9f86ebb0358affaaa7eaf09c..1e559ddd94bc1323cf439f45d3a1db2a78a7a38d 100644
--- a/v4/gtk/gtkbuilder.go
+++ b/v4/gtk/gtkbuilder.go
@@ -750,6 +750,67 @@ func (c *Builder) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The object the builder is evaluating for.
+
+func (x *Builder) SetPropertyCurrentObject(value *gobject.Object) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("current-object", &v)
+}
+
+func (x *Builder) GetPropertyCurrentObject() *gobject.Object {
+	var v gobject.Value
+	x.GetProperty("current-object", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gobject.Object{}
+	result.Ptr = ptr
+	return result
+}
+
+// The scope the builder is operating in
+
+func (x *Builder) SetPropertyScope(value BuilderScope) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("scope", &v)
+}
+
+func (x *Builder) GetPropertyScope() BuilderScope {
+	var v gobject.Value
+	x.GetProperty("scope", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &BuilderScopeBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The translation domain used when translating property values that
+// have been marked as translatable.
+//
+// If the translation domain is %NULL, `GtkBuilder` uses gettext(),
+// otherwise g_dgettext().
+
+func (x *Builder) SetPropertyTranslationDomain(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("translation-domain", &v)
+}
+
+func (x *Builder) GetPropertyTranslationDomain() string {
+	var v gobject.Value
+	x.GetProperty("translation-domain", &v)
+	return v.GetString()
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkbuilderlistitemfactory.go b/v4/gtk/gtkbuilderlistitemfactory.go
index 894868fe2d51f49158ca23413b483e2745b77f35..89f84b04798ab7ec8b8c56db8f9f5e6d869ab2e7 100644
--- a/v4/gtk/gtkbuilderlistitemfactory.go
+++ b/v4/gtk/gtkbuilderlistitemfactory.go
@@ -142,6 +142,57 @@ func (c *BuilderListItemFactory) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// `GBytes` containing the UI definition.
+
+func (x *BuilderListItemFactory) SetPropertyBytes(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("bytes", &v)
+}
+
+func (x *BuilderListItemFactory) GetPropertyBytes() uintptr {
+	var v gobject.Value
+	x.GetProperty("bytes", &v)
+	return v.GetPointer()
+}
+
+// Path of the resource containing the UI definition.
+
+func (x *BuilderListItemFactory) SetPropertyResource(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("resource", &v)
+}
+
+func (x *BuilderListItemFactory) GetPropertyResource() string {
+	var v gobject.Value
+	x.GetProperty("resource", &v)
+	return v.GetString()
+}
+
+// `GtkBuilderScope` to use when instantiating listitems
+
+func (x *BuilderListItemFactory) SetPropertyScope(value BuilderScope) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("scope", &v)
+}
+
+func (x *BuilderListItemFactory) GetPropertyScope() BuilderScope {
+	var v gobject.Value
+	x.GetProperty("scope", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &BuilderScopeBase{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkbutton.go b/v4/gtk/gtkbutton.go
index 01dab333209e3951809e0efd89e6528b71f88460..624f1e5c732b2a697ddb1744dffe5c832d4a1588 100644
--- a/v4/gtk/gtkbutton.go
+++ b/v4/gtk/gtkbutton.go
@@ -342,6 +342,88 @@ func (c *Button) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *Button) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *Button) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the button has a frame.
+
+func (x *Button) SetPropertyHasFrame(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-frame", &v)
+}
+
+func (x *Button) GetPropertyHasFrame() bool {
+	var v gobject.Value
+	x.GetProperty("has-frame", &v)
+	return v.GetBoolean()
+}
+
+// The name of the icon used to automatically populate the button.
+
+func (x *Button) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *Button) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// Text of the label inside the button, if the button contains a label widget.
+
+func (x *Button) SetPropertyLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("label", &v)
+}
+
+func (x *Button) GetPropertyLabel() string {
+	var v gobject.Value
+	x.GetProperty("label", &v)
+	return v.GetString()
+}
+
+// If set, an underline in the text indicates that the following character is
+// to be used as mnemonic.
+
+func (x *Button) SetPropertyUseUnderline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-underline", &v)
+}
+
+func (x *Button) GetPropertyUseUnderline() bool {
+	var v gobject.Value
+	x.GetProperty("use-underline", &v)
+	return v.GetBoolean()
+}
+
 // Emitted to animate press then release.
 //
 // This is an action signal. Applications should never connect
diff --git a/v4/gtk/gtkcalendar.go b/v4/gtk/gtkcalendar.go
index 5536f03754c4c099f3543c9dbe44911daed03434..5d663c48695b98a3502ffd60aed8e81add9fbaac 100644
--- a/v4/gtk/gtkcalendar.go
+++ b/v4/gtk/gtkcalendar.go
@@ -231,6 +231,100 @@ func (c *Calendar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The selected day (as a number between 1 and 31).
+
+func (x *Calendar) SetPropertyDay(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("day", &v)
+}
+
+func (x *Calendar) GetPropertyDay() int {
+	var v gobject.Value
+	x.GetProperty("day", &v)
+	return v.GetInt()
+}
+
+// The selected month (as a number between 0 and 11).
+//
+// This property gets initially set to the current month.
+
+func (x *Calendar) SetPropertyMonth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("month", &v)
+}
+
+func (x *Calendar) GetPropertyMonth() int {
+	var v gobject.Value
+	x.GetProperty("month", &v)
+	return v.GetInt()
+}
+
+// Determines whether day names are displayed.
+
+func (x *Calendar) SetPropertyShowDayNames(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-day-names", &v)
+}
+
+func (x *Calendar) GetPropertyShowDayNames() bool {
+	var v gobject.Value
+	x.GetProperty("show-day-names", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether a heading is displayed.
+
+func (x *Calendar) SetPropertyShowHeading(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-heading", &v)
+}
+
+func (x *Calendar) GetPropertyShowHeading() bool {
+	var v gobject.Value
+	x.GetProperty("show-heading", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether week numbers are displayed.
+
+func (x *Calendar) SetPropertyShowWeekNumbers(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-week-numbers", &v)
+}
+
+func (x *Calendar) GetPropertyShowWeekNumbers() bool {
+	var v gobject.Value
+	x.GetProperty("show-week-numbers", &v)
+	return v.GetBoolean()
+}
+
+// The selected year.
+//
+// This property gets initially set to the current year.
+
+func (x *Calendar) SetPropertyYear(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("year", &v)
+}
+
+func (x *Calendar) GetPropertyYear() int {
+	var v gobject.Value
+	x.GetProperty("year", &v)
+	return v.GetInt()
+}
+
 // Emitted when the user selects a day.
 func (x *Calendar) ConnectDaySelected(cb *func(Calendar)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gtk/gtkcellarea.go b/v4/gtk/gtkcellarea.go
index 8ad77b3ab456fb03ff28244e36f5792d61468fd0..48a63f776fd6ffd8abcc2165477ba385c1787f56 100644
--- a/v4/gtk/gtkcellarea.go
+++ b/v4/gtk/gtkcellarea.go
@@ -1478,6 +1478,61 @@ func (c *CellArea) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The widget currently editing the edited cell
+//
+// This property is read-only and only changes as
+// a result of a call gtk_cell_area_activate_cell().
+
+func (x *CellArea) GetPropertyEditWidget() CellEditable {
+	var v gobject.Value
+	x.GetProperty("edit-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &CellEditableBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The cell in the area that is currently edited
+//
+// This property is read-only and only changes as
+// a result of a call gtk_cell_area_activate_cell().
+
+func (x *CellArea) GetPropertyEditedCell() *CellRenderer {
+	var v gobject.Value
+	x.GetProperty("edited-cell", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &CellRenderer{}
+	result.Ptr = ptr
+	return result
+}
+
+// The cell in the area that currently has focus
+
+func (x *CellArea) SetPropertyFocusCell(value *CellRenderer) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("focus-cell", &v)
+}
+
+func (x *CellArea) GetPropertyFocusCell() *CellRenderer {
+	var v gobject.Value
+	x.GetProperty("focus-cell", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &CellRenderer{}
+	result.Ptr = ptr
+	return result
+}
+
 // Indicates that editing has started on @renderer and that @editable
 // should be added to the owning cell-layouting widget at @cell_area.
 func (x *CellArea) ConnectAddEditable(cb *func(CellArea, uintptr, uintptr, uintptr, string)) uint32 {
diff --git a/v4/gtk/gtkcellareabox.go b/v4/gtk/gtkcellareabox.go
index 1aa0008cc5ab3636c3f44a02adb197e5beb80bf6..9799859748b312fea20eddcb817ccea6a6ad7955 100644
--- a/v4/gtk/gtkcellareabox.go
+++ b/v4/gtk/gtkcellareabox.go
@@ -114,6 +114,21 @@ func (c *CellAreaBox) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The amount of space to reserve between cells.
+
+func (x *CellAreaBox) SetPropertySpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("spacing", &v)
+}
+
+func (x *CellAreaBox) GetPropertySpacing() int {
+	var v gobject.Value
+	x.GetProperty("spacing", &v)
+	return v.GetInt()
+}
+
 // Gets the ID of the @buildable object.
 //
 // `GtkBuilder` sets the name based on the ID attribute
diff --git a/v4/gtk/gtkcellareacontext.go b/v4/gtk/gtkcellareacontext.go
index 992dd36d9e696639e2a464d31182d0f853344f8f..8ba39df13df3a534146469b4aea3e0f345011050 100644
--- a/v4/gtk/gtkcellareacontext.go
+++ b/v4/gtk/gtkcellareacontext.go
@@ -339,6 +339,67 @@ func (c *CellAreaContext) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GtkCellArea` this context was created by
+
+func (x *CellAreaContext) SetPropertyArea(value *CellArea) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("area", &v)
+}
+
+func (x *CellAreaContext) GetPropertyArea() *CellArea {
+	var v gobject.Value
+	x.GetProperty("area", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &CellArea{}
+	result.Ptr = ptr
+	return result
+}
+
+// The minimum height for the `GtkCellArea` in this context
+// for all `GtkTreeModel` rows that this context was requested
+// for using gtk_cell_area_get_preferred_height().
+
+func (x *CellAreaContext) GetPropertyMinimumHeight() int {
+	var v gobject.Value
+	x.GetProperty("minimum-height", &v)
+	return v.GetInt()
+}
+
+// The minimum width for the `GtkCellArea` in this context
+// for all `GtkTreeModel` rows that this context was requested
+// for using gtk_cell_area_get_preferred_width().
+
+func (x *CellAreaContext) GetPropertyMinimumWidth() int {
+	var v gobject.Value
+	x.GetProperty("minimum-width", &v)
+	return v.GetInt()
+}
+
+// The natural height for the `GtkCellArea` in this context
+// for all `GtkTreeModel` rows that this context was requested
+// for using gtk_cell_area_get_preferred_height().
+
+func (x *CellAreaContext) GetPropertyNaturalHeight() int {
+	var v gobject.Value
+	x.GetProperty("natural-height", &v)
+	return v.GetInt()
+}
+
+// The natural width for the `GtkCellArea` in this context
+// for all `GtkTreeModel` rows that this context was requested
+// for using gtk_cell_area_get_preferred_width().
+
+func (x *CellAreaContext) GetPropertyNaturalWidth() int {
+	var v gobject.Value
+	x.GetProperty("natural-width", &v)
+	return v.GetInt()
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkcelleditable.go b/v4/gtk/gtkcelleditable.go
index ea97087367a48f5cddc02a7f038ef15fa0d9f477..8f0ca52feca4334f9531342cac573463a4a88cb7 100644
--- a/v4/gtk/gtkcelleditable.go
+++ b/v4/gtk/gtkcelleditable.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/gdk"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -158,6 +159,23 @@ func (x *CellEditableBase) StartEditing(EventVar *gdk.Event) {
 
 	XGtkCellEditableStartEditing(x.GoPointer(), EventVar.GoPointer())
 
+}
+
+// Indicates whether editing on the cell has been canceled.
+
+func (x *CellEditableBase) SetPropertyEditingCanceled(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("editing-canceled", &v)
+}
+
+func (x *CellEditableBase) GetPropertyEditingCanceled() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("editing-canceled", &v)
+	return v.GetBoolean()
 }
 
 var XGtkCellEditableEditingDone func(uintptr)
diff --git a/v4/gtk/gtkcellrenderer.go b/v4/gtk/gtkcellrenderer.go
index d88a404d9e143cc32cd8c4ea3691083fb7db0ec1..59c5e5ddd0d1ab19b90c84d42c3ab8b121c8f2dd 100644
--- a/v4/gtk/gtkcellrenderer.go
+++ b/v4/gtk/gtkcellrenderer.go
@@ -713,6 +713,190 @@ func (c *CellRenderer) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *CellRenderer) SetPropertyCellBackground(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("cell-background", &v)
+}
+
+// Cell background as a `GdkRGBA`
+
+func (x *CellRenderer) SetPropertyCellBackgroundRgba(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("cell-background-rgba", &v)
+}
+
+func (x *CellRenderer) GetPropertyCellBackgroundRgba() uintptr {
+	var v gobject.Value
+	x.GetProperty("cell-background-rgba", &v)
+	return v.GetPointer()
+}
+
+func (x *CellRenderer) SetPropertyCellBackgroundSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("cell-background-set", &v)
+}
+
+func (x *CellRenderer) GetPropertyCellBackgroundSet() bool {
+	var v gobject.Value
+	x.GetProperty("cell-background-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRenderer) GetPropertyEditing() bool {
+	var v gobject.Value
+	x.GetProperty("editing", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRenderer) SetPropertyHeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("height", &v)
+}
+
+func (x *CellRenderer) GetPropertyHeight() int {
+	var v gobject.Value
+	x.GetProperty("height", &v)
+	return v.GetInt()
+}
+
+func (x *CellRenderer) SetPropertyIsExpanded(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-expanded", &v)
+}
+
+func (x *CellRenderer) GetPropertyIsExpanded() bool {
+	var v gobject.Value
+	x.GetProperty("is-expanded", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRenderer) SetPropertyIsExpander(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-expander", &v)
+}
+
+func (x *CellRenderer) GetPropertyIsExpander() bool {
+	var v gobject.Value
+	x.GetProperty("is-expander", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRenderer) SetPropertyMode(value CellRendererMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("mode", &v)
+}
+
+func (x *CellRenderer) GetPropertyMode() CellRendererMode {
+	var v gobject.Value
+	x.GetProperty("mode", &v)
+	return CellRendererMode(v.GetEnum())
+}
+
+func (x *CellRenderer) SetPropertySensitive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("sensitive", &v)
+}
+
+func (x *CellRenderer) GetPropertySensitive() bool {
+	var v gobject.Value
+	x.GetProperty("sensitive", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRenderer) SetPropertyVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("visible", &v)
+}
+
+func (x *CellRenderer) GetPropertyVisible() bool {
+	var v gobject.Value
+	x.GetProperty("visible", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRenderer) SetPropertyWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("width", &v)
+}
+
+func (x *CellRenderer) GetPropertyWidth() int {
+	var v gobject.Value
+	x.GetProperty("width", &v)
+	return v.GetInt()
+}
+
+func (x *CellRenderer) SetPropertyXalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("xalign", &v)
+}
+
+func (x *CellRenderer) GetPropertyXalign() float32 {
+	var v gobject.Value
+	x.GetProperty("xalign", &v)
+	return v.GetFloat()
+}
+
+func (x *CellRenderer) SetPropertyXpad(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("xpad", &v)
+}
+
+func (x *CellRenderer) GetPropertyXpad() uint {
+	var v gobject.Value
+	x.GetProperty("xpad", &v)
+	return v.GetUint()
+}
+
+func (x *CellRenderer) SetPropertyYalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("yalign", &v)
+}
+
+func (x *CellRenderer) GetPropertyYalign() float32 {
+	var v gobject.Value
+	x.GetProperty("yalign", &v)
+	return v.GetFloat()
+}
+
+func (x *CellRenderer) SetPropertyYpad(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("ypad", &v)
+}
+
+func (x *CellRenderer) GetPropertyYpad() uint {
+	var v gobject.Value
+	x.GetProperty("ypad", &v)
+	return v.GetUint()
+}
+
 // This signal gets emitted when the user cancels the process of editing a
 // cell.  For example, an editable cell renderer could be written to cancel
 // editing when the user presses Escape.
diff --git a/v4/gtk/gtkcellrendereraccel.go b/v4/gtk/gtkcellrendereraccel.go
index 26e7b5a1b14e875230ddcc70476f76bfc48acd98..b9a78bd035f43066ce66a9f2fe75c5e34727f662 100644
--- a/v4/gtk/gtkcellrendereraccel.go
+++ b/v4/gtk/gtkcellrendereraccel.go
@@ -78,6 +78,71 @@ func (c *CellRendererAccel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The keyval of the accelerator.
+
+func (x *CellRendererAccel) SetPropertyAccelKey(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("accel-key", &v)
+}
+
+func (x *CellRendererAccel) GetPropertyAccelKey() uint {
+	var v gobject.Value
+	x.GetProperty("accel-key", &v)
+	return v.GetUint()
+}
+
+// Determines if the edited accelerators are GTK accelerators. If
+// they are, consumed modifiers are suppressed, only accelerators
+// accepted by GTK are allowed, and the accelerators are rendered
+// in the same way as they are in menus.
+
+func (x *CellRendererAccel) SetPropertyAccelMode(value CellRendererAccelMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("accel-mode", &v)
+}
+
+func (x *CellRendererAccel) GetPropertyAccelMode() CellRendererAccelMode {
+	var v gobject.Value
+	x.GetProperty("accel-mode", &v)
+	return CellRendererAccelMode(v.GetEnum())
+}
+
+// The modifier mask of the accelerator.
+
+func (x *CellRendererAccel) SetPropertyAccelMods(value gdk.ModifierType) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("accel-mods", &v)
+}
+
+func (x *CellRendererAccel) GetPropertyAccelMods() gdk.ModifierType {
+	var v gobject.Value
+	x.GetProperty("accel-mods", &v)
+	return gdk.ModifierType(v.GetFlags())
+}
+
+// The hardware keycode of the accelerator. Note that the hardware keycode is
+// only relevant if the key does not have a keyval. Normally, the keyboard
+// configuration should assign keyvals to all keys.
+
+func (x *CellRendererAccel) SetPropertyKeycode(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("keycode", &v)
+}
+
+func (x *CellRendererAccel) GetPropertyKeycode() uint {
+	var v gobject.Value
+	x.GetProperty("keycode", &v)
+	return v.GetUint()
+}
+
 // Gets emitted when the user has removed the accelerator.
 func (x *CellRendererAccel) ConnectAccelCleared(cb *func(CellRendererAccel, string)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gtk/gtkcellrenderercombo.go b/v4/gtk/gtkcellrenderercombo.go
index 55f2e474deb40be59aeac2f59ff362c3dc7755e8..8ee0a65b671fac651662d449f42471299de01eed 100644
--- a/v4/gtk/gtkcellrenderercombo.go
+++ b/v4/gtk/gtkcellrenderercombo.go
@@ -73,6 +73,67 @@ func (c *CellRendererCombo) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If %TRUE, the cell renderer will include an entry and allow to enter
+// values other than the ones in the popup list.
+
+func (x *CellRendererCombo) SetPropertyHasEntry(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-entry", &v)
+}
+
+func (x *CellRendererCombo) GetPropertyHasEntry() bool {
+	var v gobject.Value
+	x.GetProperty("has-entry", &v)
+	return v.GetBoolean()
+}
+
+// Holds a tree model containing the possible values for the combo box.
+// Use the text_column property to specify the column holding the values.
+
+func (x *CellRendererCombo) SetPropertyModel(value TreeModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *CellRendererCombo) GetPropertyModel() TreeModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TreeModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Specifies the model column which holds the possible values for the
+// combo box.
+//
+// Note that this refers to the model specified in the model property,
+// not the model backing the tree view to which
+// this cell renderer is attached.
+//
+// `GtkCellRendererCombo` automatically adds a text cell renderer for
+// this column to its combo box.
+
+func (x *CellRendererCombo) SetPropertyTextColumn(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("text-column", &v)
+}
+
+func (x *CellRendererCombo) GetPropertyTextColumn() int {
+	var v gobject.Value
+	x.GetProperty("text-column", &v)
+	return v.GetInt()
+}
+
 // This signal is emitted each time after the user selected an item in
 // the combo box, either by using the mouse or the arrow keys.  Contrary
 // to GtkComboBox, GtkCellRendererCombo::changed is not emitted for
diff --git a/v4/gtk/gtkcellrendererpixbuf.go b/v4/gtk/gtkcellrendererpixbuf.go
index 4644ce3642c48024432100e99736aa32f27459c1..6fec7b240a4c025122980d94e12376652e316eb5 100644
--- a/v4/gtk/gtkcellrendererpixbuf.go
+++ b/v4/gtk/gtkcellrendererpixbuf.go
@@ -4,6 +4,9 @@
 import (
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gdk"
+	"github.com/jwijenbergh/puregotk/v4/gdkpixbuf"
+	"github.com/jwijenbergh/puregotk/v4/gio"
 	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
@@ -70,6 +73,124 @@ }
 
 func (c *CellRendererPixbuf) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The GIcon representing the icon to display.
+// If the icon theme is changed, the image will be updated
+// automatically.
+
+func (x *CellRendererPixbuf) SetPropertyGicon(value gio.Icon) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("gicon", &v)
+}
+
+func (x *CellRendererPixbuf) GetPropertyGicon() gio.Icon {
+	var v gobject.Value
+	x.GetProperty("gicon", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.IconBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the themed icon to display.
+// This property only has an effect if not overridden by the "pixbuf" property.
+
+func (x *CellRendererPixbuf) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *CellRendererPixbuf) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// The `GtkIconSize` value that specifies the size of the rendered icon.
+
+func (x *CellRendererPixbuf) SetPropertyIconSize(value IconSize) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("icon-size", &v)
+}
+
+func (x *CellRendererPixbuf) GetPropertyIconSize() IconSize {
+	var v gobject.Value
+	x.GetProperty("icon-size", &v)
+	return IconSize(v.GetEnum())
+}
+
+func (x *CellRendererPixbuf) SetPropertyPixbuf(value *gdkpixbuf.Pixbuf) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("pixbuf", &v)
+}
+
+func (x *CellRendererPixbuf) SetPropertyPixbufExpanderClosed(value *gdkpixbuf.Pixbuf) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("pixbuf-expander-closed", &v)
+}
+
+func (x *CellRendererPixbuf) GetPropertyPixbufExpanderClosed() *gdkpixbuf.Pixbuf {
+	var v gobject.Value
+	x.GetProperty("pixbuf-expander-closed", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdkpixbuf.Pixbuf{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *CellRendererPixbuf) SetPropertyPixbufExpanderOpen(value *gdkpixbuf.Pixbuf) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("pixbuf-expander-open", &v)
+}
+
+func (x *CellRendererPixbuf) GetPropertyPixbufExpanderOpen() *gdkpixbuf.Pixbuf {
+	var v gobject.Value
+	x.GetProperty("pixbuf-expander-open", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdkpixbuf.Pixbuf{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *CellRendererPixbuf) SetPropertyTexture(value *gdk.Texture) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("texture", &v)
+}
+
+func (x *CellRendererPixbuf) GetPropertyTexture() *gdk.Texture {
+	var v gobject.Value
+	x.GetProperty("texture", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Texture{}
+	result.Ptr = ptr
+	return result
 }
 
 func init() {
diff --git a/v4/gtk/gtkcellrendererprogress.go b/v4/gtk/gtkcellrendererprogress.go
index cc712a5c1da7d62d7fa076ff9e8068c7b11b6274..40c66a21c7dba7716cf422e8e445733d687f8fcc 100644
--- a/v4/gtk/gtkcellrendererprogress.go
+++ b/v4/gtk/gtkcellrendererprogress.go
@@ -56,6 +56,111 @@ func (c *CellRendererProgress) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *CellRendererProgress) SetPropertyInverted(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("inverted", &v)
+}
+
+func (x *CellRendererProgress) GetPropertyInverted() bool {
+	var v gobject.Value
+	x.GetProperty("inverted", &v)
+	return v.GetBoolean()
+}
+
+// Setting this to a non-negative value causes the cell renderer to
+// enter "activity mode", where a block bounces back and forth to
+// indicate that some progress is made, without specifying exactly how
+// much.
+//
+// Each increment of the property causes the block to move by a little
+// bit.
+//
+// To indicate that the activity has not started yet, set the property
+// to zero. To indicate completion, set the property to %G_MAXINT.
+
+func (x *CellRendererProgress) SetPropertyPulse(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("pulse", &v)
+}
+
+func (x *CellRendererProgress) GetPropertyPulse() int {
+	var v gobject.Value
+	x.GetProperty("pulse", &v)
+	return v.GetInt()
+}
+
+// The "text" property determines the label which will be drawn
+// over the progress bar. Setting this property to %NULL causes the default
+// label to be displayed. Setting this property to an empty string causes
+// no label to be displayed.
+
+func (x *CellRendererProgress) SetPropertyText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("text", &v)
+}
+
+func (x *CellRendererProgress) GetPropertyText() string {
+	var v gobject.Value
+	x.GetProperty("text", &v)
+	return v.GetString()
+}
+
+// The "text-xalign" property controls the horizontal alignment of the
+// text in the progress bar.  Valid values range from 0 (left) to 1
+// (right).  Reserved for RTL layouts.
+
+func (x *CellRendererProgress) SetPropertyTextXalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("text-xalign", &v)
+}
+
+func (x *CellRendererProgress) GetPropertyTextXalign() float32 {
+	var v gobject.Value
+	x.GetProperty("text-xalign", &v)
+	return v.GetFloat()
+}
+
+// The "text-yalign" property controls the vertical alignment of the
+// text in the progress bar.  Valid values range from 0 (top) to 1
+// (bottom).
+
+func (x *CellRendererProgress) SetPropertyTextYalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("text-yalign", &v)
+}
+
+func (x *CellRendererProgress) GetPropertyTextYalign() float32 {
+	var v gobject.Value
+	x.GetProperty("text-yalign", &v)
+	return v.GetFloat()
+}
+
+// The "value" property determines the percentage to which the
+// progress bar will be "filled in".
+
+func (x *CellRendererProgress) SetPropertyValue(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("value", &v)
+}
+
+func (x *CellRendererProgress) GetPropertyValue() int {
+	var v gobject.Value
+	x.GetProperty("value", &v)
+	return v.GetInt()
+}
+
 // Retrieves the orientation of the @orientable.
 func (x *CellRendererProgress) GetOrientation() Orientation {
 
diff --git a/v4/gtk/gtkcellrendererspin.go b/v4/gtk/gtkcellrendererspin.go
index ca38132ad679cb8c7e65ba3298ea2d14fbc8ff12..4574a53e6061bfd09f213968d442ac8a2328933f 100644
--- a/v4/gtk/gtkcellrendererspin.go
+++ b/v4/gtk/gtkcellrendererspin.go
@@ -67,6 +67,58 @@ func (c *CellRendererSpin) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The adjustment that holds the value of the spinbutton.
+// This must be non-%NULL for the cell renderer to be editable.
+
+func (x *CellRendererSpin) SetPropertyAdjustment(value *Adjustment) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("adjustment", &v)
+}
+
+func (x *CellRendererSpin) GetPropertyAdjustment() *Adjustment {
+	var v gobject.Value
+	x.GetProperty("adjustment", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Adjustment{}
+	result.Ptr = ptr
+	return result
+}
+
+// The acceleration rate when you hold down a button.
+
+func (x *CellRendererSpin) SetPropertyClimbRate(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("climb-rate", &v)
+}
+
+func (x *CellRendererSpin) GetPropertyClimbRate() float64 {
+	var v gobject.Value
+	x.GetProperty("climb-rate", &v)
+	return v.GetDouble()
+}
+
+// The number of decimal places to display.
+
+func (x *CellRendererSpin) SetPropertyDigits(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("digits", &v)
+}
+
+func (x *CellRendererSpin) GetPropertyDigits() uint {
+	var v gobject.Value
+	x.GetProperty("digits", &v)
+	return v.GetUint()
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkcellrendererspinner.go b/v4/gtk/gtkcellrendererspinner.go
index 5dbc81304c5c129216d238cb11de0285f5d91bb9..4779817ee681d87fc402dbb5b854abc7043bdd3d 100644
--- a/v4/gtk/gtkcellrendererspinner.go
+++ b/v4/gtk/gtkcellrendererspinner.go
@@ -65,6 +65,53 @@ func (c *CellRendererSpinner) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *CellRendererSpinner) SetPropertyActive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("active", &v)
+}
+
+func (x *CellRendererSpinner) GetPropertyActive() bool {
+	var v gobject.Value
+	x.GetProperty("active", &v)
+	return v.GetBoolean()
+}
+
+// Pulse of the spinner. Increment this value to draw the next frame of the
+// spinner animation. Usually, you would update this value in a timeout.
+//
+// By default, the `GtkSpinner` widget draws one full cycle of the animation,
+// consisting of 12 frames, in 750 milliseconds.
+
+func (x *CellRendererSpinner) SetPropertyPulse(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("pulse", &v)
+}
+
+func (x *CellRendererSpinner) GetPropertyPulse() uint {
+	var v gobject.Value
+	x.GetProperty("pulse", &v)
+	return v.GetUint()
+}
+
+// The `GtkIconSize` value that specifies the size of the rendered spinner.
+
+func (x *CellRendererSpinner) SetPropertySize(value IconSize) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("size", &v)
+}
+
+func (x *CellRendererSpinner) GetPropertySize() IconSize {
+	var v gobject.Value
+	x.GetProperty("size", &v)
+	return IconSize(v.GetEnum())
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkcellrenderertext.go b/v4/gtk/gtkcellrenderertext.go
index 5ba4a009e2e7d2d9767b2e6d8b4ecea2d83ac05f..c5e96c3318dbf20e81ad7492ea3c2eb9fc7b05a5 100644
--- a/v4/gtk/gtkcellrenderertext.go
+++ b/v4/gtk/gtkcellrenderertext.go
@@ -10,6 +10,7 @@ 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
 	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/pango"
 )
 
 type CellRendererTextClass struct {
@@ -120,6 +121,625 @@ }
 
 func (c *CellRendererText) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+func (x *CellRendererText) SetPropertyAlignSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("align-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyAlignSet() bool {
+	var v gobject.Value
+	x.GetProperty("align-set", &v)
+	return v.GetBoolean()
+}
+
+// Specifies how to align the lines of text with respect to each other.
+//
+// Note that this property describes how to align the lines of text in
+// case there are several of them. The "xalign" property of `GtkCellRenderer`,
+// on the other hand, sets the horizontal alignment of the whole text.
+
+func (x *CellRendererText) SetPropertyAlignment(value pango.Alignment) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("alignment", &v)
+}
+
+func (x *CellRendererText) GetPropertyAlignment() pango.Alignment {
+	var v gobject.Value
+	x.GetProperty("alignment", &v)
+	return pango.Alignment(v.GetEnum())
+}
+
+func (x *CellRendererText) SetPropertyAttributes(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("attributes", &v)
+}
+
+func (x *CellRendererText) GetPropertyAttributes() uintptr {
+	var v gobject.Value
+	x.GetProperty("attributes", &v)
+	return v.GetPointer()
+}
+
+func (x *CellRendererText) SetPropertyBackground(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("background", &v)
+}
+
+// Background color as a `GdkRGBA`
+
+func (x *CellRendererText) SetPropertyBackgroundRgba(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("background-rgba", &v)
+}
+
+func (x *CellRendererText) GetPropertyBackgroundRgba() uintptr {
+	var v gobject.Value
+	x.GetProperty("background-rgba", &v)
+	return v.GetPointer()
+}
+
+func (x *CellRendererText) SetPropertyBackgroundSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("background-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyBackgroundSet() bool {
+	var v gobject.Value
+	x.GetProperty("background-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyEditable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("editable", &v)
+}
+
+func (x *CellRendererText) GetPropertyEditable() bool {
+	var v gobject.Value
+	x.GetProperty("editable", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyEditableSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("editable-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyEditableSet() bool {
+	var v gobject.Value
+	x.GetProperty("editable-set", &v)
+	return v.GetBoolean()
+}
+
+// Specifies the preferred place to ellipsize the string, if the cell renderer
+// does not have enough room to display the entire string. Setting it to
+// %PANGO_ELLIPSIZE_NONE turns off ellipsizing. See the wrap-width property
+// for another way of making the text fit into a given width.
+
+func (x *CellRendererText) SetPropertyEllipsize(value pango.EllipsizeMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("ellipsize", &v)
+}
+
+func (x *CellRendererText) GetPropertyEllipsize() pango.EllipsizeMode {
+	var v gobject.Value
+	x.GetProperty("ellipsize", &v)
+	return pango.EllipsizeMode(v.GetEnum())
+}
+
+func (x *CellRendererText) SetPropertyEllipsizeSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("ellipsize-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyEllipsizeSet() bool {
+	var v gobject.Value
+	x.GetProperty("ellipsize-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyFamily(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("family", &v)
+}
+
+func (x *CellRendererText) GetPropertyFamily() string {
+	var v gobject.Value
+	x.GetProperty("family", &v)
+	return v.GetString()
+}
+
+func (x *CellRendererText) SetPropertyFamilySet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("family-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyFamilySet() bool {
+	var v gobject.Value
+	x.GetProperty("family-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyFont(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("font", &v)
+}
+
+func (x *CellRendererText) GetPropertyFont() string {
+	var v gobject.Value
+	x.GetProperty("font", &v)
+	return v.GetString()
+}
+
+func (x *CellRendererText) SetPropertyFontDesc(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("font-desc", &v)
+}
+
+func (x *CellRendererText) GetPropertyFontDesc() uintptr {
+	var v gobject.Value
+	x.GetProperty("font-desc", &v)
+	return v.GetPointer()
+}
+
+func (x *CellRendererText) SetPropertyForeground(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("foreground", &v)
+}
+
+// Foreground color as a `GdkRGBA`
+
+func (x *CellRendererText) SetPropertyForegroundRgba(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("foreground-rgba", &v)
+}
+
+func (x *CellRendererText) GetPropertyForegroundRgba() uintptr {
+	var v gobject.Value
+	x.GetProperty("foreground-rgba", &v)
+	return v.GetPointer()
+}
+
+func (x *CellRendererText) SetPropertyForegroundSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("foreground-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyForegroundSet() bool {
+	var v gobject.Value
+	x.GetProperty("foreground-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyLanguage(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("language", &v)
+}
+
+func (x *CellRendererText) GetPropertyLanguage() string {
+	var v gobject.Value
+	x.GetProperty("language", &v)
+	return v.GetString()
+}
+
+func (x *CellRendererText) SetPropertyLanguageSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("language-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyLanguageSet() bool {
+	var v gobject.Value
+	x.GetProperty("language-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyMarkup(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("markup", &v)
+}
+
+// The desired maximum width of the cell, in characters. If this property
+// is set to -1, the width will be calculated automatically.
+//
+// For cell renderers that ellipsize or wrap text; this property
+// controls the maximum reported width of the cell. The
+// cell should not receive any greater allocation unless it is
+// set to expand in its `GtkCellLayout` and all of the cell's siblings
+// have received their natural width.
+
+func (x *CellRendererText) SetPropertyMaxWidthChars(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-width-chars", &v)
+}
+
+func (x *CellRendererText) GetPropertyMaxWidthChars() int {
+	var v gobject.Value
+	x.GetProperty("max-width-chars", &v)
+	return v.GetInt()
+}
+
+// The text that will be displayed in the `GtkCellRenderer` if
+// `GtkCellRendererText:editable` is %TRUE and the cell is empty.
+
+func (x *CellRendererText) SetPropertyPlaceholderText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("placeholder-text", &v)
+}
+
+func (x *CellRendererText) GetPropertyPlaceholderText() string {
+	var v gobject.Value
+	x.GetProperty("placeholder-text", &v)
+	return v.GetString()
+}
+
+func (x *CellRendererText) SetPropertyRise(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("rise", &v)
+}
+
+func (x *CellRendererText) GetPropertyRise() int {
+	var v gobject.Value
+	x.GetProperty("rise", &v)
+	return v.GetInt()
+}
+
+func (x *CellRendererText) SetPropertyRiseSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("rise-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyRiseSet() bool {
+	var v gobject.Value
+	x.GetProperty("rise-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyScale(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("scale", &v)
+}
+
+func (x *CellRendererText) GetPropertyScale() float64 {
+	var v gobject.Value
+	x.GetProperty("scale", &v)
+	return v.GetDouble()
+}
+
+func (x *CellRendererText) SetPropertyScaleSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("scale-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyScaleSet() bool {
+	var v gobject.Value
+	x.GetProperty("scale-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertySingleParagraphMode(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("single-paragraph-mode", &v)
+}
+
+func (x *CellRendererText) GetPropertySingleParagraphMode() bool {
+	var v gobject.Value
+	x.GetProperty("single-paragraph-mode", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertySize(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("size", &v)
+}
+
+func (x *CellRendererText) GetPropertySize() int {
+	var v gobject.Value
+	x.GetProperty("size", &v)
+	return v.GetInt()
+}
+
+func (x *CellRendererText) SetPropertySizePoints(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("size-points", &v)
+}
+
+func (x *CellRendererText) GetPropertySizePoints() float64 {
+	var v gobject.Value
+	x.GetProperty("size-points", &v)
+	return v.GetDouble()
+}
+
+func (x *CellRendererText) SetPropertySizeSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("size-set", &v)
+}
+
+func (x *CellRendererText) GetPropertySizeSet() bool {
+	var v gobject.Value
+	x.GetProperty("size-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyStretch(value pango.Stretch) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("stretch", &v)
+}
+
+func (x *CellRendererText) GetPropertyStretch() pango.Stretch {
+	var v gobject.Value
+	x.GetProperty("stretch", &v)
+	return pango.Stretch(v.GetEnum())
+}
+
+func (x *CellRendererText) SetPropertyStretchSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("stretch-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyStretchSet() bool {
+	var v gobject.Value
+	x.GetProperty("stretch-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyStrikethrough(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("strikethrough", &v)
+}
+
+func (x *CellRendererText) GetPropertyStrikethrough() bool {
+	var v gobject.Value
+	x.GetProperty("strikethrough", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyStrikethroughSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("strikethrough-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyStrikethroughSet() bool {
+	var v gobject.Value
+	x.GetProperty("strikethrough-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyStyle(value pango.Style) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("style", &v)
+}
+
+func (x *CellRendererText) GetPropertyStyle() pango.Style {
+	var v gobject.Value
+	x.GetProperty("style", &v)
+	return pango.Style(v.GetEnum())
+}
+
+func (x *CellRendererText) SetPropertyStyleSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("style-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyStyleSet() bool {
+	var v gobject.Value
+	x.GetProperty("style-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("text", &v)
+}
+
+func (x *CellRendererText) GetPropertyText() string {
+	var v gobject.Value
+	x.GetProperty("text", &v)
+	return v.GetString()
+}
+
+func (x *CellRendererText) SetPropertyUnderline(value pango.Underline) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("underline", &v)
+}
+
+func (x *CellRendererText) GetPropertyUnderline() pango.Underline {
+	var v gobject.Value
+	x.GetProperty("underline", &v)
+	return pango.Underline(v.GetEnum())
+}
+
+func (x *CellRendererText) SetPropertyUnderlineSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("underline-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyUnderlineSet() bool {
+	var v gobject.Value
+	x.GetProperty("underline-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyVariant(value pango.Variant) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("variant", &v)
+}
+
+func (x *CellRendererText) GetPropertyVariant() pango.Variant {
+	var v gobject.Value
+	x.GetProperty("variant", &v)
+	return pango.Variant(v.GetEnum())
+}
+
+func (x *CellRendererText) SetPropertyVariantSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("variant-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyVariantSet() bool {
+	var v gobject.Value
+	x.GetProperty("variant-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererText) SetPropertyWeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("weight", &v)
+}
+
+func (x *CellRendererText) GetPropertyWeight() int {
+	var v gobject.Value
+	x.GetProperty("weight", &v)
+	return v.GetInt()
+}
+
+func (x *CellRendererText) SetPropertyWeightSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("weight-set", &v)
+}
+
+func (x *CellRendererText) GetPropertyWeightSet() bool {
+	var v gobject.Value
+	x.GetProperty("weight-set", &v)
+	return v.GetBoolean()
+}
+
+// The desired width of the cell, in characters. If this property is set to
+// -1, the width will be calculated automatically, otherwise the cell will
+// request either 3 characters or the property value, whichever is greater.
+
+func (x *CellRendererText) SetPropertyWidthChars(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("width-chars", &v)
+}
+
+func (x *CellRendererText) GetPropertyWidthChars() int {
+	var v gobject.Value
+	x.GetProperty("width-chars", &v)
+	return v.GetInt()
+}
+
+// Specifies how to break the string into multiple lines, if the cell
+// renderer does not have enough room to display the entire string.
+// This property has no effect unless the wrap-width property is set.
+
+func (x *CellRendererText) SetPropertyWrapMode(value pango.WrapMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("wrap-mode", &v)
+}
+
+func (x *CellRendererText) GetPropertyWrapMode() pango.WrapMode {
+	var v gobject.Value
+	x.GetProperty("wrap-mode", &v)
+	return pango.WrapMode(v.GetEnum())
+}
+
+// Specifies the minimum width at which the text is wrapped. The wrap-mode property can
+// be used to influence at what character positions the line breaks can be placed.
+// Setting wrap-width to -1 turns wrapping off.
+
+func (x *CellRendererText) SetPropertyWrapWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("wrap-width", &v)
+}
+
+func (x *CellRendererText) GetPropertyWrapWidth() int {
+	var v gobject.Value
+	x.GetProperty("wrap-width", &v)
+	return v.GetInt()
 }
 
 // This signal is emitted after @renderer has been edited.
diff --git a/v4/gtk/gtkcellrenderertoggle.go b/v4/gtk/gtkcellrenderertoggle.go
index 2e7d53979d56090801f3fa9328d15c1967e5553f..37fb5391b4a228302413e6ad780134a06a1aa8ef 100644
--- a/v4/gtk/gtkcellrenderertoggle.go
+++ b/v4/gtk/gtkcellrenderertoggle.go
@@ -129,6 +129,58 @@ func (c *CellRendererToggle) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *CellRendererToggle) SetPropertyActivatable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activatable", &v)
+}
+
+func (x *CellRendererToggle) GetPropertyActivatable() bool {
+	var v gobject.Value
+	x.GetProperty("activatable", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererToggle) SetPropertyActive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("active", &v)
+}
+
+func (x *CellRendererToggle) GetPropertyActive() bool {
+	var v gobject.Value
+	x.GetProperty("active", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererToggle) SetPropertyInconsistent(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("inconsistent", &v)
+}
+
+func (x *CellRendererToggle) GetPropertyInconsistent() bool {
+	var v gobject.Value
+	x.GetProperty("inconsistent", &v)
+	return v.GetBoolean()
+}
+
+func (x *CellRendererToggle) SetPropertyRadio(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("radio", &v)
+}
+
+func (x *CellRendererToggle) GetPropertyRadio() bool {
+	var v gobject.Value
+	x.GetProperty("radio", &v)
+	return v.GetBoolean()
+}
+
 // The ::toggled signal is emitted when the cell is toggled.
 //
 // It is the responsibility of the application to update the model
diff --git a/v4/gtk/gtkcellview.go b/v4/gtk/gtkcellview.go
index 98f8d361513a71dba101834788ebc3d3e23a9f75..2781438209162164cc133a2e3a39d669568a1b3a 100644
--- a/v4/gtk/gtkcellview.go
+++ b/v4/gtk/gtkcellview.go
@@ -250,6 +250,126 @@ func (c *CellView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GtkCellArea` rendering cells
+//
+// If no area is specified when creating the cell view with gtk_cell_view_new_with_context()
+// a horizontally oriented `GtkCellArea`Box will be used.
+//
+// since 3.0
+
+func (x *CellView) SetPropertyCellArea(value *CellArea) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("cell-area", &v)
+}
+
+func (x *CellView) GetPropertyCellArea() *CellArea {
+	var v gobject.Value
+	x.GetProperty("cell-area", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &CellArea{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GtkCellAreaContext` used to compute the geometry of the cell view.
+//
+// A group of cell views can be assigned the same context in order to
+// ensure the sizes and cell alignments match across all the views with
+// the same context.
+//
+// `GtkComboBox` menus uses this to assign the same context to all cell views
+// in the menu items for a single menu (each submenu creates its own
+// context since the size of each submenu does not depend on parent
+// or sibling menus).
+//
+// since 3.0
+
+func (x *CellView) SetPropertyCellAreaContext(value *CellAreaContext) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("cell-area-context", &v)
+}
+
+func (x *CellView) GetPropertyCellAreaContext() *CellAreaContext {
+	var v gobject.Value
+	x.GetProperty("cell-area-context", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &CellAreaContext{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether all cells should be draw as sensitive for this view regardless
+// of the actual cell properties (used to make menus with submenus appear
+// sensitive when the items in submenus might be insensitive).
+//
+// since 3.0
+
+func (x *CellView) SetPropertyDrawSensitive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("draw-sensitive", &v)
+}
+
+func (x *CellView) GetPropertyDrawSensitive() bool {
+	var v gobject.Value
+	x.GetProperty("draw-sensitive", &v)
+	return v.GetBoolean()
+}
+
+// Whether the view should request enough space to always fit
+// the size of every row in the model (used by the combo box to
+// ensure the combo box size doesn't change when different items
+// are selected).
+//
+// since 3.0
+
+func (x *CellView) SetPropertyFitModel(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("fit-model", &v)
+}
+
+func (x *CellView) GetPropertyFitModel() bool {
+	var v gobject.Value
+	x.GetProperty("fit-model", &v)
+	return v.GetBoolean()
+}
+
+// The model for cell view
+//
+// since 2.10
+
+func (x *CellView) SetPropertyModel(value TreeModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *CellView) GetPropertyModel() TreeModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TreeModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *CellView) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkcenterbox.go b/v4/gtk/gtkcenterbox.go
index c213d0a865668f58f81993d631dc3b7633fe718e..3daf1be2eba557dec4b6a1cdbce9a78406e287d0 100644
--- a/v4/gtk/gtkcenterbox.go
+++ b/v4/gtk/gtkcenterbox.go
@@ -203,6 +203,21 @@ func (c *CenterBox) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The position of the baseline aligned widget if extra space is available.
+
+func (x *CenterBox) SetPropertyBaselinePosition(value BaselinePosition) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("baseline-position", &v)
+}
+
+func (x *CenterBox) GetPropertyBaselinePosition() BaselinePosition {
+	var v gobject.Value
+	x.GetProperty("baseline-position", &v)
+	return BaselinePosition(v.GetEnum())
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *CenterBox) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkcheckbutton.go b/v4/gtk/gtkcheckbutton.go
index 5ed5742548a6c4300552251bd7b6e87b37545b0a..44e71c0e45c278c3165b0667be5380a589db1e00 100644
--- a/v4/gtk/gtkcheckbutton.go
+++ b/v4/gtk/gtkcheckbutton.go
@@ -342,6 +342,103 @@ func (c *CheckButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If the check button is active.
+//
+// Setting `active` to %TRUE will add the `:checked:` state to both
+// the check button and the indicator CSS node.
+
+func (x *CheckButton) SetPropertyActive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("active", &v)
+}
+
+func (x *CheckButton) GetPropertyActive() bool {
+	var v gobject.Value
+	x.GetProperty("active", &v)
+	return v.GetBoolean()
+}
+
+// The child widget.
+
+func (x *CheckButton) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *CheckButton) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The check button whose group this widget belongs to.
+
+func (x *CheckButton) SetPropertyGroup(value *CheckButton) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("group", &v)
+}
+
+// If the check button is in an âin betweenâ state.
+//
+// The inconsistent state only affects visual appearance,
+// not the semantics of the button.
+
+func (x *CheckButton) SetPropertyInconsistent(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("inconsistent", &v)
+}
+
+func (x *CheckButton) GetPropertyInconsistent() bool {
+	var v gobject.Value
+	x.GetProperty("inconsistent", &v)
+	return v.GetBoolean()
+}
+
+// Text of the label inside the check button, if it contains a label widget.
+
+func (x *CheckButton) SetPropertyLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("label", &v)
+}
+
+func (x *CheckButton) GetPropertyLabel() string {
+	var v gobject.Value
+	x.GetProperty("label", &v)
+	return v.GetString()
+}
+
+// If set, an underline in the text indicates that the following
+// character is to be used as mnemonic.
+
+func (x *CheckButton) SetPropertyUseUnderline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-underline", &v)
+}
+
+func (x *CheckButton) GetPropertyUseUnderline() bool {
+	var v gobject.Value
+	x.GetProperty("use-underline", &v)
+	return v.GetBoolean()
+}
+
 // Emitted to when the check button is activated.
 //
 // The `::activate` signal on `GtkCheckButton` is an action signal and
diff --git a/v4/gtk/gtkcolorbutton.go b/v4/gtk/gtkcolorbutton.go
index f36e94f00cc628471d43c87571376b1c5bd9b4f1..e484061b64d8434e7d84a9c6280a49ef9397e31e 100644
--- a/v4/gtk/gtkcolorbutton.go
+++ b/v4/gtk/gtkcolorbutton.go
@@ -135,6 +135,55 @@ func (c *ColorButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the color chooser dialog should be modal.
+
+func (x *ColorButton) SetPropertyModal(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("modal", &v)
+}
+
+func (x *ColorButton) GetPropertyModal() bool {
+	var v gobject.Value
+	x.GetProperty("modal", &v)
+	return v.GetBoolean()
+}
+
+// Whether the color chooser should open in editor mode.
+//
+// This property should be used in cases where the palette
+// in the editor would be redundant, such as when the color
+// button is already part of a palette.
+
+func (x *ColorButton) SetPropertyShowEditor(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-editor", &v)
+}
+
+func (x *ColorButton) GetPropertyShowEditor() bool {
+	var v gobject.Value
+	x.GetProperty("show-editor", &v)
+	return v.GetBoolean()
+}
+
+// The title of the color chooser dialog
+
+func (x *ColorButton) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *ColorButton) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
 // Emitted to when the color button is activated.
 //
 // The `::activate` signal on `GtkMenuButton` is an action signal and
diff --git a/v4/gtk/gtkcolorchooser.go b/v4/gtk/gtkcolorchooser.go
index 8727841b14dda7d3758c0c9cf2234c4d701899c2..bb7fe5288fdcc7dd494f41839b7a5c209ce8529f 100644
--- a/v4/gtk/gtkcolorchooser.go
+++ b/v4/gtk/gtkcolorchooser.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/gdk"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -211,6 +212,50 @@ func (x *ColorChooserBase) SetUseAlpha(UseAlphaVar bool) {
 
 	XGtkColorChooserSetUseAlpha(x.GoPointer(), UseAlphaVar)
 
+}
+
+// The currently selected color, as a `GdkRGBA` struct.
+//
+// The property can be set to change the current selection
+// programmatically.
+
+func (x *ColorChooserBase) SetPropertyRgba(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("rgba", &v)
+}
+
+func (x *ColorChooserBase) GetPropertyRgba() uintptr {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("rgba", &v)
+	return v.GetPointer()
+}
+
+// Whether colors may have alpha (translucency).
+//
+// When ::use-alpha is %FALSE, the `GdkRGBA` struct obtained
+// via the [property@Gtk.ColorChooser:rgba] property will be
+// forced to have alpha == 1.
+//
+// Implementations are expected to show alpha by rendering the color
+// over a non-uniform background (like a checkerboard pattern).
+
+func (x *ColorChooserBase) SetPropertyUseAlpha(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("use-alpha", &v)
+}
+
+func (x *ColorChooserBase) GetPropertyUseAlpha() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("use-alpha", &v)
+	return v.GetBoolean()
 }
 
 var XGtkColorChooserAddPalette func(uintptr, Orientation, int, int, []gdk.RGBA)
diff --git a/v4/gtk/gtkcolorchooserdialog.go b/v4/gtk/gtkcolorchooserdialog.go
index 02450db89a86d3820bf096cf5d0c49e9c0963db3..7b0e1f9968b0d3b92458661d9cc79f8d1cd2cf0f 100644
--- a/v4/gtk/gtkcolorchooserdialog.go
+++ b/v4/gtk/gtkcolorchooserdialog.go
@@ -66,6 +66,19 @@ func (c *ColorChooserDialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *ColorChooserDialog) SetPropertyShowEditor(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-editor", &v)
+}
+
+func (x *ColorChooserDialog) GetPropertyShowEditor() bool {
+	var v gobject.Value
+	x.GetProperty("show-editor", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ColorChooserDialog) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkcolorchooserwidget.go b/v4/gtk/gtkcolorchooserwidget.go
index 07f61ac87f01ebff313ed286d0d57bbc097b6584..1ee3eb64c85db96ee224f0a4d95a3acea16df09a 100644
--- a/v4/gtk/gtkcolorchooserwidget.go
+++ b/v4/gtk/gtkcolorchooserwidget.go
@@ -77,6 +77,23 @@ func (c *ColorChooserWidget) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// %TRUE when the color chooser is showing the single-color editor.
+//
+// It can be set to switch the color chooser into single-color editing mode.
+
+func (x *ColorChooserWidget) SetPropertyShowEditor(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-editor", &v)
+}
+
+func (x *ColorChooserWidget) GetPropertyShowEditor() bool {
+	var v gobject.Value
+	x.GetProperty("show-editor", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ColorChooserWidget) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkcolumnview.go b/v4/gtk/gtkcolumnview.go
index 28c36cf4581083fed4516982026438fa00cf4d28..471f24c5553d9d78773085cba07f5539a9383546 100644
--- a/v4/gtk/gtkcolumnview.go
+++ b/v4/gtk/gtkcolumnview.go
@@ -362,6 +362,130 @@ func (c *ColumnView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The list of columns.
+
+func (x *ColumnView) GetPropertyColumns() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("columns", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Allow rubberband selection.
+
+func (x *ColumnView) SetPropertyEnableRubberband(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-rubberband", &v)
+}
+
+func (x *ColumnView) GetPropertyEnableRubberband() bool {
+	var v gobject.Value
+	x.GetProperty("enable-rubberband", &v)
+	return v.GetBoolean()
+}
+
+// Model for the items displayed.
+
+func (x *ColumnView) SetPropertyModel(value SelectionModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *ColumnView) GetPropertyModel() SelectionModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SelectionModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether columns are reorderable.
+
+func (x *ColumnView) SetPropertyReorderable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reorderable", &v)
+}
+
+func (x *ColumnView) GetPropertyReorderable() bool {
+	var v gobject.Value
+	x.GetProperty("reorderable", &v)
+	return v.GetBoolean()
+}
+
+// Show separators between columns.
+
+func (x *ColumnView) SetPropertyShowColumnSeparators(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-column-separators", &v)
+}
+
+func (x *ColumnView) GetPropertyShowColumnSeparators() bool {
+	var v gobject.Value
+	x.GetProperty("show-column-separators", &v)
+	return v.GetBoolean()
+}
+
+// Show separators between rows.
+
+func (x *ColumnView) SetPropertyShowRowSeparators(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-row-separators", &v)
+}
+
+func (x *ColumnView) GetPropertyShowRowSeparators() bool {
+	var v gobject.Value
+	x.GetProperty("show-row-separators", &v)
+	return v.GetBoolean()
+}
+
+// Activate rows on single click and select them on hover.
+
+func (x *ColumnView) SetPropertySingleClickActivate(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("single-click-activate", &v)
+}
+
+func (x *ColumnView) GetPropertySingleClickActivate() bool {
+	var v gobject.Value
+	x.GetProperty("single-click-activate", &v)
+	return v.GetBoolean()
+}
+
+// Sorter with the sorting choices of the user.
+
+func (x *ColumnView) GetPropertySorter() *Sorter {
+	var v gobject.Value
+	x.GetProperty("sorter", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Sorter{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emitted when a row has been activated by the user, usually via activating
 // the GtkListBase|list.activate-item action.
 //
diff --git a/v4/gtk/gtkcolumnviewcolumn.go b/v4/gtk/gtkcolumnviewcolumn.go
index 26707a98014d6a6f340cf3a7777b32fff29f7a7b..2c7a2acc7abe2adb6e221ac039ce89bae82e7a15 100644
--- a/v4/gtk/gtkcolumnviewcolumn.go
+++ b/v4/gtk/gtkcolumnviewcolumn.go
@@ -298,6 +298,159 @@ func (c *ColumnViewColumn) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GtkColumnView` this column is a part of.
+
+func (x *ColumnViewColumn) GetPropertyColumnView() *ColumnView {
+	var v gobject.Value
+	x.GetProperty("column-view", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ColumnView{}
+	result.Ptr = ptr
+	return result
+}
+
+// Column gets share of extra width allocated to the view.
+
+func (x *ColumnViewColumn) SetPropertyExpand(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("expand", &v)
+}
+
+func (x *ColumnViewColumn) GetPropertyExpand() bool {
+	var v gobject.Value
+	x.GetProperty("expand", &v)
+	return v.GetBoolean()
+}
+
+// Factory for populating list items.
+
+func (x *ColumnViewColumn) SetPropertyFactory(value *ListItemFactory) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("factory", &v)
+}
+
+func (x *ColumnViewColumn) GetPropertyFactory() *ListItemFactory {
+	var v gobject.Value
+	x.GetProperty("factory", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ListItemFactory{}
+	result.Ptr = ptr
+	return result
+}
+
+// If not -1, this is the width that the column is allocated,
+// regardless of the size of its content.
+
+func (x *ColumnViewColumn) SetPropertyFixedWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("fixed-width", &v)
+}
+
+func (x *ColumnViewColumn) GetPropertyFixedWidth() int {
+	var v gobject.Value
+	x.GetProperty("fixed-width", &v)
+	return v.GetInt()
+}
+
+// Menu model used to create the context menu for the column header.
+
+func (x *ColumnViewColumn) SetPropertyHeaderMenu(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("header-menu", &v)
+}
+
+func (x *ColumnViewColumn) GetPropertyHeaderMenu() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("header-menu", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether this column is resizable.
+
+func (x *ColumnViewColumn) SetPropertyResizable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("resizable", &v)
+}
+
+func (x *ColumnViewColumn) GetPropertyResizable() bool {
+	var v gobject.Value
+	x.GetProperty("resizable", &v)
+	return v.GetBoolean()
+}
+
+// Sorter for sorting items according to this column.
+
+func (x *ColumnViewColumn) SetPropertySorter(value *Sorter) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("sorter", &v)
+}
+
+func (x *ColumnViewColumn) GetPropertySorter() *Sorter {
+	var v gobject.Value
+	x.GetProperty("sorter", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Sorter{}
+	result.Ptr = ptr
+	return result
+}
+
+// Title displayed in the header.
+
+func (x *ColumnViewColumn) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *ColumnViewColumn) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// Whether this column is visible.
+
+func (x *ColumnViewColumn) SetPropertyVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("visible", &v)
+}
+
+func (x *ColumnViewColumn) GetPropertyVisible() bool {
+	var v gobject.Value
+	x.GetProperty("visible", &v)
+	return v.GetBoolean()
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkcombobox.go b/v4/gtk/gtkcombobox.go
index fddba6c9c46613492795d5438a16503ff47e055f..b01f61c4435e6bd2a1c7596896df1dc9bbfe78f0 100644
--- a/v4/gtk/gtkcombobox.go
+++ b/v4/gtk/gtkcombobox.go
@@ -567,6 +567,190 @@ func (c *ComboBox) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The item which is currently active.
+//
+// If the model is a non-flat treemodel, and the active item is not an
+// immediate child of the root of the tree, this property has the value
+// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
+// [struct@Gtk.TreePath] of the active item.
+
+func (x *ComboBox) SetPropertyActive(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("active", &v)
+}
+
+func (x *ComboBox) GetPropertyActive() int {
+	var v gobject.Value
+	x.GetProperty("active", &v)
+	return v.GetInt()
+}
+
+// The value of the ID column of the active row.
+
+func (x *ComboBox) SetPropertyActiveId(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("active-id", &v)
+}
+
+func (x *ComboBox) GetPropertyActiveId() string {
+	var v gobject.Value
+	x.GetProperty("active-id", &v)
+	return v.GetString()
+}
+
+// Whether the dropdown button is sensitive when
+// the model is empty.
+
+func (x *ComboBox) SetPropertyButtonSensitivity(value SensitivityType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("button-sensitivity", &v)
+}
+
+func (x *ComboBox) GetPropertyButtonSensitivity() SensitivityType {
+	var v gobject.Value
+	x.GetProperty("button-sensitivity", &v)
+	return SensitivityType(v.GetEnum())
+}
+
+// The child widget.
+
+func (x *ComboBox) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *ComboBox) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The model column to associate with strings from the entry.
+//
+// This is property only relevant if the combo was created with
+// [property@Gtk.ComboBox:has-entry] is %TRUE.
+
+func (x *ComboBox) SetPropertyEntryTextColumn(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("entry-text-column", &v)
+}
+
+func (x *ComboBox) GetPropertyEntryTextColumn() int {
+	var v gobject.Value
+	x.GetProperty("entry-text-column", &v)
+	return v.GetInt()
+}
+
+// Whether the combo box has an entry.
+
+func (x *ComboBox) SetPropertyHasEntry(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-entry", &v)
+}
+
+func (x *ComboBox) GetPropertyHasEntry() bool {
+	var v gobject.Value
+	x.GetProperty("has-entry", &v)
+	return v.GetBoolean()
+}
+
+// The `has-frame` property controls whether a frame is drawn around the entry.
+
+func (x *ComboBox) SetPropertyHasFrame(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-frame", &v)
+}
+
+func (x *ComboBox) GetPropertyHasFrame() bool {
+	var v gobject.Value
+	x.GetProperty("has-frame", &v)
+	return v.GetBoolean()
+}
+
+// The model column that provides string IDs for the values
+// in the model, if != -1.
+
+func (x *ComboBox) SetPropertyIdColumn(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("id-column", &v)
+}
+
+func (x *ComboBox) GetPropertyIdColumn() int {
+	var v gobject.Value
+	x.GetProperty("id-column", &v)
+	return v.GetInt()
+}
+
+// The model from which the combo box takes its values.
+
+func (x *ComboBox) SetPropertyModel(value TreeModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *ComboBox) GetPropertyModel() TreeModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TreeModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the popup's width should be a fixed width matching the
+// allocated width of the combo box.
+
+func (x *ComboBox) SetPropertyPopupFixedWidth(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("popup-fixed-width", &v)
+}
+
+func (x *ComboBox) GetPropertyPopupFixedWidth() bool {
+	var v gobject.Value
+	x.GetProperty("popup-fixed-width", &v)
+	return v.GetBoolean()
+}
+
+// Whether the combo boxes dropdown is popped up.
+//
+// Note that this property is mainly useful, because
+// it allows you to connect to notify::popup-shown.
+
+func (x *ComboBox) GetPropertyPopupShown() bool {
+	var v gobject.Value
+	x.GetProperty("popup-shown", &v)
+	return v.GetBoolean()
+}
+
 // Emitted to when the combo box is activated.
 //
 // The `::activate` signal on `GtkComboBox` is an action signal and
diff --git a/v4/gtk/gtkconstraint.go b/v4/gtk/gtkconstraint.go
index e97de12b2954ef7150ae819cd42312b68fe2338f..745b097b7e470d7a46fcb04698f83216cdfdb1dc 100644
--- a/v4/gtk/gtkconstraint.go
+++ b/v4/gtk/gtkconstraint.go
@@ -265,6 +265,152 @@ func (c *Constraint) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The constant value to be added to the [property@Gtk.Constraint:source-attribute].
+
+func (x *Constraint) SetPropertyConstant(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("constant", &v)
+}
+
+func (x *Constraint) GetPropertyConstant() float64 {
+	var v gobject.Value
+	x.GetProperty("constant", &v)
+	return v.GetDouble()
+}
+
+// The multiplication factor to be applied to
+// the [property@Gtk.Constraint:source-attribute].
+
+func (x *Constraint) SetPropertyMultiplier(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("multiplier", &v)
+}
+
+func (x *Constraint) GetPropertyMultiplier() float64 {
+	var v gobject.Value
+	x.GetProperty("multiplier", &v)
+	return v.GetDouble()
+}
+
+// The order relation between the terms of the constraint.
+
+func (x *Constraint) SetPropertyRelation(value ConstraintRelation) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("relation", &v)
+}
+
+func (x *Constraint) GetPropertyRelation() ConstraintRelation {
+	var v gobject.Value
+	x.GetProperty("relation", &v)
+	return ConstraintRelation(v.GetEnum())
+}
+
+// The source of the constraint.
+//
+// The constraint will set the [property@Gtk.Constraint:target-attribute]
+// property of the target using the [property@Gtk.Constraint:source-attribute]
+// property of the source.
+
+func (x *Constraint) SetPropertySource(value ConstraintTarget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("source", &v)
+}
+
+func (x *Constraint) GetPropertySource() ConstraintTarget {
+	var v gobject.Value
+	x.GetProperty("source", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ConstraintTargetBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The attribute of the [property@Gtk.Constraint:source] read by the
+// constraint.
+
+func (x *Constraint) SetPropertySourceAttribute(value ConstraintAttribute) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("source-attribute", &v)
+}
+
+func (x *Constraint) GetPropertySourceAttribute() ConstraintAttribute {
+	var v gobject.Value
+	x.GetProperty("source-attribute", &v)
+	return ConstraintAttribute(v.GetEnum())
+}
+
+// The strength of the constraint.
+//
+// The strength can be expressed either using one of the symbolic values
+// of the [enum@Gtk.ConstraintStrength] enumeration, or any positive integer
+// value.
+
+func (x *Constraint) SetPropertyStrength(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("strength", &v)
+}
+
+func (x *Constraint) GetPropertyStrength() int {
+	var v gobject.Value
+	x.GetProperty("strength", &v)
+	return v.GetInt()
+}
+
+// The target of the constraint.
+//
+// The constraint will set the [property@Gtk.Constraint:target-attribute]
+// property of the target using the [property@Gtk.Constraint:source-attribute]
+// property of the source widget.
+
+func (x *Constraint) SetPropertyTarget(value ConstraintTarget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("target", &v)
+}
+
+func (x *Constraint) GetPropertyTarget() ConstraintTarget {
+	var v gobject.Value
+	x.GetProperty("target", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ConstraintTargetBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The attribute of the [property@Gtk.Constraint:target] set by the constraint.
+
+func (x *Constraint) SetPropertyTargetAttribute(value ConstraintAttribute) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("target-attribute", &v)
+}
+
+func (x *Constraint) GetPropertyTargetAttribute() ConstraintAttribute {
+	var v gobject.Value
+	x.GetProperty("target-attribute", &v)
+	return ConstraintAttribute(v.GetEnum())
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkconstraintguide.go b/v4/gtk/gtkconstraintguide.go
index 04a6a462295d98c64a634690f47bbfde64080bd8..e703fdc933801814165b9db6976353d71b71487f 100644
--- a/v4/gtk/gtkconstraintguide.go
+++ b/v4/gtk/gtkconstraintguide.go
@@ -178,6 +178,127 @@ func (c *ConstraintGuide) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The maximum height of the guide.
+
+func (x *ConstraintGuide) SetPropertyMaxHeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-height", &v)
+}
+
+func (x *ConstraintGuide) GetPropertyMaxHeight() int {
+	var v gobject.Value
+	x.GetProperty("max-height", &v)
+	return v.GetInt()
+}
+
+// The maximum width of the guide.
+
+func (x *ConstraintGuide) SetPropertyMaxWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-width", &v)
+}
+
+func (x *ConstraintGuide) GetPropertyMaxWidth() int {
+	var v gobject.Value
+	x.GetProperty("max-width", &v)
+	return v.GetInt()
+}
+
+// The minimum height of the guide.
+
+func (x *ConstraintGuide) SetPropertyMinHeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("min-height", &v)
+}
+
+func (x *ConstraintGuide) GetPropertyMinHeight() int {
+	var v gobject.Value
+	x.GetProperty("min-height", &v)
+	return v.GetInt()
+}
+
+// The minimum width of the guide.
+
+func (x *ConstraintGuide) SetPropertyMinWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("min-width", &v)
+}
+
+func (x *ConstraintGuide) GetPropertyMinWidth() int {
+	var v gobject.Value
+	x.GetProperty("min-width", &v)
+	return v.GetInt()
+}
+
+// A name that identifies the `GtkConstraintGuide`, for debugging.
+
+func (x *ConstraintGuide) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *ConstraintGuide) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// The preferred, or natural, height of the guide.
+
+func (x *ConstraintGuide) SetPropertyNatHeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("nat-height", &v)
+}
+
+func (x *ConstraintGuide) GetPropertyNatHeight() int {
+	var v gobject.Value
+	x.GetProperty("nat-height", &v)
+	return v.GetInt()
+}
+
+// The preferred, or natural, width of the guide.
+
+func (x *ConstraintGuide) SetPropertyNatWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("nat-width", &v)
+}
+
+func (x *ConstraintGuide) GetPropertyNatWidth() int {
+	var v gobject.Value
+	x.GetProperty("nat-width", &v)
+	return v.GetInt()
+}
+
+// The `GtkConstraintStrength` to be used for the constraint on
+// the natural size of the guide.
+
+func (x *ConstraintGuide) SetPropertyStrength(value ConstraintStrength) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("strength", &v)
+}
+
+func (x *ConstraintGuide) GetPropertyStrength() ConstraintStrength {
+	var v gobject.Value
+	x.GetProperty("strength", &v)
+	return ConstraintStrength(v.GetEnum())
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkdialog.go b/v4/gtk/gtkdialog.go
index 03f62e55d7b2444beeb954a2a60963b8f47e50a2..db03d25d82be1a97593d52abffde4fd7cc59ef47 100644
--- a/v4/gtk/gtkdialog.go
+++ b/v4/gtk/gtkdialog.go
@@ -511,6 +511,38 @@ func (c *Dialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// %TRUE if the dialog uses a headerbar for action buttons
+// instead of the action-area.
+//
+// For technical reasons, this property is declared as an integer
+// property, but you should only set it to %TRUE or %FALSE.
+//
+// ## Creating a dialog with headerbar
+//
+// Builtin `GtkDialog` subclasses such as [class@Gtk.ColorChooserDialog]
+// set this property according to platform conventions (using the
+// [property@Gtk.Settings:gtk-dialogs-use-header] setting).
+//
+// Here is how you can achieve the same:
+//
+// ```c
+// g_object_get (settings, "gtk-dialogs-use-header", &amp;header, NULL);
+// dialog = g_object_new (GTK_TYPE_DIALOG, header, TRUE, NULL);
+// ```
+
+func (x *Dialog) SetPropertyUseHeaderBar(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("use-header-bar", &v)
+}
+
+func (x *Dialog) GetPropertyUseHeaderBar() int {
+	var v gobject.Value
+	x.GetProperty("use-header-bar", &v)
+	return v.GetInt()
+}
+
 // Emitted when the user uses a keybinding to close the dialog.
 //
 // This is a [keybinding signal](class.SignalAction.html).
diff --git a/v4/gtk/gtkdirectorylist.go b/v4/gtk/gtkdirectorylist.go
index 631fec7905b357ba22296da2f18c80b6b19fa81b..5f588f940737a891c73ffd8f5dbd68f952184e1e 100644
--- a/v4/gtk/gtkdirectorylist.go
+++ b/v4/gtk/gtkdirectorylist.go
@@ -224,6 +224,104 @@ func (c *DirectoryList) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The attributes to query.
+
+func (x *DirectoryList) SetPropertyAttributes(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("attributes", &v)
+}
+
+func (x *DirectoryList) GetPropertyAttributes() string {
+	var v gobject.Value
+	x.GetProperty("attributes", &v)
+	return v.GetString()
+}
+
+// Error encountered while loading files.
+
+func (x *DirectoryList) GetPropertyError() uintptr {
+	var v gobject.Value
+	x.GetProperty("error", &v)
+	return v.GetPointer()
+}
+
+// File to query.
+
+func (x *DirectoryList) SetPropertyFile(value gio.File) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("file", &v)
+}
+
+func (x *DirectoryList) GetPropertyFile() gio.File {
+	var v gobject.Value
+	x.GetProperty("file", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.FileBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Priority used when loading.
+
+func (x *DirectoryList) SetPropertyIoPriority(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("io-priority", &v)
+}
+
+func (x *DirectoryList) GetPropertyIoPriority() int {
+	var v gobject.Value
+	x.GetProperty("io-priority", &v)
+	return v.GetInt()
+}
+
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *DirectoryList) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// %TRUE if files are being loaded.
+
+func (x *DirectoryList) GetPropertyLoading() bool {
+	var v gobject.Value
+	x.GetProperty("loading", &v)
+	return v.GetBoolean()
+}
+
+// %TRUE if the directory is monitored for changed.
+
+func (x *DirectoryList) SetPropertyMonitored(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("monitored", &v)
+}
+
+func (x *DirectoryList) GetPropertyMonitored() bool {
+	var v gobject.Value
+	x.GetProperty("monitored", &v)
+	return v.GetBoolean()
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *DirectoryList) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtkdragicon.go b/v4/gtk/gtkdragicon.go
index 65f72cae55df7ac3a62639715a889c2741738190..47d1013eceaee19c7e9a8e4f78f2dd0b3ef9b69b 100644
--- a/v4/gtk/gtkdragicon.go
+++ b/v4/gtk/gtkdragicon.go
@@ -87,6 +87,27 @@ func (c *DragIcon) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The widget to display as drag icon.
+
+func (x *DragIcon) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *DragIcon) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *DragIcon) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkdragsource.go b/v4/gtk/gtkdragsource.go
index fa6eb88a62432df3d2d5e8e36143df42fe8a7c23..e5e145a6f523daa6d41accceb1b26f6c6aa6ef31 100644
--- a/v4/gtk/gtkdragsource.go
+++ b/v4/gtk/gtkdragsource.go
@@ -253,6 +253,45 @@ func (c *DragSource) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The actions that are supported by drag operations from the source.
+//
+// Note that you must handle the [signal@Gtk.DragSource::drag-end] signal
+// if the actions include %GDK_ACTION_MOVE.
+
+func (x *DragSource) SetPropertyActions(value gdk.DragAction) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("actions", &v)
+}
+
+func (x *DragSource) GetPropertyActions() gdk.DragAction {
+	var v gobject.Value
+	x.GetProperty("actions", &v)
+	return gdk.DragAction(v.GetFlags())
+}
+
+// The data that is offered by drag operations from this source.
+
+func (x *DragSource) SetPropertyContent(value *gdk.ContentProvider) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("content", &v)
+}
+
+func (x *DragSource) GetPropertyContent() *gdk.ContentProvider {
+	var v gobject.Value
+	x.GetProperty("content", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.ContentProvider{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emitted on the drag source when a drag is started.
 //
 // It can be used to e.g. set a custom drag icon with
diff --git a/v4/gtk/gtkdrawingarea.go b/v4/gtk/gtkdrawingarea.go
index 6284978d0e9702412e8710b3dba2b9809b8db5bc..7f81c8ab25c53820e16d26fb4d96883d2c4937ca 100644
--- a/v4/gtk/gtkdrawingarea.go
+++ b/v4/gtk/gtkdrawingarea.go
@@ -257,6 +257,36 @@ func (c *DrawingArea) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The content height.
+
+func (x *DrawingArea) SetPropertyContentHeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("content-height", &v)
+}
+
+func (x *DrawingArea) GetPropertyContentHeight() int {
+	var v gobject.Value
+	x.GetProperty("content-height", &v)
+	return v.GetInt()
+}
+
+// The content width.
+
+func (x *DrawingArea) SetPropertyContentWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("content-width", &v)
+}
+
+func (x *DrawingArea) GetPropertyContentWidth() int {
+	var v gobject.Value
+	x.GetProperty("content-width", &v)
+	return v.GetInt()
+}
+
 // Emitted once when the widget is realized, and then each time the widget
 // is changed while realized.
 //
diff --git a/v4/gtk/gtkdropcontrollermotion.go b/v4/gtk/gtkdropcontrollermotion.go
index b9c3bdfff5c5779e7f6f73974acfcb4c2a578fd9..5006dac0275d7160de31913c8d2c6217e7180214 100644
--- a/v4/gtk/gtkdropcontrollermotion.go
+++ b/v4/gtk/gtkdropcontrollermotion.go
@@ -111,6 +111,60 @@ func (c *DropControllerMotion) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the pointer of a Drag-and-Drop operation is in
+// the controller's widget or a descendant.
+//
+// See also [property@Gtk.DropControllerMotion:is-pointer].
+//
+// When handling crossing events, this property is updated
+// before [signal@Gtk.DropControllerMotion::enter], but after
+// [signal@Gtk.DropControllerMotion::leave] is emitted.
+
+func (x *DropControllerMotion) GetPropertyContainsPointer() bool {
+	var v gobject.Value
+	x.GetProperty("contains-pointer", &v)
+	return v.GetBoolean()
+}
+
+// The ongoing drop operation over the controller's widget or
+// its descendant.
+//
+// If no drop operation is going on, this property returns %NULL.
+//
+// The event controller should not modify the @drop, but it might
+// want to query its properties.
+//
+// When handling crossing events, this property is updated
+// before [signal@Gtk.DropControllerMotion::enter], but after
+// [signal@Gtk.DropControllerMotion::leave] is emitted.
+
+func (x *DropControllerMotion) GetPropertyDrop() *gdk.Drop {
+	var v gobject.Value
+	x.GetProperty("drop", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Drop{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the pointer is in the controllers widget itself,
+// as opposed to in a descendent widget.
+//
+// See also [property@Gtk.DropControllerMotion:contains-pointer].
+//
+// When handling crossing events, this property is updated
+// before [signal@Gtk.DropControllerMotion::enter], but after
+// [signal@Gtk.DropControllerMotion::leave] is emitted.
+
+func (x *DropControllerMotion) GetPropertyIsPointer() bool {
+	var v gobject.Value
+	x.GetProperty("is-pointer", &v)
+	return v.GetBoolean()
+}
+
 // Signals that the pointer has entered the widget.
 func (x *DropControllerMotion) ConnectEnter(cb *func(DropControllerMotion, float64, float64)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gtk/gtkdropdown.go b/v4/gtk/gtkdropdown.go
index 475db470ff812c4f2e369d23e329522267ff1825..5f25b510c881838a34f381ca74bd8f41979ed99d 100644
--- a/v4/gtk/gtkdropdown.go
+++ b/v4/gtk/gtkdropdown.go
@@ -320,6 +320,162 @@ func (c *DropDown) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to show a search entry in the popup.
+//
+// Note that search requires [property@Gtk.DropDown:expression]
+// to be set.
+
+func (x *DropDown) SetPropertyEnableSearch(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-search", &v)
+}
+
+func (x *DropDown) GetPropertyEnableSearch() bool {
+	var v gobject.Value
+	x.GetProperty("enable-search", &v)
+	return v.GetBoolean()
+}
+
+// An expression to evaluate to obtain strings to match against the search
+// term.
+//
+// See [property@Gtk.DropDown:enable-search] for how to enable search.
+// If [property@Gtk.DropDown:factory] is not set, the expression is also
+// used to bind strings to labels produced by a default factory.
+
+func (x *DropDown) SetPropertyExpression(value *Expression) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("expression", &v)
+}
+
+func (x *DropDown) GetPropertyExpression() *Expression {
+	var v gobject.Value
+	x.GetProperty("expression", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Expression{}
+	result.Ptr = ptr
+	return result
+}
+
+// Factory for populating list items.
+
+func (x *DropDown) SetPropertyFactory(value *ListItemFactory) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("factory", &v)
+}
+
+func (x *DropDown) GetPropertyFactory() *ListItemFactory {
+	var v gobject.Value
+	x.GetProperty("factory", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ListItemFactory{}
+	result.Ptr = ptr
+	return result
+}
+
+// The factory for populating list items in the popup.
+//
+// If this is not set, [property@Gtk.DropDown:factory] is used.
+
+func (x *DropDown) SetPropertyListFactory(value *ListItemFactory) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("list-factory", &v)
+}
+
+func (x *DropDown) GetPropertyListFactory() *ListItemFactory {
+	var v gobject.Value
+	x.GetProperty("list-factory", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ListItemFactory{}
+	result.Ptr = ptr
+	return result
+}
+
+// Model for the displayed items.
+
+func (x *DropDown) SetPropertyModel(value gio.ListModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *DropDown) GetPropertyModel() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The position of the selected item.
+//
+// If no item is selected, the property has the value
+// %GTK_INVALID_LIST_POSITION.
+
+func (x *DropDown) SetPropertySelected(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("selected", &v)
+}
+
+func (x *DropDown) GetPropertySelected() uint {
+	var v gobject.Value
+	x.GetProperty("selected", &v)
+	return v.GetUint()
+}
+
+// The selected item.
+
+func (x *DropDown) GetPropertySelectedItem() *gobject.Object {
+	var v gobject.Value
+	x.GetProperty("selected-item", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gobject.Object{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to show an arrow within the GtkDropDown widget.
+
+func (x *DropDown) SetPropertyShowArrow(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-arrow", &v)
+}
+
+func (x *DropDown) GetPropertyShowArrow() bool {
+	var v gobject.Value
+	x.GetProperty("show-arrow", &v)
+	return v.GetBoolean()
+}
+
 // Emitted to when the drop down is activated.
 //
 // The `::activate` signal on `GtkDropDown` is an action signal and
diff --git a/v4/gtk/gtkdroptarget.go b/v4/gtk/gtkdroptarget.go
index fa379df687382183e92ef6fcf47149e4b767b1cf..6d0305a9f7942e5ebd883c5a4d8288a1c8199401 100644
--- a/v4/gtk/gtkdroptarget.go
+++ b/v4/gtk/gtkdroptarget.go
@@ -273,6 +273,98 @@ func (c *DropTarget) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GdkDragActions` that this drop target supports.
+
+func (x *DropTarget) SetPropertyActions(value gdk.DragAction) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("actions", &v)
+}
+
+func (x *DropTarget) GetPropertyActions() gdk.DragAction {
+	var v gobject.Value
+	x.GetProperty("actions", &v)
+	return gdk.DragAction(v.GetFlags())
+}
+
+// The `GdkDrop` that is currently being performed.
+
+func (x *DropTarget) GetPropertyCurrentDrop() *gdk.Drop {
+	var v gobject.Value
+	x.GetProperty("current-drop", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Drop{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GdkContentFormats` that determine the supported data formats.
+
+func (x *DropTarget) SetPropertyFormats(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("formats", &v)
+}
+
+func (x *DropTarget) GetPropertyFormats() uintptr {
+	var v gobject.Value
+	x.GetProperty("formats", &v)
+	return v.GetPointer()
+}
+
+// Whether the drop data should be preloaded when the pointer is only
+// hovering over the widget but has not been released.
+//
+// Setting this property allows finer grained reaction to an ongoing
+// drop at the cost of loading more data.
+//
+// The default value for this property is %FALSE to avoid downloading
+// huge amounts of data by accident.
+//
+// For example, if somebody drags a full document of gigabytes of text
+// from a text editor across a widget with a preloading drop target,
+// this data will be downloaded, even if the data is ultimately dropped
+// elsewhere.
+//
+// For a lot of data formats, the amount of data is very small (like
+// %GDK_TYPE_RGBA), so enabling this property does not hurt at all.
+// And for local-only Drag-and-Drop operations, no data transfer is done,
+// so enabling it there is free.
+
+func (x *DropTarget) SetPropertyPreload(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("preload", &v)
+}
+
+func (x *DropTarget) GetPropertyPreload() bool {
+	var v gobject.Value
+	x.GetProperty("preload", &v)
+	return v.GetBoolean()
+}
+
+// The value for this drop operation.
+//
+// This is %NULL if the data has not been loaded yet or no drop
+// operation is going on.
+//
+// Data may be available before the [signal@Gtk.DropTarget::drop]
+// signal gets emitted - for example when the [property@Gtk.DropTarget:preload]
+// property is set. You can use the ::notify signal to be notified
+// of available data.
+
+func (x *DropTarget) GetPropertyValue() uintptr {
+	var v gobject.Value
+	x.GetProperty("value", &v)
+	return v.GetPointer()
+}
+
 // Emitted on the drop site when a drop operation is about to begin.
 //
 // If the drop is not accepted, %FALSE will be returned and the drop target
diff --git a/v4/gtk/gtkdroptargetasync.go b/v4/gtk/gtkdroptargetasync.go
index 16d1624d1368eef3b593d28b81f3fac261bf9c0a..bac22665c0c03ea93b7ea68d677e173e10e48476 100644
--- a/v4/gtk/gtkdroptargetasync.go
+++ b/v4/gtk/gtkdroptargetasync.go
@@ -149,6 +149,36 @@ func (c *DropTargetAsync) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GdkDragActions` that this drop target supports.
+
+func (x *DropTargetAsync) SetPropertyActions(value gdk.DragAction) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("actions", &v)
+}
+
+func (x *DropTargetAsync) GetPropertyActions() gdk.DragAction {
+	var v gobject.Value
+	x.GetProperty("actions", &v)
+	return gdk.DragAction(v.GetFlags())
+}
+
+// The `GdkContentFormats` that determines the supported data formats.
+
+func (x *DropTargetAsync) SetPropertyFormats(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("formats", &v)
+}
+
+func (x *DropTargetAsync) GetPropertyFormats() uintptr {
+	var v gobject.Value
+	x.GetProperty("formats", &v)
+	return v.GetPointer()
+}
+
 // Emitted on the drop site when a drop operation is about to begin.
 //
 // If the drop is not accepted, %FALSE will be returned and the drop target
diff --git a/v4/gtk/gtkeditable.go b/v4/gtk/gtkeditable.go
index 2590b07c6048b93ade424f3fd018ee0e88ce126a..cf5759f2eceeff7e6e5967cc320593cb600cae43 100644
--- a/v4/gtk/gtkeditable.go
+++ b/v4/gtk/gtkeditable.go
@@ -689,6 +689,128 @@ 	XGtkEditableSetWidthChars(x.GoPointer(), NCharsVar)
 
 }
 
+// The current position of the insertion cursor in chars.
+
+func (x *EditableBase) GetPropertyCursorPosition() int {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("cursor-position", &v)
+	return v.GetInt()
+}
+
+// Whether the entry contents can be edited.
+
+func (x *EditableBase) SetPropertyEditable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("editable", &v)
+}
+
+func (x *EditableBase) GetPropertyEditable() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("editable", &v)
+	return v.GetBoolean()
+}
+
+// If undo/redo should be enabled for the editable.
+
+func (x *EditableBase) SetPropertyEnableUndo(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("enable-undo", &v)
+}
+
+func (x *EditableBase) GetPropertyEnableUndo() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("enable-undo", &v)
+	return v.GetBoolean()
+}
+
+// The desired maximum width of the entry, in characters.
+
+func (x *EditableBase) SetPropertyMaxWidthChars(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("max-width-chars", &v)
+}
+
+func (x *EditableBase) GetPropertyMaxWidthChars() int {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("max-width-chars", &v)
+	return v.GetInt()
+}
+
+// The position of the opposite end of the selection from the cursor in chars.
+
+func (x *EditableBase) GetPropertySelectionBound() int {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("selection-bound", &v)
+	return v.GetInt()
+}
+
+// The contents of the entry.
+
+func (x *EditableBase) SetPropertyText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("text", &v)
+}
+
+func (x *EditableBase) GetPropertyText() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("text", &v)
+	return v.GetString()
+}
+
+// Number of characters to leave space for in the entry.
+
+func (x *EditableBase) SetPropertyWidthChars(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("width-chars", &v)
+}
+
+func (x *EditableBase) GetPropertyWidthChars() int {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("width-chars", &v)
+	return v.GetInt()
+}
+
+// The horizontal alignment, from 0 (left) to 1 (right).
+//
+// Reversed for RTL layouts.
+
+func (x *EditableBase) SetPropertyXalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("xalign", &v)
+}
+
+func (x *EditableBase) GetPropertyXalign() float32 {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("xalign", &v)
+	return v.GetFloat()
+}
+
 var XGtkEditableDeleteSelection func(uintptr)
 var XGtkEditableDeleteText func(uintptr, int, int)
 var XGtkEditableFinishDelegate func(uintptr)
diff --git a/v4/gtk/gtkeditablelabel.go b/v4/gtk/gtkeditablelabel.go
index 85c9896dc8badac71c067335baa96b29de6b321e..6a54e47a7556e40693a86c4e5dc5c039069d54b1 100644
--- a/v4/gtk/gtkeditablelabel.go
+++ b/v4/gtk/gtkeditablelabel.go
@@ -127,6 +127,21 @@ func (c *EditableLabel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// This property is %TRUE while the widget is in edit mode.
+
+func (x *EditableLabel) SetPropertyEditing(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("editing", &v)
+}
+
+func (x *EditableLabel) GetPropertyEditing() bool {
+	var v gobject.Value
+	x.GetProperty("editing", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *EditableLabel) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkentry.go b/v4/gtk/gtkentry.go
index c3f5e21dff81fd828187fc5a6d3380e2c7ab98db..e264f62c8a0162d4f7baa1fd1ff4303ccb322a52 100644
--- a/v4/gtk/gtkentry.go
+++ b/v4/gtk/gtkentry.go
@@ -958,6 +958,663 @@ func (c *Entry) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to activate the default widget when Enter is pressed.
+
+func (x *Entry) SetPropertyActivatesDefault(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activates-default", &v)
+}
+
+func (x *Entry) GetPropertyActivatesDefault() bool {
+	var v gobject.Value
+	x.GetProperty("activates-default", &v)
+	return v.GetBoolean()
+}
+
+// A list of Pango attributes to apply to the text of the entry.
+//
+// This is mainly useful to change the size or weight of the text.
+//
+// The `PangoAttribute`'s @start_index and @end_index must refer to the
+// [class@Gtk.EntryBuffer] text, i.e. without the preedit string.
+
+func (x *Entry) SetPropertyAttributes(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("attributes", &v)
+}
+
+func (x *Entry) GetPropertyAttributes() uintptr {
+	var v gobject.Value
+	x.GetProperty("attributes", &v)
+	return v.GetPointer()
+}
+
+// The buffer object which actually stores the text.
+
+func (x *Entry) SetPropertyBuffer(value *EntryBuffer) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("buffer", &v)
+}
+
+func (x *Entry) GetPropertyBuffer() *EntryBuffer {
+	var v gobject.Value
+	x.GetProperty("buffer", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &EntryBuffer{}
+	result.Ptr = ptr
+	return result
+}
+
+// The auxiliary completion object to use with the entry.
+
+func (x *Entry) SetPropertyCompletion(value *EntryCompletion) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("completion", &v)
+}
+
+func (x *Entry) GetPropertyCompletion() *EntryCompletion {
+	var v gobject.Value
+	x.GetProperty("completion", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &EntryCompletion{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to suggest Emoji replacements for :-delimited names
+// like `:heart:`.
+
+func (x *Entry) SetPropertyEnableEmojiCompletion(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-emoji-completion", &v)
+}
+
+func (x *Entry) GetPropertyEnableEmojiCompletion() bool {
+	var v gobject.Value
+	x.GetProperty("enable-emoji-completion", &v)
+	return v.GetBoolean()
+}
+
+// A menu model whose contents will be appended to the context menu.
+
+func (x *Entry) SetPropertyExtraMenu(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("extra-menu", &v)
+}
+
+func (x *Entry) GetPropertyExtraMenu() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("extra-menu", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whehter the entry should draw a frame.
+
+func (x *Entry) SetPropertyHasFrame(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-frame", &v)
+}
+
+func (x *Entry) GetPropertyHasFrame() bool {
+	var v gobject.Value
+	x.GetProperty("has-frame", &v)
+	return v.GetBoolean()
+}
+
+// Which IM (input method) module should be used for this entry.
+//
+// See [class@Gtk.IMContext].
+//
+// Setting this to a non-%NULL value overrides the system-wide IM
+// module setting. See the GtkSettings [property@Gtk.Settings:gtk-im-module]
+// property.
+
+func (x *Entry) SetPropertyImModule(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("im-module", &v)
+}
+
+func (x *Entry) GetPropertyImModule() string {
+	var v gobject.Value
+	x.GetProperty("im-module", &v)
+	return v.GetString()
+}
+
+// Additional hints that allow input methods to fine-tune their behavior.
+//
+// Also see [property@Gtk.Entry:input-purpose]
+
+func (x *Entry) SetPropertyInputHints(value InputHints) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("input-hints", &v)
+}
+
+func (x *Entry) GetPropertyInputHints() InputHints {
+	var v gobject.Value
+	x.GetProperty("input-hints", &v)
+	return InputHints(v.GetFlags())
+}
+
+// The purpose of this text field.
+//
+// This property can be used by on-screen keyboards and other input
+// methods to adjust their behaviour.
+//
+// Note that setting the purpose to %GTK_INPUT_PURPOSE_PASSWORD or
+// %GTK_INPUT_PURPOSE_PIN is independent from setting
+// [property@Gtk.Entry:visibility].
+
+func (x *Entry) SetPropertyInputPurpose(value InputPurpose) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("input-purpose", &v)
+}
+
+func (x *Entry) GetPropertyInputPurpose() InputPurpose {
+	var v gobject.Value
+	x.GetProperty("input-purpose", &v)
+	return InputPurpose(v.GetEnum())
+}
+
+// The character to use when masking entry contents (âpassword modeâ).
+
+func (x *Entry) SetPropertyInvisibleChar(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("invisible-char", &v)
+}
+
+func (x *Entry) GetPropertyInvisibleChar() uint {
+	var v gobject.Value
+	x.GetProperty("invisible-char", &v)
+	return v.GetUint()
+}
+
+// Whether the invisible char has been set for the `GtkEntry`.
+
+func (x *Entry) SetPropertyInvisibleCharSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("invisible-char-set", &v)
+}
+
+func (x *Entry) GetPropertyInvisibleCharSet() bool {
+	var v gobject.Value
+	x.GetProperty("invisible-char-set", &v)
+	return v.GetBoolean()
+}
+
+// Maximum number of characters for this entry.
+
+func (x *Entry) SetPropertyMaxLength(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-length", &v)
+}
+
+func (x *Entry) GetPropertyMaxLength() int {
+	var v gobject.Value
+	x.GetProperty("max-length", &v)
+	return v.GetInt()
+}
+
+// If text is overwritten when typing in the `GtkEntry`.
+
+func (x *Entry) SetPropertyOverwriteMode(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("overwrite-mode", &v)
+}
+
+func (x *Entry) GetPropertyOverwriteMode() bool {
+	var v gobject.Value
+	x.GetProperty("overwrite-mode", &v)
+	return v.GetBoolean()
+}
+
+// The text that will be displayed in the `GtkEntry` when it is empty
+// and unfocused.
+
+func (x *Entry) SetPropertyPlaceholderText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("placeholder-text", &v)
+}
+
+func (x *Entry) GetPropertyPlaceholderText() string {
+	var v gobject.Value
+	x.GetProperty("placeholder-text", &v)
+	return v.GetString()
+}
+
+// Whether the primary icon is activatable.
+//
+// GTK emits the [signal@Gtk.Entry::icon-press] and
+// [signal@Gtk.Entry::icon-release] signals only on sensitive,
+// activatable icons.
+//
+// Sensitive, but non-activatable icons can be used for purely
+// informational purposes.
+
+func (x *Entry) SetPropertyPrimaryIconActivatable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("primary-icon-activatable", &v)
+}
+
+func (x *Entry) GetPropertyPrimaryIconActivatable() bool {
+	var v gobject.Value
+	x.GetProperty("primary-icon-activatable", &v)
+	return v.GetBoolean()
+}
+
+// The `GIcon` to use for the primary icon for the entry.
+
+func (x *Entry) SetPropertyPrimaryIconGicon(value gio.Icon) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("primary-icon-gicon", &v)
+}
+
+func (x *Entry) GetPropertyPrimaryIconGicon() gio.Icon {
+	var v gobject.Value
+	x.GetProperty("primary-icon-gicon", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.IconBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The icon name to use for the primary icon for the entry.
+
+func (x *Entry) SetPropertyPrimaryIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("primary-icon-name", &v)
+}
+
+func (x *Entry) GetPropertyPrimaryIconName() string {
+	var v gobject.Value
+	x.GetProperty("primary-icon-name", &v)
+	return v.GetString()
+}
+
+// A `GdkPaintable` to use as the primary icon for the entry.
+
+func (x *Entry) SetPropertyPrimaryIconPaintable(value gdk.Paintable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("primary-icon-paintable", &v)
+}
+
+func (x *Entry) GetPropertyPrimaryIconPaintable() gdk.Paintable {
+	var v gobject.Value
+	x.GetProperty("primary-icon-paintable", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.PaintableBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the primary icon is sensitive.
+//
+// An insensitive icon appears grayed out. GTK does not emit the
+// [signal@Gtk.Entry::icon-press] and [signal@Gtk.Entry::icon-release]
+// signals and does not allow DND from insensitive icons.
+//
+// An icon should be set insensitive if the action that would trigger
+// when clicked is currently not available.
+
+func (x *Entry) SetPropertyPrimaryIconSensitive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("primary-icon-sensitive", &v)
+}
+
+func (x *Entry) GetPropertyPrimaryIconSensitive() bool {
+	var v gobject.Value
+	x.GetProperty("primary-icon-sensitive", &v)
+	return v.GetBoolean()
+}
+
+// The representation which is used for the primary icon of the entry.
+
+func (x *Entry) GetPropertyPrimaryIconStorageType() ImageType {
+	var v gobject.Value
+	x.GetProperty("primary-icon-storage-type", &v)
+	return ImageType(v.GetEnum())
+}
+
+// The contents of the tooltip on the primary icon, with markup.
+//
+// Also see [method@Gtk.Entry.set_icon_tooltip_markup].
+
+func (x *Entry) SetPropertyPrimaryIconTooltipMarkup(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("primary-icon-tooltip-markup", &v)
+}
+
+func (x *Entry) GetPropertyPrimaryIconTooltipMarkup() string {
+	var v gobject.Value
+	x.GetProperty("primary-icon-tooltip-markup", &v)
+	return v.GetString()
+}
+
+// The contents of the tooltip on the primary icon.
+//
+// Also see [method@Gtk.Entry.set_icon_tooltip_text].
+
+func (x *Entry) SetPropertyPrimaryIconTooltipText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("primary-icon-tooltip-text", &v)
+}
+
+func (x *Entry) GetPropertyPrimaryIconTooltipText() string {
+	var v gobject.Value
+	x.GetProperty("primary-icon-tooltip-text", &v)
+	return v.GetString()
+}
+
+// The current fraction of the task that's been completed.
+
+func (x *Entry) SetPropertyProgressFraction(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("progress-fraction", &v)
+}
+
+func (x *Entry) GetPropertyProgressFraction() float64 {
+	var v gobject.Value
+	x.GetProperty("progress-fraction", &v)
+	return v.GetDouble()
+}
+
+// The fraction of total entry width to move the progress
+// bouncing block for each pulse.
+//
+// See [method@Gtk.Entry.progress_pulse].
+
+func (x *Entry) SetPropertyProgressPulseStep(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("progress-pulse-step", &v)
+}
+
+func (x *Entry) GetPropertyProgressPulseStep() float64 {
+	var v gobject.Value
+	x.GetProperty("progress-pulse-step", &v)
+	return v.GetDouble()
+}
+
+// Number of pixels of the entry scrolled off the screen to the left.
+
+func (x *Entry) GetPropertyScrollOffset() int {
+	var v gobject.Value
+	x.GetProperty("scroll-offset", &v)
+	return v.GetInt()
+}
+
+// Whether the secondary icon is activatable.
+//
+// GTK emits the [signal@Gtk.Entry::icon-press] and
+// [signal@Gtk.Entry::icon-release] signals only on sensitive,
+// activatable icons.
+//
+// Sensitive, but non-activatable icons can be used for purely
+// informational purposes.
+
+func (x *Entry) SetPropertySecondaryIconActivatable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("secondary-icon-activatable", &v)
+}
+
+func (x *Entry) GetPropertySecondaryIconActivatable() bool {
+	var v gobject.Value
+	x.GetProperty("secondary-icon-activatable", &v)
+	return v.GetBoolean()
+}
+
+// The `GIcon` to use for the secondary icon for the entry.
+
+func (x *Entry) SetPropertySecondaryIconGicon(value gio.Icon) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("secondary-icon-gicon", &v)
+}
+
+func (x *Entry) GetPropertySecondaryIconGicon() gio.Icon {
+	var v gobject.Value
+	x.GetProperty("secondary-icon-gicon", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.IconBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The icon name to use for the secondary icon for the entry.
+
+func (x *Entry) SetPropertySecondaryIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("secondary-icon-name", &v)
+}
+
+func (x *Entry) GetPropertySecondaryIconName() string {
+	var v gobject.Value
+	x.GetProperty("secondary-icon-name", &v)
+	return v.GetString()
+}
+
+// A `GdkPaintable` to use as the secondary icon for the entry.
+
+func (x *Entry) SetPropertySecondaryIconPaintable(value gdk.Paintable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("secondary-icon-paintable", &v)
+}
+
+func (x *Entry) GetPropertySecondaryIconPaintable() gdk.Paintable {
+	var v gobject.Value
+	x.GetProperty("secondary-icon-paintable", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.PaintableBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the secondary icon is sensitive.
+//
+// An insensitive icon appears grayed out. GTK does not emit the
+// [signal@Gtk.Entry::icon-press[ and [signal@Gtk.Entry::icon-release]
+// signals and does not allow DND from insensitive icons.
+//
+// An icon should be set insensitive if the action that would trigger
+// when clicked is currently not available.
+
+func (x *Entry) SetPropertySecondaryIconSensitive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("secondary-icon-sensitive", &v)
+}
+
+func (x *Entry) GetPropertySecondaryIconSensitive() bool {
+	var v gobject.Value
+	x.GetProperty("secondary-icon-sensitive", &v)
+	return v.GetBoolean()
+}
+
+// The representation which is used for the secondary icon of the entry.
+
+func (x *Entry) GetPropertySecondaryIconStorageType() ImageType {
+	var v gobject.Value
+	x.GetProperty("secondary-icon-storage-type", &v)
+	return ImageType(v.GetEnum())
+}
+
+// The contents of the tooltip on the secondary icon, with markup.
+//
+// Also see [method@Gtk.Entry.set_icon_tooltip_markup].
+
+func (x *Entry) SetPropertySecondaryIconTooltipMarkup(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("secondary-icon-tooltip-markup", &v)
+}
+
+func (x *Entry) GetPropertySecondaryIconTooltipMarkup() string {
+	var v gobject.Value
+	x.GetProperty("secondary-icon-tooltip-markup", &v)
+	return v.GetString()
+}
+
+// The contents of the tooltip on the secondary icon.
+//
+// Also see [method@Gtk.Entry.set_icon_tooltip_text].
+
+func (x *Entry) SetPropertySecondaryIconTooltipText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("secondary-icon-tooltip-text", &v)
+}
+
+func (x *Entry) GetPropertySecondaryIconTooltipText() string {
+	var v gobject.Value
+	x.GetProperty("secondary-icon-tooltip-text", &v)
+	return v.GetString()
+}
+
+func (x *Entry) SetPropertyShowEmojiIcon(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-emoji-icon", &v)
+}
+
+func (x *Entry) GetPropertyShowEmojiIcon() bool {
+	var v gobject.Value
+	x.GetProperty("show-emoji-icon", &v)
+	return v.GetBoolean()
+}
+
+func (x *Entry) SetPropertyTabs(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("tabs", &v)
+}
+
+func (x *Entry) GetPropertyTabs() uintptr {
+	var v gobject.Value
+	x.GetProperty("tabs", &v)
+	return v.GetPointer()
+}
+
+// The length of the text in the `GtkEntry`.
+
+func (x *Entry) GetPropertyTextLength() uint {
+	var v gobject.Value
+	x.GetProperty("text-length", &v)
+	return v.GetUint()
+}
+
+// When %TRUE, pasted multi-line text is truncated to the first line.
+
+func (x *Entry) SetPropertyTruncateMultiline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("truncate-multiline", &v)
+}
+
+func (x *Entry) GetPropertyTruncateMultiline() bool {
+	var v gobject.Value
+	x.GetProperty("truncate-multiline", &v)
+	return v.GetBoolean()
+}
+
+// Whether the entry should show the âinvisible charâ instead of the
+// actual text (âpassword modeâ).
+
+func (x *Entry) SetPropertyVisibility(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("visibility", &v)
+}
+
+func (x *Entry) GetPropertyVisibility() bool {
+	var v gobject.Value
+	x.GetProperty("visibility", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when the entry is activated.
 //
 // The keybindings for this signal are all forms of the Enter key.
diff --git a/v4/gtk/gtkentrybuffer.go b/v4/gtk/gtkentrybuffer.go
index 6d046e942efbd35a190a1792539f5ad24588afc5..a1158ad761e52cccece17262e864f61844bcad50 100644
--- a/v4/gtk/gtkentrybuffer.go
+++ b/v4/gtk/gtkentrybuffer.go
@@ -549,6 +549,44 @@ func (c *EntryBuffer) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The length (in characters) of the text in buffer.
+
+func (x *EntryBuffer) GetPropertyLength() uint {
+	var v gobject.Value
+	x.GetProperty("length", &v)
+	return v.GetUint()
+}
+
+// The maximum length (in characters) of the text in the buffer.
+
+func (x *EntryBuffer) SetPropertyMaxLength(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-length", &v)
+}
+
+func (x *EntryBuffer) GetPropertyMaxLength() int {
+	var v gobject.Value
+	x.GetProperty("max-length", &v)
+	return v.GetInt()
+}
+
+// The contents of the buffer.
+
+func (x *EntryBuffer) SetPropertyText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("text", &v)
+}
+
+func (x *EntryBuffer) GetPropertyText() string {
+	var v gobject.Value
+	x.GetProperty("text", &v)
+	return v.GetString()
+}
+
 // The text is altered in the default handler for this signal.
 //
 // If you want access to the text after the text has been modified,
diff --git a/v4/gtk/gtkentrycompletion.go b/v4/gtk/gtkentrycompletion.go
index c4d96a4cabd2f8a26d95ceb344ceb1d2be0b9c76..eae96f683ecba766db679de9454b06596e8fc282 100644
--- a/v4/gtk/gtkentrycompletion.go
+++ b/v4/gtk/gtkentrycompletion.go
@@ -378,6 +378,166 @@ func (c *EntryCompletion) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GtkCellArea` used to layout cell renderers in the treeview column.
+//
+// If no area is specified when creating the entry completion with
+// [ctor@Gtk.EntryCompletion.new_with_area], a horizontally oriented
+// [class@Gtk.CellAreaBox] will be used.
+
+func (x *EntryCompletion) SetPropertyCellArea(value *CellArea) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("cell-area", &v)
+}
+
+func (x *EntryCompletion) GetPropertyCellArea() *CellArea {
+	var v gobject.Value
+	x.GetProperty("cell-area", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &CellArea{}
+	result.Ptr = ptr
+	return result
+}
+
+// Determines whether the common prefix of the possible completions
+// should be inserted automatically in the entry.
+//
+// Note that this requires text-column to be set, even if you are
+// using a custom match function.
+
+func (x *EntryCompletion) SetPropertyInlineCompletion(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("inline-completion", &v)
+}
+
+func (x *EntryCompletion) GetPropertyInlineCompletion() bool {
+	var v gobject.Value
+	x.GetProperty("inline-completion", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the possible completions on the popup
+// will appear in the entry as you navigate through them.
+
+func (x *EntryCompletion) SetPropertyInlineSelection(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("inline-selection", &v)
+}
+
+func (x *EntryCompletion) GetPropertyInlineSelection() bool {
+	var v gobject.Value
+	x.GetProperty("inline-selection", &v)
+	return v.GetBoolean()
+}
+
+func (x *EntryCompletion) SetPropertyMinimumKeyLength(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("minimum-key-length", &v)
+}
+
+func (x *EntryCompletion) GetPropertyMinimumKeyLength() int {
+	var v gobject.Value
+	x.GetProperty("minimum-key-length", &v)
+	return v.GetInt()
+}
+
+func (x *EntryCompletion) SetPropertyModel(value TreeModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *EntryCompletion) GetPropertyModel() TreeModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TreeModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Determines whether the possible completions should be
+// shown in a popup window.
+
+func (x *EntryCompletion) SetPropertyPopupCompletion(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("popup-completion", &v)
+}
+
+func (x *EntryCompletion) GetPropertyPopupCompletion() bool {
+	var v gobject.Value
+	x.GetProperty("popup-completion", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the completions popup window will be
+// resized to the width of the entry.
+
+func (x *EntryCompletion) SetPropertyPopupSetWidth(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("popup-set-width", &v)
+}
+
+func (x *EntryCompletion) GetPropertyPopupSetWidth() bool {
+	var v gobject.Value
+	x.GetProperty("popup-set-width", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the completions popup window will shown
+// for a single possible completion.
+//
+// You probably want to set this to %FALSE if you are using
+// [property@Gtk.EntryCompletion:inline-completion].
+
+func (x *EntryCompletion) SetPropertyPopupSingleMatch(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("popup-single-match", &v)
+}
+
+func (x *EntryCompletion) GetPropertyPopupSingleMatch() bool {
+	var v gobject.Value
+	x.GetProperty("popup-single-match", &v)
+	return v.GetBoolean()
+}
+
+// The column of the model containing the strings.
+//
+// Note that the strings must be UTF-8.
+
+func (x *EntryCompletion) SetPropertyTextColumn(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("text-column", &v)
+}
+
+func (x *EntryCompletion) GetPropertyTextColumn() int {
+	var v gobject.Value
+	x.GetProperty("text-column", &v)
+	return v.GetInt()
+}
+
 // Emitted when a match from the cursor is on a match of the list.
 //
 // The default behaviour is to replace the contents
diff --git a/v4/gtk/gtkeventcontroller.go b/v4/gtk/gtkeventcontroller.go
index f2af1732fa78beb77689f285139ad0ba400ec93c..f017680362f05674d4019478416f1c5a0b5230a4 100644
--- a/v4/gtk/gtkeventcontroller.go
+++ b/v4/gtk/gtkeventcontroller.go
@@ -218,6 +218,65 @@ func (c *EventController) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The name for this controller, typically used for debugging purposes.
+
+func (x *EventController) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *EventController) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// The limit for which events this controller will handle.
+
+func (x *EventController) SetPropertyPropagationLimit(value PropagationLimit) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("propagation-limit", &v)
+}
+
+func (x *EventController) GetPropertyPropagationLimit() PropagationLimit {
+	var v gobject.Value
+	x.GetProperty("propagation-limit", &v)
+	return PropagationLimit(v.GetEnum())
+}
+
+// The propagation phase at which this controller will handle events.
+
+func (x *EventController) SetPropertyPropagationPhase(value PropagationPhase) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("propagation-phase", &v)
+}
+
+func (x *EventController) GetPropertyPropagationPhase() PropagationPhase {
+	var v gobject.Value
+	x.GetProperty("propagation-phase", &v)
+	return PropagationPhase(v.GetEnum())
+}
+
+// The widget receiving the `GdkEvents` that the controller will handle.
+
+func (x *EventController) GetPropertyWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkeventcontrollerfocus.go b/v4/gtk/gtkeventcontrollerfocus.go
index 97a5d161902703ca8f9b9cea000eea435597fcf0..0a20d13aba0e54e158e92633b703932e10f92b93 100644
--- a/v4/gtk/gtkeventcontrollerfocus.go
+++ b/v4/gtk/gtkeventcontrollerfocus.go
@@ -90,6 +90,36 @@ func (c *EventControllerFocus) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// %TRUE if focus is contained in the controllers widget.
+//
+// See [property@Gtk.EventControllerFocus:is-focus] for whether
+// the focus is in the widget itself or inside a descendent.
+//
+// When handling focus events, this property is updated
+// before [signal@Gtk.EventControllerFocus::enter] or
+// [signal@Gtk.EventControllerFocus::leave] are emitted.
+
+func (x *EventControllerFocus) GetPropertyContainsFocus() bool {
+	var v gobject.Value
+	x.GetProperty("contains-focus", &v)
+	return v.GetBoolean()
+}
+
+// %TRUE if focus is in the controllers widget itself,
+// as opposed to in a descendent widget.
+//
+// See also [property@Gtk.EventControllerFocus:contains-focus].
+//
+// When handling focus events, this property is updated
+// before [signal@Gtk.EventControllerFocus::enter] or
+// [signal@Gtk.EventControllerFocus::leave] are emitted.
+
+func (x *EventControllerFocus) GetPropertyIsFocus() bool {
+	var v gobject.Value
+	x.GetProperty("is-focus", &v)
+	return v.GetBoolean()
+}
+
 // Emitted whenever the focus enters into the widget or one
 // of its descendents.
 //
diff --git a/v4/gtk/gtkeventcontrollermotion.go b/v4/gtk/gtkeventcontrollermotion.go
index 0d50f89eba2f9e78fa334dcca188892a85d47b00..2d1d218c26c2af03dae3667a8964131874255a49 100644
--- a/v4/gtk/gtkeventcontrollermotion.go
+++ b/v4/gtk/gtkeventcontrollermotion.go
@@ -90,6 +90,35 @@ func (c *EventControllerMotion) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the pointer is in the controllers widget or a descendant.
+//
+// See also [property@Gtk.EventControllerMotion:is-pointer].
+//
+// When handling crossing events, this property is updated
+// before [signal@Gtk.EventControllerMotion::enter], but after
+// [signal@Gtk.EventControllerMotion::leave] is emitted.
+
+func (x *EventControllerMotion) GetPropertyContainsPointer() bool {
+	var v gobject.Value
+	x.GetProperty("contains-pointer", &v)
+	return v.GetBoolean()
+}
+
+// Whether the pointer is in the controllers widget itself,
+// as opposed to in a descendent widget.
+//
+// See also [property@Gtk.EventControllerMotion:contains-pointer].
+//
+// When handling crossing events, this property is updated
+// before [signal@Gtk.EventControllerMotion::enter], but after
+// [signal@Gtk.EventControllerMotion::leave] is emitted.
+
+func (x *EventControllerMotion) GetPropertyIsPointer() bool {
+	var v gobject.Value
+	x.GetProperty("is-pointer", &v)
+	return v.GetBoolean()
+}
+
 // Signals that the pointer has entered the widget.
 func (x *EventControllerMotion) ConnectEnter(cb *func(EventControllerMotion, float64, float64)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gtk/gtkeventcontrollerscroll.go b/v4/gtk/gtkeventcontrollerscroll.go
index 261cbc3a67d2cb05800ec319e2f98ceceaa9d054..2097be3b2e3efcf98b5323d6fe9b461cdf14accc 100644
--- a/v4/gtk/gtkeventcontrollerscroll.go
+++ b/v4/gtk/gtkeventcontrollerscroll.go
@@ -154,6 +154,21 @@ func (c *EventControllerScroll) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The flags affecting event controller behavior.
+
+func (x *EventControllerScroll) SetPropertyFlags(value EventControllerScrollFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("flags", &v)
+}
+
+func (x *EventControllerScroll) GetPropertyFlags() EventControllerScrollFlags {
+	var v gobject.Value
+	x.GetProperty("flags", &v)
+	return EventControllerScrollFlags(v.GetFlags())
+}
+
 // Emitted after scroll is finished if the
 // %GTK_EVENT_CONTROLLER_SCROLL_KINETIC flag is set.
 //
diff --git a/v4/gtk/gtkexpander.go b/v4/gtk/gtkexpander.go
index 71aa5dcb260a8fdb8be3c04ef969e485e51aef2b..4e4cbc3203e5b6dd8e11575e8b1004f505e21f38 100644
--- a/v4/gtk/gtkexpander.go
+++ b/v4/gtk/gtkexpander.go
@@ -338,6 +338,124 @@ func (c *Expander) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *Expander) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *Expander) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the expander has been opened to reveal the child.
+
+func (x *Expander) SetPropertyExpanded(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("expanded", &v)
+}
+
+func (x *Expander) GetPropertyExpanded() bool {
+	var v gobject.Value
+	x.GetProperty("expanded", &v)
+	return v.GetBoolean()
+}
+
+// The text of the expanders label.
+
+func (x *Expander) SetPropertyLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("label", &v)
+}
+
+func (x *Expander) GetPropertyLabel() string {
+	var v gobject.Value
+	x.GetProperty("label", &v)
+	return v.GetString()
+}
+
+// A widget to display instead of the usual expander label.
+
+func (x *Expander) SetPropertyLabelWidget(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("label-widget", &v)
+}
+
+func (x *Expander) GetPropertyLabelWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("label-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// When this property is %TRUE, the expander will resize the toplevel
+// widget containing the expander upon expanding and collapsing.
+
+func (x *Expander) SetPropertyResizeToplevel(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("resize-toplevel", &v)
+}
+
+func (x *Expander) GetPropertyResizeToplevel() bool {
+	var v gobject.Value
+	x.GetProperty("resize-toplevel", &v)
+	return v.GetBoolean()
+}
+
+// Whether the text in the label is Pango markup.
+
+func (x *Expander) SetPropertyUseMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-markup", &v)
+}
+
+func (x *Expander) GetPropertyUseMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("use-markup", &v)
+	return v.GetBoolean()
+}
+
+// Whether an underline in the text indicates a mnemonic.
+
+func (x *Expander) SetPropertyUseUnderline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-underline", &v)
+}
+
+func (x *Expander) GetPropertyUseUnderline() bool {
+	var v gobject.Value
+	x.GetProperty("use-underline", &v)
+	return v.GetBoolean()
+}
+
 // Activates the `GtkExpander`.
 func (x *Expander) ConnectActivate(cb *func(Expander)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gtk/gtkfilechooser.go b/v4/gtk/gtkfilechooser.go
index c815022358b4b3e91d975aed97d044e7ce166ca1..947eec1b426c8ba6670bf3881fc109fc3c43ea5e 100644
--- a/v4/gtk/gtkfilechooser.go
+++ b/v4/gtk/gtkfilechooser.go
@@ -454,6 +454,119 @@ 	XGtkFileChooserSetSelectMultiple(x.GoPointer(), SelectMultipleVar)
 
 }
 
+// The type of operation that the file chooser is performing.
+
+func (x *FileChooserBase) SetPropertyAction(value FileChooserAction) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("action", &v)
+}
+
+func (x *FileChooserBase) GetPropertyAction() FileChooserAction {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("action", &v)
+	return FileChooserAction(v.GetEnum())
+}
+
+// Whether a file chooser not in %GTK_FILE_CHOOSER_ACTION_OPEN mode
+// will offer the user to create new folders.
+
+func (x *FileChooserBase) SetPropertyCreateFolders(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("create-folders", &v)
+}
+
+func (x *FileChooserBase) GetPropertyCreateFolders() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("create-folders", &v)
+	return v.GetBoolean()
+}
+
+// The current filter for selecting files that are displayed.
+
+func (x *FileChooserBase) SetPropertyFilter(value *FileFilter) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("filter", &v)
+}
+
+func (x *FileChooserBase) GetPropertyFilter() *FileFilter {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("filter", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &FileFilter{}
+	result.Ptr = ptr
+	return result
+}
+
+// A `GListModel` containing the filters that have been
+// added with gtk_file_chooser_add_filter().
+//
+// The returned object should not be modified. It may
+// or may not be updated for later changes.
+
+func (x *FileChooserBase) GetPropertyFilters() gio.ListModel {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("filters", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to allow multiple files to be selected.
+
+func (x *FileChooserBase) SetPropertySelectMultiple(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("select-multiple", &v)
+}
+
+func (x *FileChooserBase) GetPropertySelectMultiple() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("select-multiple", &v)
+	return v.GetBoolean()
+}
+
+// A `GListModel` containing the shortcut folders that have been
+// added with gtk_file_chooser_add_shortcut_folder().
+//
+// The returned object should not be modified. It may
+// or may not be updated for later changes.
+
+func (x *FileChooserBase) GetPropertyShortcutFolders() gio.ListModel {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("shortcut-folders", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
 var XGtkFileChooserAddChoice func(uintptr, string, string, []string, []string)
 var XGtkFileChooserAddFilter func(uintptr, uintptr)
 var XGtkFileChooserAddShortcutFolder func(uintptr, uintptr, **glib.Error) bool
diff --git a/v4/gtk/gtkfilechoosernative.go b/v4/gtk/gtkfilechoosernative.go
index c67e9f9ab2208c2a1dc5ca951f15f41f86e8dbc2..9b35be51cd5b3ccc01a180f19c838b1c45806762 100644
--- a/v4/gtk/gtkfilechoosernative.go
+++ b/v4/gtk/gtkfilechoosernative.go
@@ -268,6 +268,38 @@ func (c *FileChooserNative) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The text used for the label on the accept button in the dialog, or
+// %NULL to use the default text.
+
+func (x *FileChooserNative) SetPropertyAcceptLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("accept-label", &v)
+}
+
+func (x *FileChooserNative) GetPropertyAcceptLabel() string {
+	var v gobject.Value
+	x.GetProperty("accept-label", &v)
+	return v.GetString()
+}
+
+// The text used for the label on the cancel button in the dialog, or
+// %NULL to use the default text.
+
+func (x *FileChooserNative) SetPropertyCancelLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("cancel-label", &v)
+}
+
+func (x *FileChooserNative) GetPropertyCancelLabel() string {
+	var v gobject.Value
+	x.GetProperty("cancel-label", &v)
+	return v.GetString()
+}
+
 // Adds a 'choice' to the file chooser.
 //
 // This is typically implemented as a combobox or, for boolean choices,
diff --git a/v4/gtk/gtkfilechooserwidget.go b/v4/gtk/gtkfilechooserwidget.go
index 0c9ec4ea3b30ddbf418ef1e706f8b3b712417beb..14616648d5510ae98a362809322a64e58d3f723e 100644
--- a/v4/gtk/gtkfilechooserwidget.go
+++ b/v4/gtk/gtkfilechooserwidget.go
@@ -69,6 +69,25 @@ func (c *FileChooserWidget) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *FileChooserWidget) SetPropertySearchMode(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("search-mode", &v)
+}
+
+func (x *FileChooserWidget) GetPropertySearchMode() bool {
+	var v gobject.Value
+	x.GetProperty("search-mode", &v)
+	return v.GetBoolean()
+}
+
+func (x *FileChooserWidget) GetPropertySubtitle() string {
+	var v gobject.Value
+	x.GetProperty("subtitle", &v)
+	return v.GetString()
+}
+
 // Emitted when the user asks for it.
 //
 // This is a [keybinding signal](class.SignalAction.html).
diff --git a/v4/gtk/gtkfilefilter.go b/v4/gtk/gtkfilefilter.go
index 6b1344d8abfc446841dfd00f58ba18653d8b07ab..d2e04a3370181e048f240d1cbdc3e277b8ec8af5 100644
--- a/v4/gtk/gtkfilefilter.go
+++ b/v4/gtk/gtkfilefilter.go
@@ -5,6 +5,7 @@ import (
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -225,6 +226,24 @@ }
 
 func (c *FileFilter) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The human-readable name of the filter.
+//
+// This is the string that will be displayed in the file chooser
+// user interface if there is a selectable list of filters.
+
+func (x *FileFilter) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *FileFilter) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
 }
 
 // Gets the ID of the @buildable object.
diff --git a/v4/gtk/gtkfilterlistmodel.go b/v4/gtk/gtkfilterlistmodel.go
index 35755ba611ce1e6d2e2f4abcf068580cbcbe723c..3a4a51a5df8c0ad20976550637d54ee2cd200e28 100644
--- a/v4/gtk/gtkfilterlistmodel.go
+++ b/v4/gtk/gtkfilterlistmodel.go
@@ -191,6 +191,87 @@ func (c *FilterListModel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The filter for this model.
+
+func (x *FilterListModel) SetPropertyFilter(value *Filter) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("filter", &v)
+}
+
+func (x *FilterListModel) GetPropertyFilter() *Filter {
+	var v gobject.Value
+	x.GetProperty("filter", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Filter{}
+	result.Ptr = ptr
+	return result
+}
+
+// If the model should filter items incrementally.
+
+func (x *FilterListModel) SetPropertyIncremental(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("incremental", &v)
+}
+
+func (x *FilterListModel) GetPropertyIncremental() bool {
+	var v gobject.Value
+	x.GetProperty("incremental", &v)
+	return v.GetBoolean()
+}
+
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *FilterListModel) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The model being filtered.
+
+func (x *FilterListModel) SetPropertyModel(value gio.ListModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *FilterListModel) GetPropertyModel() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *FilterListModel) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
+// Number of items not yet filtered.
+
+func (x *FilterListModel) GetPropertyPending() uint {
+	var v gobject.Value
+	x.GetProperty("pending", &v)
+	return v.GetUint()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtkfixedlayout.go b/v4/gtk/gtkfixedlayout.go
index db72d66b0cd126a8b0747da03413af8b5188eaf6..4c059a89c8523671bcc903fb746e47293107ccc0 100644
--- a/v4/gtk/gtkfixedlayout.go
+++ b/v4/gtk/gtkfixedlayout.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 	"github.com/jwijenbergh/puregotk/v4/gsk"
 )
@@ -149,6 +150,21 @@ }
 
 func (c *FixedLayoutChild) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The transform of the child.
+
+func (x *FixedLayoutChild) SetPropertyTransform(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("transform", &v)
+}
+
+func (x *FixedLayoutChild) GetPropertyTransform() uintptr {
+	var v gobject.Value
+	x.GetProperty("transform", &v)
+	return v.GetPointer()
 }
 
 func init() {
diff --git a/v4/gtk/gtkflattenlistmodel.go b/v4/gtk/gtkflattenlistmodel.go
index 5aaff4d0ce3e19ac397d82a9cd62338a6b0754a6..e8b28f1e5d1773f0688e7d5ad2754b06732dddb7 100644
--- a/v4/gtk/gtkflattenlistmodel.go
+++ b/v4/gtk/gtkflattenlistmodel.go
@@ -113,6 +113,43 @@ func (c *FlattenListModel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *FlattenListModel) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The model being flattened.
+
+func (x *FlattenListModel) SetPropertyModel(value gio.ListModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *FlattenListModel) GetPropertyModel() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *FlattenListModel) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtkflowbox.go b/v4/gtk/gtkflowbox.go
index 499fd3041779113c47348057c063999d9c481c78..09dbf730be2aaf25e277a766cdfc3e3964f2d28e 100644
--- a/v4/gtk/gtkflowbox.go
+++ b/v4/gtk/gtkflowbox.go
@@ -571,6 +571,132 @@ func (c *FlowBox) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *FlowBox) SetPropertyAcceptUnpairedRelease(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("accept-unpaired-release", &v)
+}
+
+func (x *FlowBox) GetPropertyAcceptUnpairedRelease() bool {
+	var v gobject.Value
+	x.GetProperty("accept-unpaired-release", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether children can be activated with a single
+// click, or require a double-click.
+
+func (x *FlowBox) SetPropertyActivateOnSingleClick(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activate-on-single-click", &v)
+}
+
+func (x *FlowBox) GetPropertyActivateOnSingleClick() bool {
+	var v gobject.Value
+	x.GetProperty("activate-on-single-click", &v)
+	return v.GetBoolean()
+}
+
+// The amount of horizontal space between two children.
+
+func (x *FlowBox) SetPropertyColumnSpacing(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("column-spacing", &v)
+}
+
+func (x *FlowBox) GetPropertyColumnSpacing() uint {
+	var v gobject.Value
+	x.GetProperty("column-spacing", &v)
+	return v.GetUint()
+}
+
+// Determines whether all children should be allocated the
+// same size.
+
+func (x *FlowBox) SetPropertyHomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("homogeneous", &v)
+}
+
+func (x *FlowBox) GetPropertyHomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("homogeneous", &v)
+	return v.GetBoolean()
+}
+
+// The maximum amount of children to request space for consecutively
+// in the given orientation.
+
+func (x *FlowBox) SetPropertyMaxChildrenPerLine(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("max-children-per-line", &v)
+}
+
+func (x *FlowBox) GetPropertyMaxChildrenPerLine() uint {
+	var v gobject.Value
+	x.GetProperty("max-children-per-line", &v)
+	return v.GetUint()
+}
+
+// The minimum number of children to allocate consecutively
+// in the given orientation.
+//
+// Setting the minimum children per line ensures
+// that a reasonably small height will be requested
+// for the overall minimum width of the box.
+
+func (x *FlowBox) SetPropertyMinChildrenPerLine(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("min-children-per-line", &v)
+}
+
+func (x *FlowBox) GetPropertyMinChildrenPerLine() uint {
+	var v gobject.Value
+	x.GetProperty("min-children-per-line", &v)
+	return v.GetUint()
+}
+
+// The amount of vertical space between two children.
+
+func (x *FlowBox) SetPropertyRowSpacing(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("row-spacing", &v)
+}
+
+func (x *FlowBox) GetPropertyRowSpacing() uint {
+	var v gobject.Value
+	x.GetProperty("row-spacing", &v)
+	return v.GetUint()
+}
+
+// The selection mode used by the flow box.
+
+func (x *FlowBox) SetPropertySelectionMode(value SelectionMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("selection-mode", &v)
+}
+
+func (x *FlowBox) GetPropertySelectionMode() SelectionMode {
+	var v gobject.Value
+	x.GetProperty("selection-mode", &v)
+	return SelectionMode(v.GetEnum())
+}
+
 // Emitted when the user activates the @box.
 //
 // This is a [keybinding signal](class.SignalAction.html).
@@ -1020,6 +1146,27 @@ }
 
 func (c *FlowBoxChild) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The child widget.
+
+func (x *FlowBoxChild) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *FlowBoxChild) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
 }
 
 // Emitted when the user activates a child widget in a `GtkFlowBox`.
diff --git a/v4/gtk/gtkfontbutton.go b/v4/gtk/gtkfontbutton.go
index c1f4e7dfc5a649df6a6458654de9da6ca0f31e2e..e1cd2fe461ba30d8cf3fb02f90af30321467147e 100644
--- a/v4/gtk/gtkfontbutton.go
+++ b/v4/gtk/gtkfontbutton.go
@@ -166,6 +166,66 @@ func (c *FontButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the font chooser dialog should be modal.
+
+func (x *FontButton) SetPropertyModal(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("modal", &v)
+}
+
+func (x *FontButton) GetPropertyModal() bool {
+	var v gobject.Value
+	x.GetProperty("modal", &v)
+	return v.GetBoolean()
+}
+
+// The title of the font chooser dialog.
+
+func (x *FontButton) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *FontButton) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// Whether the buttons label will be drawn in the selected font.
+
+func (x *FontButton) SetPropertyUseFont(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-font", &v)
+}
+
+func (x *FontButton) GetPropertyUseFont() bool {
+	var v gobject.Value
+	x.GetProperty("use-font", &v)
+	return v.GetBoolean()
+}
+
+// Whether the buttons label will use the selected font size.
+
+func (x *FontButton) SetPropertyUseSize(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-size", &v)
+}
+
+func (x *FontButton) GetPropertyUseSize() bool {
+	var v gobject.Value
+	x.GetProperty("use-size", &v)
+	return v.GetBoolean()
+}
+
 // Emitted to when the font button is activated.
 //
 // The `::activate` signal on `GtkFontButton` is an action signal and
diff --git a/v4/gtk/gtkfontchooser.go b/v4/gtk/gtkfontchooser.go
index 2f91c629ab1cd1e9fea8f0b0de1e6c6ca8441e45..980bd68c6c8a175dd25cd3f95d47d4bc07bc27f9 100644
--- a/v4/gtk/gtkfontchooser.go
+++ b/v4/gtk/gtkfontchooser.go
@@ -500,6 +500,120 @@ 	XGtkFontChooserSetShowPreviewEntry(x.GoPointer(), ShowPreviewEntryVar)
 
 }
 
+// The font description as a string, e.g. "Sans Italic 12".
+
+func (x *FontChooserBase) SetPropertyFont(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("font", &v)
+}
+
+func (x *FontChooserBase) GetPropertyFont() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("font", &v)
+	return v.GetString()
+}
+
+// The font description as a `PangoFontDescription`.
+
+func (x *FontChooserBase) SetPropertyFontDesc(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("font-desc", &v)
+}
+
+func (x *FontChooserBase) GetPropertyFontDesc() uintptr {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("font-desc", &v)
+	return v.GetPointer()
+}
+
+// The selected font features.
+//
+// The format of the string is compatible with
+// CSS and with Pango attributes.
+
+func (x *FontChooserBase) GetPropertyFontFeatures() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("font-features", &v)
+	return v.GetString()
+}
+
+// The language for which the font features were selected.
+
+func (x *FontChooserBase) SetPropertyLanguage(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("language", &v)
+}
+
+func (x *FontChooserBase) GetPropertyLanguage() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("language", &v)
+	return v.GetString()
+}
+
+// The level of granularity to offer for selecting fonts.
+
+func (x *FontChooserBase) SetPropertyLevel(value FontChooserLevel) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("level", &v)
+}
+
+func (x *FontChooserBase) GetPropertyLevel() FontChooserLevel {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("level", &v)
+	return FontChooserLevel(v.GetFlags())
+}
+
+// The string with which to preview the font.
+
+func (x *FontChooserBase) SetPropertyPreviewText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("preview-text", &v)
+}
+
+func (x *FontChooserBase) GetPropertyPreviewText() string {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("preview-text", &v)
+	return v.GetString()
+}
+
+// Whether to show an entry to change the preview text.
+
+func (x *FontChooserBase) SetPropertyShowPreviewEntry(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("show-preview-entry", &v)
+}
+
+func (x *FontChooserBase) GetPropertyShowPreviewEntry() bool {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("show-preview-entry", &v)
+	return v.GetBoolean()
+}
+
 var XGtkFontChooserGetFont func(uintptr) string
 var XGtkFontChooserGetFontDesc func(uintptr) *pango.FontDescription
 var XGtkFontChooserGetFontFace func(uintptr) uintptr
diff --git a/v4/gtk/gtkfontchooserwidget.go b/v4/gtk/gtkfontchooserwidget.go
index 66bd3932a600dc93e9135ebed77fb8e20b1d7832..6e7bc3645e545bd4854232a533fc0a29c591c706 100644
--- a/v4/gtk/gtkfontchooserwidget.go
+++ b/v4/gtk/gtkfontchooserwidget.go
@@ -4,6 +4,7 @@
 import (
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
 	"github.com/jwijenbergh/puregotk/v4/glib"
 	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
@@ -69,6 +70,25 @@ }
 
 func (c *FontChooserWidget) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// A toggle action that can be used to switch to the tweak page
+// of the font chooser widget, which lets the user tweak the
+// OpenType features and variation axes of the selected font.
+//
+// The action will be enabled or disabled depending on whether
+// the selected font has any features or axes.
+
+func (x *FontChooserWidget) GetPropertyTweakAction() gio.Action {
+	var v gobject.Value
+	x.GetProperty("tweak-action", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ActionBase{}
+	result.Ptr = ptr
+	return result
 }
 
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
diff --git a/v4/gtk/gtkframe.go b/v4/gtk/gtkframe.go
index 3dd88e691419e97d8311432f06a34ad0015dc24f..94df36b16c9b09c0b541eec2f3c138cc9019c647 100644
--- a/v4/gtk/gtkframe.go
+++ b/v4/gtk/gtkframe.go
@@ -235,6 +235,78 @@ func (c *Frame) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *Frame) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *Frame) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Text of the frame's label.
+
+func (x *Frame) SetPropertyLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("label", &v)
+}
+
+func (x *Frame) GetPropertyLabel() string {
+	var v gobject.Value
+	x.GetProperty("label", &v)
+	return v.GetString()
+}
+
+// Widget to display in place of the usual frame label.
+
+func (x *Frame) SetPropertyLabelWidget(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("label-widget", &v)
+}
+
+func (x *Frame) GetPropertyLabelWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("label-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The horizontal alignment of the label.
+
+func (x *Frame) SetPropertyLabelXalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("label-xalign", &v)
+}
+
+func (x *Frame) GetPropertyLabelXalign() float32 {
+	var v gobject.Value
+	x.GetProperty("label-xalign", &v)
+	return v.GetFloat()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Frame) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkgesture.go b/v4/gtk/gtkgesture.go
index 62654d694bc7b81f3d16f69a21aafb75d32db368..28d134bbd0b096cef3d77fe19bd37466c3a87468 100644
--- a/v4/gtk/gtkgesture.go
+++ b/v4/gtk/gtkgesture.go
@@ -405,6 +405,22 @@ func (c *Gesture) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The number of touch points that trigger
+// recognition on this gesture.
+
+func (x *Gesture) SetPropertyNPoints(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("n-points", &v)
+}
+
+func (x *Gesture) GetPropertyNPoints() uint {
+	var v gobject.Value
+	x.GetProperty("n-points", &v)
+	return v.GetUint()
+}
+
 // Emitted when the gesture is recognized.
 //
 // This means the number of touch sequences matches
diff --git a/v4/gtk/gtkgesturelongpress.go b/v4/gtk/gtkgesturelongpress.go
index 078ff0fe24a8d4c4912444787da4bc84913538dd..e3612eb9c5c98044669f52ce5bb3dfda24f23df3 100644
--- a/v4/gtk/gtkgesturelongpress.go
+++ b/v4/gtk/gtkgesturelongpress.go
@@ -99,6 +99,21 @@ func (c *GestureLongPress) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Factor by which to modify the default timeout.
+
+func (x *GestureLongPress) SetPropertyDelayFactor(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("delay-factor", &v)
+}
+
+func (x *GestureLongPress) GetPropertyDelayFactor() float64 {
+	var v gobject.Value
+	x.GetProperty("delay-factor", &v)
+	return v.GetDouble()
+}
+
 // Emitted whenever a press moved too far, or was released
 // before [signal@Gtk.GestureLongPress::pressed] happened.
 func (x *GestureLongPress) ConnectCancelled(cb *func(GestureLongPress)) uint32 {
diff --git a/v4/gtk/gtkgesturepan.go b/v4/gtk/gtkgesturepan.go
index f5d49b0edce963d655bf6fbd59e4805eb8f24739..6e3bdf355705366409a2a6654cbaf79adf405ff7 100644
--- a/v4/gtk/gtkgesturepan.go
+++ b/v4/gtk/gtkgesturepan.go
@@ -95,6 +95,21 @@ func (c *GesturePan) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The expected orientation of pan gestures.
+
+func (x *GesturePan) SetPropertyOrientation(value Orientation) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("orientation", &v)
+}
+
+func (x *GesturePan) GetPropertyOrientation() Orientation {
+	var v gobject.Value
+	x.GetProperty("orientation", &v)
+	return Orientation(v.GetEnum())
+}
+
 // Emitted once a panning gesture along the expected axis is detected.
 func (x *GesturePan) ConnectPan(cb *func(GesturePan, PanDirection, float64)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gtk/gtkgesturesingle.go b/v4/gtk/gtkgesturesingle.go
index 888b491957785000cc0de7592f381a71bf34cc2d..5990fa83d16dfb51ade4baf14c1880be7b3fce13 100644
--- a/v4/gtk/gtkgesturesingle.go
+++ b/v4/gtk/gtkgesturesingle.go
@@ -8,6 +8,7 @@
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/gdk"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -150,6 +151,53 @@ }
 
 func (c *GestureSingle) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Mouse button number to listen to, or 0 to listen for any button.
+
+func (x *GestureSingle) SetPropertyButton(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("button", &v)
+}
+
+func (x *GestureSingle) GetPropertyButton() uint {
+	var v gobject.Value
+	x.GetProperty("button", &v)
+	return v.GetUint()
+}
+
+// Whether the gesture is exclusive.
+//
+// Exclusive gestures only listen to pointer and pointer emulated events.
+
+func (x *GestureSingle) SetPropertyExclusive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("exclusive", &v)
+}
+
+func (x *GestureSingle) GetPropertyExclusive() bool {
+	var v gobject.Value
+	x.GetProperty("exclusive", &v)
+	return v.GetBoolean()
+}
+
+// Whether the gesture handles only touch events.
+
+func (x *GestureSingle) SetPropertyTouchOnly(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("touch-only", &v)
+}
+
+func (x *GestureSingle) GetPropertyTouchOnly() bool {
+	var v gobject.Value
+	x.GetProperty("touch-only", &v)
+	return v.GetBoolean()
 }
 
 func init() {
diff --git a/v4/gtk/gtkglarea.go b/v4/gtk/gtkglarea.go
index 29c846f81d498b123776e41fc4a345c52f9ae355..fd8e58bb97460e21008083a8fe9b3b7bbaf408c1 100644
--- a/v4/gtk/gtkglarea.go
+++ b/v4/gtk/gtkglarea.go
@@ -467,6 +467,100 @@ func (c *GLArea) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If set to %TRUE the ::render signal will be emitted every time
+// the widget draws.
+//
+// This is the default and is useful if drawing the widget is faster.
+//
+// If set to %FALSE the data from previous rendering is kept around and will
+// be used for drawing the widget the next time, unless the window is resized.
+// In order to force a rendering [method@Gtk.GLArea.queue_render] must be called.
+// This mode is useful when the scene changes seldom, but takes a long time
+// to redraw.
+
+func (x *GLArea) SetPropertyAutoRender(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("auto-render", &v)
+}
+
+func (x *GLArea) GetPropertyAutoRender() bool {
+	var v gobject.Value
+	x.GetProperty("auto-render", &v)
+	return v.GetBoolean()
+}
+
+// The `GdkGLContext` used by the `GtkGLArea` widget.
+//
+// The `GtkGLArea` widget is responsible for creating the `GdkGLContext`
+// instance. If you need to render with other kinds of buffers (stencil,
+// depth, etc), use render buffers.
+
+func (x *GLArea) GetPropertyContext() *gdk.GLContext {
+	var v gobject.Value
+	x.GetProperty("context", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.GLContext{}
+	result.Ptr = ptr
+	return result
+}
+
+// If set to %TRUE the widget will allocate and enable a depth buffer for the
+// target framebuffer.
+//
+// Setting this property will enable GL's depth testing as a side effect. If
+// you don't need depth testing, you should call `glDisable(GL_DEPTH_TEST)`
+// in your `GtkGLArea::render` handler.
+
+func (x *GLArea) SetPropertyHasDepthBuffer(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-depth-buffer", &v)
+}
+
+func (x *GLArea) GetPropertyHasDepthBuffer() bool {
+	var v gobject.Value
+	x.GetProperty("has-depth-buffer", &v)
+	return v.GetBoolean()
+}
+
+// If set to %TRUE the widget will allocate and enable a stencil buffer for the
+// target framebuffer.
+
+func (x *GLArea) SetPropertyHasStencilBuffer(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-stencil-buffer", &v)
+}
+
+func (x *GLArea) GetPropertyHasStencilBuffer() bool {
+	var v gobject.Value
+	x.GetProperty("has-stencil-buffer", &v)
+	return v.GetBoolean()
+}
+
+// If set to %TRUE the widget will try to create a `GdkGLContext` using
+// OpenGL ES instead of OpenGL.
+
+func (x *GLArea) SetPropertyUseEs(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-es", &v)
+}
+
+func (x *GLArea) GetPropertyUseEs() bool {
+	var v gobject.Value
+	x.GetProperty("use-es", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when the widget is being realized.
 //
 // This allows you to override how the GL context is created.
diff --git a/v4/gtk/gtkgrid.go b/v4/gtk/gtkgrid.go
index 9c42bcfca768dd4507698a8fe4414229ed46ee46..5e104817ee55fcbcb35cf1b1a268656fa725273c 100644
--- a/v4/gtk/gtkgrid.go
+++ b/v4/gtk/gtkgrid.go
@@ -405,6 +405,81 @@ func (c *Grid) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The row to align to the baseline when valign is %GTK_ALIGN_BASELINE.
+
+func (x *Grid) SetPropertyBaselineRow(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("baseline-row", &v)
+}
+
+func (x *Grid) GetPropertyBaselineRow() int {
+	var v gobject.Value
+	x.GetProperty("baseline-row", &v)
+	return v.GetInt()
+}
+
+// If %TRUE, the columns are all the same width.
+
+func (x *Grid) SetPropertyColumnHomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("column-homogeneous", &v)
+}
+
+func (x *Grid) GetPropertyColumnHomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("column-homogeneous", &v)
+	return v.GetBoolean()
+}
+
+// The amount of space between two consecutive columns.
+
+func (x *Grid) SetPropertyColumnSpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("column-spacing", &v)
+}
+
+func (x *Grid) GetPropertyColumnSpacing() int {
+	var v gobject.Value
+	x.GetProperty("column-spacing", &v)
+	return v.GetInt()
+}
+
+// If %TRUE, the rows are all the same height.
+
+func (x *Grid) SetPropertyRowHomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("row-homogeneous", &v)
+}
+
+func (x *Grid) GetPropertyRowHomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("row-homogeneous", &v)
+	return v.GetBoolean()
+}
+
+// The amount of space between two consecutive rows.
+
+func (x *Grid) SetPropertyRowSpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("row-spacing", &v)
+}
+
+func (x *Grid) GetPropertyRowSpacing() int {
+	var v gobject.Value
+	x.GetProperty("row-spacing", &v)
+	return v.GetInt()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Grid) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkgridlayout.go b/v4/gtk/gtkgridlayout.go
index 9f3525e799acfd207f2379e6d1fe76090e78c1a9..967bd0bfcc51ac4f4d6bd21952c3fcfc22d2fcdb 100644
--- a/v4/gtk/gtkgridlayout.go
+++ b/v4/gtk/gtkgridlayout.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -205,6 +206,82 @@ func (c *GridLayout) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The row to align to the baseline, when `GtkWidget:valign` is set
+// to %GTK_ALIGN_BASELINE.
+
+func (x *GridLayout) SetPropertyBaselineRow(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("baseline-row", &v)
+}
+
+func (x *GridLayout) GetPropertyBaselineRow() int {
+	var v gobject.Value
+	x.GetProperty("baseline-row", &v)
+	return v.GetInt()
+}
+
+// Whether all the columns in the grid have the same width.
+
+func (x *GridLayout) SetPropertyColumnHomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("column-homogeneous", &v)
+}
+
+func (x *GridLayout) GetPropertyColumnHomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("column-homogeneous", &v)
+	return v.GetBoolean()
+}
+
+// The amount of space between to consecutive columns.
+
+func (x *GridLayout) SetPropertyColumnSpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("column-spacing", &v)
+}
+
+func (x *GridLayout) GetPropertyColumnSpacing() int {
+	var v gobject.Value
+	x.GetProperty("column-spacing", &v)
+	return v.GetInt()
+}
+
+// Whether all the rows in the grid have the same height.
+
+func (x *GridLayout) SetPropertyRowHomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("row-homogeneous", &v)
+}
+
+func (x *GridLayout) GetPropertyRowHomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("row-homogeneous", &v)
+	return v.GetBoolean()
+}
+
+// The amount of space between to consecutive rows.
+
+func (x *GridLayout) SetPropertyRowSpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("row-spacing", &v)
+}
+
+func (x *GridLayout) GetPropertyRowSpacing() int {
+	var v gobject.Value
+	x.GetProperty("row-spacing", &v)
+	return v.GetInt()
+}
+
 // `GtkLayoutChild` subclass for children in a `GtkGridLayout`.
 type GridLayoutChild struct {
 	LayoutChild
@@ -303,6 +380,66 @@ }
 
 func (c *GridLayoutChild) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The column to place the child in.
+
+func (x *GridLayoutChild) SetPropertyColumn(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("column", &v)
+}
+
+func (x *GridLayoutChild) GetPropertyColumn() int {
+	var v gobject.Value
+	x.GetProperty("column", &v)
+	return v.GetInt()
+}
+
+// The number of columns the child spans to.
+
+func (x *GridLayoutChild) SetPropertyColumnSpan(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("column-span", &v)
+}
+
+func (x *GridLayoutChild) GetPropertyColumnSpan() int {
+	var v gobject.Value
+	x.GetProperty("column-span", &v)
+	return v.GetInt()
+}
+
+// The row to place the child in.
+
+func (x *GridLayoutChild) SetPropertyRow(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("row", &v)
+}
+
+func (x *GridLayoutChild) GetPropertyRow() int {
+	var v gobject.Value
+	x.GetProperty("row", &v)
+	return v.GetInt()
+}
+
+// The number of rows the child spans to.
+
+func (x *GridLayoutChild) SetPropertyRowSpan(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("row-span", &v)
+}
+
+func (x *GridLayoutChild) GetPropertyRowSpan() int {
+	var v gobject.Value
+	x.GetProperty("row-span", &v)
+	return v.GetInt()
 }
 
 func init() {
diff --git a/v4/gtk/gtkgridview.go b/v4/gtk/gtkgridview.go
index 9c355345d97c1e78c39c01f4e99da38e97bee6da..7f723ff2e3fd2be6972cfc4d9434b52643513323 100644
--- a/v4/gtk/gtkgridview.go
+++ b/v4/gtk/gtkgridview.go
@@ -247,6 +247,111 @@ func (c *GridView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Allow rubberband selection.
+
+func (x *GridView) SetPropertyEnableRubberband(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-rubberband", &v)
+}
+
+func (x *GridView) GetPropertyEnableRubberband() bool {
+	var v gobject.Value
+	x.GetProperty("enable-rubberband", &v)
+	return v.GetBoolean()
+}
+
+// Factory for populating list items.
+
+func (x *GridView) SetPropertyFactory(value *ListItemFactory) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("factory", &v)
+}
+
+func (x *GridView) GetPropertyFactory() *ListItemFactory {
+	var v gobject.Value
+	x.GetProperty("factory", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ListItemFactory{}
+	result.Ptr = ptr
+	return result
+}
+
+// Maximum number of columns per row.
+//
+// If this number is smaller than [property@Gtk.GridView:min-columns],
+// that value is used instead.
+
+func (x *GridView) SetPropertyMaxColumns(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("max-columns", &v)
+}
+
+func (x *GridView) GetPropertyMaxColumns() uint {
+	var v gobject.Value
+	x.GetProperty("max-columns", &v)
+	return v.GetUint()
+}
+
+// Minimum number of columns per row.
+
+func (x *GridView) SetPropertyMinColumns(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("min-columns", &v)
+}
+
+func (x *GridView) GetPropertyMinColumns() uint {
+	var v gobject.Value
+	x.GetProperty("min-columns", &v)
+	return v.GetUint()
+}
+
+// Model for the items displayed.
+
+func (x *GridView) SetPropertyModel(value SelectionModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *GridView) GetPropertyModel() SelectionModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SelectionModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Activate rows on single click and select them on hover.
+
+func (x *GridView) SetPropertySingleClickActivate(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("single-click-activate", &v)
+}
+
+func (x *GridView) GetPropertySingleClickActivate() bool {
+	var v gobject.Value
+	x.GetProperty("single-click-activate", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when a cell has been activated by the user,
 // usually via activating the GtkGridView|list.activate-item action.
 //
diff --git a/v4/gtk/gtkheaderbar.go b/v4/gtk/gtkheaderbar.go
index ae6b0a17fd7cce06714179db3120735cb2c35ba4..63b8563deff9a1d46fdfdff2dd0c8ebc1a708153 100644
--- a/v4/gtk/gtkheaderbar.go
+++ b/v4/gtk/gtkheaderbar.go
@@ -253,6 +253,63 @@ func (c *HeaderBar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The decoration layout for buttons.
+//
+// If this property is not set, the
+// [property@Gtk.Settings:gtk-decoration-layout] setting is used.
+
+func (x *HeaderBar) SetPropertyDecorationLayout(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("decoration-layout", &v)
+}
+
+func (x *HeaderBar) GetPropertyDecorationLayout() string {
+	var v gobject.Value
+	x.GetProperty("decoration-layout", &v)
+	return v.GetString()
+}
+
+// Whether to show title buttons like close, minimize, maximize.
+//
+// Which buttons are actually shown and where is determined
+// by the [property@Gtk.HeaderBar:decoration-layout] property,
+// and by the state of the window (e.g. a close button will not
+// be shown if the window can't be closed).
+
+func (x *HeaderBar) SetPropertyShowTitleButtons(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-title-buttons", &v)
+}
+
+func (x *HeaderBar) GetPropertyShowTitleButtons() bool {
+	var v gobject.Value
+	x.GetProperty("show-title-buttons", &v)
+	return v.GetBoolean()
+}
+
+func (x *HeaderBar) SetPropertyTitleWidget(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("title-widget", &v)
+}
+
+func (x *HeaderBar) GetPropertyTitleWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("title-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *HeaderBar) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkicontheme.go b/v4/gtk/gtkicontheme.go
index 5c34d8b623e4bda99dd3fd2b1ede3f58f332f4e7..4ee554f6ed06d552bb0712716ee8b34768341249 100644
--- a/v4/gtk/gtkicontheme.go
+++ b/v4/gtk/gtkicontheme.go
@@ -150,6 +150,57 @@ func (c *IconPaintable) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The file representing the icon, if any.
+
+func (x *IconPaintable) SetPropertyFile(value gio.File) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("file", &v)
+}
+
+func (x *IconPaintable) GetPropertyFile() gio.File {
+	var v gobject.Value
+	x.GetProperty("file", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.FileBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The icon name that was chosen during lookup.
+
+func (x *IconPaintable) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *IconPaintable) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// Whether the icon is symbolic or not.
+
+func (x *IconPaintable) SetPropertyIsSymbolic(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-symbolic", &v)
+}
+
+func (x *IconPaintable) GetPropertyIsSymbolic() bool {
+	var v gobject.Value
+	x.GetProperty("is-symbolic", &v)
+	return v.GetBoolean()
+}
+
 // Compute a concrete size for the `GdkPaintable`.
 //
 // Applies the sizing algorithm outlined in the
@@ -608,6 +659,91 @@ }
 
 func (c *IconTheme) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The display that this icon theme object is attached to.
+
+func (x *IconTheme) SetPropertyDisplay(value *gdk.Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *IconTheme) GetPropertyDisplay() *gdk.Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Display{}
+	result.Ptr = ptr
+	return result
+}
+
+// The icon names that are supported by the icon theme.
+
+func (x *IconTheme) GetPropertyIconNames() []string {
+	var v gobject.Value
+	x.GetProperty("icon-names", &v)
+	return nil
+}
+
+// Resource paths that will be looked at when looking for icons,
+// similar to search paths.
+//
+// The resources are considered as part of the hicolor icon theme
+// and must be located in subdirectories that are defined in the
+// hicolor icon theme, such as `@path/16x16/actions/run.png`.
+// Icons that are directly placed in the resource path instead
+// of a subdirectory are also considered as ultimate fallback.
+
+func (x *IconTheme) SetPropertyResourcePath(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *IconTheme) GetPropertyResourcePath() []string {
+	var v gobject.Value
+	x.GetProperty("resource-path", &v)
+	return nil
+}
+
+// The search path for this icon theme.
+//
+// When looking for icons, GTK will search for a subdirectory of
+// one or more of the directories in the search path with the same
+// name as the icon theme containing an index.theme file. (Themes
+// from multiple of the path elements are combined to allow themes
+// to be extended by adding icons in the userâs home directory.)
+
+func (x *IconTheme) SetPropertySearchPath(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *IconTheme) GetPropertySearchPath() []string {
+	var v gobject.Value
+	x.GetProperty("search-path", &v)
+	return nil
+}
+
+// The name of the icon theme that is being used.
+//
+// Unless set to a different value, this will be the value of
+// the `GtkSettings:gtk-icon-theme-name` property of the `GtkSettings`
+// object associated to the display of the icontheme object.
+
+func (x *IconTheme) SetPropertyThemeName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("theme-name", &v)
+}
+
+func (x *IconTheme) GetPropertyThemeName() string {
+	var v gobject.Value
+	x.GetProperty("theme-name", &v)
+	return v.GetString()
 }
 
 // Emitted when the icon theme changes.
diff --git a/v4/gtk/gtkiconview.go b/v4/gtk/gtkiconview.go
index 4d6a93d71941d36398d0666c36a3a7038d90fa1e..20da943e25c581baee7db634e377591613b4a695 100644
--- a/v4/gtk/gtkiconview.go
+++ b/v4/gtk/gtkiconview.go
@@ -816,6 +816,296 @@ func (c *IconView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The activate-on-single-click property specifies whether the "item-activated" signal
+// will be emitted after a single click.
+
+func (x *IconView) SetPropertyActivateOnSingleClick(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activate-on-single-click", &v)
+}
+
+func (x *IconView) GetPropertyActivateOnSingleClick() bool {
+	var v gobject.Value
+	x.GetProperty("activate-on-single-click", &v)
+	return v.GetBoolean()
+}
+
+// The `GtkCellArea` used to layout cell renderers for this view.
+//
+// If no area is specified when creating the icon view with gtk_icon_view_new_with_area()
+// a `GtkCellAreaBox` will be used.
+
+func (x *IconView) SetPropertyCellArea(value *CellArea) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("cell-area", &v)
+}
+
+func (x *IconView) GetPropertyCellArea() *CellArea {
+	var v gobject.Value
+	x.GetProperty("cell-area", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &CellArea{}
+	result.Ptr = ptr
+	return result
+}
+
+// The column-spacing property specifies the space which is inserted between
+// the columns of the icon view.
+
+func (x *IconView) SetPropertyColumnSpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("column-spacing", &v)
+}
+
+func (x *IconView) GetPropertyColumnSpacing() int {
+	var v gobject.Value
+	x.GetProperty("column-spacing", &v)
+	return v.GetInt()
+}
+
+// The columns property contains the number of the columns in which the
+// items should be displayed. If it is -1, the number of columns will
+// be chosen automatically to fill the available area.
+
+func (x *IconView) SetPropertyColumns(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("columns", &v)
+}
+
+func (x *IconView) GetPropertyColumns() int {
+	var v gobject.Value
+	x.GetProperty("columns", &v)
+	return v.GetInt()
+}
+
+// The item-orientation property specifies how the cells (i.e. the icon and
+// the text) of the item are positioned relative to each other.
+
+func (x *IconView) SetPropertyItemOrientation(value Orientation) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("item-orientation", &v)
+}
+
+func (x *IconView) GetPropertyItemOrientation() Orientation {
+	var v gobject.Value
+	x.GetProperty("item-orientation", &v)
+	return Orientation(v.GetEnum())
+}
+
+// The item-padding property specifies the padding around each
+// of the icon view's item.
+
+func (x *IconView) SetPropertyItemPadding(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("item-padding", &v)
+}
+
+func (x *IconView) GetPropertyItemPadding() int {
+	var v gobject.Value
+	x.GetProperty("item-padding", &v)
+	return v.GetInt()
+}
+
+// The item-width property specifies the width to use for each item.
+// If it is set to -1, the icon view will automatically determine a
+// suitable item size.
+
+func (x *IconView) SetPropertyItemWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("item-width", &v)
+}
+
+func (x *IconView) GetPropertyItemWidth() int {
+	var v gobject.Value
+	x.GetProperty("item-width", &v)
+	return v.GetInt()
+}
+
+// The margin property specifies the space which is inserted
+// at the edges of the icon view.
+
+func (x *IconView) SetPropertyMargin(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("margin", &v)
+}
+
+func (x *IconView) GetPropertyMargin() int {
+	var v gobject.Value
+	x.GetProperty("margin", &v)
+	return v.GetInt()
+}
+
+// The ::markup-column property contains the number of the model column
+// containing markup information to be displayed. The markup column must be
+// of type `G_TYPE_STRING`. If this property and the :text-column property
+// are both set to column numbers, it overrides the text column.
+// If both are set to -1, no texts are displayed.
+
+func (x *IconView) SetPropertyMarkupColumn(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("markup-column", &v)
+}
+
+func (x *IconView) GetPropertyMarkupColumn() int {
+	var v gobject.Value
+	x.GetProperty("markup-column", &v)
+	return v.GetInt()
+}
+
+func (x *IconView) SetPropertyModel(value TreeModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *IconView) GetPropertyModel() TreeModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TreeModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The ::pixbuf-column property contains the number of the model column
+// containing the pixbufs which are displayed. The pixbuf column must be
+// of type `GDK_TYPE_PIXBUF`. Setting this property to -1 turns off the
+// display of pixbufs.
+
+func (x *IconView) SetPropertyPixbufColumn(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("pixbuf-column", &v)
+}
+
+func (x *IconView) GetPropertyPixbufColumn() int {
+	var v gobject.Value
+	x.GetProperty("pixbuf-column", &v)
+	return v.GetInt()
+}
+
+// The reorderable property specifies if the items can be reordered
+// by DND.
+
+func (x *IconView) SetPropertyReorderable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reorderable", &v)
+}
+
+func (x *IconView) GetPropertyReorderable() bool {
+	var v gobject.Value
+	x.GetProperty("reorderable", &v)
+	return v.GetBoolean()
+}
+
+// The row-spacing property specifies the space which is inserted between
+// the rows of the icon view.
+
+func (x *IconView) SetPropertyRowSpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("row-spacing", &v)
+}
+
+func (x *IconView) GetPropertyRowSpacing() int {
+	var v gobject.Value
+	x.GetProperty("row-spacing", &v)
+	return v.GetInt()
+}
+
+// The ::selection-mode property specifies the selection mode of
+// icon view. If the mode is %GTK_SELECTION_MULTIPLE, rubberband selection
+// is enabled, for the other modes, only keyboard selection is possible.
+
+func (x *IconView) SetPropertySelectionMode(value SelectionMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("selection-mode", &v)
+}
+
+func (x *IconView) GetPropertySelectionMode() SelectionMode {
+	var v gobject.Value
+	x.GetProperty("selection-mode", &v)
+	return SelectionMode(v.GetEnum())
+}
+
+// The spacing property specifies the space which is inserted between
+// the cells (i.e. the icon and the text) of an item.
+
+func (x *IconView) SetPropertySpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("spacing", &v)
+}
+
+func (x *IconView) GetPropertySpacing() int {
+	var v gobject.Value
+	x.GetProperty("spacing", &v)
+	return v.GetInt()
+}
+
+// The ::text-column property contains the number of the model column
+// containing the texts which are displayed. The text column must be
+// of type `G_TYPE_STRING`. If this property and the :markup-column
+// property are both set to -1, no texts are displayed.
+
+func (x *IconView) SetPropertyTextColumn(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("text-column", &v)
+}
+
+func (x *IconView) GetPropertyTextColumn() int {
+	var v gobject.Value
+	x.GetProperty("text-column", &v)
+	return v.GetInt()
+}
+
+func (x *IconView) SetPropertyTooltipColumn(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("tooltip-column", &v)
+}
+
+func (x *IconView) GetPropertyTooltipColumn() int {
+	var v gobject.Value
+	x.GetProperty("tooltip-column", &v)
+	return v.GetInt()
+}
+
 // A [keybinding signal][class@Gtk.SignalAction]
 // which gets emitted when the user activates the currently
 // focused item.
diff --git a/v4/gtk/gtkimage.go b/v4/gtk/gtkimage.go
index a60586f4640ebab7f5a11d5a5dacb2643df0cfa5..455082c3de75fc19c8a18479966e08d669f83347 100644
--- a/v4/gtk/gtkimage.go
+++ b/v4/gtk/gtkimage.go
@@ -463,6 +463,159 @@ func (c *Image) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GFile to display.
+
+func (x *Image) SetPropertyFile(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("file", &v)
+}
+
+func (x *Image) GetPropertyFile() string {
+	var v gobject.Value
+	x.GetProperty("file", &v)
+	return v.GetString()
+}
+
+// The `GIcon` displayed in the GtkImage.
+//
+// For themed icons, If the icon theme is changed, the image will be updated
+// automatically.
+
+func (x *Image) SetPropertyGicon(value gio.Icon) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("gicon", &v)
+}
+
+func (x *Image) GetPropertyGicon() gio.Icon {
+	var v gobject.Value
+	x.GetProperty("gicon", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.IconBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the icon in the icon theme.
+//
+// If the icon theme is changed, the image will be updated automatically.
+
+func (x *Image) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *Image) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// The symbolic size to display icons at.
+
+func (x *Image) SetPropertyIconSize(value IconSize) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("icon-size", &v)
+}
+
+func (x *Image) GetPropertyIconSize() IconSize {
+	var v gobject.Value
+	x.GetProperty("icon-size", &v)
+	return IconSize(v.GetEnum())
+}
+
+// The `GdkPaintable` to display.
+
+func (x *Image) SetPropertyPaintable(value gdk.Paintable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("paintable", &v)
+}
+
+func (x *Image) GetPropertyPaintable() gdk.Paintable {
+	var v gobject.Value
+	x.GetProperty("paintable", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.PaintableBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The size in pixels to display icons at.
+//
+// If set to a value != -1, this property overrides the
+// [property@Gtk.Image:icon-size] property for images of type
+// `GTK_IMAGE_ICON_NAME`.
+
+func (x *Image) SetPropertyPixelSize(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("pixel-size", &v)
+}
+
+func (x *Image) GetPropertyPixelSize() int {
+	var v gobject.Value
+	x.GetProperty("pixel-size", &v)
+	return v.GetInt()
+}
+
+// A path to a resource file to display.
+
+func (x *Image) SetPropertyResource(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("resource", &v)
+}
+
+func (x *Image) GetPropertyResource() string {
+	var v gobject.Value
+	x.GetProperty("resource", &v)
+	return v.GetString()
+}
+
+// The representation being used for image data.
+
+func (x *Image) GetPropertyStorageType() ImageType {
+	var v gobject.Value
+	x.GetProperty("storage-type", &v)
+	return ImageType(v.GetEnum())
+}
+
+// Whether the icon displayed in the `GtkImage` will use
+// standard icon names fallback.
+//
+// The value of this property is only relevant for images of type
+// %GTK_IMAGE_ICON_NAME and %GTK_IMAGE_GICON.
+
+func (x *Image) SetPropertyUseFallback(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-fallback", &v)
+}
+
+func (x *Image) GetPropertyUseFallback() bool {
+	var v gobject.Value
+	x.GetProperty("use-fallback", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Image) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkimcontext.go b/v4/gtk/gtkimcontext.go
index ac38928c01002703c8a999a65207447c6e14d3c7..3b11d27ef35c373bef3c05ae5beac97ee0f7e977 100644
--- a/v4/gtk/gtkimcontext.go
+++ b/v4/gtk/gtkimcontext.go
@@ -865,6 +865,40 @@ func (c *IMContext) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Additional hints that allow input methods to fine-tune
+// their behaviour.
+
+func (x *IMContext) SetPropertyInputHints(value InputHints) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("input-hints", &v)
+}
+
+func (x *IMContext) GetPropertyInputHints() InputHints {
+	var v gobject.Value
+	x.GetProperty("input-hints", &v)
+	return InputHints(v.GetFlags())
+}
+
+// The purpose of the text field that the `GtkIMContext is connected to.
+//
+// This property can be used by on-screen keyboards and other input
+// methods to adjust their behaviour.
+
+func (x *IMContext) SetPropertyInputPurpose(value InputPurpose) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("input-purpose", &v)
+}
+
+func (x *IMContext) GetPropertyInputPurpose() InputPurpose {
+	var v gobject.Value
+	x.GetProperty("input-purpose", &v)
+	return InputPurpose(v.GetEnum())
+}
+
 // The ::commit signal is emitted when a complete input sequence
 // has been entered by the user.
 //
diff --git a/v4/gtk/gtkinfobar.go b/v4/gtk/gtkinfobar.go
index 3ae42d8981846b9fbcb548e850ecb27124b2ccc4..d21c9921454eb65ed466cecef24ac3773271b4a0 100644
--- a/v4/gtk/gtkinfobar.go
+++ b/v4/gtk/gtkinfobar.go
@@ -339,6 +339,53 @@ func (c *InfoBar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The type of the message.
+//
+// The type may be used to determine the appearance of the info bar.
+
+func (x *InfoBar) SetPropertyMessageType(value MessageType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("message-type", &v)
+}
+
+func (x *InfoBar) GetPropertyMessageType() MessageType {
+	var v gobject.Value
+	x.GetProperty("message-type", &v)
+	return MessageType(v.GetEnum())
+}
+
+// Whether the info bar shows its contents.
+
+func (x *InfoBar) SetPropertyRevealed(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("revealed", &v)
+}
+
+func (x *InfoBar) GetPropertyRevealed() bool {
+	var v gobject.Value
+	x.GetProperty("revealed", &v)
+	return v.GetBoolean()
+}
+
+// Whether to include a standard close button.
+
+func (x *InfoBar) SetPropertyShowCloseButton(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-close-button", &v)
+}
+
+func (x *InfoBar) GetPropertyShowCloseButton() bool {
+	var v gobject.Value
+	x.GetProperty("show-close-button", &v)
+	return v.GetBoolean()
+}
+
 // Gets emitted when the user uses a keybinding to dismiss the info bar.
 //
 // The ::close signal is a [keybinding signal](class.SignalAction.html).
diff --git a/v4/gtk/gtkinscription.go b/v4/gtk/gtkinscription.go
index bee350fc9f41d4966eae13b213f2092245f8217b..54cc57ab2fdda2933c931084be868665c3b6894d 100644
--- a/v4/gtk/gtkinscription.go
+++ b/v4/gtk/gtkinscription.go
@@ -319,6 +319,212 @@ func (c *Inscription) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// A list of style attributes to apply to the text of the inscription.
+
+func (x *Inscription) SetPropertyAttributes(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("attributes", &v)
+}
+
+func (x *Inscription) GetPropertyAttributes() uintptr {
+	var v gobject.Value
+	x.GetProperty("attributes", &v)
+	return v.GetPointer()
+}
+
+// Utility property that sets both the [property@Gtk.Inscription:text] and
+// [property@Gtk.Inscription:attributes] properties, mainly intended for use in
+// GtkBuilder ui files to ease translation support and bindings.
+//
+// This function uses [func@Pango.parse_markup] to parse the markup into text and
+// attributes. The markup must be valid. If you cannot ensure that, consider using
+// [func@Pango.parse_markup] and setting the two properties yourself.
+
+func (x *Inscription) SetPropertyMarkup(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("markup", &v)
+}
+
+// The number of characters that should fit into the inscription at minimum.
+//
+// This influences the requested width, not the width actually given to the widget,
+// which might turn out to be larger.
+//
+// Note that this is an approximate character width, so some characters might be
+// wider and some might be thinner, so do not expect the number of characters to
+// exactly match.
+//
+// If you set this property to 0, the inscription will not request any width at all
+// and its width will be determined entirely by its surroundings.
+
+func (x *Inscription) SetPropertyMinChars(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("min-chars", &v)
+}
+
+func (x *Inscription) GetPropertyMinChars() uint {
+	var v gobject.Value
+	x.GetProperty("min-chars", &v)
+	return v.GetUint()
+}
+
+// The number of lines that should fit into the inscription at minimum.
+//
+// This influences the requested height, not the height actually given to the widget,
+// which might turn out to be larger.
+//
+// Note that this is an approximate line height, so if the text uses things like fancy
+// Unicode or attribute that influence the height, the text might not fit.
+//
+// If you set this property to 0, the inscription will not request any height at all
+// and its height will be determined entirely by its surroundings.
+
+func (x *Inscription) SetPropertyMinLines(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("min-lines", &v)
+}
+
+func (x *Inscription) GetPropertyMinLines() uint {
+	var v gobject.Value
+	x.GetProperty("min-lines", &v)
+	return v.GetUint()
+}
+
+// The number of characters that should ideally fit into the inscription.
+//
+// This influences the requested width, not the width actually given to the widget.
+// The widget might turn out larger as well as smaller.
+//
+// If this property is set to a value smaller than [property@Gtk.Inscription:min-chars],
+// that value will be used. In particular, for the default value of 0, this will always
+// be the case.
+
+func (x *Inscription) SetPropertyNatChars(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("nat-chars", &v)
+}
+
+func (x *Inscription) GetPropertyNatChars() uint {
+	var v gobject.Value
+	x.GetProperty("nat-chars", &v)
+	return v.GetUint()
+}
+
+// The number of lines that should ideally fit into the inscription.
+//
+// This influences the requested height, not the height actually given to the widget.
+// The widget might turn out larger as well as smaller.
+//
+// If this property is set to a value smaller than [property@Gtk.Inscription:min-lines],
+// that value will be used. In particular, for the default value of 0, this will always
+// be the case.
+
+func (x *Inscription) SetPropertyNatLines(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("nat-lines", &v)
+}
+
+func (x *Inscription) GetPropertyNatLines() uint {
+	var v gobject.Value
+	x.GetProperty("nat-lines", &v)
+	return v.GetUint()
+}
+
+// The displayed text.
+
+func (x *Inscription) SetPropertyText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("text", &v)
+}
+
+func (x *Inscription) GetPropertyText() string {
+	var v gobject.Value
+	x.GetProperty("text", &v)
+	return v.GetString()
+}
+
+// The overflow method to use for the text.
+
+func (x *Inscription) SetPropertyTextOverflow(value InscriptionOverflow) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("text-overflow", &v)
+}
+
+func (x *Inscription) GetPropertyTextOverflow() InscriptionOverflow {
+	var v gobject.Value
+	x.GetProperty("text-overflow", &v)
+	return InscriptionOverflow(v.GetEnum())
+}
+
+// Controls how the line wrapping is done.
+//
+// Note that unlike `GtkLabel`, the default here is %PANGO_WRAP_WORD_CHAR.
+
+func (x *Inscription) SetPropertyWrapMode(value pango.WrapMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("wrap-mode", &v)
+}
+
+func (x *Inscription) GetPropertyWrapMode() pango.WrapMode {
+	var v gobject.Value
+	x.GetProperty("wrap-mode", &v)
+	return pango.WrapMode(v.GetEnum())
+}
+
+// The horizontal alignment of the text inside the allocated size.
+//
+// Compare this to [property@Gtk.Widget:halign], which determines how the
+// inscription's size allocation is positioned in the available space.
+
+func (x *Inscription) SetPropertyXalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("xalign", &v)
+}
+
+func (x *Inscription) GetPropertyXalign() float32 {
+	var v gobject.Value
+	x.GetProperty("xalign", &v)
+	return v.GetFloat()
+}
+
+// The vertical alignment of the text inside the allocated size.
+//
+// Compare this to [property@Gtk.Widget:valign], which determines how the
+// inscription's size allocation is positioned in the available space.
+
+func (x *Inscription) SetPropertyYalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("yalign", &v)
+}
+
+func (x *Inscription) GetPropertyYalign() float32 {
+	var v gobject.Value
+	x.GetProperty("yalign", &v)
+	return v.GetFloat()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Inscription) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtklabel.go b/v4/gtk/gtklabel.go
index 479af6f46bafae9402cc2f0a524b019a3bdda837..869e2f9107d2c783a41c3c69767eecb18aa1367b 100644
--- a/v4/gtk/gtklabel.go
+++ b/v4/gtk/gtklabel.go
@@ -930,6 +930,376 @@ func (c *Label) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// A list of style attributes to apply to the text of the label.
+
+func (x *Label) SetPropertyAttributes(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("attributes", &v)
+}
+
+func (x *Label) GetPropertyAttributes() uintptr {
+	var v gobject.Value
+	x.GetProperty("attributes", &v)
+	return v.GetPointer()
+}
+
+// The preferred place to ellipsize the string, if the label does
+// not have enough room to display the entire string.
+//
+// Note that setting this property to a value other than
+// %PANGO_ELLIPSIZE_NONE has the side-effect that the label requests
+// only enough space to display the ellipsis "...". In particular, this
+// means that ellipsizing labels do not work well in notebook tabs, unless
+// the [property@Gtk.NotebookPage:tab-expand] child property is set to %TRUE.
+// Other ways to set a label's width are [method@Gtk.Widget.set_size_request]
+// and [method@Gtk.Label.set_width_chars].
+
+func (x *Label) SetPropertyEllipsize(value pango.EllipsizeMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("ellipsize", &v)
+}
+
+func (x *Label) GetPropertyEllipsize() pango.EllipsizeMode {
+	var v gobject.Value
+	x.GetProperty("ellipsize", &v)
+	return pango.EllipsizeMode(v.GetEnum())
+}
+
+// A menu model whose contents will be appended to the context menu.
+
+func (x *Label) SetPropertyExtraMenu(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("extra-menu", &v)
+}
+
+func (x *Label) GetPropertyExtraMenu() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("extra-menu", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// The alignment of the lines in the text of the label, relative to each other.
+//
+// This does *not* affect the alignment of the label within its allocation.
+// See [property@Gtk.Label:xalign] for that.
+
+func (x *Label) SetPropertyJustify(value Justification) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("justify", &v)
+}
+
+func (x *Label) GetPropertyJustify() Justification {
+	var v gobject.Value
+	x.GetProperty("justify", &v)
+	return Justification(v.GetEnum())
+}
+
+// The contents of the label.
+//
+// If the string contains Pango markup (see [func@Pango.parse_markup]),
+// you will have to set the [property@Gtk.Label:use-markup] property to
+// %TRUE in order for the label to display the markup attributes. See also
+// [method@Gtk.Label.set_markup] for a convenience function that sets both
+// this property and the [property@Gtk.Label:use-markup] property at the
+// same time.
+//
+// If the string contains underlines acting as mnemonics, you will have to
+// set the [property@Gtk.Label:use-underline] property to %TRUE in order
+// for the label to display them.
+
+func (x *Label) SetPropertyLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("label", &v)
+}
+
+func (x *Label) GetPropertyLabel() string {
+	var v gobject.Value
+	x.GetProperty("label", &v)
+	return v.GetString()
+}
+
+// The number of lines to which an ellipsized, wrapping label
+// should be limited.
+//
+// This property has no effect if the label is not wrapping or ellipsized.
+// Set this property to -1 if you don't want to limit the number of lines.
+
+func (x *Label) SetPropertyLines(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("lines", &v)
+}
+
+func (x *Label) GetPropertyLines() int {
+	var v gobject.Value
+	x.GetProperty("lines", &v)
+	return v.GetInt()
+}
+
+// The desired maximum width of the label, in characters.
+//
+// If this property is set to -1, the width will be calculated automatically.
+//
+// See the section on [text layout](class.Label.html#text-layout) for details of how
+// [property@Gtk.Label:width-chars] and [property@Gtk.Label:max-width-chars]
+// determine the width of ellipsized and wrapped labels.
+
+func (x *Label) SetPropertyMaxWidthChars(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-width-chars", &v)
+}
+
+func (x *Label) GetPropertyMaxWidthChars() int {
+	var v gobject.Value
+	x.GetProperty("max-width-chars", &v)
+	return v.GetInt()
+}
+
+// The mnemonic accelerator key for the label.
+
+func (x *Label) GetPropertyMnemonicKeyval() uint {
+	var v gobject.Value
+	x.GetProperty("mnemonic-keyval", &v)
+	return v.GetUint()
+}
+
+// The widget to be activated when the labels mnemonic key is pressed.
+
+func (x *Label) SetPropertyMnemonicWidget(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("mnemonic-widget", &v)
+}
+
+func (x *Label) GetPropertyMnemonicWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("mnemonic-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Select the line wrapping for the natural size request.
+//
+// This only affects the natural size requested. For the actual wrapping used,
+// see the [property@Gtk.Label:wrap-mode] property.
+//
+// The default is %GTK_NATURAL_WRAP_INHERIT, which inherits the behavior of the
+// [property@Gtk.Label:wrap-mode] property.
+
+func (x *Label) SetPropertyNaturalWrapMode(value NaturalWrapMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("natural-wrap-mode", &v)
+}
+
+func (x *Label) GetPropertyNaturalWrapMode() NaturalWrapMode {
+	var v gobject.Value
+	x.GetProperty("natural-wrap-mode", &v)
+	return NaturalWrapMode(v.GetEnum())
+}
+
+// Whether the label text can be selected with the mouse.
+
+func (x *Label) SetPropertySelectable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("selectable", &v)
+}
+
+func (x *Label) GetPropertySelectable() bool {
+	var v gobject.Value
+	x.GetProperty("selectable", &v)
+	return v.GetBoolean()
+}
+
+// Whether the label is in single line mode.
+//
+// In single line mode, the height of the label does not depend on the
+// actual text, it is always set to ascent + descent of the font. This
+// can be an advantage in situations where resizing the label because
+// of text changes would be distracting, e.g. in a statusbar.
+
+func (x *Label) SetPropertySingleLineMode(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("single-line-mode", &v)
+}
+
+func (x *Label) GetPropertySingleLineMode() bool {
+	var v gobject.Value
+	x.GetProperty("single-line-mode", &v)
+	return v.GetBoolean()
+}
+
+// Custom tabs for this label.
+
+func (x *Label) SetPropertyTabs(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("tabs", &v)
+}
+
+func (x *Label) GetPropertyTabs() uintptr {
+	var v gobject.Value
+	x.GetProperty("tabs", &v)
+	return v.GetPointer()
+}
+
+// %TRUE if the text of the label includes Pango markup.
+//
+// See [func@Pango.parse_markup].
+
+func (x *Label) SetPropertyUseMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-markup", &v)
+}
+
+func (x *Label) GetPropertyUseMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("use-markup", &v)
+	return v.GetBoolean()
+}
+
+// %TRUE if the text of the label indicates a mnemonic with _.
+
+func (x *Label) SetPropertyUseUnderline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-underline", &v)
+}
+
+func (x *Label) GetPropertyUseUnderline() bool {
+	var v gobject.Value
+	x.GetProperty("use-underline", &v)
+	return v.GetBoolean()
+}
+
+// The desired width of the label, in characters.
+//
+// If this property is set to -1, the width will be calculated automatically.
+//
+// See the section on [text layout](class.Label.html#text-layout) for details of how
+// [property@Gtk.Label:width-chars] and [property@Gtk.Label:max-width-chars]
+// determine the width of ellipsized and wrapped labels.
+
+func (x *Label) SetPropertyWidthChars(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("width-chars", &v)
+}
+
+func (x *Label) GetPropertyWidthChars() int {
+	var v gobject.Value
+	x.GetProperty("width-chars", &v)
+	return v.GetInt()
+}
+
+// %TRUE if the label text will wrap if it gets too wide.
+
+func (x *Label) SetPropertyWrap(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("wrap", &v)
+}
+
+func (x *Label) GetPropertyWrap() bool {
+	var v gobject.Value
+	x.GetProperty("wrap", &v)
+	return v.GetBoolean()
+}
+
+// Controls how the line wrapping is done.
+//
+// This only affects the formatting if line wrapping is on (see the
+// [property@Gtk.Label:wrap] property). The default is %PANGO_WRAP_WORD,
+// which means wrap on word boundaries.
+//
+// For sizing behavior, also consider the [property@Gtk.Label:natural-wrap-mode]
+// property.
+
+func (x *Label) SetPropertyWrapMode(value pango.WrapMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("wrap-mode", &v)
+}
+
+func (x *Label) GetPropertyWrapMode() pango.WrapMode {
+	var v gobject.Value
+	x.GetProperty("wrap-mode", &v)
+	return pango.WrapMode(v.GetEnum())
+}
+
+// The horizontal alignment of the label text inside its size allocation.
+//
+// Compare this to [property@Gtk.Widget:halign], which determines how the
+// labels size allocation is positioned in the space available for the label.
+
+func (x *Label) SetPropertyXalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("xalign", &v)
+}
+
+func (x *Label) GetPropertyXalign() float32 {
+	var v gobject.Value
+	x.GetProperty("xalign", &v)
+	return v.GetFloat()
+}
+
+// The vertical alignment of the label text inside its size allocation.
+//
+// Compare this to [property@Gtk.Widget:valign], which determines how the
+// labels size allocation is positioned in the space available for the label.
+
+func (x *Label) SetPropertyYalign(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("yalign", &v)
+}
+
+func (x *Label) GetPropertyYalign() float32 {
+	var v gobject.Value
+	x.GetProperty("yalign", &v)
+	return v.GetFloat()
+}
+
 // Gets emitted when the user activates a link in the label.
 //
 // The ::activate-current-link is a [keybinding signal](class.SignalAction.html).
diff --git a/v4/gtk/gtklayoutchild.go b/v4/gtk/gtklayoutchild.go
index b0033fd91d25f1264c3c4b577dec473f77523675..edb4fa3b6a7778c90bfbbb65525d467ba049a63c 100644
--- a/v4/gtk/gtklayoutchild.go
+++ b/v4/gtk/gtklayoutchild.go
@@ -92,6 +92,48 @@ func (c *LayoutChild) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The widget that is associated to the `GtkLayoutChild` instance.
+
+func (x *LayoutChild) SetPropertyChildWidget(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child-widget", &v)
+}
+
+func (x *LayoutChild) GetPropertyChildWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("child-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The layout manager that created the `GtkLayoutChild` instance.
+
+func (x *LayoutChild) SetPropertyLayoutManager(value *LayoutManager) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("layout-manager", &v)
+}
+
+func (x *LayoutChild) GetPropertyLayoutManager() *LayoutManager {
+	var v gobject.Value
+	x.GetProperty("layout-manager", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &LayoutManager{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtklevelbar.go b/v4/gtk/gtklevelbar.go
index 4820ec9f99ee4b0f4223f199edac5e091c15d7ae..e1fcf308f9252e1916c1ed5d494e622ef9dc7988 100644
--- a/v4/gtk/gtklevelbar.go
+++ b/v4/gtk/gtklevelbar.go
@@ -316,6 +316,93 @@ func (c *LevelBar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the `GtkLeveBar` is inverted.
+//
+// Level bars normally grow from top to bottom or left to right.
+// Inverted level bars grow in the opposite direction.
+
+func (x *LevelBar) SetPropertyInverted(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("inverted", &v)
+}
+
+func (x *LevelBar) GetPropertyInverted() bool {
+	var v gobject.Value
+	x.GetProperty("inverted", &v)
+	return v.GetBoolean()
+}
+
+// Determines the maximum value of the interval that can be displayed by the bar.
+
+func (x *LevelBar) SetPropertyMaxValue(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("max-value", &v)
+}
+
+func (x *LevelBar) GetPropertyMaxValue() float64 {
+	var v gobject.Value
+	x.GetProperty("max-value", &v)
+	return v.GetDouble()
+}
+
+// Determines the minimum value of the interval that can be displayed by the bar.
+
+func (x *LevelBar) SetPropertyMinValue(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("min-value", &v)
+}
+
+func (x *LevelBar) GetPropertyMinValue() float64 {
+	var v gobject.Value
+	x.GetProperty("min-value", &v)
+	return v.GetDouble()
+}
+
+// Determines the way `GtkLevelBar` interprets the value properties to draw the
+// level fill area.
+//
+// Specifically, when the value is %GTK_LEVEL_BAR_MODE_CONTINUOUS,
+// `GtkLevelBar` will draw a single block representing the current value in
+// that area; when the value is %GTK_LEVEL_BAR_MODE_DISCRETE,
+// the widget will draw a succession of separate blocks filling the
+// draw area, with the number of blocks being equal to the units separating
+// the integral roundings of [property@Gtk.LevelBar:min-value] and
+// [property@Gtk.LevelBar:max-value].
+
+func (x *LevelBar) SetPropertyMode(value LevelBarMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("mode", &v)
+}
+
+func (x *LevelBar) GetPropertyMode() LevelBarMode {
+	var v gobject.Value
+	x.GetProperty("mode", &v)
+	return LevelBarMode(v.GetEnum())
+}
+
+// Determines the currently filled value of the level bar.
+
+func (x *LevelBar) SetPropertyValue(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("value", &v)
+}
+
+func (x *LevelBar) GetPropertyValue() float64 {
+	var v gobject.Value
+	x.GetProperty("value", &v)
+	return v.GetDouble()
+}
+
 // Emitted when an offset specified on the bar changes value.
 //
 // This typically is the result of a [method@Gtk.LevelBar.add_offset_value]
diff --git a/v4/gtk/gtklinkbutton.go b/v4/gtk/gtklinkbutton.go
index 654ac98dded745469ad6b77becca27da1906c2a2..6ed2f0f9b8261bd5dbe4e1c61bf6ec6c27813bd1 100644
--- a/v4/gtk/gtklinkbutton.go
+++ b/v4/gtk/gtklinkbutton.go
@@ -143,6 +143,38 @@ func (c *LinkButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The URI bound to this button.
+
+func (x *LinkButton) SetPropertyUri(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("uri", &v)
+}
+
+func (x *LinkButton) GetPropertyUri() string {
+	var v gobject.Value
+	x.GetProperty("uri", &v)
+	return v.GetString()
+}
+
+// The 'visited' state of this button.
+//
+// A visited link is drawn in a different color.
+
+func (x *LinkButton) SetPropertyVisited(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("visited", &v)
+}
+
+func (x *LinkButton) GetPropertyVisited() bool {
+	var v gobject.Value
+	x.GetProperty("visited", &v)
+	return v.GetBoolean()
+}
+
 // Emitted each time the `GtkLinkButton` is clicked.
 //
 // The default handler will call [func@Gtk.show_uri] with the URI
diff --git a/v4/gtk/gtklistbase.go b/v4/gtk/gtklistbase.go
index 3274488f81a9aa1b49dbcfd4d1a8ebface2d9141..438f7578668a660a4447791b52975235e6914d32 100644
--- a/v4/gtk/gtklistbase.go
+++ b/v4/gtk/gtklistbase.go
@@ -45,6 +45,22 @@ func (c *ListBase) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The orientation of the list. See GtkOrientable:orientation
+// for details.
+
+func (x *ListBase) SetPropertyOrientation(value Orientation) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("orientation", &v)
+}
+
+func (x *ListBase) GetPropertyOrientation() Orientation {
+	var v gobject.Value
+	x.GetProperty("orientation", &v)
+	return Orientation(v.GetEnum())
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ListBase) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtklistbox.go b/v4/gtk/gtklistbox.go
index c76fbad397b3655c4dac187d61afbaa9feaa13ee..04048569bc6a770e50bdb60420382bb721d2cd1a 100644
--- a/v4/gtk/gtklistbox.go
+++ b/v4/gtk/gtklistbox.go
@@ -600,6 +600,67 @@ func (c *ListBox) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to accept unpaired release events.
+
+func (x *ListBox) SetPropertyAcceptUnpairedRelease(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("accept-unpaired-release", &v)
+}
+
+func (x *ListBox) GetPropertyAcceptUnpairedRelease() bool {
+	var v gobject.Value
+	x.GetProperty("accept-unpaired-release", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether children can be activated with a single
+// click, or require a double-click.
+
+func (x *ListBox) SetPropertyActivateOnSingleClick(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activate-on-single-click", &v)
+}
+
+func (x *ListBox) GetPropertyActivateOnSingleClick() bool {
+	var v gobject.Value
+	x.GetProperty("activate-on-single-click", &v)
+	return v.GetBoolean()
+}
+
+// The selection mode used by the list box.
+
+func (x *ListBox) SetPropertySelectionMode(value SelectionMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("selection-mode", &v)
+}
+
+func (x *ListBox) GetPropertySelectionMode() SelectionMode {
+	var v gobject.Value
+	x.GetProperty("selection-mode", &v)
+	return SelectionMode(v.GetEnum())
+}
+
+// Whether to show separators between rows.
+
+func (x *ListBox) SetPropertyShowSeparators(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-separators", &v)
+}
+
+func (x *ListBox) GetPropertyShowSeparators() bool {
+	var v gobject.Value
+	x.GetProperty("show-separators", &v)
+	return v.GetBoolean()
+}
+
 func (x *ListBox) ConnectActivateCursorRow(cb *func(ListBox)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
 	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
@@ -1102,6 +1163,58 @@ }
 
 func (c *ListBoxRow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Determines whether the ::row-activated
+// signal will be emitted for this row.
+
+func (x *ListBoxRow) SetPropertyActivatable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activatable", &v)
+}
+
+func (x *ListBoxRow) GetPropertyActivatable() bool {
+	var v gobject.Value
+	x.GetProperty("activatable", &v)
+	return v.GetBoolean()
+}
+
+// The child widget.
+
+func (x *ListBoxRow) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *ListBoxRow) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Determines whether this row can be selected.
+
+func (x *ListBoxRow) SetPropertySelectable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("selectable", &v)
+}
+
+func (x *ListBoxRow) GetPropertySelectable() bool {
+	var v gobject.Value
+	x.GetProperty("selectable", &v)
+	return v.GetBoolean()
 }
 
 // This is a keybinding signal, which will cause this row to be activated.
diff --git a/v4/gtk/gtklistitem.go b/v4/gtk/gtklistitem.go
index 682f2a8d96a89d9b66db22a2ab2710e18af89ba6..a0d0cfdd1332dac72b5735abe931fb5da4039ce0 100644
--- a/v4/gtk/gtklistitem.go
+++ b/v4/gtk/gtklistitem.go
@@ -192,6 +192,87 @@ func (c *ListItem) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If the item can be activated by the user.
+
+func (x *ListItem) SetPropertyActivatable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activatable", &v)
+}
+
+func (x *ListItem) GetPropertyActivatable() bool {
+	var v gobject.Value
+	x.GetProperty("activatable", &v)
+	return v.GetBoolean()
+}
+
+// Widget used for display.
+
+func (x *ListItem) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *ListItem) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Displayed item.
+
+func (x *ListItem) GetPropertyItem() *gobject.Object {
+	var v gobject.Value
+	x.GetProperty("item", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gobject.Object{}
+	result.Ptr = ptr
+	return result
+}
+
+// Position of the item.
+
+func (x *ListItem) GetPropertyPosition() uint {
+	var v gobject.Value
+	x.GetProperty("position", &v)
+	return v.GetUint()
+}
+
+// If the item can be selected by the user.
+
+func (x *ListItem) SetPropertySelectable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("selectable", &v)
+}
+
+func (x *ListItem) GetPropertySelectable() bool {
+	var v gobject.Value
+	x.GetProperty("selectable", &v)
+	return v.GetBoolean()
+}
+
+// If the item is currently selected.
+
+func (x *ListItem) GetPropertySelected() bool {
+	var v gobject.Value
+	x.GetProperty("selected", &v)
+	return v.GetBoolean()
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtklistview.go b/v4/gtk/gtklistview.go
index ca6bbf0afaf6522bd66069d055fed40296141e53..a6f48bb050ea5e986932946337c327a022e8def5 100644
--- a/v4/gtk/gtklistview.go
+++ b/v4/gtk/gtklistview.go
@@ -290,6 +290,93 @@ func (c *ListView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Allow rubberband selection.
+
+func (x *ListView) SetPropertyEnableRubberband(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-rubberband", &v)
+}
+
+func (x *ListView) GetPropertyEnableRubberband() bool {
+	var v gobject.Value
+	x.GetProperty("enable-rubberband", &v)
+	return v.GetBoolean()
+}
+
+// Factory for populating list items.
+
+func (x *ListView) SetPropertyFactory(value *ListItemFactory) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("factory", &v)
+}
+
+func (x *ListView) GetPropertyFactory() *ListItemFactory {
+	var v gobject.Value
+	x.GetProperty("factory", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ListItemFactory{}
+	result.Ptr = ptr
+	return result
+}
+
+// Model for the items displayed.
+
+func (x *ListView) SetPropertyModel(value SelectionModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *ListView) GetPropertyModel() SelectionModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SelectionModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Show separators between rows.
+
+func (x *ListView) SetPropertyShowSeparators(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-separators", &v)
+}
+
+func (x *ListView) GetPropertyShowSeparators() bool {
+	var v gobject.Value
+	x.GetProperty("show-separators", &v)
+	return v.GetBoolean()
+}
+
+// Activate rows on single click and select them on hover.
+
+func (x *ListView) SetPropertySingleClickActivate(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("single-click-activate", &v)
+}
+
+func (x *ListView) GetPropertySingleClickActivate() bool {
+	var v gobject.Value
+	x.GetProperty("single-click-activate", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when a row has been activated by the user,
 // usually via activating the GtkListView|list.activate-item action.
 //
diff --git a/v4/gtk/gtklockbutton.go b/v4/gtk/gtklockbutton.go
index 4ed826e9647e8b638acfcb38b82e65518c69a2d7..a890901d3830ab122502fefcafccf8189a54e5fe 100644
--- a/v4/gtk/gtklockbutton.go
+++ b/v4/gtk/gtklockbutton.go
@@ -117,6 +117,102 @@ func (c *LockButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GPermission object controlling this button.
+
+func (x *LockButton) SetPropertyPermission(value *gio.Permission) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("permission", &v)
+}
+
+func (x *LockButton) GetPropertyPermission() *gio.Permission {
+	var v gobject.Value
+	x.GetProperty("permission", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.Permission{}
+	result.Ptr = ptr
+	return result
+}
+
+// The text to display when prompting the user to lock.
+
+func (x *LockButton) SetPropertyTextLock(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("text-lock", &v)
+}
+
+func (x *LockButton) GetPropertyTextLock() string {
+	var v gobject.Value
+	x.GetProperty("text-lock", &v)
+	return v.GetString()
+}
+
+// The text to display when prompting the user to unlock.
+
+func (x *LockButton) SetPropertyTextUnlock(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("text-unlock", &v)
+}
+
+func (x *LockButton) GetPropertyTextUnlock() string {
+	var v gobject.Value
+	x.GetProperty("text-unlock", &v)
+	return v.GetString()
+}
+
+// The tooltip to display when prompting the user to lock.
+
+func (x *LockButton) SetPropertyTooltipLock(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("tooltip-lock", &v)
+}
+
+func (x *LockButton) GetPropertyTooltipLock() string {
+	var v gobject.Value
+	x.GetProperty("tooltip-lock", &v)
+	return v.GetString()
+}
+
+// The tooltip to display when the user cannot obtain authorization.
+
+func (x *LockButton) SetPropertyTooltipNotAuthorized(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("tooltip-not-authorized", &v)
+}
+
+func (x *LockButton) GetPropertyTooltipNotAuthorized() string {
+	var v gobject.Value
+	x.GetProperty("tooltip-not-authorized", &v)
+	return v.GetString()
+}
+
+// The tooltip to display when prompting the user to unlock.
+
+func (x *LockButton) SetPropertyTooltipUnlock(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("tooltip-unlock", &v)
+}
+
+func (x *LockButton) GetPropertyTooltipUnlock() string {
+	var v gobject.Value
+	x.GetProperty("tooltip-unlock", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *LockButton) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkmaplistmodel.go b/v4/gtk/gtkmaplistmodel.go
index 15bc465abfe7d14c985dc5133a74277faf69f38d..3b730e72c6d5fcea67d7e6e3ac2295df7ce1c689 100644
--- a/v4/gtk/gtkmaplistmodel.go
+++ b/v4/gtk/gtkmaplistmodel.go
@@ -163,6 +163,51 @@ func (c *MapListModel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If a map is set for this model
+
+func (x *MapListModel) GetPropertyHasMap() bool {
+	var v gobject.Value
+	x.GetProperty("has-map", &v)
+	return v.GetBoolean()
+}
+
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *MapListModel) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The model being mapped.
+
+func (x *MapListModel) SetPropertyModel(value gio.ListModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *MapListModel) GetPropertyModel() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *MapListModel) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtkmediacontrols.go b/v4/gtk/gtkmediacontrols.go
index 9d064d4d46f771c530b39dbc949d55fd9a8103dd..22b23f6e0f67af45c7088e97dea07bb9ecf92134 100644
--- a/v4/gtk/gtkmediacontrols.go
+++ b/v4/gtk/gtkmediacontrols.go
@@ -96,6 +96,27 @@ func (c *MediaControls) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The media-stream managed by this object or %NULL if none.
+
+func (x *MediaControls) SetPropertyMediaStream(value *MediaStream) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("media-stream", &v)
+}
+
+func (x *MediaControls) GetPropertyMediaStream() *MediaStream {
+	var v gobject.Value
+	x.GetProperty("media-stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &MediaStream{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *MediaControls) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkmediafile.go b/v4/gtk/gtkmediafile.go
index 4f2fd58d76ff101a18bd4449fe9b564a088b40cb..bd1bd6111ca21a98bad6300134f337e61f923b54 100644
--- a/v4/gtk/gtkmediafile.go
+++ b/v4/gtk/gtkmediafile.go
@@ -399,6 +399,50 @@ func (c *MediaFile) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The file being played back or %NULL if not playing a file.
+
+func (x *MediaFile) SetPropertyFile(value gio.File) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("file", &v)
+}
+
+func (x *MediaFile) GetPropertyFile() gio.File {
+	var v gobject.Value
+	x.GetProperty("file", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.FileBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The stream being played back or %NULL if not playing a stream.
+//
+// This is %NULL when playing a file.
+
+func (x *MediaFile) SetPropertyInputStream(value *gio.InputStream) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("input-stream", &v)
+}
+
+func (x *MediaFile) GetPropertyInputStream() *gio.InputStream {
+	var v gobject.Value
+	x.GetProperty("input-stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.InputStream{}
+	result.Ptr = ptr
+	return result
+}
+
 // Compute a concrete size for the `GdkPaintable`.
 //
 // Applies the sizing algorithm outlined in the
diff --git a/v4/gtk/gtkmediastream.go b/v4/gtk/gtkmediastream.go
index 43cd745a9c6837814f589e51c617dc5570c1b996..35e9e2d07bf4b9210876e4f7f2a5a831e64ffa34 100644
--- a/v4/gtk/gtkmediastream.go
+++ b/v4/gtk/gtkmediastream.go
@@ -868,6 +868,147 @@ func (c *MediaStream) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The stream's duration in microseconds or 0 if unknown.
+
+func (x *MediaStream) GetPropertyDuration() int64 {
+	var v gobject.Value
+	x.GetProperty("duration", &v)
+	return v.GetInt64()
+}
+
+// Set when playback has finished.
+
+func (x *MediaStream) GetPropertyEnded() bool {
+	var v gobject.Value
+	x.GetProperty("ended", &v)
+	return v.GetBoolean()
+}
+
+// %NULL for a properly working stream or the `GError`
+// that the stream is in.
+
+func (x *MediaStream) GetPropertyError() uintptr {
+	var v gobject.Value
+	x.GetProperty("error", &v)
+	return v.GetPointer()
+}
+
+// Whether the stream contains audio.
+
+func (x *MediaStream) GetPropertyHasAudio() bool {
+	var v gobject.Value
+	x.GetProperty("has-audio", &v)
+	return v.GetBoolean()
+}
+
+// Whether the stream contains video.
+
+func (x *MediaStream) GetPropertyHasVideo() bool {
+	var v gobject.Value
+	x.GetProperty("has-video", &v)
+	return v.GetBoolean()
+}
+
+// Try to restart the media from the beginning once it ended.
+
+func (x *MediaStream) SetPropertyLoop(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("loop", &v)
+}
+
+func (x *MediaStream) GetPropertyLoop() bool {
+	var v gobject.Value
+	x.GetProperty("loop", &v)
+	return v.GetBoolean()
+}
+
+// Whether the audio stream should be muted.
+
+func (x *MediaStream) SetPropertyMuted(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("muted", &v)
+}
+
+func (x *MediaStream) GetPropertyMuted() bool {
+	var v gobject.Value
+	x.GetProperty("muted", &v)
+	return v.GetBoolean()
+}
+
+// Whether the stream is currently playing.
+
+func (x *MediaStream) SetPropertyPlaying(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("playing", &v)
+}
+
+func (x *MediaStream) GetPropertyPlaying() bool {
+	var v gobject.Value
+	x.GetProperty("playing", &v)
+	return v.GetBoolean()
+}
+
+// Whether the stream has finished initializing and existence of
+// audio and video is known.
+
+func (x *MediaStream) SetPropertyPrepared(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("prepared", &v)
+}
+
+func (x *MediaStream) GetPropertyPrepared() bool {
+	var v gobject.Value
+	x.GetProperty("prepared", &v)
+	return v.GetBoolean()
+}
+
+// Set unless the stream is known to not support seeking.
+
+func (x *MediaStream) GetPropertySeekable() bool {
+	var v gobject.Value
+	x.GetProperty("seekable", &v)
+	return v.GetBoolean()
+}
+
+// Set while a seek is in progress.
+
+func (x *MediaStream) GetPropertySeeking() bool {
+	var v gobject.Value
+	x.GetProperty("seeking", &v)
+	return v.GetBoolean()
+}
+
+// The current presentation timestamp in microseconds.
+
+func (x *MediaStream) GetPropertyTimestamp() int64 {
+	var v gobject.Value
+	x.GetProperty("timestamp", &v)
+	return v.GetInt64()
+}
+
+// Volume of the audio stream.
+
+func (x *MediaStream) SetPropertyVolume(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("volume", &v)
+}
+
+func (x *MediaStream) GetPropertyVolume() float64 {
+	var v gobject.Value
+	x.GetProperty("volume", &v)
+	return v.GetDouble()
+}
+
 // Compute a concrete size for the `GdkPaintable`.
 //
 // Applies the sizing algorithm outlined in the
diff --git a/v4/gtk/gtkmenubutton.go b/v4/gtk/gtkmenubutton.go
index 3f4068fba1febcfb3e6e8e96d1f5b8c249b67cba..d20bf33b4c320ebefc4b5abbf4566eee8c88543a 100644
--- a/v4/gtk/gtkmenubutton.go
+++ b/v4/gtk/gtkmenubutton.go
@@ -424,6 +424,180 @@ func (c *MenuButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to show a dropdown arrow even when using an icon or a custom child.
+
+func (x *MenuButton) SetPropertyAlwaysShowArrow(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("always-show-arrow", &v)
+}
+
+func (x *MenuButton) GetPropertyAlwaysShowArrow() bool {
+	var v gobject.Value
+	x.GetProperty("always-show-arrow", &v)
+	return v.GetBoolean()
+}
+
+// The child widget.
+
+func (x *MenuButton) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *MenuButton) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GtkArrowType` representing the direction in which the
+// menu or popover will be popped out.
+
+func (x *MenuButton) SetPropertyDirection(value ArrowType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("direction", &v)
+}
+
+func (x *MenuButton) GetPropertyDirection() ArrowType {
+	var v gobject.Value
+	x.GetProperty("direction", &v)
+	return ArrowType(v.GetEnum())
+}
+
+// Whether the button has a frame.
+
+func (x *MenuButton) SetPropertyHasFrame(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-frame", &v)
+}
+
+func (x *MenuButton) GetPropertyHasFrame() bool {
+	var v gobject.Value
+	x.GetProperty("has-frame", &v)
+	return v.GetBoolean()
+}
+
+// The name of the icon used to automatically populate the button.
+
+func (x *MenuButton) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *MenuButton) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// The label for the button.
+
+func (x *MenuButton) SetPropertyLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("label", &v)
+}
+
+func (x *MenuButton) GetPropertyLabel() string {
+	var v gobject.Value
+	x.GetProperty("label", &v)
+	return v.GetString()
+}
+
+// The `GMenuModel` from which the popup will be created.
+//
+// See [method@Gtk.MenuButton.set_menu_model] for the interaction
+// with the [property@Gtk.MenuButton:popover] property.
+
+func (x *MenuButton) SetPropertyMenuModel(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("menu-model", &v)
+}
+
+func (x *MenuButton) GetPropertyMenuModel() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("menu-model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GtkPopover` that will be popped up when the button is clicked.
+
+func (x *MenuButton) SetPropertyPopover(value *Popover) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("popover", &v)
+}
+
+func (x *MenuButton) GetPropertyPopover() *Popover {
+	var v gobject.Value
+	x.GetProperty("popover", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Popover{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the menu button acts as a primary menu.
+//
+// Primary menus can be opened using the &lt;kbd&gt;F10&lt;/kbd&gt; key
+
+func (x *MenuButton) SetPropertyPrimary(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("primary", &v)
+}
+
+func (x *MenuButton) GetPropertyPrimary() bool {
+	var v gobject.Value
+	x.GetProperty("primary", &v)
+	return v.GetBoolean()
+}
+
+// If set an underscore in the text indicates a mnemonic.
+
+func (x *MenuButton) SetPropertyUseUnderline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-underline", &v)
+}
+
+func (x *MenuButton) GetPropertyUseUnderline() bool {
+	var v gobject.Value
+	x.GetProperty("use-underline", &v)
+	return v.GetBoolean()
+}
+
 // Emitted to when the menu button is activated.
 //
 // The `::activate` signal on `GtkMenuButton` is an action signal and
diff --git a/v4/gtk/gtkmessagedialog.go b/v4/gtk/gtkmessagedialog.go
index 38372c7874ed38f2c32367453f2c85568c405dc9..bd709231cfc9e54a8bddc431bdf6f3197bd9cfc7 100644
--- a/v4/gtk/gtkmessagedialog.go
+++ b/v4/gtk/gtkmessagedialog.go
@@ -280,6 +280,111 @@ func (c *MessageDialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *MessageDialog) SetPropertyButtons(value ButtonsType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("buttons", &v)
+}
+
+// The `GtkBox` that corresponds to the message area of this dialog.
+//
+// See [method@Gtk.MessageDialog.get_message_area] for a detailed
+// description of this area.
+
+func (x *MessageDialog) GetPropertyMessageArea() *Widget {
+	var v gobject.Value
+	x.GetProperty("message-area", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The type of the message.
+
+func (x *MessageDialog) SetPropertyMessageType(value MessageType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("message-type", &v)
+}
+
+func (x *MessageDialog) GetPropertyMessageType() MessageType {
+	var v gobject.Value
+	x.GetProperty("message-type", &v)
+	return MessageType(v.GetEnum())
+}
+
+// The secondary text of the message dialog.
+
+func (x *MessageDialog) SetPropertySecondaryText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("secondary-text", &v)
+}
+
+func (x *MessageDialog) GetPropertySecondaryText() string {
+	var v gobject.Value
+	x.GetProperty("secondary-text", &v)
+	return v.GetString()
+}
+
+// %TRUE if the secondary text of the dialog includes Pango markup.
+//
+// See [func@Pango.parse_markup].
+
+func (x *MessageDialog) SetPropertySecondaryUseMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("secondary-use-markup", &v)
+}
+
+func (x *MessageDialog) GetPropertySecondaryUseMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("secondary-use-markup", &v)
+	return v.GetBoolean()
+}
+
+// The primary text of the message dialog.
+//
+// If the dialog has a secondary text, this will appear as the title.
+
+func (x *MessageDialog) SetPropertyText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("text", &v)
+}
+
+func (x *MessageDialog) GetPropertyText() string {
+	var v gobject.Value
+	x.GetProperty("text", &v)
+	return v.GetString()
+}
+
+// %TRUE if the primary text of the dialog includes Pango markup.
+//
+// See [func@Pango.parse_markup].
+
+func (x *MessageDialog) SetPropertyUseMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-markup", &v)
+}
+
+func (x *MessageDialog) GetPropertyUseMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("use-markup", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *MessageDialog) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkmountoperation.go b/v4/gtk/gtkmountoperation.go
index 865764b8f1d969f09b99e0b88c82fda39814a000..851531ae39f4f376fd965345a761b26665c57158 100644
--- a/v4/gtk/gtkmountoperation.go
+++ b/v4/gtk/gtkmountoperation.go
@@ -251,6 +251,56 @@ func (c *MountOperation) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The display where dialogs will be shown.
+
+func (x *MountOperation) SetPropertyDisplay(value *gdk.Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *MountOperation) GetPropertyDisplay() *gdk.Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Display{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether a dialog is currently shown.
+
+func (x *MountOperation) GetPropertyIsShowing() bool {
+	var v gobject.Value
+	x.GetProperty("is-showing", &v)
+	return v.GetBoolean()
+}
+
+// The parent window.
+
+func (x *MountOperation) SetPropertyParent(value *Window) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("parent", &v)
+}
+
+func (x *MountOperation) GetPropertyParent() *Window {
+	var v gobject.Value
+	x.GetProperty("parent", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Window{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkmultifilter.go b/v4/gtk/gtkmultifilter.go
index 5281c5ef35c1e4c1d6c5c612a2c1035b37bc9ee9..bda8812a0b64b17bb13c88eb953debead3be9591 100644
--- a/v4/gtk/gtkmultifilter.go
+++ b/v4/gtk/gtkmultifilter.go
@@ -392,6 +392,22 @@ func (c *MultiFilter) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *MultiFilter) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *MultiFilter) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtkmultiselection.go b/v4/gtk/gtkmultiselection.go
index e944d6399b29c2fd60d42a2f1d3b4757a5a9eb89..42b143b69bfa6de410a21e27c16c1f9f514c50fb 100644
--- a/v4/gtk/gtkmultiselection.go
+++ b/v4/gtk/gtkmultiselection.go
@@ -95,6 +95,43 @@ func (c *MultiSelection) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *MultiSelection) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The list managed by this selection.
+
+func (x *MultiSelection) SetPropertyModel(value gio.ListModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *MultiSelection) GetPropertyModel() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *MultiSelection) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtkmultisorter.go b/v4/gtk/gtkmultisorter.go
index 04211d0fd75abc544f6f9da302c54a219a072443..2a382c4c668998f6c380e21287bc0cb1fee42647 100644
--- a/v4/gtk/gtkmultisorter.go
+++ b/v4/gtk/gtkmultisorter.go
@@ -99,6 +99,22 @@ func (c *MultiSorter) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *MultiSorter) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *MultiSorter) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtknativedialog.go b/v4/gtk/gtknativedialog.go
index 34a790de28a5140678b5be68370afb3e8b1cdbb2..ddc45b1f760f7311549ff0201eeb5c93b61acd2a 100644
--- a/v4/gtk/gtknativedialog.go
+++ b/v4/gtk/gtknativedialog.go
@@ -374,6 +374,72 @@ func (c *NativeDialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the window should be modal with respect to its transient parent.
+
+func (x *NativeDialog) SetPropertyModal(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("modal", &v)
+}
+
+func (x *NativeDialog) GetPropertyModal() bool {
+	var v gobject.Value
+	x.GetProperty("modal", &v)
+	return v.GetBoolean()
+}
+
+// The title of the dialog window
+
+func (x *NativeDialog) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *NativeDialog) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// The transient parent of the dialog, or %NULL for none.
+
+func (x *NativeDialog) SetPropertyTransientFor(value *Window) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("transient-for", &v)
+}
+
+func (x *NativeDialog) GetPropertyTransientFor() *Window {
+	var v gobject.Value
+	x.GetProperty("transient-for", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Window{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the window is currently visible.
+
+func (x *NativeDialog) SetPropertyVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("visible", &v)
+}
+
+func (x *NativeDialog) GetPropertyVisible() bool {
+	var v gobject.Value
+	x.GetProperty("visible", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when the user responds to the dialog.
 //
 // When this is called the dialog has been hidden.
diff --git a/v4/gtk/gtknoselection.go b/v4/gtk/gtknoselection.go
index 30eed875190ead2848331d4fb044f3f50b31009a..d8632f869735dc8e13012ca8886c79b9e7ed9192 100644
--- a/v4/gtk/gtknoselection.go
+++ b/v4/gtk/gtknoselection.go
@@ -98,6 +98,43 @@ func (c *NoSelection) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *NoSelection) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The model being managed.
+
+func (x *NoSelection) SetPropertyModel(value gio.ListModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *NoSelection) GetPropertyModel() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *NoSelection) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtknotebook.go b/v4/gtk/gtknotebook.go
index ef9b213cfa9788f0afbab05bb84424a690bcabe7..f888e69617ac57fb3b1dbfe01660d3bd1ba1ccb7 100644
--- a/v4/gtk/gtknotebook.go
+++ b/v4/gtk/gtknotebook.go
@@ -711,6 +711,125 @@ func (c *Notebook) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If %TRUE, pressing the right mouse button on the notebook shows a page switching menu.
+
+func (x *Notebook) SetPropertyEnablePopup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-popup", &v)
+}
+
+func (x *Notebook) GetPropertyEnablePopup() bool {
+	var v gobject.Value
+	x.GetProperty("enable-popup", &v)
+	return v.GetBoolean()
+}
+
+// Group name for tab drag and drop.
+
+func (x *Notebook) SetPropertyGroupName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("group-name", &v)
+}
+
+func (x *Notebook) GetPropertyGroupName() string {
+	var v gobject.Value
+	x.GetProperty("group-name", &v)
+	return v.GetString()
+}
+
+// The index of the current page.
+
+func (x *Notebook) SetPropertyPage(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("page", &v)
+}
+
+func (x *Notebook) GetPropertyPage() int {
+	var v gobject.Value
+	x.GetProperty("page", &v)
+	return v.GetInt()
+}
+
+// A selection model with the pages.
+
+func (x *Notebook) GetPropertyPages() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("pages", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// If %TRUE, scroll arrows are added if there are too many pages to fit.
+
+func (x *Notebook) SetPropertyScrollable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("scrollable", &v)
+}
+
+func (x *Notebook) GetPropertyScrollable() bool {
+	var v gobject.Value
+	x.GetProperty("scrollable", &v)
+	return v.GetBoolean()
+}
+
+// Whether the border should be shown.
+
+func (x *Notebook) SetPropertyShowBorder(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-border", &v)
+}
+
+func (x *Notebook) GetPropertyShowBorder() bool {
+	var v gobject.Value
+	x.GetProperty("show-border", &v)
+	return v.GetBoolean()
+}
+
+// Whether tabs should be shown.
+
+func (x *Notebook) SetPropertyShowTabs(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-tabs", &v)
+}
+
+func (x *Notebook) GetPropertyShowTabs() bool {
+	var v gobject.Value
+	x.GetProperty("show-tabs", &v)
+	return v.GetBoolean()
+}
+
+// Which side of the notebook holds the tabs.
+
+func (x *Notebook) SetPropertyTabPos(value PositionType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("tab-pos", &v)
+}
+
+func (x *Notebook) GetPropertyTabPos() PositionType {
+	var v gobject.Value
+	x.GetProperty("tab-pos", &v)
+	return PositionType(v.GetEnum())
+}
+
 func (x *Notebook) ConnectChangeCurrentPage(cb *func(Notebook, int) bool) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
 	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
@@ -1103,6 +1222,174 @@ }
 
 func (c *NotebookPage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The child for this page.
+
+func (x *NotebookPage) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *NotebookPage) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the tab is detachable.
+
+func (x *NotebookPage) SetPropertyDetachable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("detachable", &v)
+}
+
+func (x *NotebookPage) GetPropertyDetachable() bool {
+	var v gobject.Value
+	x.GetProperty("detachable", &v)
+	return v.GetBoolean()
+}
+
+// The label widget displayed in the childs menu entry.
+
+func (x *NotebookPage) SetPropertyMenu(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("menu", &v)
+}
+
+func (x *NotebookPage) GetPropertyMenu() *Widget {
+	var v gobject.Value
+	x.GetProperty("menu", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The text of the menu widget.
+
+func (x *NotebookPage) SetPropertyMenuLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("menu-label", &v)
+}
+
+func (x *NotebookPage) GetPropertyMenuLabel() string {
+	var v gobject.Value
+	x.GetProperty("menu-label", &v)
+	return v.GetString()
+}
+
+// The index of the child in the parent.
+
+func (x *NotebookPage) SetPropertyPosition(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("position", &v)
+}
+
+func (x *NotebookPage) GetPropertyPosition() int {
+	var v gobject.Value
+	x.GetProperty("position", &v)
+	return v.GetInt()
+}
+
+// Whether the tab is reorderable by user action.
+
+func (x *NotebookPage) SetPropertyReorderable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reorderable", &v)
+}
+
+func (x *NotebookPage) GetPropertyReorderable() bool {
+	var v gobject.Value
+	x.GetProperty("reorderable", &v)
+	return v.GetBoolean()
+}
+
+// The tab widget for tihs page.
+
+func (x *NotebookPage) SetPropertyTab(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("tab", &v)
+}
+
+func (x *NotebookPage) GetPropertyTab() *Widget {
+	var v gobject.Value
+	x.GetProperty("tab", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to expand the childs tab.
+
+func (x *NotebookPage) SetPropertyTabExpand(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("tab-expand", &v)
+}
+
+func (x *NotebookPage) GetPropertyTabExpand() bool {
+	var v gobject.Value
+	x.GetProperty("tab-expand", &v)
+	return v.GetBoolean()
+}
+
+// Whether the childs tab should fill the allocated area.
+
+func (x *NotebookPage) SetPropertyTabFill(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("tab-fill", &v)
+}
+
+func (x *NotebookPage) GetPropertyTabFill() bool {
+	var v gobject.Value
+	x.GetProperty("tab-fill", &v)
+	return v.GetBoolean()
+}
+
+// The text of the tab widget.
+
+func (x *NotebookPage) SetPropertyTabLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("tab-label", &v)
+}
+
+func (x *NotebookPage) GetPropertyTabLabel() string {
+	var v gobject.Value
+	x.GetProperty("tab-label", &v)
+	return v.GetString()
 }
 
 func init() {
diff --git a/v4/gtk/gtknumericsorter.go b/v4/gtk/gtknumericsorter.go
index a9cf8e0bd222fd3de5a9e02e67d32c03b15d7f3f..520bf3385ddc4cdad1f4382d7765e29e30a2d80f 100644
--- a/v4/gtk/gtknumericsorter.go
+++ b/v4/gtk/gtknumericsorter.go
@@ -121,6 +121,42 @@ func (c *NumericSorter) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The expression to evaluate on items to get a number to compare with.
+
+func (x *NumericSorter) SetPropertyExpression(value *Expression) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("expression", &v)
+}
+
+func (x *NumericSorter) GetPropertyExpression() *Expression {
+	var v gobject.Value
+	x.GetProperty("expression", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Expression{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the sorter will sort smaller numbers first.
+
+func (x *NumericSorter) SetPropertySortOrder(value SortType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("sort-order", &v)
+}
+
+func (x *NumericSorter) GetPropertySortOrder() SortType {
+	var v gobject.Value
+	x.GetProperty("sort-order", &v)
+	return SortType(v.GetEnum())
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkorientable.go b/v4/gtk/gtkorientable.go
index 584a8d80b5576de0601adee18699745b1e326941..06fd100d7f07b6db6f59134f2175d7db3272f568 100644
--- a/v4/gtk/gtkorientable.go
+++ b/v4/gtk/gtkorientable.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -65,6 +66,23 @@ func (x *OrientableBase) SetOrientation(OrientationVar Orientation) {
 
 	XGtkOrientableSetOrientation(x.GoPointer(), OrientationVar)
 
+}
+
+// The orientation of the orientable.
+
+func (x *OrientableBase) SetPropertyOrientation(value Orientation) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("orientation", &v)
+}
+
+func (x *OrientableBase) GetPropertyOrientation() Orientation {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("orientation", &v)
+	return Orientation(v.GetEnum())
 }
 
 var XGtkOrientableGetOrientation func(uintptr) Orientation
diff --git a/v4/gtk/gtkoverlay.go b/v4/gtk/gtkoverlay.go
index b741894a85acc566c8936651e8baacf1d00e2345..45fa62664eff8a6a152cb32400ae6f85c9194e7d 100644
--- a/v4/gtk/gtkoverlay.go
+++ b/v4/gtk/gtkoverlay.go
@@ -179,6 +179,25 @@ func (c *Overlay) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *Overlay) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *Overlay) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emitted to determine the position and size of any overlay
 // child widgets.
 //
diff --git a/v4/gtk/gtkoverlaylayout.go b/v4/gtk/gtkoverlaylayout.go
index 673a0065f81b4d0c7a385a259fdb06a49ec2eb30..289f6e36125e31035c93c623df0d4da85db93c25 100644
--- a/v4/gtk/gtkoverlaylayout.go
+++ b/v4/gtk/gtkoverlaylayout.go
@@ -7,6 +7,7 @@ 	"unsafe"
 
 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -142,6 +143,37 @@ }
 
 func (c *OverlayLayoutChild) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Whether the child should be clipped to fit the parent's size.
+
+func (x *OverlayLayoutChild) SetPropertyClipOverlay(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("clip-overlay", &v)
+}
+
+func (x *OverlayLayoutChild) GetPropertyClipOverlay() bool {
+	var v gobject.Value
+	x.GetProperty("clip-overlay", &v)
+	return v.GetBoolean()
+}
+
+// Whether the child size should contribute to the `GtkOverlayLayout`'s
+// measurement.
+
+func (x *OverlayLayoutChild) SetPropertyMeasure(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("measure", &v)
+}
+
+func (x *OverlayLayoutChild) GetPropertyMeasure() bool {
+	var v gobject.Value
+	x.GetProperty("measure", &v)
+	return v.GetBoolean()
 }
 
 func init() {
diff --git a/v4/gtk/gtkpadcontroller.go b/v4/gtk/gtkpadcontroller.go
index e87471fcc30357092d8d9c7df96157f8c536b6a1..d1726194a8806e3d2e9495ca6ccebd37a123fb98 100644
--- a/v4/gtk/gtkpadcontroller.go
+++ b/v4/gtk/gtkpadcontroller.go
@@ -9,6 +9,7 @@ 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/gdk"
 	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
 
@@ -189,6 +190,44 @@ }
 
 func (c *PadController) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+func (x *PadController) SetPropertyActionGroup(value gio.ActionGroup) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("action-group", &v)
+}
+
+func (x *PadController) GetPropertyActionGroup() gio.ActionGroup {
+	var v gobject.Value
+	x.GetProperty("action-group", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ActionGroupBase{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *PadController) SetPropertyPad(value *gdk.Device) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("pad", &v)
+}
+
+func (x *PadController) GetPropertyPad() *gdk.Device {
+	var v gobject.Value
+	x.GetProperty("pad", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Device{}
+	result.Ptr = ptr
+	return result
 }
 
 func init() {
diff --git a/v4/gtk/gtkpaned.go b/v4/gtk/gtkpaned.go
index 9038364b73423b3e185c6b3674557b9132fd296f..4d33f0bb549bd379c0ec82ca0d267f29c7c910f8 100644
--- a/v4/gtk/gtkpaned.go
+++ b/v4/gtk/gtkpaned.go
@@ -286,6 +286,184 @@ func (c *Paned) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The second child.
+
+func (x *Paned) SetPropertyEndChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("end-child", &v)
+}
+
+func (x *Paned) GetPropertyEndChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("end-child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The largest possible value for the [property@Gtk.Paned:position]
+// property.
+//
+// This property is derived from the size and shrinkability
+// of the widget's children.
+
+func (x *Paned) GetPropertyMaxPosition() int {
+	var v gobject.Value
+	x.GetProperty("max-position", &v)
+	return v.GetInt()
+}
+
+// The smallest possible value for the [property@Gtk.Paned:position]
+// property.
+//
+// This property is derived from the size and shrinkability
+// of the widget's children.
+
+func (x *Paned) GetPropertyMinPosition() int {
+	var v gobject.Value
+	x.GetProperty("min-position", &v)
+	return v.GetInt()
+}
+
+// Position of the separator in pixels, from the left/top.
+
+func (x *Paned) SetPropertyPosition(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("position", &v)
+}
+
+func (x *Paned) GetPropertyPosition() int {
+	var v gobject.Value
+	x.GetProperty("position", &v)
+	return v.GetInt()
+}
+
+// Whether the [property@Gtk.Paned:position] property has been set.
+
+func (x *Paned) SetPropertyPositionSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("position-set", &v)
+}
+
+func (x *Paned) GetPropertyPositionSet() bool {
+	var v gobject.Value
+	x.GetProperty("position-set", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the second child expands and shrinks
+// along with the paned widget.
+
+func (x *Paned) SetPropertyResizeEndChild(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("resize-end-child", &v)
+}
+
+func (x *Paned) GetPropertyResizeEndChild() bool {
+	var v gobject.Value
+	x.GetProperty("resize-end-child", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the first child expands and shrinks
+// along with the paned widget.
+
+func (x *Paned) SetPropertyResizeStartChild(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("resize-start-child", &v)
+}
+
+func (x *Paned) GetPropertyResizeStartChild() bool {
+	var v gobject.Value
+	x.GetProperty("resize-start-child", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the second child can be made smaller
+// than its requisition.
+
+func (x *Paned) SetPropertyShrinkEndChild(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("shrink-end-child", &v)
+}
+
+func (x *Paned) GetPropertyShrinkEndChild() bool {
+	var v gobject.Value
+	x.GetProperty("shrink-end-child", &v)
+	return v.GetBoolean()
+}
+
+// Determines whether the first child can be made smaller
+// than its requisition.
+
+func (x *Paned) SetPropertyShrinkStartChild(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("shrink-start-child", &v)
+}
+
+func (x *Paned) GetPropertyShrinkStartChild() bool {
+	var v gobject.Value
+	x.GetProperty("shrink-start-child", &v)
+	return v.GetBoolean()
+}
+
+// The first child.
+
+func (x *Paned) SetPropertyStartChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("start-child", &v)
+}
+
+func (x *Paned) GetPropertyStartChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("start-child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the `GtkPaned` should provide a stronger visual separation.
+//
+// For example, this could be set when a paned contains two
+// [class@Gtk.Notebook]s, whose tab rows would otherwise merge visually.
+
+func (x *Paned) SetPropertyWideHandle(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("wide-handle", &v)
+}
+
+func (x *Paned) GetPropertyWideHandle() bool {
+	var v gobject.Value
+	x.GetProperty("wide-handle", &v)
+	return v.GetBoolean()
+}
+
 // Emitted to accept the current position of the handle when
 // moving it using key bindings.
 //
diff --git a/v4/gtk/gtkpasswordentry.go b/v4/gtk/gtkpasswordentry.go
index a1e72152366d714811085ffad6d165def20b99ee..f130d2d9b49f19552d93dbce1d4ba728c070ded9 100644
--- a/v4/gtk/gtkpasswordentry.go
+++ b/v4/gtk/gtkpasswordentry.go
@@ -148,6 +148,74 @@ func (c *PasswordEntry) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to activate the default widget when Enter is pressed.
+
+func (x *PasswordEntry) SetPropertyActivatesDefault(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activates-default", &v)
+}
+
+func (x *PasswordEntry) GetPropertyActivatesDefault() bool {
+	var v gobject.Value
+	x.GetProperty("activates-default", &v)
+	return v.GetBoolean()
+}
+
+// A menu model whose contents will be appended to
+// the context menu.
+
+func (x *PasswordEntry) SetPropertyExtraMenu(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("extra-menu", &v)
+}
+
+func (x *PasswordEntry) GetPropertyExtraMenu() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("extra-menu", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// The text that will be displayed in the `GtkPasswordEntry`
+// when it is empty and unfocused.
+
+func (x *PasswordEntry) SetPropertyPlaceholderText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("placeholder-text", &v)
+}
+
+func (x *PasswordEntry) GetPropertyPlaceholderText() string {
+	var v gobject.Value
+	x.GetProperty("placeholder-text", &v)
+	return v.GetString()
+}
+
+// Whether to show an icon for revealing the content.
+
+func (x *PasswordEntry) SetPropertyShowPeekIcon(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-peek-icon", &v)
+}
+
+func (x *PasswordEntry) GetPropertyShowPeekIcon() bool {
+	var v gobject.Value
+	x.GetProperty("show-peek-icon", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when the entry is activated.
 //
 // The keybindings for this signal are all forms of the Enter key.
diff --git a/v4/gtk/gtkpicture.go b/v4/gtk/gtkpicture.go
index 5bdcd807965a615e6592de43245868e2d4cc515e..b57274a8e9f47e4a2dea23a853d6256d98103e22 100644
--- a/v4/gtk/gtkpicture.go
+++ b/v4/gtk/gtkpicture.go
@@ -417,6 +417,109 @@ func (c *Picture) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The alternative textual description for the picture.
+
+func (x *Picture) SetPropertyAlternativeText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("alternative-text", &v)
+}
+
+func (x *Picture) GetPropertyAlternativeText() string {
+	var v gobject.Value
+	x.GetProperty("alternative-text", &v)
+	return v.GetString()
+}
+
+// If the `GtkPicture` can be made smaller than the natural size of its contents.
+
+func (x *Picture) SetPropertyCanShrink(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-shrink", &v)
+}
+
+func (x *Picture) GetPropertyCanShrink() bool {
+	var v gobject.Value
+	x.GetProperty("can-shrink", &v)
+	return v.GetBoolean()
+}
+
+// How the content should be resized to fit inside the `GtkPicture`.
+
+func (x *Picture) SetPropertyContentFit(value ContentFit) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("content-fit", &v)
+}
+
+func (x *Picture) GetPropertyContentFit() ContentFit {
+	var v gobject.Value
+	x.GetProperty("content-fit", &v)
+	return ContentFit(v.GetEnum())
+}
+
+// The `GFile` that is displayed or %NULL if none.
+
+func (x *Picture) SetPropertyFile(value gio.File) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("file", &v)
+}
+
+func (x *Picture) GetPropertyFile() gio.File {
+	var v gobject.Value
+	x.GetProperty("file", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.FileBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the GtkPicture will render its contents trying to preserve the aspect
+// ratio.
+
+func (x *Picture) SetPropertyKeepAspectRatio(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("keep-aspect-ratio", &v)
+}
+
+func (x *Picture) GetPropertyKeepAspectRatio() bool {
+	var v gobject.Value
+	x.GetProperty("keep-aspect-ratio", &v)
+	return v.GetBoolean()
+}
+
+// The `GdkPaintable` to be displayed by this `GtkPicture`.
+
+func (x *Picture) SetPropertyPaintable(value gdk.Paintable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("paintable", &v)
+}
+
+func (x *Picture) GetPropertyPaintable() gdk.Paintable {
+	var v gobject.Value
+	x.GetProperty("paintable", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.PaintableBase{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Picture) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkpopover.go b/v4/gtk/gtkpopover.go
index 807d575a883876c6f9648df589c1a953387dea51..47917d5e3671733a7b161cb00ed995747b33f853 100644
--- a/v4/gtk/gtkpopover.go
+++ b/v4/gtk/gtkpopover.go
@@ -429,6 +429,140 @@ func (c *Popover) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to dismiss the popover on outside clicks.
+
+func (x *Popover) SetPropertyAutohide(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("autohide", &v)
+}
+
+func (x *Popover) GetPropertyAutohide() bool {
+	var v gobject.Value
+	x.GetProperty("autohide", &v)
+	return v.GetBoolean()
+}
+
+// Whether the popover pops down after a child popover.
+//
+// This is used to implement the expected behavior of submenus.
+
+func (x *Popover) SetPropertyCascadePopdown(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("cascade-popdown", &v)
+}
+
+func (x *Popover) GetPropertyCascadePopdown() bool {
+	var v gobject.Value
+	x.GetProperty("cascade-popdown", &v)
+	return v.GetBoolean()
+}
+
+// The child widget.
+
+func (x *Popover) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *Popover) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The default widget inside the popover.
+
+func (x *Popover) SetPropertyDefaultWidget(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("default-widget", &v)
+}
+
+func (x *Popover) GetPropertyDefaultWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("default-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to draw an arrow.
+
+func (x *Popover) SetPropertyHasArrow(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-arrow", &v)
+}
+
+func (x *Popover) GetPropertyHasArrow() bool {
+	var v gobject.Value
+	x.GetProperty("has-arrow", &v)
+	return v.GetBoolean()
+}
+
+// Whether mnemonics are currently visible in this popover.
+
+func (x *Popover) SetPropertyMnemonicsVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("mnemonics-visible", &v)
+}
+
+func (x *Popover) GetPropertyMnemonicsVisible() bool {
+	var v gobject.Value
+	x.GetProperty("mnemonics-visible", &v)
+	return v.GetBoolean()
+}
+
+// Rectangle in the parent widget that the popover points to.
+
+func (x *Popover) SetPropertyPointingTo(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("pointing-to", &v)
+}
+
+func (x *Popover) GetPropertyPointingTo() uintptr {
+	var v gobject.Value
+	x.GetProperty("pointing-to", &v)
+	return v.GetPointer()
+}
+
+// How to place the popover, relative to its parent.
+
+func (x *Popover) SetPropertyPosition(value PositionType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("position", &v)
+}
+
+func (x *Popover) GetPropertyPosition() PositionType {
+	var v gobject.Value
+	x.GetProperty("position", &v)
+	return PositionType(v.GetEnum())
+}
+
 // Emitted whend the user activates the default widget.
 //
 // This is a [keybinding signal](class.SignalAction.html).
diff --git a/v4/gtk/gtkpopovermenu.go b/v4/gtk/gtkpopovermenu.go
index 0d72d0257e332633cad15657970250366ce0e9e0..56d75cc0d12d775881d0d670c70c65382451a8f9 100644
--- a/v4/gtk/gtkpopovermenu.go
+++ b/v4/gtk/gtkpopovermenu.go
@@ -268,6 +268,42 @@ func (c *PopoverMenu) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The model from which the menu is made.
+
+func (x *PopoverMenu) SetPropertyMenuModel(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("menu-model", &v)
+}
+
+func (x *PopoverMenu) GetPropertyMenuModel() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("menu-model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the visible submenu.
+
+func (x *PopoverMenu) SetPropertyVisibleSubmenu(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("visible-submenu", &v)
+}
+
+func (x *PopoverMenu) GetPropertyVisibleSubmenu() string {
+	var v gobject.Value
+	x.GetProperty("visible-submenu", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *PopoverMenu) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkpopovermenubar.go b/v4/gtk/gtkpopovermenubar.go
index 3cd7ff10b2b55f1381115bfaf06661ceb8d62591..81cf0923c8f03d1e6d506f3d71138b7507381cfa 100644
--- a/v4/gtk/gtkpopovermenubar.go
+++ b/v4/gtk/gtkpopovermenubar.go
@@ -133,6 +133,29 @@ func (c *PopoverMenuBar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GMenuModel` from which the menu bar is created.
+//
+// The model should only contain submenus as toplevel elements.
+
+func (x *PopoverMenuBar) SetPropertyMenuModel(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("menu-model", &v)
+}
+
+func (x *PopoverMenuBar) GetPropertyMenuModel() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("menu-model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *PopoverMenuBar) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkprinter.go b/v4/gtk/gtkprinter.go
index 51160176f4ec44b9a5a1e22dd6f3b0e88ea03e47..498fd144b4b09bff0de13b884c167fcc82792ffc 100644
--- a/v4/gtk/gtkprinter.go
+++ b/v4/gtk/gtkprinter.go
@@ -374,6 +374,117 @@ func (c *Printer) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// %TRUE if the printer is accepting jobs.
+
+func (x *Printer) GetPropertyAcceptingJobs() bool {
+	var v gobject.Value
+	x.GetProperty("accepting-jobs", &v)
+	return v.GetBoolean()
+}
+
+// %TRUE if this printer can accept PDF.
+
+func (x *Printer) SetPropertyAcceptsPdf(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("accepts-pdf", &v)
+}
+
+func (x *Printer) GetPropertyAcceptsPdf() bool {
+	var v gobject.Value
+	x.GetProperty("accepts-pdf", &v)
+	return v.GetBoolean()
+}
+
+// %TRUE if this printer can accept PostScript.
+
+func (x *Printer) SetPropertyAcceptsPs(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("accepts-ps", &v)
+}
+
+func (x *Printer) GetPropertyAcceptsPs() bool {
+	var v gobject.Value
+	x.GetProperty("accepts-ps", &v)
+	return v.GetBoolean()
+}
+
+// Icon name to use for the printer.
+
+func (x *Printer) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// %FALSE if this represents a real hardware device.
+
+func (x *Printer) SetPropertyIsVirtual(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-virtual", &v)
+}
+
+func (x *Printer) GetPropertyIsVirtual() bool {
+	var v gobject.Value
+	x.GetProperty("is-virtual", &v)
+	return v.GetBoolean()
+}
+
+// Number of jobs queued in the printer.
+
+func (x *Printer) GetPropertyJobCount() int {
+	var v gobject.Value
+	x.GetProperty("job-count", &v)
+	return v.GetInt()
+}
+
+// Information about the location of the printer.
+
+func (x *Printer) GetPropertyLocation() string {
+	var v gobject.Value
+	x.GetProperty("location", &v)
+	return v.GetString()
+}
+
+// The name of the printer.
+
+func (x *Printer) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *Printer) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// %TRUE if this printer is paused.
+//
+// A paused printer still accepts jobs, but it does
+// not print them.
+
+func (x *Printer) GetPropertyPaused() bool {
+	var v gobject.Value
+	x.GetProperty("paused", &v)
+	return v.GetBoolean()
+}
+
+// String giving the current status of the printer.
+
+func (x *Printer) GetPropertyStateMessage() string {
+	var v gobject.Value
+	x.GetProperty("state-message", &v)
+	return v.GetString()
+}
+
 // Emitted in response to a request for detailed information
 // about a printer from the print backend.
 //
diff --git a/v4/gtk/gtkprintjob.go b/v4/gtk/gtkprintjob.go
index fc11e750c6174d1336ee8258685e8337a6d49437..7e3b27b400c195834f50bde53b430ed609f5cebe 100644
--- a/v4/gtk/gtkprintjob.go
+++ b/v4/gtk/gtkprintjob.go
@@ -399,6 +399,100 @@ func (c *PrintJob) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Page setup.
+
+func (x *PrintJob) SetPropertyPageSetup(value *PageSetup) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("page-setup", &v)
+}
+
+func (x *PrintJob) GetPropertyPageSetup() *PageSetup {
+	var v gobject.Value
+	x.GetProperty("page-setup", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &PageSetup{}
+	result.Ptr = ptr
+	return result
+}
+
+// The printer to send the job to.
+
+func (x *PrintJob) SetPropertyPrinter(value *Printer) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("printer", &v)
+}
+
+func (x *PrintJob) GetPropertyPrinter() *Printer {
+	var v gobject.Value
+	x.GetProperty("printer", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Printer{}
+	result.Ptr = ptr
+	return result
+}
+
+// Printer settings.
+
+func (x *PrintJob) SetPropertySettings(value *PrintSettings) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("settings", &v)
+}
+
+func (x *PrintJob) GetPropertySettings() *PrintSettings {
+	var v gobject.Value
+	x.GetProperty("settings", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &PrintSettings{}
+	result.Ptr = ptr
+	return result
+}
+
+// The title of the print job.
+
+func (x *PrintJob) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *PrintJob) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// %TRUE if the print job will continue to emit status-changed
+// signals after the print data has been setn to the printer.
+
+func (x *PrintJob) SetPropertyTrackPrintStatus(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("track-print-status", &v)
+}
+
+func (x *PrintJob) GetPropertyTrackPrintStatus() bool {
+	var v gobject.Value
+	x.GetProperty("track-print-status", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when the status of a job changes.
 //
 // The signal handler can use [method@Gtk.PrintJob.get_status]
diff --git a/v4/gtk/gtkprintoperation.go b/v4/gtk/gtkprintoperation.go
index 6976666c3efc869e7e18363d43a1199a7d92b711..fc74b9f420a1a0565c4937af8a55ec7317309a4d 100644
--- a/v4/gtk/gtkprintoperation.go
+++ b/v4/gtk/gtkprintoperation.go
@@ -1055,6 +1055,353 @@ func (c *PrintOperation) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Determines whether the print operation may run asynchronously or not.
+//
+// Some systems don't support asynchronous printing, but those that do
+// will return %GTK_PRINT_OPERATION_RESULT_IN_PROGRESS as the status, and
+// emit the [signal@Gtk.PrintOperation::done] signal when the operation
+// is actually done.
+//
+// The Windows port does not support asynchronous operation at all (this
+// is unlikely to change). On other platforms, all actions except for
+// %GTK_PRINT_OPERATION_ACTION_EXPORT support asynchronous operation.
+
+func (x *PrintOperation) SetPropertyAllowAsync(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-async", &v)
+}
+
+func (x *PrintOperation) GetPropertyAllowAsync() bool {
+	var v gobject.Value
+	x.GetProperty("allow-async", &v)
+	return v.GetBoolean()
+}
+
+// The current page in the document.
+//
+// If this is set before [method@Gtk.PrintOperation.run],
+// the user will be able to select to print only the current page.
+//
+// Note that this only makes sense for pre-paginated documents.
+
+func (x *PrintOperation) SetPropertyCurrentPage(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("current-page", &v)
+}
+
+func (x *PrintOperation) GetPropertyCurrentPage() int {
+	var v gobject.Value
+	x.GetProperty("current-page", &v)
+	return v.GetInt()
+}
+
+// Used as the label of the tab containing custom widgets.
+//
+// Note that this property may be ignored on some platforms.
+//
+// If this is %NULL, GTK uses a default label.
+
+func (x *PrintOperation) SetPropertyCustomTabLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("custom-tab-label", &v)
+}
+
+func (x *PrintOperation) GetPropertyCustomTabLabel() string {
+	var v gobject.Value
+	x.GetProperty("custom-tab-label", &v)
+	return v.GetString()
+}
+
+// The `GtkPageSetup` used by default.
+//
+// This page setup will be used by [method@Gtk.PrintOperation.run],
+// but it can be overridden on a per-page basis by connecting
+// to the [signal@Gtk.PrintOperation::request-page-setup] signal.
+
+func (x *PrintOperation) SetPropertyDefaultPageSetup(value *PageSetup) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("default-page-setup", &v)
+}
+
+func (x *PrintOperation) GetPropertyDefaultPageSetup() *PageSetup {
+	var v gobject.Value
+	x.GetProperty("default-page-setup", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &PageSetup{}
+	result.Ptr = ptr
+	return result
+}
+
+// If %TRUE, page size combo box and orientation combo box
+// are embedded into page setup page.
+
+func (x *PrintOperation) SetPropertyEmbedPageSetup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("embed-page-setup", &v)
+}
+
+func (x *PrintOperation) GetPropertyEmbedPageSetup() bool {
+	var v gobject.Value
+	x.GetProperty("embed-page-setup", &v)
+	return v.GetBoolean()
+}
+
+// The name of a file to generate instead of showing the print dialog.
+//
+// Currently, PDF is the only supported format.
+//
+// The intended use of this property is for implementing
+// âExport to PDFâ actions.
+//
+// âPrint to PDFâ support is independent of this and is done
+// by letting the user pick the âPrint to PDFâ item from the
+// list of printers in the print dialog.
+
+func (x *PrintOperation) SetPropertyExportFilename(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("export-filename", &v)
+}
+
+func (x *PrintOperation) GetPropertyExportFilename() string {
+	var v gobject.Value
+	x.GetProperty("export-filename", &v)
+	return v.GetString()
+}
+
+// Determines whether there is a selection in your application.
+//
+// This can allow your application to print the selection.
+// This is typically used to make a "Selection" button sensitive.
+
+func (x *PrintOperation) SetPropertyHasSelection(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-selection", &v)
+}
+
+func (x *PrintOperation) GetPropertyHasSelection() bool {
+	var v gobject.Value
+	x.GetProperty("has-selection", &v)
+	return v.GetBoolean()
+}
+
+// A string used to identify the job (e.g. in monitoring
+// applications like eggcups).
+//
+// If you don't set a job name, GTK picks a default one
+// by numbering successive print jobs.
+
+func (x *PrintOperation) SetPropertyJobName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("job-name", &v)
+}
+
+func (x *PrintOperation) GetPropertyJobName() string {
+	var v gobject.Value
+	x.GetProperty("job-name", &v)
+	return v.GetString()
+}
+
+// The number of pages in the document.
+//
+// This must be set to a positive number before the rendering
+// starts. It may be set in a [signal@Gtk.PrintOperation::begin-print]
+// signal handler.
+//
+// Note that the page numbers passed to the
+// [signal@Gtk.PrintOperation::request-page-setup] and
+// [signal@Gtk.PrintOperation::draw-page] signals are 0-based, i.e.
+// if the user chooses to print all pages, the last ::draw-page signal
+// will be for page @n_pages - 1.
+
+func (x *PrintOperation) SetPropertyNPages(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("n-pages", &v)
+}
+
+func (x *PrintOperation) GetPropertyNPages() int {
+	var v gobject.Value
+	x.GetProperty("n-pages", &v)
+	return v.GetInt()
+}
+
+// The number of pages that will be printed.
+//
+// Note that this value is set during print preparation phase
+// (%GTK_PRINT_STATUS_PREPARING), so this value should never be
+// get before the data generation phase (%GTK_PRINT_STATUS_GENERATING_DATA).
+// You can connect to the [signal@Gtk.PrintOperation::status-changed] signal
+// and call [method@Gtk.PrintOperation.get_n_pages_to_print] when
+// print status is %GTK_PRINT_STATUS_GENERATING_DATA.
+//
+// This is typically used to track the progress of print operation.
+
+func (x *PrintOperation) GetPropertyNPagesToPrint() int {
+	var v gobject.Value
+	x.GetProperty("n-pages-to-print", &v)
+	return v.GetInt()
+}
+
+// The `GtkPrintSettings` used for initializing the dialog.
+//
+// Setting this property is typically used to re-establish
+// print settings from a previous print operation, see
+// [method@Gtk.PrintOperation.run].
+
+func (x *PrintOperation) SetPropertyPrintSettings(value *PrintSettings) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("print-settings", &v)
+}
+
+func (x *PrintOperation) GetPropertyPrintSettings() *PrintSettings {
+	var v gobject.Value
+	x.GetProperty("print-settings", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &PrintSettings{}
+	result.Ptr = ptr
+	return result
+}
+
+// Determines whether to show a progress dialog during the
+// print operation.
+
+func (x *PrintOperation) SetPropertyShowProgress(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-progress", &v)
+}
+
+func (x *PrintOperation) GetPropertyShowProgress() bool {
+	var v gobject.Value
+	x.GetProperty("show-progress", &v)
+	return v.GetBoolean()
+}
+
+// The status of the print operation.
+
+func (x *PrintOperation) GetPropertyStatus() PrintStatus {
+	var v gobject.Value
+	x.GetProperty("status", &v)
+	return PrintStatus(v.GetEnum())
+}
+
+// A string representation of the status of the print operation.
+//
+// The string is translated and suitable for displaying the print
+// status e.g. in a `GtkStatusbar`.
+//
+// See the [property@Gtk.PrintOperation:status] property for a status
+// value that is suitable for programmatic use.
+
+func (x *PrintOperation) GetPropertyStatusString() string {
+	var v gobject.Value
+	x.GetProperty("status-string", &v)
+	return v.GetString()
+}
+
+// If %TRUE, the print operation will support print of selection.
+//
+// This allows the print dialog to show a "Selection" button.
+
+func (x *PrintOperation) SetPropertySupportSelection(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("support-selection", &v)
+}
+
+func (x *PrintOperation) GetPropertySupportSelection() bool {
+	var v gobject.Value
+	x.GetProperty("support-selection", &v)
+	return v.GetBoolean()
+}
+
+// If %TRUE, the print operation will try to continue report on
+// the status of the print job in the printer queues and printer.
+//
+// This can allow your application to show things like âout of paperâ
+// issues, and when the print job actually reaches the printer.
+// However, this is often implemented using polling, and should
+// not be enabled unless needed.
+
+func (x *PrintOperation) SetPropertyTrackPrintStatus(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("track-print-status", &v)
+}
+
+func (x *PrintOperation) GetPropertyTrackPrintStatus() bool {
+	var v gobject.Value
+	x.GetProperty("track-print-status", &v)
+	return v.GetBoolean()
+}
+
+// The transformation for the cairo context obtained from
+// `GtkPrintContext` is set up in such a way that distances
+// are measured in units of @unit.
+
+func (x *PrintOperation) SetPropertyUnit(value Unit) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("unit", &v)
+}
+
+func (x *PrintOperation) GetPropertyUnit() Unit {
+	var v gobject.Value
+	x.GetProperty("unit", &v)
+	return Unit(v.GetEnum())
+}
+
+// If %TRUE, the transformation for the cairo context obtained
+// from `GtkPrintContext` puts the origin at the top left corner
+// of the page.
+//
+// This may not be the top left corner of the sheet, depending on
+// page orientation and the number of pages per sheet. Otherwise,
+// the origin is at the top left corner of the imageable area (i.e.
+// inside the margins).
+
+func (x *PrintOperation) SetPropertyUseFullPage(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-full-page", &v)
+}
+
+func (x *PrintOperation) GetPropertyUseFullPage() bool {
+	var v gobject.Value
+	x.GetProperty("use-full-page", &v)
+	return v.GetBoolean()
+}
+
 // Emitted after the user has finished changing print settings
 // in the dialog, before the actual rendering starts.
 //
diff --git a/v4/gtk/gtkprintunixdialog.go b/v4/gtk/gtkprintunixdialog.go
index ffe5bfb9111701c386c399ffc81b572dd17b7f34..1f1b3917c4f99654ca64306bd8f546620b81b04c 100644
--- a/v4/gtk/gtkprintunixdialog.go
+++ b/v4/gtk/gtkprintunixdialog.go
@@ -305,6 +305,137 @@ func (c *PrintUnixDialog) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The current page in the document.
+
+func (x *PrintUnixDialog) SetPropertyCurrentPage(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("current-page", &v)
+}
+
+func (x *PrintUnixDialog) GetPropertyCurrentPage() int {
+	var v gobject.Value
+	x.GetProperty("current-page", &v)
+	return v.GetInt()
+}
+
+// %TRUE if the page setup controls are embedded.
+
+func (x *PrintUnixDialog) SetPropertyEmbedPageSetup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("embed-page-setup", &v)
+}
+
+func (x *PrintUnixDialog) GetPropertyEmbedPageSetup() bool {
+	var v gobject.Value
+	x.GetProperty("embed-page-setup", &v)
+	return v.GetBoolean()
+}
+
+// Whether the application has a selection.
+
+func (x *PrintUnixDialog) SetPropertyHasSelection(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-selection", &v)
+}
+
+func (x *PrintUnixDialog) GetPropertyHasSelection() bool {
+	var v gobject.Value
+	x.GetProperty("has-selection", &v)
+	return v.GetBoolean()
+}
+
+// Capabilities the application can handle.
+
+func (x *PrintUnixDialog) SetPropertyManualCapabilities(value PrintCapabilities) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("manual-capabilities", &v)
+}
+
+func (x *PrintUnixDialog) GetPropertyManualCapabilities() PrintCapabilities {
+	var v gobject.Value
+	x.GetProperty("manual-capabilities", &v)
+	return PrintCapabilities(v.GetFlags())
+}
+
+// The `GtkPageSetup` object to use.
+
+func (x *PrintUnixDialog) SetPropertyPageSetup(value *PageSetup) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("page-setup", &v)
+}
+
+func (x *PrintUnixDialog) GetPropertyPageSetup() *PageSetup {
+	var v gobject.Value
+	x.GetProperty("page-setup", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &PageSetup{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GtkPrintSettings` object used for this dialog.
+
+func (x *PrintUnixDialog) SetPropertyPrintSettings(value *PrintSettings) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("print-settings", &v)
+}
+
+func (x *PrintUnixDialog) GetPropertyPrintSettings() *PrintSettings {
+	var v gobject.Value
+	x.GetProperty("print-settings", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &PrintSettings{}
+	result.Ptr = ptr
+	return result
+}
+
+// The `GtkPrinter` which is selected.
+
+func (x *PrintUnixDialog) GetPropertySelectedPrinter() *Printer {
+	var v gobject.Value
+	x.GetProperty("selected-printer", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Printer{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the dialog supports selection.
+
+func (x *PrintUnixDialog) SetPropertySupportSelection(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("support-selection", &v)
+}
+
+func (x *PrintUnixDialog) GetPropertySupportSelection() bool {
+	var v gobject.Value
+	x.GetProperty("support-selection", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *PrintUnixDialog) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkprogressbar.go b/v4/gtk/gtkprogressbar.go
index 9e949ec636f5faef6a16e36d7af157cfd3f8a063..76d05a5acfd6d7158dccb646a2e16ed3e8fb888f 100644
--- a/v4/gtk/gtkprogressbar.go
+++ b/v4/gtk/gtkprogressbar.go
@@ -263,6 +263,113 @@ func (c *ProgressBar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The preferred place to ellipsize the string.
+//
+// The text will be ellipsized if the progress bar does not have enough room
+// to display the entire string, specified as a `PangoEllipsizeMode`.
+//
+// Note that setting this property to a value other than
+// %PANGO_ELLIPSIZE_NONE has the side-effect that the progress bar requests
+// only enough space to display the ellipsis ("..."). Another means to set a
+// progress bar's width is [method@Gtk.Widget.set_size_request].
+
+func (x *ProgressBar) SetPropertyEllipsize(value pango.EllipsizeMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("ellipsize", &v)
+}
+
+func (x *ProgressBar) GetPropertyEllipsize() pango.EllipsizeMode {
+	var v gobject.Value
+	x.GetProperty("ellipsize", &v)
+	return pango.EllipsizeMode(v.GetEnum())
+}
+
+// The fraction of total work that has been completed.
+
+func (x *ProgressBar) SetPropertyFraction(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("fraction", &v)
+}
+
+func (x *ProgressBar) GetPropertyFraction() float64 {
+	var v gobject.Value
+	x.GetProperty("fraction", &v)
+	return v.GetDouble()
+}
+
+// Invert the direction in which the progress bar grows.
+
+func (x *ProgressBar) SetPropertyInverted(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("inverted", &v)
+}
+
+func (x *ProgressBar) GetPropertyInverted() bool {
+	var v gobject.Value
+	x.GetProperty("inverted", &v)
+	return v.GetBoolean()
+}
+
+// The fraction of total progress to move the bounding block when pulsed.
+
+func (x *ProgressBar) SetPropertyPulseStep(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("pulse-step", &v)
+}
+
+func (x *ProgressBar) GetPropertyPulseStep() float64 {
+	var v gobject.Value
+	x.GetProperty("pulse-step", &v)
+	return v.GetDouble()
+}
+
+// Sets whether the progress bar will show a text in addition
+// to the bar itself.
+//
+// The shown text is either the value of the [property@Gtk.ProgressBar:text]
+// property or, if that is %NULL, the [property@Gtk.ProgressBar:fraction]
+// value, as a percentage.
+//
+// To make a progress bar that is styled and sized suitably for showing text
+// (even if the actual text is blank), set [property@Gtk.ProgressBar:show-text]
+// to %TRUE and [property@Gtk.ProgressBar:text] to the empty string (not %NULL).
+
+func (x *ProgressBar) SetPropertyShowText(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-text", &v)
+}
+
+func (x *ProgressBar) GetPropertyShowText() bool {
+	var v gobject.Value
+	x.GetProperty("show-text", &v)
+	return v.GetBoolean()
+}
+
+// Text to be displayed in the progress bar.
+
+func (x *ProgressBar) SetPropertyText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("text", &v)
+}
+
+func (x *ProgressBar) GetPropertyText() string {
+	var v gobject.Value
+	x.GetProperty("text", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ProgressBar) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkrange.go b/v4/gtk/gtkrange.go
index 9a6afd042b80e8c61d4e046ca7619784185b5515..11f19093cd50306fee473e6c057a7724bda02354 100644
--- a/v4/gtk/gtkrange.go
+++ b/v4/gtk/gtkrange.go
@@ -465,6 +465,107 @@ func (c *Range) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The adjustment that is controlled by the range.
+
+func (x *Range) SetPropertyAdjustment(value *Adjustment) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("adjustment", &v)
+}
+
+func (x *Range) GetPropertyAdjustment() *Adjustment {
+	var v gobject.Value
+	x.GetProperty("adjustment", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Adjustment{}
+	result.Ptr = ptr
+	return result
+}
+
+// The fill level (e.g. prebuffering of a network stream).
+
+func (x *Range) SetPropertyFillLevel(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("fill-level", &v)
+}
+
+func (x *Range) GetPropertyFillLevel() float64 {
+	var v gobject.Value
+	x.GetProperty("fill-level", &v)
+	return v.GetDouble()
+}
+
+// If %TRUE, the direction in which the slider moves is inverted.
+
+func (x *Range) SetPropertyInverted(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("inverted", &v)
+}
+
+func (x *Range) GetPropertyInverted() bool {
+	var v gobject.Value
+	x.GetProperty("inverted", &v)
+	return v.GetBoolean()
+}
+
+// Controls whether slider movement is restricted to an
+// upper boundary set by the fill level.
+
+func (x *Range) SetPropertyRestrictToFillLevel(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("restrict-to-fill-level", &v)
+}
+
+func (x *Range) GetPropertyRestrictToFillLevel() bool {
+	var v gobject.Value
+	x.GetProperty("restrict-to-fill-level", &v)
+	return v.GetBoolean()
+}
+
+// The number of digits to round the value to when
+// it changes.
+//
+// See [signal@Gtk.Range::change-value].
+
+func (x *Range) SetPropertyRoundDigits(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("round-digits", &v)
+}
+
+func (x *Range) GetPropertyRoundDigits() int {
+	var v gobject.Value
+	x.GetProperty("round-digits", &v)
+	return v.GetInt()
+}
+
+// Controls whether fill level indicator graphics are displayed
+// on the trough.
+
+func (x *Range) SetPropertyShowFillLevel(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-fill-level", &v)
+}
+
+func (x *Range) GetPropertyShowFillLevel() bool {
+	var v gobject.Value
+	x.GetProperty("show-fill-level", &v)
+	return v.GetBoolean()
+}
+
 // Emitted before clamping a value, to give the application a
 // chance to adjust the bounds.
 func (x *Range) ConnectAdjustBounds(cb *func(Range, float64)) uint32 {
diff --git a/v4/gtk/gtkrecentmanager.go b/v4/gtk/gtkrecentmanager.go
index 04976d3e2f1bcfea7cc22d84dae6154c13ed179b..f428b8490ce9f50834f7ab98e234e0c919f810ab 100644
--- a/v4/gtk/gtkrecentmanager.go
+++ b/v4/gtk/gtkrecentmanager.go
@@ -738,6 +738,30 @@ func (c *RecentManager) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The full path to the file to be used to store and read the
+// recently used resources list
+
+func (x *RecentManager) SetPropertyFilename(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("filename", &v)
+}
+
+func (x *RecentManager) GetPropertyFilename() string {
+	var v gobject.Value
+	x.GetProperty("filename", &v)
+	return v.GetString()
+}
+
+// The size of the recently used resources list.
+
+func (x *RecentManager) GetPropertySize() int {
+	var v gobject.Value
+	x.GetProperty("size", &v)
+	return v.GetInt()
+}
+
 // Emitted when the current recently used resources manager changes
 // its contents.
 //
diff --git a/v4/gtk/gtkrevealer.go b/v4/gtk/gtkrevealer.go
index 8eb0d16614ecb6a534418075eecc646339735576..1f9a3755c6053983baa35da4956130d8f2a1e5d2 100644
--- a/v4/gtk/gtkrevealer.go
+++ b/v4/gtk/gtkrevealer.go
@@ -212,6 +212,80 @@ func (c *Revealer) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *Revealer) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *Revealer) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the child is revealed and the animation target reached.
+
+func (x *Revealer) GetPropertyChildRevealed() bool {
+	var v gobject.Value
+	x.GetProperty("child-revealed", &v)
+	return v.GetBoolean()
+}
+
+// Whether the revealer should reveal the child.
+
+func (x *Revealer) SetPropertyRevealChild(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reveal-child", &v)
+}
+
+func (x *Revealer) GetPropertyRevealChild() bool {
+	var v gobject.Value
+	x.GetProperty("reveal-child", &v)
+	return v.GetBoolean()
+}
+
+// The animation duration, in milliseconds.
+
+func (x *Revealer) SetPropertyTransitionDuration(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("transition-duration", &v)
+}
+
+func (x *Revealer) GetPropertyTransitionDuration() uint {
+	var v gobject.Value
+	x.GetProperty("transition-duration", &v)
+	return v.GetUint()
+}
+
+// The type of animation used to transition.
+
+func (x *Revealer) SetPropertyTransitionType(value RevealerTransitionType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("transition-type", &v)
+}
+
+func (x *Revealer) GetPropertyTransitionType() RevealerTransitionType {
+	var v gobject.Value
+	x.GetProperty("transition-type", &v)
+	return RevealerTransitionType(v.GetEnum())
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Revealer) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkscale.go b/v4/gtk/gtkscale.go
index 0c8579097d4cbd65c03c08bae1cb1c55909bffb9..625fdd9bbf23bc26655f5ee656959edf2f2da7b7 100644
--- a/v4/gtk/gtkscale.go
+++ b/v4/gtk/gtkscale.go
@@ -372,6 +372,66 @@ func (c *Scale) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The number of decimal places that are displayed in the value.
+
+func (x *Scale) SetPropertyDigits(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("digits", &v)
+}
+
+func (x *Scale) GetPropertyDigits() int {
+	var v gobject.Value
+	x.GetProperty("digits", &v)
+	return v.GetInt()
+}
+
+// Whether the current value is displayed as a string next to the slider.
+
+func (x *Scale) SetPropertyDrawValue(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("draw-value", &v)
+}
+
+func (x *Scale) GetPropertyDrawValue() bool {
+	var v gobject.Value
+	x.GetProperty("draw-value", &v)
+	return v.GetBoolean()
+}
+
+// Whether the scale has an origin.
+
+func (x *Scale) SetPropertyHasOrigin(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-origin", &v)
+}
+
+func (x *Scale) GetPropertyHasOrigin() bool {
+	var v gobject.Value
+	x.GetProperty("has-origin", &v)
+	return v.GetBoolean()
+}
+
+// The position in which the current value is displayed.
+
+func (x *Scale) SetPropertyValuePos(value PositionType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("value-pos", &v)
+}
+
+func (x *Scale) GetPropertyValuePos() PositionType {
+	var v gobject.Value
+	x.GetProperty("value-pos", &v)
+	return PositionType(v.GetEnum())
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Scale) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkscalebutton.go b/v4/gtk/gtkscalebutton.go
index c5037a6f3140aca90226aaf0db567f23931ca11c..2b70a3d5c24d467c210e61e5d8bb553adadf087a 100644
--- a/v4/gtk/gtkscalebutton.go
+++ b/v4/gtk/gtkscalebutton.go
@@ -221,6 +221,69 @@ func (c *ScaleButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GtkAdjustment` that is used as the model.
+
+func (x *ScaleButton) SetPropertyAdjustment(value *Adjustment) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("adjustment", &v)
+}
+
+func (x *ScaleButton) GetPropertyAdjustment() *Adjustment {
+	var v gobject.Value
+	x.GetProperty("adjustment", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Adjustment{}
+	result.Ptr = ptr
+	return result
+}
+
+// The names of the icons to be used by the scale button.
+//
+// The first item in the array will be used in the button
+// when the current value is the lowest value, the second
+// item for the highest value. All the subsequent icons will
+// be used for all the other values, spread evenly over the
+// range of values.
+//
+// If there's only one icon name in the @icons array, it will
+// be used for all the values. If only two icon names are in
+// the @icons array, the first one will be used for the bottom
+// 50% of the scale, and the second one for the top 50%.
+//
+// It is recommended to use at least 3 icons so that the
+// `GtkScaleButton` reflects the current value of the scale
+// better for the users.
+
+func (x *ScaleButton) SetPropertyIcons(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *ScaleButton) GetPropertyIcons() []string {
+	var v gobject.Value
+	x.GetProperty("icons", &v)
+	return nil
+}
+
+// The value of the scale.
+
+func (x *ScaleButton) SetPropertyValue(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("value", &v)
+}
+
+func (x *ScaleButton) GetPropertyValue() float64 {
+	var v gobject.Value
+	x.GetProperty("value", &v)
+	return v.GetDouble()
+}
+
 // Emitted to dismiss the popup.
 //
 // This is a [keybinding signal](class.SignalAction.html).
diff --git a/v4/gtk/gtkscrollable.go b/v4/gtk/gtkscrollable.go
index fd7def4b60cb5ef70bcb8fcb634ccc4087822296..0da143b569771c661a200460b93c933b72740338 100644
--- a/v4/gtk/gtkscrollable.go
+++ b/v4/gtk/gtkscrollable.go
@@ -199,6 +199,90 @@ 	XGtkScrollableSetVscrollPolicy(x.GoPointer(), PolicyVar)
 
 }
 
+// Horizontal `GtkAdjustment` of the scrollable widget.
+//
+// This adjustment is shared between the scrollable widget and its parent.
+
+func (x *ScrollableBase) SetPropertyHadjustment(value *Adjustment) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("hadjustment", &v)
+}
+
+func (x *ScrollableBase) GetPropertyHadjustment() *Adjustment {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("hadjustment", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Adjustment{}
+	result.Ptr = ptr
+	return result
+}
+
+// Determines when horizontal scrolling should start.
+
+func (x *ScrollableBase) SetPropertyHscrollPolicy(value ScrollablePolicy) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("hscroll-policy", &v)
+}
+
+func (x *ScrollableBase) GetPropertyHscrollPolicy() ScrollablePolicy {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("hscroll-policy", &v)
+	return ScrollablePolicy(v.GetEnum())
+}
+
+// Vertical `GtkAdjustment` of the scrollable widget.
+//
+// This adjustment is shared between the scrollable widget and its parent.
+
+func (x *ScrollableBase) SetPropertyVadjustment(value *Adjustment) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("vadjustment", &v)
+}
+
+func (x *ScrollableBase) GetPropertyVadjustment() *Adjustment {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("vadjustment", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Adjustment{}
+	result.Ptr = ptr
+	return result
+}
+
+// Determines when vertical scrolling should start.
+
+func (x *ScrollableBase) SetPropertyVscrollPolicy(value ScrollablePolicy) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.SetProperty("vscroll-policy", &v)
+}
+
+func (x *ScrollableBase) GetPropertyVscrollPolicy() ScrollablePolicy {
+	var v gobject.Value
+	obj := gobject.Object{Ptr: x.GoPointer()}
+	obj.GetProperty("vscroll-policy", &v)
+	return ScrollablePolicy(v.GetEnum())
+}
+
 var XGtkScrollableGetBorder func(uintptr, *Border) bool
 var XGtkScrollableGetHadjustment func(uintptr) uintptr
 var XGtkScrollableGetHscrollPolicy func(uintptr) ScrollablePolicy
diff --git a/v4/gtk/gtkscrollbar.go b/v4/gtk/gtkscrollbar.go
index 8315a4562f15b30a3a6d0fe51f26bb2fedbd6e04..c7855f3743de328915f0428a8eb6fc5d8a2169bb 100644
--- a/v4/gtk/gtkscrollbar.go
+++ b/v4/gtk/gtkscrollbar.go
@@ -122,6 +122,27 @@ func (c *Scrollbar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GtkAdjustment` controlled by this scrollbar.
+
+func (x *Scrollbar) SetPropertyAdjustment(value *Adjustment) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("adjustment", &v)
+}
+
+func (x *Scrollbar) GetPropertyAdjustment() *Adjustment {
+	var v gobject.Value
+	x.GetProperty("adjustment", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Adjustment{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Scrollbar) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkscrolledwindow.go b/v4/gtk/gtkscrolledwindow.go
index af9093eba1fbe260581e7e2cebcfe02a0e34db86..330ba756a3f97fc5b5d58658f7855a9545d22b7a 100644
--- a/v4/gtk/gtkscrolledwindow.go
+++ b/v4/gtk/gtkscrolledwindow.go
@@ -573,6 +573,268 @@ func (c *ScrolledWindow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *ScrolledWindow) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *ScrolledWindow) SetPropertyHadjustment(value *Adjustment) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("hadjustment", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyHadjustment() *Adjustment {
+	var v gobject.Value
+	x.GetProperty("hadjustment", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Adjustment{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to draw a frame around the contents.
+
+func (x *ScrolledWindow) SetPropertyHasFrame(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-frame", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyHasFrame() bool {
+	var v gobject.Value
+	x.GetProperty("has-frame", &v)
+	return v.GetBoolean()
+}
+
+// When the horizontal scrollbar is displayed.
+//
+// Use [method@Gtk.ScrolledWindow.set_policy] to set
+// this property.
+
+func (x *ScrolledWindow) SetPropertyHscrollbarPolicy(value PolicyType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("hscrollbar-policy", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyHscrollbarPolicy() PolicyType {
+	var v gobject.Value
+	x.GetProperty("hscrollbar-policy", &v)
+	return PolicyType(v.GetEnum())
+}
+
+// Whether kinetic scrolling is enabled or not.
+//
+// Kinetic scrolling only applies to devices with source %GDK_SOURCE_TOUCHSCREEN.
+
+func (x *ScrolledWindow) SetPropertyKineticScrolling(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("kinetic-scrolling", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyKineticScrolling() bool {
+	var v gobject.Value
+	x.GetProperty("kinetic-scrolling", &v)
+	return v.GetBoolean()
+}
+
+// The maximum content height of @scrolled_window.
+
+func (x *ScrolledWindow) SetPropertyMaxContentHeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-content-height", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyMaxContentHeight() int {
+	var v gobject.Value
+	x.GetProperty("max-content-height", &v)
+	return v.GetInt()
+}
+
+// The maximum content width of @scrolled_window.
+
+func (x *ScrolledWindow) SetPropertyMaxContentWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-content-width", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyMaxContentWidth() int {
+	var v gobject.Value
+	x.GetProperty("max-content-width", &v)
+	return v.GetInt()
+}
+
+// The minimum content height of @scrolled_window.
+
+func (x *ScrolledWindow) SetPropertyMinContentHeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("min-content-height", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyMinContentHeight() int {
+	var v gobject.Value
+	x.GetProperty("min-content-height", &v)
+	return v.GetInt()
+}
+
+// The minimum content width of @scrolled_window.
+
+func (x *ScrolledWindow) SetPropertyMinContentWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("min-content-width", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyMinContentWidth() int {
+	var v gobject.Value
+	x.GetProperty("min-content-width", &v)
+	return v.GetInt()
+}
+
+// Whether overlay scrolling is enabled or not.
+//
+// If it is, the scrollbars are only added as traditional widgets
+// when a mouse is present. Otherwise, they are overlaid on top of
+// the content, as narrow indicators.
+//
+// Note that overlay scrolling can also be globally disabled, with
+// the [property@Gtk.Settings:gtk-overlay-scrolling] setting.
+
+func (x *ScrolledWindow) SetPropertyOverlayScrolling(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("overlay-scrolling", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyOverlayScrolling() bool {
+	var v gobject.Value
+	x.GetProperty("overlay-scrolling", &v)
+	return v.GetBoolean()
+}
+
+// Whether the natural height of the child should be calculated and propagated
+// through the scrolled windowâs requested natural height.
+//
+// This is useful in cases where an attempt should be made to allocate exactly
+// enough space for the natural size of the child.
+
+func (x *ScrolledWindow) SetPropertyPropagateNaturalHeight(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("propagate-natural-height", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyPropagateNaturalHeight() bool {
+	var v gobject.Value
+	x.GetProperty("propagate-natural-height", &v)
+	return v.GetBoolean()
+}
+
+// Whether the natural width of the child should be calculated and propagated
+// through the scrolled windowâs requested natural width.
+//
+// This is useful in cases where an attempt should be made to allocate exactly
+// enough space for the natural size of the child.
+
+func (x *ScrolledWindow) SetPropertyPropagateNaturalWidth(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("propagate-natural-width", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyPropagateNaturalWidth() bool {
+	var v gobject.Value
+	x.GetProperty("propagate-natural-width", &v)
+	return v.GetBoolean()
+}
+
+func (x *ScrolledWindow) SetPropertyVadjustment(value *Adjustment) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("vadjustment", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyVadjustment() *Adjustment {
+	var v gobject.Value
+	x.GetProperty("vadjustment", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Adjustment{}
+	result.Ptr = ptr
+	return result
+}
+
+// When the vertical scrollbar is displayed.
+//
+// Use [method@Gtk.ScrolledWindow.set_policy] to set
+// this property.
+
+func (x *ScrolledWindow) SetPropertyVscrollbarPolicy(value PolicyType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("vscrollbar-policy", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyVscrollbarPolicy() PolicyType {
+	var v gobject.Value
+	x.GetProperty("vscrollbar-policy", &v)
+	return PolicyType(v.GetEnum())
+}
+
+// Where the contents are located with respect to the scrollbars.
+
+func (x *ScrolledWindow) SetPropertyWindowPlacement(value CornerType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("window-placement", &v)
+}
+
+func (x *ScrolledWindow) GetPropertyWindowPlacement() CornerType {
+	var v gobject.Value
+	x.GetProperty("window-placement", &v)
+	return CornerType(v.GetEnum())
+}
+
 // Emitted whenever user initiated scrolling makes the scrolled
 // window firmly surpass the limits defined by the adjustment
 // in that orientation.
diff --git a/v4/gtk/gtksearchbar.go b/v4/gtk/gtksearchbar.go
index b7e7947f677018ddb02028f2b275a3eb3d8b3d15..f854111c850b4eec9eceada4c93ba3ae0e3a95f7 100644
--- a/v4/gtk/gtksearchbar.go
+++ b/v4/gtk/gtksearchbar.go
@@ -218,6 +218,78 @@ func (c *SearchBar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *SearchBar) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *SearchBar) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The key capture widget.
+
+func (x *SearchBar) SetPropertyKeyCaptureWidget(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("key-capture-widget", &v)
+}
+
+func (x *SearchBar) GetPropertyKeyCaptureWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("key-capture-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the search mode is on and the search bar shown.
+
+func (x *SearchBar) SetPropertySearchModeEnabled(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("search-mode-enabled", &v)
+}
+
+func (x *SearchBar) GetPropertySearchModeEnabled() bool {
+	var v gobject.Value
+	x.GetProperty("search-mode-enabled", &v)
+	return v.GetBoolean()
+}
+
+// Whether to show the close button in the search bar.
+
+func (x *SearchBar) SetPropertyShowCloseButton(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-close-button", &v)
+}
+
+func (x *SearchBar) GetPropertyShowCloseButton() bool {
+	var v gobject.Value
+	x.GetProperty("show-close-button", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *SearchBar) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtksearchentry.go b/v4/gtk/gtksearchentry.go
index 7d66eec3c0368e8037ffea4ed5e96715a60febf8..8b050fa6fcd8171400cf846274be9f248ad0d90b 100644
--- a/v4/gtk/gtksearchentry.go
+++ b/v4/gtk/gtksearchentry.go
@@ -161,6 +161,53 @@ func (c *SearchEntry) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to activate the default widget when Enter is pressed.
+
+func (x *SearchEntry) SetPropertyActivatesDefault(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activates-default", &v)
+}
+
+func (x *SearchEntry) GetPropertyActivatesDefault() bool {
+	var v gobject.Value
+	x.GetProperty("activates-default", &v)
+	return v.GetBoolean()
+}
+
+// The text that will be displayed in the `GtkSearchEntry`
+// when it is empty and unfocused.
+
+func (x *SearchEntry) SetPropertyPlaceholderText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("placeholder-text", &v)
+}
+
+func (x *SearchEntry) GetPropertyPlaceholderText() string {
+	var v gobject.Value
+	x.GetProperty("placeholder-text", &v)
+	return v.GetString()
+}
+
+// The delay in milliseconds from last keypress to the search
+// changed signal.
+
+func (x *SearchEntry) SetPropertySearchDelay(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("search-delay", &v)
+}
+
+func (x *SearchEntry) GetPropertySearchDelay() uint {
+	var v gobject.Value
+	x.GetProperty("search-delay", &v)
+	return v.GetUint()
+}
+
 // Emitted when the entry is activated.
 //
 // The keybindings for this signal are all forms of the Enter key.
diff --git a/v4/gtk/gtkselectionfiltermodel.go b/v4/gtk/gtkselectionfiltermodel.go
index 220ec58f8c1ff1b8b0843dcb550a1c0300b2a8ab..1c02821054237a8178ae22478449a52349523e25 100644
--- a/v4/gtk/gtkselectionfiltermodel.go
+++ b/v4/gtk/gtkselectionfiltermodel.go
@@ -99,6 +99,43 @@ func (c *SelectionFilterModel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *SelectionFilterModel) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The model being filtered.
+
+func (x *SelectionFilterModel) SetPropertyModel(value SelectionModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *SelectionFilterModel) GetPropertyModel() SelectionModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SelectionModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *SelectionFilterModel) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtksettings.go b/v4/gtk/gtksettings.go
index 6276c20d773bc4dab0777bb1cb25a7c7bfbec724..000457e31e5f634d3b5f27118af814183da7d5ce 100644
--- a/v4/gtk/gtksettings.go
+++ b/v4/gtk/gtksettings.go
@@ -75,6 +75,922 @@ func (c *Settings) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether buttons in dialogs should use the alternative button order.
+
+func (x *Settings) SetPropertyGtkAlternativeButtonOrder(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-alternative-button-order", &v)
+}
+
+func (x *Settings) GetPropertyGtkAlternativeButtonOrder() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-alternative-button-order", &v)
+	return v.GetBoolean()
+}
+
+// Controls the direction of the sort indicators in sorted list and tree
+// views.
+//
+// By default an arrow pointing down means the column is sorted
+// in ascending order. When set to %TRUE, this order will be inverted.
+
+func (x *Settings) SetPropertyGtkAlternativeSortArrows(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-alternative-sort-arrows", &v)
+}
+
+func (x *Settings) GetPropertyGtkAlternativeSortArrows() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-alternative-sort-arrows", &v)
+	return v.GetBoolean()
+}
+
+// Whether the application prefers to use a dark theme.
+//
+// If a GTK theme includes a dark variant, it will be used
+// instead of the configured theme.
+//
+// Some applications benefit from minimizing the amount of light
+// pollution that interferes with the content. Good candidates for
+// dark themes are photo and video editors that make the actual
+// content get all the attention and minimize the distraction of
+// the chrome.
+//
+// Dark themes should not be used for documents, where large spaces
+// are white/light and the dark chrome creates too much contrast
+// (web browser, text editor...).
+
+func (x *Settings) SetPropertyGtkApplicationPreferDarkTheme(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-application-prefer-dark-theme", &v)
+}
+
+func (x *Settings) GetPropertyGtkApplicationPreferDarkTheme() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-application-prefer-dark-theme", &v)
+	return v.GetBoolean()
+}
+
+// The aspect ratio of the text caret.
+
+func (x *Settings) SetPropertyGtkCursorAspectRatio(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("gtk-cursor-aspect-ratio", &v)
+}
+
+func (x *Settings) GetPropertyGtkCursorAspectRatio() float64 {
+	var v gobject.Value
+	x.GetProperty("gtk-cursor-aspect-ratio", &v)
+	return v.GetDouble()
+}
+
+// Whether the cursor should blink.
+//
+// Also see the [property@Gtk.Settings:gtk-cursor-blink-timeout] setting,
+// which allows more flexible control over cursor blinking.
+
+func (x *Settings) SetPropertyGtkCursorBlink(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-cursor-blink", &v)
+}
+
+func (x *Settings) GetPropertyGtkCursorBlink() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-cursor-blink", &v)
+	return v.GetBoolean()
+}
+
+// Length of the cursor blink cycle, in milliseconds.
+
+func (x *Settings) SetPropertyGtkCursorBlinkTime(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("gtk-cursor-blink-time", &v)
+}
+
+func (x *Settings) GetPropertyGtkCursorBlinkTime() int {
+	var v gobject.Value
+	x.GetProperty("gtk-cursor-blink-time", &v)
+	return v.GetInt()
+}
+
+// Time after which the cursor stops blinking, in seconds.
+//
+// The timer is reset after each user interaction.
+//
+// Setting this to zero has the same effect as setting
+// [property@Gtk.Settings:gtk-cursor-blink] to %FALSE.
+
+func (x *Settings) SetPropertyGtkCursorBlinkTimeout(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("gtk-cursor-blink-timeout", &v)
+}
+
+func (x *Settings) GetPropertyGtkCursorBlinkTimeout() int {
+	var v gobject.Value
+	x.GetProperty("gtk-cursor-blink-timeout", &v)
+	return v.GetInt()
+}
+
+// Name of the cursor theme to use.
+//
+// Use %NULL to use the default theme.
+
+func (x *Settings) SetPropertyGtkCursorThemeName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-cursor-theme-name", &v)
+}
+
+func (x *Settings) GetPropertyGtkCursorThemeName() string {
+	var v gobject.Value
+	x.GetProperty("gtk-cursor-theme-name", &v)
+	return v.GetString()
+}
+
+// The size to use for cursors.
+//
+// 0 means to use the default size.
+
+func (x *Settings) SetPropertyGtkCursorThemeSize(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("gtk-cursor-theme-size", &v)
+}
+
+func (x *Settings) GetPropertyGtkCursorThemeSize() int {
+	var v gobject.Value
+	x.GetProperty("gtk-cursor-theme-size", &v)
+	return v.GetInt()
+}
+
+// Determines which buttons should be put in the
+// titlebar of client-side decorated windows, and whether they
+// should be placed on the left or right.
+//
+// The format of the string is button names, separated by commas.
+// A colon separates the buttons that should appear on the left
+// from those on the right. Recognized button names are minimize,
+// maximize, close, icon (the window icon) and menu (a menu button
+// for the fallback app menu).
+//
+// For example, "menu:minimize,maximize,close" specifies a menu
+// on the left, and minimize, maximize and close buttons on the right.
+//
+// Note that buttons will only be shown when they are meaningful.
+// E.g. a menu button only appears when the desktop shell does not
+// show the app menu, and a close button only appears on a window
+// that can be closed.
+//
+// Also note that the setting can be overridden with the
+// [property@Gtk.HeaderBar:decoration-layout] property.
+
+func (x *Settings) SetPropertyGtkDecorationLayout(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-decoration-layout", &v)
+}
+
+func (x *Settings) GetPropertyGtkDecorationLayout() string {
+	var v gobject.Value
+	x.GetProperty("gtk-decoration-layout", &v)
+	return v.GetString()
+}
+
+// Whether builtin GTK dialogs such as the file chooser, the
+// color chooser or the font chooser will use a header bar at
+// the top to show action widgets, or an action area at the bottom.
+//
+// This setting does not affect custom dialogs using `GtkDialog`
+// directly, or message dialogs.
+
+func (x *Settings) SetPropertyGtkDialogsUseHeader(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-dialogs-use-header", &v)
+}
+
+func (x *Settings) GetPropertyGtkDialogsUseHeader() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-dialogs-use-header", &v)
+	return v.GetBoolean()
+}
+
+// The number of pixels the cursor can move before dragging.
+
+func (x *Settings) SetPropertyGtkDndDragThreshold(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("gtk-dnd-drag-threshold", &v)
+}
+
+func (x *Settings) GetPropertyGtkDndDragThreshold() int {
+	var v gobject.Value
+	x.GetProperty("gtk-dnd-drag-threshold", &v)
+	return v.GetInt()
+}
+
+// The maximum distance allowed between two clicks for them to be considered
+// a double click, in pixels.
+
+func (x *Settings) SetPropertyGtkDoubleClickDistance(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("gtk-double-click-distance", &v)
+}
+
+func (x *Settings) GetPropertyGtkDoubleClickDistance() int {
+	var v gobject.Value
+	x.GetProperty("gtk-double-click-distance", &v)
+	return v.GetInt()
+}
+
+// The maximum time to allow between two clicks for them to be considered
+// a double click, in milliseconds.
+
+func (x *Settings) SetPropertyGtkDoubleClickTime(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("gtk-double-click-time", &v)
+}
+
+func (x *Settings) GetPropertyGtkDoubleClickTime() int {
+	var v gobject.Value
+	x.GetProperty("gtk-double-click-time", &v)
+	return v.GetInt()
+}
+
+// Whether menu items should have visible accelerators which can be
+// activated.
+
+func (x *Settings) SetPropertyGtkEnableAccels(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-enable-accels", &v)
+}
+
+func (x *Settings) GetPropertyGtkEnableAccels() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-enable-accels", &v)
+	return v.GetBoolean()
+}
+
+// Whether to enable toolkit-wide animations.
+
+func (x *Settings) SetPropertyGtkEnableAnimations(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-enable-animations", &v)
+}
+
+func (x *Settings) GetPropertyGtkEnableAnimations() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-enable-animations", &v)
+	return v.GetBoolean()
+}
+
+// Whether to play any event sounds at all.
+//
+// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
+// for more information on event sounds and sound themes.
+//
+// GTK itself does not support event sounds, you have to use a loadable
+// module like the one that comes with libcanberra.
+
+func (x *Settings) SetPropertyGtkEnableEventSounds(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-enable-event-sounds", &v)
+}
+
+func (x *Settings) GetPropertyGtkEnableEventSounds() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-enable-event-sounds", &v)
+	return v.GetBoolean()
+}
+
+// Whether to play event sounds as feedback to user input.
+//
+// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
+// for more information on event sounds and sound themes.
+//
+// GTK itself does not support event sounds, you have to use a loadable
+// module like the one that comes with libcanberra.
+
+func (x *Settings) SetPropertyGtkEnableInputFeedbackSounds(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-enable-input-feedback-sounds", &v)
+}
+
+func (x *Settings) GetPropertyGtkEnableInputFeedbackSounds() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-enable-input-feedback-sounds", &v)
+	return v.GetBoolean()
+}
+
+// Whether a middle click on a mouse should paste the
+// 'PRIMARY' clipboard content at the cursor location.
+
+func (x *Settings) SetPropertyGtkEnablePrimaryPaste(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-enable-primary-paste", &v)
+}
+
+func (x *Settings) GetPropertyGtkEnablePrimaryPaste() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-enable-primary-paste", &v)
+	return v.GetBoolean()
+}
+
+// How long to show the last input character in hidden
+// entries.
+//
+// This value is in milliseconds. 0 disables showing the
+// last char. 600 is a good value for enabling it.
+
+func (x *Settings) SetPropertyGtkEntryPasswordHintTimeout(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("gtk-entry-password-hint-timeout", &v)
+}
+
+func (x *Settings) GetPropertyGtkEntryPasswordHintTimeout() uint {
+	var v gobject.Value
+	x.GetProperty("gtk-entry-password-hint-timeout", &v)
+	return v.GetUint()
+}
+
+func (x *Settings) SetPropertyGtkEntrySelectOnFocus(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-entry-select-on-focus", &v)
+}
+
+func (x *Settings) GetPropertyGtkEntrySelectOnFocus() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-entry-select-on-focus", &v)
+	return v.GetBoolean()
+}
+
+// When %TRUE, keyboard navigation and other input-related errors
+// will cause a beep.
+//
+// Since the error bell is implemented using gdk_surface_beep(), the
+// windowing system may offer ways to configure the error bell in many
+// ways, such as flashing the window or similar visual effects.
+
+func (x *Settings) SetPropertyGtkErrorBell(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-error-bell", &v)
+}
+
+func (x *Settings) GetPropertyGtkErrorBell() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-error-bell", &v)
+	return v.GetBoolean()
+}
+
+// The default font to use.
+//
+// GTK uses the family name and size from this string.
+
+func (x *Settings) SetPropertyGtkFontName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-font-name", &v)
+}
+
+func (x *Settings) GetPropertyGtkFontName() string {
+	var v gobject.Value
+	x.GetProperty("gtk-font-name", &v)
+	return v.GetString()
+}
+
+// Timestamp of the curent fontconfig configuration.
+
+func (x *Settings) SetPropertyGtkFontconfigTimestamp(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("gtk-fontconfig-timestamp", &v)
+}
+
+func (x *Settings) GetPropertyGtkFontconfigTimestamp() uint {
+	var v gobject.Value
+	x.GetProperty("gtk-fontconfig-timestamp", &v)
+	return v.GetUint()
+}
+
+// Whether hinting should be applied to font metrics.
+//
+// Note that this also turns off subpixel positioning of glyphs,
+// since it conflicts with metrics hinting.
+
+func (x *Settings) SetPropertyGtkHintFontMetrics(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-hint-font-metrics", &v)
+}
+
+func (x *Settings) GetPropertyGtkHintFontMetrics() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-hint-font-metrics", &v)
+	return v.GetBoolean()
+}
+
+// Name of the icon theme to use.
+//
+// See [class@Gtk.IconTheme] for details about how
+// GTK handles icon themes.
+
+func (x *Settings) SetPropertyGtkIconThemeName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-icon-theme-name", &v)
+}
+
+func (x *Settings) GetPropertyGtkIconThemeName() string {
+	var v gobject.Value
+	x.GetProperty("gtk-icon-theme-name", &v)
+	return v.GetString()
+}
+
+// Which IM (input method) module should be used by default.
+//
+// This is the input method that will be used if the user has not
+// explicitly chosen another input method from the IM context menu.
+// This also can be a colon-separated list of input methods, which GTK
+// will try in turn until it finds one available on the system.
+//
+// See [class@Gtk.IMContext].
+
+func (x *Settings) SetPropertyGtkImModule(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-im-module", &v)
+}
+
+func (x *Settings) GetPropertyGtkImModule() string {
+	var v gobject.Value
+	x.GetProperty("gtk-im-module", &v)
+	return v.GetString()
+}
+
+// Whether GTK should make sure that text can be navigated with
+// a caret, even if it is not editable.
+//
+// This is useful when using a screen reader.
+
+func (x *Settings) SetPropertyGtkKeynavUseCaret(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-keynav-use-caret", &v)
+}
+
+func (x *Settings) GetPropertyGtkKeynavUseCaret() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-keynav-use-caret", &v)
+	return v.GetBoolean()
+}
+
+// Whether to select the contents of a selectable
+// label when it is focused.
+
+func (x *Settings) SetPropertyGtkLabelSelectOnFocus(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-label-select-on-focus", &v)
+}
+
+func (x *Settings) GetPropertyGtkLabelSelectOnFocus() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-label-select-on-focus", &v)
+	return v.GetBoolean()
+}
+
+// The time for a button or touch press to be considered a âlong pressâ.
+//
+// See [class@Gtk.GestureLongPress].
+
+func (x *Settings) SetPropertyGtkLongPressTime(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("gtk-long-press-time", &v)
+}
+
+func (x *Settings) GetPropertyGtkLongPressTime() uint {
+	var v gobject.Value
+	x.GetProperty("gtk-long-press-time", &v)
+	return v.GetUint()
+}
+
+// Whether scrolled windows may use overlaid scrolling indicators.
+//
+// If this is set to %FALSE, scrolled windows will have permanent
+// scrollbars.
+
+func (x *Settings) SetPropertyGtkOverlayScrolling(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-overlay-scrolling", &v)
+}
+
+func (x *Settings) GetPropertyGtkOverlayScrolling() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-overlay-scrolling", &v)
+	return v.GetBoolean()
+}
+
+// If the value of this setting is %TRUE, clicking the primary button in a
+// `GtkRange` trough will move the slider, and hence set the rangeâs value, to
+// the point that you clicked.
+//
+// If it is %FALSE, a primary click will cause the slider/value to move
+// by the rangeâs page-size towards the point clicked.
+//
+// Whichever action you choose for the primary button, the other action will
+// be available by holding Shift and primary-clicking, or clicking the middle
+// mouse button.
+
+func (x *Settings) SetPropertyGtkPrimaryButtonWarpsSlider(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-primary-button-warps-slider", &v)
+}
+
+func (x *Settings) GetPropertyGtkPrimaryButtonWarpsSlider() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-primary-button-warps-slider", &v)
+	return v.GetBoolean()
+}
+
+// A comma-separated list of print backends to use in the print
+// dialog.
+//
+// Available print backends depend on the GTK installation,
+// and may include "file", "cups", "lpr" or "papi".
+
+func (x *Settings) SetPropertyGtkPrintBackends(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-print-backends", &v)
+}
+
+func (x *Settings) GetPropertyGtkPrintBackends() string {
+	var v gobject.Value
+	x.GetProperty("gtk-print-backends", &v)
+	return v.GetString()
+}
+
+// A command to run for displaying the print preview.
+//
+// The command should contain a `%f` placeholder, which will get
+// replaced by the path to the pdf file. The command may also
+// contain a `%s` placeholder, which will get replaced by the
+// path to a file containing the print settings in the format
+// produced by [method@Gtk.PrintSettings.to_file].
+//
+// The preview application is responsible for removing the pdf
+// file and the print settings file when it is done.
+
+func (x *Settings) SetPropertyGtkPrintPreviewCommand(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-print-preview-command", &v)
+}
+
+func (x *Settings) GetPropertyGtkPrintPreviewCommand() string {
+	var v gobject.Value
+	x.GetProperty("gtk-print-preview-command", &v)
+	return v.GetString()
+}
+
+// Whether GTK should keep track of items inside the recently used
+// resources list.
+//
+// If set to %FALSE, the list will always be empty.
+
+func (x *Settings) SetPropertyGtkRecentFilesEnabled(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-recent-files-enabled", &v)
+}
+
+func (x *Settings) GetPropertyGtkRecentFilesEnabled() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-recent-files-enabled", &v)
+	return v.GetBoolean()
+}
+
+// The maximum age, in days, of the items inside the recently used
+// resources list.
+//
+// Items older than this setting will be excised from the list.
+// If set to 0, the list will always be empty; if set to -1, no
+// item will be removed.
+
+func (x *Settings) SetPropertyGtkRecentFilesMaxAge(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("gtk-recent-files-max-age", &v)
+}
+
+func (x *Settings) GetPropertyGtkRecentFilesMaxAge() int {
+	var v gobject.Value
+	x.GetProperty("gtk-recent-files-max-age", &v)
+	return v.GetInt()
+}
+
+// Set to %TRUE if the desktop environment is displaying
+// the app menu, %FALSE if the app should display it itself.
+
+func (x *Settings) SetPropertyGtkShellShowsAppMenu(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-shell-shows-app-menu", &v)
+}
+
+func (x *Settings) GetPropertyGtkShellShowsAppMenu() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-shell-shows-app-menu", &v)
+	return v.GetBoolean()
+}
+
+// Set to %TRUE if the desktop environment is displaying
+// the desktop folder, %FALSE if not.
+
+func (x *Settings) SetPropertyGtkShellShowsDesktop(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-shell-shows-desktop", &v)
+}
+
+func (x *Settings) GetPropertyGtkShellShowsDesktop() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-shell-shows-desktop", &v)
+	return v.GetBoolean()
+}
+
+// Set to %TRUE if the desktop environment is displaying
+// the menubar, %FALSE if the app should display it itself.
+
+func (x *Settings) SetPropertyGtkShellShowsMenubar(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-shell-shows-menubar", &v)
+}
+
+func (x *Settings) GetPropertyGtkShellShowsMenubar() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-shell-shows-menubar", &v)
+	return v.GetBoolean()
+}
+
+// The XDG sound theme to use for event sounds.
+//
+// See the [Sound Theme Specifications](http://www.freedesktop.org/wiki/Specifications/sound-theme-spec)
+// for more information on event sounds and sound themes.
+//
+// GTK itself does not support event sounds, you have to use
+// a loadable module like the one that comes with libcanberra.
+
+func (x *Settings) SetPropertyGtkSoundThemeName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-sound-theme-name", &v)
+}
+
+func (x *Settings) GetPropertyGtkSoundThemeName() string {
+	var v gobject.Value
+	x.GetProperty("gtk-sound-theme-name", &v)
+	return v.GetString()
+}
+
+// Whether two cursors should be displayed for mixed left-to-right and
+// right-to-left text.
+
+func (x *Settings) SetPropertyGtkSplitCursor(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("gtk-split-cursor", &v)
+}
+
+func (x *Settings) GetPropertyGtkSplitCursor() bool {
+	var v gobject.Value
+	x.GetProperty("gtk-split-cursor", &v)
+	return v.GetBoolean()
+}
+
+// Name of the theme to load.
+//
+// See [class@Gtk.CssProvider] for details about how
+// GTK finds the CSS stylesheet for a theme.
+
+func (x *Settings) SetPropertyGtkThemeName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-theme-name", &v)
+}
+
+func (x *Settings) GetPropertyGtkThemeName() string {
+	var v gobject.Value
+	x.GetProperty("gtk-theme-name", &v)
+	return v.GetString()
+}
+
+// Determines the action to take when a double-click
+// occurs on the titlebar of client-side decorated windows.
+//
+// Recognized actions are minimize, toggle-maximize, menu, lower
+// or none.
+
+func (x *Settings) SetPropertyGtkTitlebarDoubleClick(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-titlebar-double-click", &v)
+}
+
+func (x *Settings) GetPropertyGtkTitlebarDoubleClick() string {
+	var v gobject.Value
+	x.GetProperty("gtk-titlebar-double-click", &v)
+	return v.GetString()
+}
+
+// Determines the action to take when a middle-click
+// occurs on the titlebar of client-side decorated windows.
+//
+// Recognized actions are minimize, toggle-maximize, menu, lower
+// or none.
+
+func (x *Settings) SetPropertyGtkTitlebarMiddleClick(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-titlebar-middle-click", &v)
+}
+
+func (x *Settings) GetPropertyGtkTitlebarMiddleClick() string {
+	var v gobject.Value
+	x.GetProperty("gtk-titlebar-middle-click", &v)
+	return v.GetString()
+}
+
+// Determines the action to take when a right-click
+// occurs on the titlebar of client-side decorated windows.
+//
+// Recognized actions are minimize, toggle-maximize, menu, lower
+// or none.
+
+func (x *Settings) SetPropertyGtkTitlebarRightClick(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-titlebar-right-click", &v)
+}
+
+func (x *Settings) GetPropertyGtkTitlebarRightClick() string {
+	var v gobject.Value
+	x.GetProperty("gtk-titlebar-right-click", &v)
+	return v.GetString()
+}
+
+// Whether to antialias fonts.
+//
+// The values are 0 for no, 1 for yes, or -1 for the system default.
+
+func (x *Settings) SetPropertyGtkXftAntialias(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("gtk-xft-antialias", &v)
+}
+
+func (x *Settings) GetPropertyGtkXftAntialias() int {
+	var v gobject.Value
+	x.GetProperty("gtk-xft-antialias", &v)
+	return v.GetInt()
+}
+
+// The font resolution, in 1024 * dots/inch.
+//
+// -1 to use the default value.
+
+func (x *Settings) SetPropertyGtkXftDpi(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("gtk-xft-dpi", &v)
+}
+
+func (x *Settings) GetPropertyGtkXftDpi() int {
+	var v gobject.Value
+	x.GetProperty("gtk-xft-dpi", &v)
+	return v.GetInt()
+}
+
+// Whether to enable font hinting.
+//
+// The values are 0 for no, 1 for yes, or -1 for the system default.
+
+func (x *Settings) SetPropertyGtkXftHinting(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("gtk-xft-hinting", &v)
+}
+
+func (x *Settings) GetPropertyGtkXftHinting() int {
+	var v gobject.Value
+	x.GetProperty("gtk-xft-hinting", &v)
+	return v.GetInt()
+}
+
+// What degree of font hinting to use.
+//
+// The possible vaues are hintnone, hintslight,
+// hintmedium, hintfull.
+
+func (x *Settings) SetPropertyGtkXftHintstyle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-xft-hintstyle", &v)
+}
+
+func (x *Settings) GetPropertyGtkXftHintstyle() string {
+	var v gobject.Value
+	x.GetProperty("gtk-xft-hintstyle", &v)
+	return v.GetString()
+}
+
+// The type of subpixel antialiasing to use.
+//
+// The possible values are none, rgb, bgr, vrgb, vbgr.
+
+func (x *Settings) SetPropertyGtkXftRgba(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("gtk-xft-rgba", &v)
+}
+
+func (x *Settings) GetPropertyGtkXftRgba() string {
+	var v gobject.Value
+	x.GetProperty("gtk-xft-rgba", &v)
+	return v.GetString()
+}
+
 var xSettingsGetDefault func() uintptr
 
 // Gets the `GtkSettings` object for the default display, creating
diff --git a/v4/gtk/gtkshortcut.go b/v4/gtk/gtkshortcut.go
index 880aec8a3a0d935ce4844e3e5dbef087c54b8526..ec288adf7a9c8ca4ec916d79f65be819d760e695 100644
--- a/v4/gtk/gtkshortcut.go
+++ b/v4/gtk/gtkshortcut.go
@@ -168,6 +168,63 @@ func (c *Shortcut) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The action that gets activated by this shortcut.
+
+func (x *Shortcut) SetPropertyAction(value *ShortcutAction) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("action", &v)
+}
+
+func (x *Shortcut) GetPropertyAction() *ShortcutAction {
+	var v gobject.Value
+	x.GetProperty("action", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ShortcutAction{}
+	result.Ptr = ptr
+	return result
+}
+
+// Arguments passed to activation.
+
+func (x *Shortcut) SetPropertyArguments(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("arguments", &v)
+}
+
+func (x *Shortcut) GetPropertyArguments() uintptr {
+	var v gobject.Value
+	x.GetProperty("arguments", &v)
+	return v.GetPointer()
+}
+
+// The trigger that triggers this shortcut.
+
+func (x *Shortcut) SetPropertyTrigger(value *ShortcutTrigger) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("trigger", &v)
+}
+
+func (x *Shortcut) GetPropertyTrigger() *ShortcutTrigger {
+	var v gobject.Value
+	x.GetProperty("trigger", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ShortcutTrigger{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkshortcutaction.go b/v4/gtk/gtkshortcutaction.go
index 4d34f86181d6210120a56d709353d49c93247626..cdd09198c5ff597ec232b7b0f4bea928c5221c54 100644
--- a/v4/gtk/gtkshortcutaction.go
+++ b/v4/gtk/gtkshortcutaction.go
@@ -290,6 +290,21 @@ func (c *NamedAction) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The name of the action to activate.
+
+func (x *NamedAction) SetPropertyActionName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("action-name", &v)
+}
+
+func (x *NamedAction) GetPropertyActionName() string {
+	var v gobject.Value
+	x.GetProperty("action-name", &v)
+	return v.GetString()
+}
+
 // A `GtkShortcutAction` that does nothing.
 type NothingAction struct {
 	ShortcutAction
@@ -517,6 +532,21 @@ }
 
 func (c *SignalAction) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The name of the signal to emit.
+
+func (x *SignalAction) SetPropertySignalName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("signal-name", &v)
+}
+
+func (x *SignalAction) GetPropertySignalName() string {
+	var v gobject.Value
+	x.GetProperty("signal-name", &v)
+	return v.GetString()
 }
 
 func init() {
diff --git a/v4/gtk/gtkshortcutcontroller.go b/v4/gtk/gtkshortcutcontroller.go
index f704763dea2e0d106a14141800ef88709ce0cfe6..81a56e7a4b19212c1d51404e4a8aadcbc19e9e44 100644
--- a/v4/gtk/gtkshortcutcontroller.go
+++ b/v4/gtk/gtkshortcutcontroller.go
@@ -209,6 +209,61 @@ func (c *ShortcutController) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *ShortcutController) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The modifiers that need to be pressed to allow mnemonics activation.
+
+func (x *ShortcutController) SetPropertyMnemonicModifiers(value gdk.ModifierType) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("mnemonic-modifiers", &v)
+}
+
+func (x *ShortcutController) GetPropertyMnemonicModifiers() gdk.ModifierType {
+	var v gobject.Value
+	x.GetProperty("mnemonic-modifiers", &v)
+	return gdk.ModifierType(v.GetFlags())
+}
+
+// A list model to take shortcuts from.
+
+func (x *ShortcutController) SetPropertyModel(value gio.ListModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *ShortcutController) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
+// What scope the shortcuts will be handled in.
+
+func (x *ShortcutController) SetPropertyScope(value ShortcutScope) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("scope", &v)
+}
+
+func (x *ShortcutController) GetPropertyScope() ShortcutScope {
+	var v gobject.Value
+	x.GetProperty("scope", &v)
+	return ShortcutScope(v.GetEnum())
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtkshortcutlabel.go b/v4/gtk/gtkshortcutlabel.go
index 9653344dc0fef9dac01198291aaef96736542345..dc494ce7d6bf7e025deb53d360a530e27255028e 100644
--- a/v4/gtk/gtkshortcutlabel.go
+++ b/v4/gtk/gtkshortcutlabel.go
@@ -102,6 +102,39 @@ func (c *ShortcutLabel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The accelerator that @self displays.
+//
+// See [property@Gtk.ShortcutsShortcut:accelerator]
+// for the accepted syntax.
+
+func (x *ShortcutLabel) SetPropertyAccelerator(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("accelerator", &v)
+}
+
+func (x *ShortcutLabel) GetPropertyAccelerator() string {
+	var v gobject.Value
+	x.GetProperty("accelerator", &v)
+	return v.GetString()
+}
+
+// The text that is displayed when no accelerator is set.
+
+func (x *ShortcutLabel) SetPropertyDisabledText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("disabled-text", &v)
+}
+
+func (x *ShortcutLabel) GetPropertyDisabledText() string {
+	var v gobject.Value
+	x.GetProperty("disabled-text", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ShortcutLabel) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkshortcutsgroup.go b/v4/gtk/gtkshortcutsgroup.go
index 4a50f8f41c201ef0fb75be81e83a57d9102f6ec1..1939d74c2d1a5b8dcc9671764a064c61cab0263d 100644
--- a/v4/gtk/gtkshortcutsgroup.go
+++ b/v4/gtk/gtkshortcutsgroup.go
@@ -52,6 +52,73 @@ func (c *ShortcutsGroup) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The size group for the accelerator portion of shortcuts in this group.
+//
+// This is used internally by GTK, and must not be modified by applications.
+
+func (x *ShortcutsGroup) SetPropertyAccelSizeGroup(value *SizeGroup) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("accel-size-group", &v)
+}
+
+// A rough measure for the number of lines in this group.
+//
+// This is used internally by GTK, and is not useful for applications.
+
+func (x *ShortcutsGroup) GetPropertyHeight() uint {
+	var v gobject.Value
+	x.GetProperty("height", &v)
+	return v.GetUint()
+}
+
+// The title for this group of shortcuts.
+
+func (x *ShortcutsGroup) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *ShortcutsGroup) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// The size group for the textual portion of shortcuts in this group.
+//
+// This is used internally by GTK, and must not be modified by applications.
+
+func (x *ShortcutsGroup) SetPropertyTitleSizeGroup(value *SizeGroup) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("title-size-group", &v)
+}
+
+// An optional view that the shortcuts in this group are relevant for.
+//
+// The group will be hidden if the [property@Gtk.ShortcutsWindow:view-name]
+// property does not match the view of this group.
+//
+// Set this to %NULL to make the group always visible.
+
+func (x *ShortcutsGroup) SetPropertyView(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("view", &v)
+}
+
+func (x *ShortcutsGroup) GetPropertyView() string {
+	var v gobject.Value
+	x.GetProperty("view", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *ShortcutsGroup) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkshortcutssection.go b/v4/gtk/gtkshortcutssection.go
index fc9d1235d34873dab3d1cbb5fea1d0dfd833ed79..07567da67cd509dfa4a44ac95351b8eaffac0cb0 100644
--- a/v4/gtk/gtkshortcutssection.go
+++ b/v4/gtk/gtkshortcutssection.go
@@ -59,6 +59,84 @@ func (c *ShortcutsSection) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The maximum number of lines to allow per column.
+//
+// This property can be used to influence how the groups in this
+// section are distributed across pages and columns. The default
+// value of 15 should work in most cases.
+
+func (x *ShortcutsSection) SetPropertyMaxHeight(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("max-height", &v)
+}
+
+func (x *ShortcutsSection) GetPropertyMaxHeight() uint {
+	var v gobject.Value
+	x.GetProperty("max-height", &v)
+	return v.GetUint()
+}
+
+// A unique name to identify this section among the sections
+// added to the `GtkShortcutsWindow`.
+//
+// Setting the [property@Gtk.ShortcutsWindow:section-name] property
+// to this string will make this section shown in the `GtkShortcutsWindow`.
+
+func (x *ShortcutsSection) SetPropertySectionName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("section-name", &v)
+}
+
+func (x *ShortcutsSection) GetPropertySectionName() string {
+	var v gobject.Value
+	x.GetProperty("section-name", &v)
+	return v.GetString()
+}
+
+// The string to show in the section selector of the `GtkShortcutsWindow`
+// for this section.
+//
+// If there is only one section, you don't need to set a title,
+// since the section selector will not be shown in this case.
+
+func (x *ShortcutsSection) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *ShortcutsSection) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// A view name to filter the groups in this section by.
+//
+// See [property@Gtk.ShortcutsGroup:view].
+//
+// Applications are expected to use the
+// [property@Gtk.ShortcutsWindow:view-name] property
+// for this purpose.
+
+func (x *ShortcutsSection) SetPropertyViewName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("view-name", &v)
+}
+
+func (x *ShortcutsSection) GetPropertyViewName() string {
+	var v gobject.Value
+	x.GetProperty("view-name", &v)
+	return v.GetString()
+}
+
 func (x *ShortcutsSection) ConnectChangeCurrentPage(cb *func(ShortcutsSection, int) bool) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
 	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
diff --git a/v4/gtk/gtkshortcutsshortcut.go b/v4/gtk/gtkshortcutsshortcut.go
index ffe4e91d22c703817b7c4db4ccb0dd6b4d7f825d..38244a5823a42efd9cd93524df38eb3cc46cef74 100644
--- a/v4/gtk/gtkshortcutsshortcut.go
+++ b/v4/gtk/gtkshortcutsshortcut.go
@@ -5,6 +5,7 @@ import (
 	"structs"
 	"unsafe"
 
+	"github.com/jwijenbergh/puregotk/v4/gio"
 	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
 )
@@ -83,6 +84,215 @@ }
 
 func (c *ShortcutsShortcut) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The size group for the accelerator portion of this shortcut.
+//
+// This is used internally by GTK, and must not be modified by applications.
+
+func (x *ShortcutsShortcut) SetPropertyAccelSizeGroup(value *SizeGroup) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("accel-size-group", &v)
+}
+
+// The accelerator(s) represented by this object.
+//
+// This property is used if [property@Gtk.ShortcutsShortcut:shortcut-type]
+// is set to %GTK_SHORTCUT_ACCELERATOR.
+//
+// The syntax of this property is (an extension of) the syntax understood
+// by [func@Gtk.accelerator_parse]. Multiple accelerators can be specified
+// by separating them with a space, but keep in mind that the available width
+// is limited.
+//
+// It is also possible to specify ranges of shortcuts, using "..." between
+// the keys. Sequences of keys can be specified using a "+" or "&amp;" between
+// the keys.
+//
+// Examples:
+//
+// - A single shortcut: &lt;ctl&gt;&lt;alt&gt;delete
+// - Two alternative shortcuts: &lt;shift&gt;a Home
+// - A range of shortcuts: &lt;alt&gt;1...&lt;alt&gt;9
+// - Several keys pressed together: Control_L&amp;Control_R
+// - A sequence of shortcuts or keys: &lt;ctl&gt;c+&lt;ctl&gt;x
+//
+// Use "+" instead of "&amp;" when the keys may (or have to be) pressed
+// sequentially (e.g use "t+t" for 'press the t key twice').
+//
+// Note that &lt;, &gt; and &amp; need to be escaped as &amp;lt;, &amp;gt; and &amp;amp; when used
+// in .ui files.
+
+func (x *ShortcutsShortcut) SetPropertyAccelerator(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("accelerator", &v)
+}
+
+func (x *ShortcutsShortcut) GetPropertyAccelerator() string {
+	var v gobject.Value
+	x.GetProperty("accelerator", &v)
+	return v.GetString()
+}
+
+// A detailed action name.
+//
+// If this is set for a shortcut of type %GTK_SHORTCUT_ACCELERATOR,
+// then GTK will use the accelerators that are associated with the
+// action via [method@Gtk.Application.set_accels_for_action], and
+// setting [property@Gtk.ShortcutsShortcut:accelerator] is not necessary.
+
+func (x *ShortcutsShortcut) SetPropertyActionName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("action-name", &v)
+}
+
+func (x *ShortcutsShortcut) GetPropertyActionName() string {
+	var v gobject.Value
+	x.GetProperty("action-name", &v)
+	return v.GetString()
+}
+
+// The text direction for which this shortcut is active.
+//
+// If the shortcut is used regardless of the text direction,
+// set this property to %GTK_TEXT_DIR_NONE.
+
+func (x *ShortcutsShortcut) SetPropertyDirection(value TextDirection) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("direction", &v)
+}
+
+func (x *ShortcutsShortcut) GetPropertyDirection() TextDirection {
+	var v gobject.Value
+	x.GetProperty("direction", &v)
+	return TextDirection(v.GetEnum())
+}
+
+// An icon to represent the shortcut or gesture.
+//
+// This property is used if [property@Gtk.ShortcutsShortcut:shortcut-type]
+// is set to %GTK_SHORTCUT_GESTURE.
+//
+// For the other predefined gesture types, GTK provides an icon on its own.
+
+func (x *ShortcutsShortcut) SetPropertyIcon(value gio.Icon) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("icon", &v)
+}
+
+func (x *ShortcutsShortcut) GetPropertyIcon() gio.Icon {
+	var v gobject.Value
+	x.GetProperty("icon", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.IconBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// %TRUE if an icon has been set.
+
+func (x *ShortcutsShortcut) SetPropertyIconSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("icon-set", &v)
+}
+
+func (x *ShortcutsShortcut) GetPropertyIconSet() bool {
+	var v gobject.Value
+	x.GetProperty("icon-set", &v)
+	return v.GetBoolean()
+}
+
+// The type of shortcut that is represented.
+
+func (x *ShortcutsShortcut) SetPropertyShortcutType(value ShortcutType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("shortcut-type", &v)
+}
+
+func (x *ShortcutsShortcut) GetPropertyShortcutType() ShortcutType {
+	var v gobject.Value
+	x.GetProperty("shortcut-type", &v)
+	return ShortcutType(v.GetEnum())
+}
+
+// The subtitle for the shortcut or gesture.
+//
+// This is typically used for gestures and should be a short, one-line
+// text that describes the gesture itself. For the predefined gesture
+// types, GTK provides a subtitle on its own.
+
+func (x *ShortcutsShortcut) SetPropertySubtitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("subtitle", &v)
+}
+
+func (x *ShortcutsShortcut) GetPropertySubtitle() string {
+	var v gobject.Value
+	x.GetProperty("subtitle", &v)
+	return v.GetString()
+}
+
+// %TRUE if a subtitle has been set.
+
+func (x *ShortcutsShortcut) SetPropertySubtitleSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("subtitle-set", &v)
+}
+
+func (x *ShortcutsShortcut) GetPropertySubtitleSet() bool {
+	var v gobject.Value
+	x.GetProperty("subtitle-set", &v)
+	return v.GetBoolean()
+}
+
+// The textual description for the shortcut or gesture represented by
+// this object.
+//
+// This should be a short string that can fit in a single line.
+
+func (x *ShortcutsShortcut) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *ShortcutsShortcut) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// The size group for the textual portion of this shortcut.
+//
+// This is used internally by GTK, and must not be modified by applications.
+
+func (x *ShortcutsShortcut) SetPropertyTitleSizeGroup(value *SizeGroup) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("title-size-group", &v)
 }
 
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
diff --git a/v4/gtk/gtkshortcutswindow.go b/v4/gtk/gtkshortcutswindow.go
index 3e4bd8e90468f1b4077ad477096ac429fe30d3c7..8c4ea485b5d8fdd07200fd1fee99d166208be4a3 100644
--- a/v4/gtk/gtkshortcutswindow.go
+++ b/v4/gtk/gtkshortcutswindow.go
@@ -80,6 +80,45 @@ func (c *ShortcutsWindow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The name of the section to show.
+//
+// This should be the section-name of one of the `GtkShortcutsSection`
+// objects that are in this shortcuts window.
+
+func (x *ShortcutsWindow) SetPropertySectionName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("section-name", &v)
+}
+
+func (x *ShortcutsWindow) GetPropertySectionName() string {
+	var v gobject.Value
+	x.GetProperty("section-name", &v)
+	return v.GetString()
+}
+
+// The view name by which to filter the contents.
+//
+// This should correspond to the [property@Gtk.ShortcutsGroup:view]
+// property of some of the [class@Gtk.ShortcutsGroup] objects that
+// are inside this shortcuts window.
+//
+// Set this to %NULL to show all groups.
+
+func (x *ShortcutsWindow) SetPropertyViewName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("view-name", &v)
+}
+
+func (x *ShortcutsWindow) GetPropertyViewName() string {
+	var v gobject.Value
+	x.GetProperty("view-name", &v)
+	return v.GetString()
+}
+
 // Emitted when the user uses a keybinding to close the window.
 //
 // This is a [keybinding signal](class.SignalAction.html).
diff --git a/v4/gtk/gtkshortcuttrigger.go b/v4/gtk/gtkshortcuttrigger.go
index 7f40cb4dcdf1c572a4b23f498c1619e3eb5259b4..9265cca465d2d6163a87fe44778e35b195760193 100644
--- a/v4/gtk/gtkshortcuttrigger.go
+++ b/v4/gtk/gtkshortcuttrigger.go
@@ -147,6 +147,48 @@ func (c *AlternativeTrigger) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The first `GtkShortcutTrigger` to check.
+
+func (x *AlternativeTrigger) SetPropertyFirst(value *ShortcutTrigger) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("first", &v)
+}
+
+func (x *AlternativeTrigger) GetPropertyFirst() *ShortcutTrigger {
+	var v gobject.Value
+	x.GetProperty("first", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ShortcutTrigger{}
+	result.Ptr = ptr
+	return result
+}
+
+// The second `GtkShortcutTrigger` to check.
+
+func (x *AlternativeTrigger) SetPropertySecond(value *ShortcutTrigger) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("second", &v)
+}
+
+func (x *AlternativeTrigger) GetPropertySecond() *ShortcutTrigger {
+	var v gobject.Value
+	x.GetProperty("second", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &ShortcutTrigger{}
+	result.Ptr = ptr
+	return result
+}
+
 // A `GtkShortcutTrigger` that triggers when a specific keyval and modifiers are pressed.
 type KeyvalTrigger struct {
 	ShortcutTrigger
@@ -212,6 +254,36 @@ func (c *KeyvalTrigger) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The key value for the trigger.
+
+func (x *KeyvalTrigger) SetPropertyKeyval(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("keyval", &v)
+}
+
+func (x *KeyvalTrigger) GetPropertyKeyval() uint {
+	var v gobject.Value
+	x.GetProperty("keyval", &v)
+	return v.GetUint()
+}
+
+// The key modifiers for the trigger.
+
+func (x *KeyvalTrigger) SetPropertyModifiers(value gdk.ModifierType) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("modifiers", &v)
+}
+
+func (x *KeyvalTrigger) GetPropertyModifiers() gdk.ModifierType {
+	var v gobject.Value
+	x.GetProperty("modifiers", &v)
+	return gdk.ModifierType(v.GetFlags())
+}
+
 // A `GtkShortcutTrigger` that triggers when a specific mnemonic is pressed.
 //
 // Mnemonics require a *mnemonic modifier* (typically &lt;kbd&gt;Alt&lt;/kbd&gt;) to be
@@ -270,6 +342,21 @@ }
 
 func (c *MnemonicTrigger) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The key value for the trigger.
+
+func (x *MnemonicTrigger) SetPropertyKeyval(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("keyval", &v)
+}
+
+func (x *MnemonicTrigger) GetPropertyKeyval() uint {
+	var v gobject.Value
+	x.GetProperty("keyval", &v)
+	return v.GetUint()
 }
 
 // A `GtkShortcutTrigger` that never triggers.
diff --git a/v4/gtk/gtksingleselection.go b/v4/gtk/gtksingleselection.go
index 52546a375d41de908feeddde9b2ae7ac9dddc8f1..c43653a5526132175900ed08d7f28e56d0657f44 100644
--- a/v4/gtk/gtksingleselection.go
+++ b/v4/gtk/gtksingleselection.go
@@ -193,6 +193,102 @@ func (c *SingleSelection) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If the selection will always select an item.
+
+func (x *SingleSelection) SetPropertyAutoselect(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("autoselect", &v)
+}
+
+func (x *SingleSelection) GetPropertyAutoselect() bool {
+	var v gobject.Value
+	x.GetProperty("autoselect", &v)
+	return v.GetBoolean()
+}
+
+// If unselecting the selected item is allowed.
+
+func (x *SingleSelection) SetPropertyCanUnselect(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-unselect", &v)
+}
+
+func (x *SingleSelection) GetPropertyCanUnselect() bool {
+	var v gobject.Value
+	x.GetProperty("can-unselect", &v)
+	return v.GetBoolean()
+}
+
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *SingleSelection) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The model being managed.
+
+func (x *SingleSelection) SetPropertyModel(value gio.ListModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *SingleSelection) GetPropertyModel() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *SingleSelection) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
+// Position of the selected item.
+
+func (x *SingleSelection) SetPropertySelected(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("selected", &v)
+}
+
+func (x *SingleSelection) GetPropertySelected() uint {
+	var v gobject.Value
+	x.GetProperty("selected", &v)
+	return v.GetUint()
+}
+
+// The selected item.
+
+func (x *SingleSelection) GetPropertySelectedItem() *gobject.Object {
+	var v gobject.Value
+	x.GetProperty("selected-item", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gobject.Object{}
+	result.Ptr = ptr
+	return result
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtksizegroup.go b/v4/gtk/gtksizegroup.go
index 85dd30814b0ea9e5c924de75f64cea7959b352cd..ffed8a34627570b74de44531acd175c51c979c2b 100644
--- a/v4/gtk/gtksizegroup.go
+++ b/v4/gtk/gtksizegroup.go
@@ -179,6 +179,21 @@ func (c *SizeGroup) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The direction in which the size group affects requested sizes.
+
+func (x *SizeGroup) SetPropertyMode(value SizeGroupMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("mode", &v)
+}
+
+func (x *SizeGroup) GetPropertyMode() SizeGroupMode {
+	var v gobject.Value
+	x.GetProperty("mode", &v)
+	return SizeGroupMode(v.GetEnum())
+}
+
 // Gets the ID of the @buildable object.
 //
 // `GtkBuilder` sets the name based on the ID attribute
diff --git a/v4/gtk/gtkslicelistmodel.go b/v4/gtk/gtkslicelistmodel.go
index 68c54f64e4cd1a29a06d61ae3c892db0f147a17d..6d6614237d10f259e031ae3e5266319de1c844a5 100644
--- a/v4/gtk/gtkslicelistmodel.go
+++ b/v4/gtk/gtkslicelistmodel.go
@@ -144,6 +144,73 @@ func (c *SliceListModel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *SliceListModel) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// Child model to take slice from.
+
+func (x *SliceListModel) SetPropertyModel(value gio.ListModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *SliceListModel) GetPropertyModel() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *SliceListModel) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
+// Offset of slice.
+
+func (x *SliceListModel) SetPropertyOffset(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("offset", &v)
+}
+
+func (x *SliceListModel) GetPropertyOffset() uint {
+	var v gobject.Value
+	x.GetProperty("offset", &v)
+	return v.GetUint()
+}
+
+// Maximum size of slice.
+
+func (x *SliceListModel) SetPropertySize(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("size", &v)
+}
+
+func (x *SliceListModel) GetPropertySize() uint {
+	var v gobject.Value
+	x.GetProperty("size", &v)
+	return v.GetUint()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtksortlistmodel.go b/v4/gtk/gtksortlistmodel.go
index 0f5d2601654b9ca714ce4f660a46e04afa11d850..f73ea6c030e04d63b96af5560b96d34ec5b115c3 100644
--- a/v4/gtk/gtksortlistmodel.go
+++ b/v4/gtk/gtksortlistmodel.go
@@ -198,6 +198,87 @@ func (c *SortListModel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If the model should sort items incrementally.
+
+func (x *SortListModel) SetPropertyIncremental(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("incremental", &v)
+}
+
+func (x *SortListModel) GetPropertyIncremental() bool {
+	var v gobject.Value
+	x.GetProperty("incremental", &v)
+	return v.GetBoolean()
+}
+
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *SortListModel) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The model being sorted.
+
+func (x *SortListModel) SetPropertyModel(value gio.ListModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *SortListModel) GetPropertyModel() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *SortListModel) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
+// Estimate of unsorted items remaining.
+
+func (x *SortListModel) GetPropertyPending() uint {
+	var v gobject.Value
+	x.GetProperty("pending", &v)
+	return v.GetUint()
+}
+
+// The sorter for this model.
+
+func (x *SortListModel) SetPropertySorter(value *Sorter) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("sorter", &v)
+}
+
+func (x *SortListModel) GetPropertySorter() *Sorter {
+	var v gobject.Value
+	x.GetProperty("sorter", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Sorter{}
+	result.Ptr = ptr
+	return result
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
diff --git a/v4/gtk/gtkspinbutton.go b/v4/gtk/gtkspinbutton.go
index 73d8c574241aca05dabba58d3a1401e139d8c9cc..a4060f0668bc9179fa60789739ec4e874e43f414 100644
--- a/v4/gtk/gtkspinbutton.go
+++ b/v4/gtk/gtkspinbutton.go
@@ -517,6 +517,134 @@ func (c *SpinButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The adjustment that holds the value of the spin button.
+
+func (x *SpinButton) SetPropertyAdjustment(value *Adjustment) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("adjustment", &v)
+}
+
+func (x *SpinButton) GetPropertyAdjustment() *Adjustment {
+	var v gobject.Value
+	x.GetProperty("adjustment", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Adjustment{}
+	result.Ptr = ptr
+	return result
+}
+
+// The acceleration rate when you hold down a button or key.
+
+func (x *SpinButton) SetPropertyClimbRate(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("climb-rate", &v)
+}
+
+func (x *SpinButton) GetPropertyClimbRate() float64 {
+	var v gobject.Value
+	x.GetProperty("climb-rate", &v)
+	return v.GetDouble()
+}
+
+// The number of decimal places to display.
+
+func (x *SpinButton) SetPropertyDigits(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("digits", &v)
+}
+
+func (x *SpinButton) GetPropertyDigits() uint {
+	var v gobject.Value
+	x.GetProperty("digits", &v)
+	return v.GetUint()
+}
+
+// Whether non-numeric characters should be ignored.
+
+func (x *SpinButton) SetPropertyNumeric(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("numeric", &v)
+}
+
+func (x *SpinButton) GetPropertyNumeric() bool {
+	var v gobject.Value
+	x.GetProperty("numeric", &v)
+	return v.GetBoolean()
+}
+
+// Whether erroneous values are automatically changed to the spin buttons
+// nearest step increment.
+
+func (x *SpinButton) SetPropertySnapToTicks(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("snap-to-ticks", &v)
+}
+
+func (x *SpinButton) GetPropertySnapToTicks() bool {
+	var v gobject.Value
+	x.GetProperty("snap-to-ticks", &v)
+	return v.GetBoolean()
+}
+
+// Whether the spin button should update always, or only when the value
+// is acceptable.
+
+func (x *SpinButton) SetPropertyUpdatePolicy(value SpinButtonUpdatePolicy) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("update-policy", &v)
+}
+
+func (x *SpinButton) GetPropertyUpdatePolicy() SpinButtonUpdatePolicy {
+	var v gobject.Value
+	x.GetProperty("update-policy", &v)
+	return SpinButtonUpdatePolicy(v.GetEnum())
+}
+
+// The current value.
+
+func (x *SpinButton) SetPropertyValue(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("value", &v)
+}
+
+func (x *SpinButton) GetPropertyValue() float64 {
+	var v gobject.Value
+	x.GetProperty("value", &v)
+	return v.GetDouble()
+}
+
+// Whether a spin button should wrap upon reaching its limits.
+
+func (x *SpinButton) SetPropertyWrap(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("wrap", &v)
+}
+
+func (x *SpinButton) GetPropertyWrap() bool {
+	var v gobject.Value
+	x.GetProperty("wrap", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when the user initiates a value change.
 //
 // This is a [keybinding signal](class.SignalAction.html).
diff --git a/v4/gtk/gtkspinner.go b/v4/gtk/gtkspinner.go
index 596a9376539a3198180bbc493259deeed5707045..15ed8da43b164464702ef7d9377aefc360f0816f 100644
--- a/v4/gtk/gtkspinner.go
+++ b/v4/gtk/gtkspinner.go
@@ -103,6 +103,21 @@ func (c *Spinner) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the spinner is spinning
+
+func (x *Spinner) SetPropertySpinning(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("spinning", &v)
+}
+
+func (x *Spinner) GetPropertySpinning() bool {
+	var v gobject.Value
+	x.GetProperty("spinning", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Spinner) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkstack.go b/v4/gtk/gtkstack.go
index c90631dda66e4daefb94912b95f6eb396af332a6..5343a2e57398a530322012c9325ad9ea6db1a05f 100644
--- a/v4/gtk/gtkstack.go
+++ b/v4/gtk/gtkstack.go
@@ -486,6 +486,139 @@ func (c *Stack) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// %TRUE if the stack allocates the same width for all children.
+
+func (x *Stack) SetPropertyHhomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("hhomogeneous", &v)
+}
+
+func (x *Stack) GetPropertyHhomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("hhomogeneous", &v)
+	return v.GetBoolean()
+}
+
+// Whether or not the size should smoothly change during the transition.
+
+func (x *Stack) SetPropertyInterpolateSize(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("interpolate-size", &v)
+}
+
+func (x *Stack) GetPropertyInterpolateSize() bool {
+	var v gobject.Value
+	x.GetProperty("interpolate-size", &v)
+	return v.GetBoolean()
+}
+
+// A selection model with the stack pages.
+
+func (x *Stack) GetPropertyPages() SelectionModel {
+	var v gobject.Value
+	x.GetProperty("pages", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &SelectionModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The animation duration, in milliseconds.
+
+func (x *Stack) SetPropertyTransitionDuration(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("transition-duration", &v)
+}
+
+func (x *Stack) GetPropertyTransitionDuration() uint {
+	var v gobject.Value
+	x.GetProperty("transition-duration", &v)
+	return v.GetUint()
+}
+
+// Whether or not the transition is currently running.
+
+func (x *Stack) GetPropertyTransitionRunning() bool {
+	var v gobject.Value
+	x.GetProperty("transition-running", &v)
+	return v.GetBoolean()
+}
+
+// The type of animation used to transition.
+
+func (x *Stack) SetPropertyTransitionType(value StackTransitionType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("transition-type", &v)
+}
+
+func (x *Stack) GetPropertyTransitionType() StackTransitionType {
+	var v gobject.Value
+	x.GetProperty("transition-type", &v)
+	return StackTransitionType(v.GetEnum())
+}
+
+// %TRUE if the stack allocates the same height for all children.
+
+func (x *Stack) SetPropertyVhomogeneous(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("vhomogeneous", &v)
+}
+
+func (x *Stack) GetPropertyVhomogeneous() bool {
+	var v gobject.Value
+	x.GetProperty("vhomogeneous", &v)
+	return v.GetBoolean()
+}
+
+// The widget currently visible in the stack.
+
+func (x *Stack) SetPropertyVisibleChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("visible-child", &v)
+}
+
+func (x *Stack) GetPropertyVisibleChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("visible-child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The name of the widget currently visible in the stack.
+
+func (x *Stack) SetPropertyVisibleChildName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("visible-child-name", &v)
+}
+
+func (x *Stack) GetPropertyVisibleChildName() string {
+	var v gobject.Value
+	x.GetProperty("visible-child-name", &v)
+	return v.GetString()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Stack) GetAccessibleRole() AccessibleRole {
 
@@ -783,6 +916,121 @@ }
 
 func (c *StackPage) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The child that this page is for.
+
+func (x *StackPage) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *StackPage) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The icon name of the child page.
+
+func (x *StackPage) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *StackPage) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// The name of the child page.
+
+func (x *StackPage) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *StackPage) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// Whether the page requires the user attention.
+//
+// This is used by the [class@Gtk.StackSwitcher] to change the
+// appearance of the corresponding button when a page needs
+// attention and it is not the current one.
+
+func (x *StackPage) SetPropertyNeedsAttention(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("needs-attention", &v)
+}
+
+func (x *StackPage) GetPropertyNeedsAttention() bool {
+	var v gobject.Value
+	x.GetProperty("needs-attention", &v)
+	return v.GetBoolean()
+}
+
+// The title of the child page.
+
+func (x *StackPage) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *StackPage) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// If set, an underline in the title indicates a mnemonic.
+
+func (x *StackPage) SetPropertyUseUnderline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-underline", &v)
+}
+
+func (x *StackPage) GetPropertyUseUnderline() bool {
+	var v gobject.Value
+	x.GetProperty("use-underline", &v)
+	return v.GetBoolean()
+}
+
+// Whether this page is visible.
+
+func (x *StackPage) SetPropertyVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("visible", &v)
+}
+
+func (x *StackPage) GetPropertyVisible() bool {
+	var v gobject.Value
+	x.GetProperty("visible", &v)
+	return v.GetBoolean()
 }
 
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
diff --git a/v4/gtk/gtkstacksidebar.go b/v4/gtk/gtkstacksidebar.go
index 5b27336605d053cfadd54025c97440f0326b2a58..dfd946be7e9a5174f6c1bafdefccd98e9e661daa 100644
--- a/v4/gtk/gtkstacksidebar.go
+++ b/v4/gtk/gtkstacksidebar.go
@@ -96,6 +96,27 @@ func (c *StackSidebar) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The stack.
+
+func (x *StackSidebar) SetPropertyStack(value *Stack) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("stack", &v)
+}
+
+func (x *StackSidebar) GetPropertyStack() *Stack {
+	var v gobject.Value
+	x.GetProperty("stack", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Stack{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *StackSidebar) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkstackswitcher.go b/v4/gtk/gtkstackswitcher.go
index baf6c3b8ef4555f349a9c261b050c8c8ad99a1ab..22060738d02d01552e7cb2c8c332c9430b7c193a 100644
--- a/v4/gtk/gtkstackswitcher.go
+++ b/v4/gtk/gtkstackswitcher.go
@@ -111,6 +111,27 @@ func (c *StackSwitcher) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The stack.
+
+func (x *StackSwitcher) SetPropertyStack(value *Stack) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("stack", &v)
+}
+
+func (x *StackSwitcher) GetPropertyStack() *Stack {
+	var v gobject.Value
+	x.GetProperty("stack", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Stack{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *StackSwitcher) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkstringfilter.go b/v4/gtk/gtkstringfilter.go
index 16b8847461a8d0a628ae5598f7ec6c718aa16608..b04faf36e03d051761e41bc41787747e73594869 100644
--- a/v4/gtk/gtkstringfilter.go
+++ b/v4/gtk/gtkstringfilter.go
@@ -186,6 +186,72 @@ func (c *StringFilter) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The expression to evaluate on item to get a string to compare with.
+
+func (x *StringFilter) SetPropertyExpression(value *Expression) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("expression", &v)
+}
+
+func (x *StringFilter) GetPropertyExpression() *Expression {
+	var v gobject.Value
+	x.GetProperty("expression", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Expression{}
+	result.Ptr = ptr
+	return result
+}
+
+// If matching is case sensitive.
+
+func (x *StringFilter) SetPropertyIgnoreCase(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("ignore-case", &v)
+}
+
+func (x *StringFilter) GetPropertyIgnoreCase() bool {
+	var v gobject.Value
+	x.GetProperty("ignore-case", &v)
+	return v.GetBoolean()
+}
+
+// If exact matches are necessary or if substrings are allowed.
+
+func (x *StringFilter) SetPropertyMatchMode(value StringFilterMatchMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("match-mode", &v)
+}
+
+func (x *StringFilter) GetPropertyMatchMode() StringFilterMatchMode {
+	var v gobject.Value
+	x.GetProperty("match-mode", &v)
+	return StringFilterMatchMode(v.GetEnum())
+}
+
+// The search term.
+
+func (x *StringFilter) SetPropertySearch(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("search", &v)
+}
+
+func (x *StringFilter) GetPropertySearch() string {
+	var v gobject.Value
+	x.GetProperty("search", &v)
+	return v.GetString()
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkstringlist.go b/v4/gtk/gtkstringlist.go
index e4751b9bb2b38f4a273d0a37c92f1dc34e3819df..42bbcd7ed9a36e5435160ded96fe6618bc28c37d 100644
--- a/v4/gtk/gtkstringlist.go
+++ b/v4/gtk/gtkstringlist.go
@@ -335,6 +335,14 @@ func (c *StringObject) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The string.
+
+func (x *StringObject) GetPropertyString() string {
+	var v gobject.Value
+	x.GetProperty("string", &v)
+	return v.GetString()
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkstringsorter.go b/v4/gtk/gtkstringsorter.go
index 1871f4730d90b9d794443e7c32359470491904bb..730c78b9829eb1d916ac947c5311fa67b7f5a266 100644
--- a/v4/gtk/gtkstringsorter.go
+++ b/v4/gtk/gtkstringsorter.go
@@ -122,6 +122,42 @@ func (c *StringSorter) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The expression to evaluate on item to get a string to compare with.
+
+func (x *StringSorter) SetPropertyExpression(value *Expression) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("expression", &v)
+}
+
+func (x *StringSorter) GetPropertyExpression() *Expression {
+	var v gobject.Value
+	x.GetProperty("expression", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Expression{}
+	result.Ptr = ptr
+	return result
+}
+
+// If matching is case sensitive.
+
+func (x *StringSorter) SetPropertyIgnoreCase(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("ignore-case", &v)
+}
+
+func (x *StringSorter) GetPropertyIgnoreCase() bool {
+	var v gobject.Value
+	x.GetProperty("ignore-case", &v)
+	return v.GetBoolean()
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtkstylecontext.go b/v4/gtk/gtkstylecontext.go
index 7d80bfb51535a8e564c4847dcfacfa7bd5fb6bb3..95420366b08ac8044ba3a2504ca3bdb61d158062 100644
--- a/v4/gtk/gtkstylecontext.go
+++ b/v4/gtk/gtkstylecontext.go
@@ -473,6 +473,25 @@ func (c *StyleContext) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *StyleContext) SetPropertyDisplay(value *gdk.Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *StyleContext) GetPropertyDisplay() *gdk.Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Display{}
+	result.Ptr = ptr
+	return result
+}
+
 var xStyleContextAddProviderForDisplay func(uintptr, uintptr, uint)
 
 // Adds a global style provider to @display, which will be used
diff --git a/v4/gtk/gtkswitch.go b/v4/gtk/gtkswitch.go
index ddff9eb668fdb719f5323a5bc4b813cf6af0aabc..49a12e324b90a0d469d5c3f81e32ca999d954d62 100644
--- a/v4/gtk/gtkswitch.go
+++ b/v4/gtk/gtkswitch.go
@@ -123,6 +123,38 @@ func (c *Switch) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the `GtkSwitch` widget is in its on or off state.
+
+func (x *Switch) SetPropertyActive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("active", &v)
+}
+
+func (x *Switch) GetPropertyActive() bool {
+	var v gobject.Value
+	x.GetProperty("active", &v)
+	return v.GetBoolean()
+}
+
+// The backend state that is controlled by the switch.
+//
+// See [signal@GtkSwitch::state-set] for details.
+
+func (x *Switch) SetPropertyState(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("state", &v)
+}
+
+func (x *Switch) GetPropertyState() bool {
+	var v gobject.Value
+	x.GetProperty("state", &v)
+	return v.GetBoolean()
+}
+
 // Emitted to animate the switch.
 //
 // Applications should never connect to this signal,
diff --git a/v4/gtk/gtktext.go b/v4/gtk/gtktext.go
index b5f49968dc93ad8b87d9a60f86ff36b4d4c5b0e2..709e8428e41b7ca6062765e6304cac051df52f02 100644
--- a/v4/gtk/gtktext.go
+++ b/v4/gtk/gtktext.go
@@ -551,6 +551,304 @@ func (c *Text) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to activate the default widget when Enter is pressed.
+
+func (x *Text) SetPropertyActivatesDefault(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activates-default", &v)
+}
+
+func (x *Text) GetPropertyActivatesDefault() bool {
+	var v gobject.Value
+	x.GetProperty("activates-default", &v)
+	return v.GetBoolean()
+}
+
+// A list of Pango attributes to apply to the text of the `GtkText`.
+//
+// This is mainly useful to change the size or weight of the text.
+//
+// The `PangoAttribute`'s @start_index and @end_index must refer to the
+// `GtkEntryBuffer` text, i.e. without the preedit string.
+
+func (x *Text) SetPropertyAttributes(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("attributes", &v)
+}
+
+func (x *Text) GetPropertyAttributes() uintptr {
+	var v gobject.Value
+	x.GetProperty("attributes", &v)
+	return v.GetPointer()
+}
+
+// The `GtkEntryBuffer` object which stores the text.
+
+func (x *Text) SetPropertyBuffer(value *EntryBuffer) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("buffer", &v)
+}
+
+func (x *Text) GetPropertyBuffer() *EntryBuffer {
+	var v gobject.Value
+	x.GetProperty("buffer", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &EntryBuffer{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to suggest Emoji replacements.
+
+func (x *Text) SetPropertyEnableEmojiCompletion(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-emoji-completion", &v)
+}
+
+func (x *Text) GetPropertyEnableEmojiCompletion() bool {
+	var v gobject.Value
+	x.GetProperty("enable-emoji-completion", &v)
+	return v.GetBoolean()
+}
+
+// A menu model whose contents will be appended to
+// the context menu.
+
+func (x *Text) SetPropertyExtraMenu(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("extra-menu", &v)
+}
+
+func (x *Text) GetPropertyExtraMenu() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("extra-menu", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// Which IM (input method) module should be used for this self.
+//
+// See [class@Gtk.IMMulticontext].
+//
+// Setting this to a non-%NULL value overrides the system-wide
+// IM module setting. See the [property@Gtk.Settings:gtk-im-module]
+// property.
+
+func (x *Text) SetPropertyImModule(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("im-module", &v)
+}
+
+func (x *Text) GetPropertyImModule() string {
+	var v gobject.Value
+	x.GetProperty("im-module", &v)
+	return v.GetString()
+}
+
+// Additional hints that allow input methods to fine-tune
+// their behaviour.
+
+func (x *Text) SetPropertyInputHints(value InputHints) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("input-hints", &v)
+}
+
+func (x *Text) GetPropertyInputHints() InputHints {
+	var v gobject.Value
+	x.GetProperty("input-hints", &v)
+	return InputHints(v.GetFlags())
+}
+
+// The purpose of this text field.
+//
+// This property can be used by on-screen keyboards and other input
+// methods to adjust their behaviour.
+//
+// Note that setting the purpose to %GTK_INPUT_PURPOSE_PASSWORD or
+// %GTK_INPUT_PURPOSE_PIN is independent from setting
+// [property@Gtk.Text:visibility].
+
+func (x *Text) SetPropertyInputPurpose(value InputPurpose) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("input-purpose", &v)
+}
+
+func (x *Text) GetPropertyInputPurpose() InputPurpose {
+	var v gobject.Value
+	x.GetProperty("input-purpose", &v)
+	return InputPurpose(v.GetEnum())
+}
+
+// The character to used when masking contents (in âpassword modeâ).
+
+func (x *Text) SetPropertyInvisibleChar(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("invisible-char", &v)
+}
+
+func (x *Text) GetPropertyInvisibleChar() uint {
+	var v gobject.Value
+	x.GetProperty("invisible-char", &v)
+	return v.GetUint()
+}
+
+// Whether the invisible char has been set for the `GtkText`.
+
+func (x *Text) SetPropertyInvisibleCharSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("invisible-char-set", &v)
+}
+
+func (x *Text) GetPropertyInvisibleCharSet() bool {
+	var v gobject.Value
+	x.GetProperty("invisible-char-set", &v)
+	return v.GetBoolean()
+}
+
+// Maximum number of characters that are allowed.
+//
+// Zero indicates no limit.
+
+func (x *Text) SetPropertyMaxLength(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-length", &v)
+}
+
+func (x *Text) GetPropertyMaxLength() int {
+	var v gobject.Value
+	x.GetProperty("max-length", &v)
+	return v.GetInt()
+}
+
+// If text is overwritten when typing in the `GtkText`.
+
+func (x *Text) SetPropertyOverwriteMode(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("overwrite-mode", &v)
+}
+
+func (x *Text) GetPropertyOverwriteMode() bool {
+	var v gobject.Value
+	x.GetProperty("overwrite-mode", &v)
+	return v.GetBoolean()
+}
+
+// The text that will be displayed in the `GtkText` when it is empty
+// and unfocused.
+
+func (x *Text) SetPropertyPlaceholderText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("placeholder-text", &v)
+}
+
+func (x *Text) GetPropertyPlaceholderText() string {
+	var v gobject.Value
+	x.GetProperty("placeholder-text", &v)
+	return v.GetString()
+}
+
+// Whether the widget should grow and shrink with the content.
+
+func (x *Text) SetPropertyPropagateTextWidth(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("propagate-text-width", &v)
+}
+
+func (x *Text) GetPropertyPropagateTextWidth() bool {
+	var v gobject.Value
+	x.GetProperty("propagate-text-width", &v)
+	return v.GetBoolean()
+}
+
+// Number of pixels scrolled of the screen to the left.
+
+func (x *Text) GetPropertyScrollOffset() int {
+	var v gobject.Value
+	x.GetProperty("scroll-offset", &v)
+	return v.GetInt()
+}
+
+// A list of tabstops to apply to the text of the `GtkText`.
+
+func (x *Text) SetPropertyTabs(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("tabs", &v)
+}
+
+func (x *Text) GetPropertyTabs() uintptr {
+	var v gobject.Value
+	x.GetProperty("tabs", &v)
+	return v.GetPointer()
+}
+
+// When %TRUE, pasted multi-line text is truncated to the first line.
+
+func (x *Text) SetPropertyTruncateMultiline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("truncate-multiline", &v)
+}
+
+func (x *Text) GetPropertyTruncateMultiline() bool {
+	var v gobject.Value
+	x.GetProperty("truncate-multiline", &v)
+	return v.GetBoolean()
+}
+
+// If %FALSE, the text is masked with the âinvisible charâ.
+
+func (x *Text) SetPropertyVisibility(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("visibility", &v)
+}
+
+func (x *Text) GetPropertyVisibility() bool {
+	var v gobject.Value
+	x.GetProperty("visibility", &v)
+	return v.GetBoolean()
+}
+
 // Emitted when the user hits the Enter key.
 //
 // The default bindings for this signal are all forms
diff --git a/v4/gtk/gtktextbuffer.go b/v4/gtk/gtktextbuffer.go
index 5a87e7e622e865a4dfa27ee45438d5a893c12457..3f97732f8cd063e2f017ac7306de58c6f7b2d076 100644
--- a/v4/gtk/gtktextbuffer.go
+++ b/v4/gtk/gtktextbuffer.go
@@ -1635,6 +1635,95 @@ func (c *TextBuffer) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Denotes that the buffer can reapply the last undone action.
+
+func (x *TextBuffer) GetPropertyCanRedo() bool {
+	var v gobject.Value
+	x.GetProperty("can-redo", &v)
+	return v.GetBoolean()
+}
+
+// Denotes that the buffer can undo the last applied action.
+
+func (x *TextBuffer) GetPropertyCanUndo() bool {
+	var v gobject.Value
+	x.GetProperty("can-undo", &v)
+	return v.GetBoolean()
+}
+
+// The position of the insert mark.
+//
+// This is an offset from the beginning of the buffer.
+// It is useful for getting notified when the cursor moves.
+
+func (x *TextBuffer) GetPropertyCursorPosition() int {
+	var v gobject.Value
+	x.GetProperty("cursor-position", &v)
+	return v.GetInt()
+}
+
+// Denotes if support for undoing and redoing changes to the buffer is allowed.
+
+func (x *TextBuffer) SetPropertyEnableUndo(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-undo", &v)
+}
+
+func (x *TextBuffer) GetPropertyEnableUndo() bool {
+	var v gobject.Value
+	x.GetProperty("enable-undo", &v)
+	return v.GetBoolean()
+}
+
+// Whether the buffer has some text currently selected.
+
+func (x *TextBuffer) GetPropertyHasSelection() bool {
+	var v gobject.Value
+	x.GetProperty("has-selection", &v)
+	return v.GetBoolean()
+}
+
+// The GtkTextTagTable for the buffer.
+
+func (x *TextBuffer) SetPropertyTagTable(value *TextTagTable) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("tag-table", &v)
+}
+
+func (x *TextBuffer) GetPropertyTagTable() *TextTagTable {
+	var v gobject.Value
+	x.GetProperty("tag-table", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TextTagTable{}
+	result.Ptr = ptr
+	return result
+}
+
+// The text content of the buffer.
+//
+// Without child widgets and images,
+// see [method@Gtk.TextBuffer.get_text] for more information.
+
+func (x *TextBuffer) SetPropertyText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("text", &v)
+}
+
+func (x *TextBuffer) GetPropertyText() string {
+	var v gobject.Value
+	x.GetProperty("text", &v)
+	return v.GetString()
+}
+
 // Emitted to apply a tag to a range of text in a `GtkTextBuffer`.
 //
 // Applying actually occurs in the default handler.
diff --git a/v4/gtk/gtktextmark.go b/v4/gtk/gtktextmark.go
index 0256e69d591d5a4da652f8777a569472ea7d0bf9..e35f7bf1944b798203d7b967d90b27d78fdd0fe2 100644
--- a/v4/gtk/gtktextmark.go
+++ b/v4/gtk/gtktextmark.go
@@ -179,6 +179,40 @@ func (c *TextMark) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the mark has left gravity.
+//
+// When text is inserted at the markâs current location, if the mark
+// has left gravity it will be moved to the left of the newly-inserted
+// text, otherwise to the right.
+
+func (x *TextMark) SetPropertyLeftGravity(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("left-gravity", &v)
+}
+
+func (x *TextMark) GetPropertyLeftGravity() bool {
+	var v gobject.Value
+	x.GetProperty("left-gravity", &v)
+	return v.GetBoolean()
+}
+
+// The name of the mark or %NULL if the mark is anonymous.
+
+func (x *TextMark) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *TextMark) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtktexttag.go b/v4/gtk/gtktexttag.go
index 48eebf3bd15aaee7ee3ef8187376c011b2422bf6..00bfc78a043df061b1c389b9f88a7e9ae670f8ca 100644
--- a/v4/gtk/gtktexttag.go
+++ b/v4/gtk/gtktexttag.go
@@ -9,6 +9,7 @@ 	"github.com/jwijenbergh/purego"
 	"github.com/jwijenbergh/puregotk/pkg/core"
 	"github.com/jwijenbergh/puregotk/v4/gobject"
 	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/pango"
 )
 
 type TextTagClass struct {
@@ -134,6 +135,1290 @@ }
 
 func (c *TextTag) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// Whether the margins accumulate or override each other.
+//
+// When set to %TRUE the margins of this tag are added to the margins
+// of any other non-accumulative margins present. When set to %FALSE
+// the margins override one another (the default).
+
+func (x *TextTag) SetPropertyAccumulativeMargin(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("accumulative-margin", &v)
+}
+
+func (x *TextTag) GetPropertyAccumulativeMargin() bool {
+	var v gobject.Value
+	x.GetProperty("accumulative-margin", &v)
+	return v.GetBoolean()
+}
+
+// Whether breaks are allowed.
+
+func (x *TextTag) SetPropertyAllowBreaks(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-breaks", &v)
+}
+
+func (x *TextTag) GetPropertyAllowBreaks() bool {
+	var v gobject.Value
+	x.GetProperty("allow-breaks", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextTag) SetPropertyAllowBreaksSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-breaks-set", &v)
+}
+
+func (x *TextTag) GetPropertyAllowBreaksSet() bool {
+	var v gobject.Value
+	x.GetProperty("allow-breaks-set", &v)
+	return v.GetBoolean()
+}
+
+// Background color as a string.
+
+func (x *TextTag) SetPropertyBackground(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("background", &v)
+}
+
+// Whether the background color fills the entire line height
+// or only the height of the tagged characters.
+
+func (x *TextTag) SetPropertyBackgroundFullHeight(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("background-full-height", &v)
+}
+
+func (x *TextTag) GetPropertyBackgroundFullHeight() bool {
+	var v gobject.Value
+	x.GetProperty("background-full-height", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextTag) SetPropertyBackgroundFullHeightSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("background-full-height-set", &v)
+}
+
+func (x *TextTag) GetPropertyBackgroundFullHeightSet() bool {
+	var v gobject.Value
+	x.GetProperty("background-full-height-set", &v)
+	return v.GetBoolean()
+}
+
+// Background color as a `GdkRGBA`.
+
+func (x *TextTag) SetPropertyBackgroundRgba(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("background-rgba", &v)
+}
+
+func (x *TextTag) GetPropertyBackgroundRgba() uintptr {
+	var v gobject.Value
+	x.GetProperty("background-rgba", &v)
+	return v.GetPointer()
+}
+
+func (x *TextTag) SetPropertyBackgroundSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("background-set", &v)
+}
+
+func (x *TextTag) GetPropertyBackgroundSet() bool {
+	var v gobject.Value
+	x.GetProperty("background-set", &v)
+	return v.GetBoolean()
+}
+
+// Text direction, e.g. right-to-left or left-to-right.
+
+func (x *TextTag) SetPropertyDirection(value TextDirection) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("direction", &v)
+}
+
+func (x *TextTag) GetPropertyDirection() TextDirection {
+	var v gobject.Value
+	x.GetProperty("direction", &v)
+	return TextDirection(v.GetEnum())
+}
+
+// Whether the text can be modified by the user.
+
+func (x *TextTag) SetPropertyEditable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("editable", &v)
+}
+
+func (x *TextTag) GetPropertyEditable() bool {
+	var v gobject.Value
+	x.GetProperty("editable", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextTag) SetPropertyEditableSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("editable-set", &v)
+}
+
+func (x *TextTag) GetPropertyEditableSet() bool {
+	var v gobject.Value
+	x.GetProperty("editable-set", &v)
+	return v.GetBoolean()
+}
+
+// Whether font fallback is enabled.
+//
+// When set to %TRUE, other fonts will be substituted
+// where the current font is missing glyphs.
+
+func (x *TextTag) SetPropertyFallback(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("fallback", &v)
+}
+
+func (x *TextTag) GetPropertyFallback() bool {
+	var v gobject.Value
+	x.GetProperty("fallback", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextTag) SetPropertyFallbackSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("fallback-set", &v)
+}
+
+func (x *TextTag) GetPropertyFallbackSet() bool {
+	var v gobject.Value
+	x.GetProperty("fallback-set", &v)
+	return v.GetBoolean()
+}
+
+// Name of the font family, e.g. Sans, Helvetica, Times, Monospace.
+
+func (x *TextTag) SetPropertyFamily(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("family", &v)
+}
+
+func (x *TextTag) GetPropertyFamily() string {
+	var v gobject.Value
+	x.GetProperty("family", &v)
+	return v.GetString()
+}
+
+func (x *TextTag) SetPropertyFamilySet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("family-set", &v)
+}
+
+func (x *TextTag) GetPropertyFamilySet() bool {
+	var v gobject.Value
+	x.GetProperty("family-set", &v)
+	return v.GetBoolean()
+}
+
+// Font description as string, e.g. \"Sans Italic 12\".
+//
+// Note that the initial value of this property depends on
+// the internals of `PangoFontDescription`.
+
+func (x *TextTag) SetPropertyFont(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("font", &v)
+}
+
+func (x *TextTag) GetPropertyFont() string {
+	var v gobject.Value
+	x.GetProperty("font", &v)
+	return v.GetString()
+}
+
+// Font description as a `PangoFontDescription`.
+
+func (x *TextTag) SetPropertyFontDesc(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("font-desc", &v)
+}
+
+func (x *TextTag) GetPropertyFontDesc() uintptr {
+	var v gobject.Value
+	x.GetProperty("font-desc", &v)
+	return v.GetPointer()
+}
+
+// OpenType font features, as a string.
+
+func (x *TextTag) SetPropertyFontFeatures(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("font-features", &v)
+}
+
+func (x *TextTag) GetPropertyFontFeatures() string {
+	var v gobject.Value
+	x.GetProperty("font-features", &v)
+	return v.GetString()
+}
+
+func (x *TextTag) SetPropertyFontFeaturesSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("font-features-set", &v)
+}
+
+func (x *TextTag) GetPropertyFontFeaturesSet() bool {
+	var v gobject.Value
+	x.GetProperty("font-features-set", &v)
+	return v.GetBoolean()
+}
+
+// Foreground color as a string.
+
+func (x *TextTag) SetPropertyForeground(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("foreground", &v)
+}
+
+// Foreground color as a `GdkRGBA`.
+
+func (x *TextTag) SetPropertyForegroundRgba(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("foreground-rgba", &v)
+}
+
+func (x *TextTag) GetPropertyForegroundRgba() uintptr {
+	var v gobject.Value
+	x.GetProperty("foreground-rgba", &v)
+	return v.GetPointer()
+}
+
+func (x *TextTag) SetPropertyForegroundSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("foreground-set", &v)
+}
+
+func (x *TextTag) GetPropertyForegroundSet() bool {
+	var v gobject.Value
+	x.GetProperty("foreground-set", &v)
+	return v.GetBoolean()
+}
+
+// Amount to indent the paragraph, in pixels.
+
+func (x *TextTag) SetPropertyIndent(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("indent", &v)
+}
+
+func (x *TextTag) GetPropertyIndent() int {
+	var v gobject.Value
+	x.GetProperty("indent", &v)
+	return v.GetInt()
+}
+
+func (x *TextTag) SetPropertyIndentSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("indent-set", &v)
+}
+
+func (x *TextTag) GetPropertyIndentSet() bool {
+	var v gobject.Value
+	x.GetProperty("indent-set", &v)
+	return v.GetBoolean()
+}
+
+// Whether to insert hyphens at breaks.
+
+func (x *TextTag) SetPropertyInsertHyphens(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("insert-hyphens", &v)
+}
+
+func (x *TextTag) GetPropertyInsertHyphens() bool {
+	var v gobject.Value
+	x.GetProperty("insert-hyphens", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextTag) SetPropertyInsertHyphensSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("insert-hyphens-set", &v)
+}
+
+func (x *TextTag) GetPropertyInsertHyphensSet() bool {
+	var v gobject.Value
+	x.GetProperty("insert-hyphens-set", &v)
+	return v.GetBoolean()
+}
+
+// Whether this text is hidden.
+//
+// Note that there may still be problems with the support for invisible
+// text, in particular when navigating programmatically inside a buffer
+// containing invisible segments.
+
+func (x *TextTag) SetPropertyInvisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("invisible", &v)
+}
+
+func (x *TextTag) GetPropertyInvisible() bool {
+	var v gobject.Value
+	x.GetProperty("invisible", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextTag) SetPropertyInvisibleSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("invisible-set", &v)
+}
+
+func (x *TextTag) GetPropertyInvisibleSet() bool {
+	var v gobject.Value
+	x.GetProperty("invisible-set", &v)
+	return v.GetBoolean()
+}
+
+// Left, right, or center justification.
+
+func (x *TextTag) SetPropertyJustification(value Justification) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("justification", &v)
+}
+
+func (x *TextTag) GetPropertyJustification() Justification {
+	var v gobject.Value
+	x.GetProperty("justification", &v)
+	return Justification(v.GetEnum())
+}
+
+func (x *TextTag) SetPropertyJustificationSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("justification-set", &v)
+}
+
+func (x *TextTag) GetPropertyJustificationSet() bool {
+	var v gobject.Value
+	x.GetProperty("justification-set", &v)
+	return v.GetBoolean()
+}
+
+// The language this text is in, as an ISO code.
+//
+// Pango can use this as a hint when rendering the text.
+// If not set, an appropriate default will be used.
+//
+// Note that the initial value of this property depends
+// on the current locale, see also [func@Gtk.get_default_language].
+
+func (x *TextTag) SetPropertyLanguage(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("language", &v)
+}
+
+func (x *TextTag) GetPropertyLanguage() string {
+	var v gobject.Value
+	x.GetProperty("language", &v)
+	return v.GetString()
+}
+
+func (x *TextTag) SetPropertyLanguageSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("language-set", &v)
+}
+
+func (x *TextTag) GetPropertyLanguageSet() bool {
+	var v gobject.Value
+	x.GetProperty("language-set", &v)
+	return v.GetBoolean()
+}
+
+// Width of the left margin in pixels.
+
+func (x *TextTag) SetPropertyLeftMargin(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("left-margin", &v)
+}
+
+func (x *TextTag) GetPropertyLeftMargin() int {
+	var v gobject.Value
+	x.GetProperty("left-margin", &v)
+	return v.GetInt()
+}
+
+func (x *TextTag) SetPropertyLeftMarginSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("left-margin-set", &v)
+}
+
+func (x *TextTag) GetPropertyLeftMarginSet() bool {
+	var v gobject.Value
+	x.GetProperty("left-margin-set", &v)
+	return v.GetBoolean()
+}
+
+// Extra spacing between graphemes, in Pango units.
+
+func (x *TextTag) SetPropertyLetterSpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("letter-spacing", &v)
+}
+
+func (x *TextTag) GetPropertyLetterSpacing() int {
+	var v gobject.Value
+	x.GetProperty("letter-spacing", &v)
+	return v.GetInt()
+}
+
+func (x *TextTag) SetPropertyLetterSpacingSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("letter-spacing-set", &v)
+}
+
+func (x *TextTag) GetPropertyLetterSpacingSet() bool {
+	var v gobject.Value
+	x.GetProperty("letter-spacing-set", &v)
+	return v.GetBoolean()
+}
+
+// Factor to scale line height by.
+
+func (x *TextTag) SetPropertyLineHeight(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("line-height", &v)
+}
+
+func (x *TextTag) GetPropertyLineHeight() float32 {
+	var v gobject.Value
+	x.GetProperty("line-height", &v)
+	return v.GetFloat()
+}
+
+func (x *TextTag) SetPropertyLineHeightSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("line-height-set", &v)
+}
+
+func (x *TextTag) GetPropertyLineHeightSet() bool {
+	var v gobject.Value
+	x.GetProperty("line-height-set", &v)
+	return v.GetBoolean()
+}
+
+// The name used to refer to the tag.
+//
+// %NULL for anonymous tags.
+
+func (x *TextTag) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *TextTag) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// Style of overline for this text.
+
+func (x *TextTag) SetPropertyOverline(value pango.Overline) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("overline", &v)
+}
+
+func (x *TextTag) GetPropertyOverline() pango.Overline {
+	var v gobject.Value
+	x.GetProperty("overline", &v)
+	return pango.Overline(v.GetEnum())
+}
+
+// This property modifies the color of overlines.
+//
+// If not set, overlines will use the foreground color.
+
+func (x *TextTag) SetPropertyOverlineRgba(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("overline-rgba", &v)
+}
+
+func (x *TextTag) GetPropertyOverlineRgba() uintptr {
+	var v gobject.Value
+	x.GetProperty("overline-rgba", &v)
+	return v.GetPointer()
+}
+
+func (x *TextTag) SetPropertyOverlineRgbaSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("overline-rgba-set", &v)
+}
+
+func (x *TextTag) GetPropertyOverlineRgbaSet() bool {
+	var v gobject.Value
+	x.GetProperty("overline-rgba-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextTag) SetPropertyOverlineSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("overline-set", &v)
+}
+
+func (x *TextTag) GetPropertyOverlineSet() bool {
+	var v gobject.Value
+	x.GetProperty("overline-set", &v)
+	return v.GetBoolean()
+}
+
+// The paragraph background color as a string.
+
+func (x *TextTag) SetPropertyParagraphBackground(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("paragraph-background", &v)
+}
+
+// The paragraph background color as a `GdkRGBA`.
+
+func (x *TextTag) SetPropertyParagraphBackgroundRgba(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("paragraph-background-rgba", &v)
+}
+
+func (x *TextTag) GetPropertyParagraphBackgroundRgba() uintptr {
+	var v gobject.Value
+	x.GetProperty("paragraph-background-rgba", &v)
+	return v.GetPointer()
+}
+
+func (x *TextTag) SetPropertyParagraphBackgroundSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("paragraph-background-set", &v)
+}
+
+func (x *TextTag) GetPropertyParagraphBackgroundSet() bool {
+	var v gobject.Value
+	x.GetProperty("paragraph-background-set", &v)
+	return v.GetBoolean()
+}
+
+// Pixels of blank space above paragraphs.
+
+func (x *TextTag) SetPropertyPixelsAboveLines(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("pixels-above-lines", &v)
+}
+
+func (x *TextTag) GetPropertyPixelsAboveLines() int {
+	var v gobject.Value
+	x.GetProperty("pixels-above-lines", &v)
+	return v.GetInt()
+}
+
+func (x *TextTag) SetPropertyPixelsAboveLinesSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("pixels-above-lines-set", &v)
+}
+
+func (x *TextTag) GetPropertyPixelsAboveLinesSet() bool {
+	var v gobject.Value
+	x.GetProperty("pixels-above-lines-set", &v)
+	return v.GetBoolean()
+}
+
+// Pixels of blank space below paragraphs.
+
+func (x *TextTag) SetPropertyPixelsBelowLines(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("pixels-below-lines", &v)
+}
+
+func (x *TextTag) GetPropertyPixelsBelowLines() int {
+	var v gobject.Value
+	x.GetProperty("pixels-below-lines", &v)
+	return v.GetInt()
+}
+
+func (x *TextTag) SetPropertyPixelsBelowLinesSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("pixels-below-lines-set", &v)
+}
+
+func (x *TextTag) GetPropertyPixelsBelowLinesSet() bool {
+	var v gobject.Value
+	x.GetProperty("pixels-below-lines-set", &v)
+	return v.GetBoolean()
+}
+
+// Pixels of blank space between wrapped lines in a paragraph.
+
+func (x *TextTag) SetPropertyPixelsInsideWrap(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("pixels-inside-wrap", &v)
+}
+
+func (x *TextTag) GetPropertyPixelsInsideWrap() int {
+	var v gobject.Value
+	x.GetProperty("pixels-inside-wrap", &v)
+	return v.GetInt()
+}
+
+func (x *TextTag) SetPropertyPixelsInsideWrapSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("pixels-inside-wrap-set", &v)
+}
+
+func (x *TextTag) GetPropertyPixelsInsideWrapSet() bool {
+	var v gobject.Value
+	x.GetProperty("pixels-inside-wrap-set", &v)
+	return v.GetBoolean()
+}
+
+// Width of the right margin, in pixels.
+
+func (x *TextTag) SetPropertyRightMargin(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("right-margin", &v)
+}
+
+func (x *TextTag) GetPropertyRightMargin() int {
+	var v gobject.Value
+	x.GetProperty("right-margin", &v)
+	return v.GetInt()
+}
+
+func (x *TextTag) SetPropertyRightMarginSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("right-margin-set", &v)
+}
+
+func (x *TextTag) GetPropertyRightMarginSet() bool {
+	var v gobject.Value
+	x.GetProperty("right-margin-set", &v)
+	return v.GetBoolean()
+}
+
+// Offset of text above the baseline, in Pango units.
+//
+// Negative values go below the baseline.
+
+func (x *TextTag) SetPropertyRise(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("rise", &v)
+}
+
+func (x *TextTag) GetPropertyRise() int {
+	var v gobject.Value
+	x.GetProperty("rise", &v)
+	return v.GetInt()
+}
+
+func (x *TextTag) SetPropertyRiseSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("rise-set", &v)
+}
+
+func (x *TextTag) GetPropertyRiseSet() bool {
+	var v gobject.Value
+	x.GetProperty("rise-set", &v)
+	return v.GetBoolean()
+}
+
+// Font size as a scale factor relative to the default font size.
+//
+// This properly adapts to theme changes, etc. so is recommended.
+// Pango predefines some scales such as %PANGO_SCALE_X_LARGE.
+
+func (x *TextTag) SetPropertyScale(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("scale", &v)
+}
+
+func (x *TextTag) GetPropertyScale() float64 {
+	var v gobject.Value
+	x.GetProperty("scale", &v)
+	return v.GetDouble()
+}
+
+func (x *TextTag) SetPropertyScaleSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("scale-set", &v)
+}
+
+func (x *TextTag) GetPropertyScaleSet() bool {
+	var v gobject.Value
+	x.GetProperty("scale-set", &v)
+	return v.GetBoolean()
+}
+
+// Whether this tag represents a single sentence.
+//
+// This affects cursor movement.
+
+func (x *TextTag) SetPropertySentence(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("sentence", &v)
+}
+
+func (x *TextTag) GetPropertySentence() bool {
+	var v gobject.Value
+	x.GetProperty("sentence", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextTag) SetPropertySentenceSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("sentence-set", &v)
+}
+
+func (x *TextTag) GetPropertySentenceSet() bool {
+	var v gobject.Value
+	x.GetProperty("sentence-set", &v)
+	return v.GetBoolean()
+}
+
+// How to render invisible characters.
+
+func (x *TextTag) SetPropertyShowSpaces(value pango.ShowFlags) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("show-spaces", &v)
+}
+
+func (x *TextTag) GetPropertyShowSpaces() pango.ShowFlags {
+	var v gobject.Value
+	x.GetProperty("show-spaces", &v)
+	return pango.ShowFlags(v.GetFlags())
+}
+
+func (x *TextTag) SetPropertyShowSpacesSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-spaces-set", &v)
+}
+
+func (x *TextTag) GetPropertyShowSpacesSet() bool {
+	var v gobject.Value
+	x.GetProperty("show-spaces-set", &v)
+	return v.GetBoolean()
+}
+
+// Font size in Pango units.
+
+func (x *TextTag) SetPropertySize(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("size", &v)
+}
+
+func (x *TextTag) GetPropertySize() int {
+	var v gobject.Value
+	x.GetProperty("size", &v)
+	return v.GetInt()
+}
+
+// Font size in points.
+
+func (x *TextTag) SetPropertySizePoints(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("size-points", &v)
+}
+
+func (x *TextTag) GetPropertySizePoints() float64 {
+	var v gobject.Value
+	x.GetProperty("size-points", &v)
+	return v.GetDouble()
+}
+
+func (x *TextTag) SetPropertySizeSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("size-set", &v)
+}
+
+func (x *TextTag) GetPropertySizeSet() bool {
+	var v gobject.Value
+	x.GetProperty("size-set", &v)
+	return v.GetBoolean()
+}
+
+// Font stretch as a `PangoStretch`, e.g. %PANGO_STRETCH_CONDENSED.
+
+func (x *TextTag) SetPropertyStretch(value pango.Stretch) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("stretch", &v)
+}
+
+func (x *TextTag) GetPropertyStretch() pango.Stretch {
+	var v gobject.Value
+	x.GetProperty("stretch", &v)
+	return pango.Stretch(v.GetEnum())
+}
+
+func (x *TextTag) SetPropertyStretchSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("stretch-set", &v)
+}
+
+func (x *TextTag) GetPropertyStretchSet() bool {
+	var v gobject.Value
+	x.GetProperty("stretch-set", &v)
+	return v.GetBoolean()
+}
+
+// Whether to strike through the text.
+
+func (x *TextTag) SetPropertyStrikethrough(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("strikethrough", &v)
+}
+
+func (x *TextTag) GetPropertyStrikethrough() bool {
+	var v gobject.Value
+	x.GetProperty("strikethrough", &v)
+	return v.GetBoolean()
+}
+
+// This property modifies the color of strikeouts.
+//
+// If not set, strikeouts will use the foreground color.
+
+func (x *TextTag) SetPropertyStrikethroughRgba(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("strikethrough-rgba", &v)
+}
+
+func (x *TextTag) GetPropertyStrikethroughRgba() uintptr {
+	var v gobject.Value
+	x.GetProperty("strikethrough-rgba", &v)
+	return v.GetPointer()
+}
+
+// If the `strikethrough-rgba` property has been set.
+
+func (x *TextTag) SetPropertyStrikethroughRgbaSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("strikethrough-rgba-set", &v)
+}
+
+func (x *TextTag) GetPropertyStrikethroughRgbaSet() bool {
+	var v gobject.Value
+	x.GetProperty("strikethrough-rgba-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextTag) SetPropertyStrikethroughSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("strikethrough-set", &v)
+}
+
+func (x *TextTag) GetPropertyStrikethroughSet() bool {
+	var v gobject.Value
+	x.GetProperty("strikethrough-set", &v)
+	return v.GetBoolean()
+}
+
+// Font style as a `PangoStyle`, e.g. %PANGO_STYLE_ITALIC.
+
+func (x *TextTag) SetPropertyStyle(value pango.Style) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("style", &v)
+}
+
+func (x *TextTag) GetPropertyStyle() pango.Style {
+	var v gobject.Value
+	x.GetProperty("style", &v)
+	return pango.Style(v.GetEnum())
+}
+
+func (x *TextTag) SetPropertyStyleSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("style-set", &v)
+}
+
+func (x *TextTag) GetPropertyStyleSet() bool {
+	var v gobject.Value
+	x.GetProperty("style-set", &v)
+	return v.GetBoolean()
+}
+
+// Custom tabs for this text.
+
+func (x *TextTag) SetPropertyTabs(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("tabs", &v)
+}
+
+func (x *TextTag) GetPropertyTabs() uintptr {
+	var v gobject.Value
+	x.GetProperty("tabs", &v)
+	return v.GetPointer()
+}
+
+func (x *TextTag) SetPropertyTabsSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("tabs-set", &v)
+}
+
+func (x *TextTag) GetPropertyTabsSet() bool {
+	var v gobject.Value
+	x.GetProperty("tabs-set", &v)
+	return v.GetBoolean()
+}
+
+// How to transform the text for display.
+
+func (x *TextTag) SetPropertyTextTransform(value pango.TextTransform) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("text-transform", &v)
+}
+
+func (x *TextTag) GetPropertyTextTransform() pango.TextTransform {
+	var v gobject.Value
+	x.GetProperty("text-transform", &v)
+	return pango.TextTransform(v.GetEnum())
+}
+
+func (x *TextTag) SetPropertyTextTransformSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("text-transform-set", &v)
+}
+
+func (x *TextTag) GetPropertyTextTransformSet() bool {
+	var v gobject.Value
+	x.GetProperty("text-transform-set", &v)
+	return v.GetBoolean()
+}
+
+// Style of underline for this text.
+
+func (x *TextTag) SetPropertyUnderline(value pango.Underline) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("underline", &v)
+}
+
+func (x *TextTag) GetPropertyUnderline() pango.Underline {
+	var v gobject.Value
+	x.GetProperty("underline", &v)
+	return pango.Underline(v.GetEnum())
+}
+
+// This property modifies the color of underlines.
+//
+// If not set, underlines will use the foreground color.
+//
+// If [property@Gtk.TextTag:underline] is set to %PANGO_UNDERLINE_ERROR,
+// an alternate color may be applied instead of the foreground. Setting
+// this property will always override those defaults.
+
+func (x *TextTag) SetPropertyUnderlineRgba(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("underline-rgba", &v)
+}
+
+func (x *TextTag) GetPropertyUnderlineRgba() uintptr {
+	var v gobject.Value
+	x.GetProperty("underline-rgba", &v)
+	return v.GetPointer()
+}
+
+// If the `underline-rgba` property has been set.
+
+func (x *TextTag) SetPropertyUnderlineRgbaSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("underline-rgba-set", &v)
+}
+
+func (x *TextTag) GetPropertyUnderlineRgbaSet() bool {
+	var v gobject.Value
+	x.GetProperty("underline-rgba-set", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextTag) SetPropertyUnderlineSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("underline-set", &v)
+}
+
+func (x *TextTag) GetPropertyUnderlineSet() bool {
+	var v gobject.Value
+	x.GetProperty("underline-set", &v)
+	return v.GetBoolean()
+}
+
+// Font variant as a `PangoVariant`, e.g. %PANGO_VARIANT_SMALL_CAPS.
+
+func (x *TextTag) SetPropertyVariant(value pango.Variant) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("variant", &v)
+}
+
+func (x *TextTag) GetPropertyVariant() pango.Variant {
+	var v gobject.Value
+	x.GetProperty("variant", &v)
+	return pango.Variant(v.GetEnum())
+}
+
+func (x *TextTag) SetPropertyVariantSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("variant-set", &v)
+}
+
+func (x *TextTag) GetPropertyVariantSet() bool {
+	var v gobject.Value
+	x.GetProperty("variant-set", &v)
+	return v.GetBoolean()
+}
+
+// Font weight as an integer.
+
+func (x *TextTag) SetPropertyWeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("weight", &v)
+}
+
+func (x *TextTag) GetPropertyWeight() int {
+	var v gobject.Value
+	x.GetProperty("weight", &v)
+	return v.GetInt()
+}
+
+func (x *TextTag) SetPropertyWeightSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("weight-set", &v)
+}
+
+func (x *TextTag) GetPropertyWeightSet() bool {
+	var v gobject.Value
+	x.GetProperty("weight-set", &v)
+	return v.GetBoolean()
+}
+
+// Whether this tag represents a single word.
+//
+// This affects line breaks and cursor movement.
+
+func (x *TextTag) SetPropertyWord(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("word", &v)
+}
+
+func (x *TextTag) GetPropertyWord() bool {
+	var v gobject.Value
+	x.GetProperty("word", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextTag) SetPropertyWordSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("word-set", &v)
+}
+
+func (x *TextTag) GetPropertyWordSet() bool {
+	var v gobject.Value
+	x.GetProperty("word-set", &v)
+	return v.GetBoolean()
+}
+
+// Whether to wrap lines never, at word boundaries, or
+// at character boundaries.
+
+func (x *TextTag) SetPropertyWrapMode(value WrapMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("wrap-mode", &v)
+}
+
+func (x *TextTag) GetPropertyWrapMode() WrapMode {
+	var v gobject.Value
+	x.GetProperty("wrap-mode", &v)
+	return WrapMode(v.GetEnum())
+}
+
+func (x *TextTag) SetPropertyWrapModeSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("wrap-mode-set", &v)
+}
+
+func (x *TextTag) GetPropertyWrapModeSet() bool {
+	var v gobject.Value
+	x.GetProperty("wrap-mode-set", &v)
+	return v.GetBoolean()
 }
 
 func init() {
diff --git a/v4/gtk/gtktextview.go b/v4/gtk/gtktextview.go
index d4599f60be9bd5f8f6ff762a825939fddcf77c9a..742b040f0c9c23d016817a9ef385f7c8c3f16d27 100644
--- a/v4/gtk/gtktextview.go
+++ b/v4/gtk/gtktextview.go
@@ -1499,6 +1499,355 @@ func (c *TextView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether Tab will result in a tab character being entered.
+
+func (x *TextView) SetPropertyAcceptsTab(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("accepts-tab", &v)
+}
+
+func (x *TextView) GetPropertyAcceptsTab() bool {
+	var v gobject.Value
+	x.GetProperty("accepts-tab", &v)
+	return v.GetBoolean()
+}
+
+// The bottom margin for text in the text view.
+//
+// Note that this property is confusingly named. In CSS terms,
+// the value set here is padding, and it is applied in addition
+// to the padding from the theme.
+//
+// Don't confuse this property with [property@Gtk.Widget:margin-bottom].
+
+func (x *TextView) SetPropertyBottomMargin(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("bottom-margin", &v)
+}
+
+func (x *TextView) GetPropertyBottomMargin() int {
+	var v gobject.Value
+	x.GetProperty("bottom-margin", &v)
+	return v.GetInt()
+}
+
+// The buffer which is displayed.
+
+func (x *TextView) SetPropertyBuffer(value *TextBuffer) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("buffer", &v)
+}
+
+func (x *TextView) GetPropertyBuffer() *TextBuffer {
+	var v gobject.Value
+	x.GetProperty("buffer", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TextBuffer{}
+	result.Ptr = ptr
+	return result
+}
+
+// If the insertion cursor is shown.
+
+func (x *TextView) SetPropertyCursorVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("cursor-visible", &v)
+}
+
+func (x *TextView) GetPropertyCursorVisible() bool {
+	var v gobject.Value
+	x.GetProperty("cursor-visible", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextView) SetPropertyEditable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("editable", &v)
+}
+
+func (x *TextView) GetPropertyEditable() bool {
+	var v gobject.Value
+	x.GetProperty("editable", &v)
+	return v.GetBoolean()
+}
+
+// A menu model whose contents will be appended to the context menu.
+
+func (x *TextView) SetPropertyExtraMenu(value *gio.MenuModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("extra-menu", &v)
+}
+
+func (x *TextView) GetPropertyExtraMenu() *gio.MenuModel {
+	var v gobject.Value
+	x.GetProperty("extra-menu", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.MenuModel{}
+	result.Ptr = ptr
+	return result
+}
+
+// Which IM (input method) module should be used for this text_view.
+//
+// See [class@Gtk.IMMulticontext].
+//
+// Setting this to a non-%NULL value overrides the system-wide IM module
+// setting. See the GtkSettings [property@Gtk.Settings:gtk-im-module] property.
+
+func (x *TextView) SetPropertyImModule(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("im-module", &v)
+}
+
+func (x *TextView) GetPropertyImModule() string {
+	var v gobject.Value
+	x.GetProperty("im-module", &v)
+	return v.GetString()
+}
+
+// Amount to indent the paragraph, in pixels.
+
+func (x *TextView) SetPropertyIndent(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("indent", &v)
+}
+
+func (x *TextView) GetPropertyIndent() int {
+	var v gobject.Value
+	x.GetProperty("indent", &v)
+	return v.GetInt()
+}
+
+// Additional hints (beyond [property@Gtk.TextView:input-purpose])
+// that allow input methods to fine-tune their behaviour.
+
+func (x *TextView) SetPropertyInputHints(value InputHints) {
+	var v gobject.Value
+	v.Init(gobject.TypeFlagsVal)
+	v.SetFlags(uint(value))
+	x.SetProperty("input-hints", &v)
+}
+
+func (x *TextView) GetPropertyInputHints() InputHints {
+	var v gobject.Value
+	x.GetProperty("input-hints", &v)
+	return InputHints(v.GetFlags())
+}
+
+// The purpose of this text field.
+//
+// This property can be used by on-screen keyboards and other input
+// methods to adjust their behaviour.
+
+func (x *TextView) SetPropertyInputPurpose(value InputPurpose) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("input-purpose", &v)
+}
+
+func (x *TextView) GetPropertyInputPurpose() InputPurpose {
+	var v gobject.Value
+	x.GetProperty("input-purpose", &v)
+	return InputPurpose(v.GetEnum())
+}
+
+func (x *TextView) SetPropertyJustification(value Justification) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("justification", &v)
+}
+
+func (x *TextView) GetPropertyJustification() Justification {
+	var v gobject.Value
+	x.GetProperty("justification", &v)
+	return Justification(v.GetEnum())
+}
+
+// The default left margin for text in the text view.
+//
+// Tags in the buffer may override the default.
+//
+// Note that this property is confusingly named. In CSS terms,
+// the value set here is padding, and it is applied in addition
+// to the padding from the theme.
+
+func (x *TextView) SetPropertyLeftMargin(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("left-margin", &v)
+}
+
+func (x *TextView) GetPropertyLeftMargin() int {
+	var v gobject.Value
+	x.GetProperty("left-margin", &v)
+	return v.GetInt()
+}
+
+// Whether text should be displayed in a monospace font.
+//
+// If %TRUE, set the .monospace style class on the
+// text view to indicate that a monospace font is desired.
+
+func (x *TextView) SetPropertyMonospace(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("monospace", &v)
+}
+
+func (x *TextView) GetPropertyMonospace() bool {
+	var v gobject.Value
+	x.GetProperty("monospace", &v)
+	return v.GetBoolean()
+}
+
+// Whether entered text overwrites existing contents.
+
+func (x *TextView) SetPropertyOverwrite(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("overwrite", &v)
+}
+
+func (x *TextView) GetPropertyOverwrite() bool {
+	var v gobject.Value
+	x.GetProperty("overwrite", &v)
+	return v.GetBoolean()
+}
+
+func (x *TextView) SetPropertyPixelsAboveLines(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("pixels-above-lines", &v)
+}
+
+func (x *TextView) GetPropertyPixelsAboveLines() int {
+	var v gobject.Value
+	x.GetProperty("pixels-above-lines", &v)
+	return v.GetInt()
+}
+
+func (x *TextView) SetPropertyPixelsBelowLines(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("pixels-below-lines", &v)
+}
+
+func (x *TextView) GetPropertyPixelsBelowLines() int {
+	var v gobject.Value
+	x.GetProperty("pixels-below-lines", &v)
+	return v.GetInt()
+}
+
+func (x *TextView) SetPropertyPixelsInsideWrap(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("pixels-inside-wrap", &v)
+}
+
+func (x *TextView) GetPropertyPixelsInsideWrap() int {
+	var v gobject.Value
+	x.GetProperty("pixels-inside-wrap", &v)
+	return v.GetInt()
+}
+
+// The default right margin for text in the text view.
+//
+// Tags in the buffer may override the default.
+//
+// Note that this property is confusingly named. In CSS terms,
+// the value set here is padding, and it is applied in addition
+// to the padding from the theme.
+
+func (x *TextView) SetPropertyRightMargin(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("right-margin", &v)
+}
+
+func (x *TextView) GetPropertyRightMargin() int {
+	var v gobject.Value
+	x.GetProperty("right-margin", &v)
+	return v.GetInt()
+}
+
+func (x *TextView) SetPropertyTabs(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("tabs", &v)
+}
+
+func (x *TextView) GetPropertyTabs() uintptr {
+	var v gobject.Value
+	x.GetProperty("tabs", &v)
+	return v.GetPointer()
+}
+
+// The top margin for text in the text view.
+//
+// Note that this property is confusingly named. In CSS terms,
+// the value set here is padding, and it is applied in addition
+// to the padding from the theme.
+//
+// Don't confuse this property with [property@Gtk.Widget:margin-top].
+
+func (x *TextView) SetPropertyTopMargin(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("top-margin", &v)
+}
+
+func (x *TextView) GetPropertyTopMargin() int {
+	var v gobject.Value
+	x.GetProperty("top-margin", &v)
+	return v.GetInt()
+}
+
+func (x *TextView) SetPropertyWrapMode(value WrapMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("wrap-mode", &v)
+}
+
+func (x *TextView) GetPropertyWrapMode() WrapMode {
+	var v gobject.Value
+	x.GetProperty("wrap-mode", &v)
+	return WrapMode(v.GetEnum())
+}
+
 // Gets emitted when the user asks for it.
 //
 // The ::backspace signal is a [keybinding signal](class.SignalAction.html).
diff --git a/v4/gtk/gtktogglebutton.go b/v4/gtk/gtktogglebutton.go
index 7f96ea5afe37c2b0dde0cdd4ff1e3b64259daa53..51faee557230824ba1155118caf27869623d35a0 100644
--- a/v4/gtk/gtktogglebutton.go
+++ b/v4/gtk/gtktogglebutton.go
@@ -264,6 +264,30 @@ func (c *ToggleButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If the toggle button should be pressed in.
+
+func (x *ToggleButton) SetPropertyActive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("active", &v)
+}
+
+func (x *ToggleButton) GetPropertyActive() bool {
+	var v gobject.Value
+	x.GetProperty("active", &v)
+	return v.GetBoolean()
+}
+
+// The toggle button whose group this widget belongs to.
+
+func (x *ToggleButton) SetPropertyGroup(value *ToggleButton) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("group", &v)
+}
+
 // Emitted whenever the `GtkToggleButton`'s state is changed.
 func (x *ToggleButton) ConnectToggled(cb *func(ToggleButton)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gtk/gtktreeexpander.go b/v4/gtk/gtktreeexpander.go
index 080ca7b0077ea472f2ce124ca235d2eae8fe1183..f952f2423a149caca3083a33e1b5b8b67a46c9fe 100644
--- a/v4/gtk/gtktreeexpander.go
+++ b/v4/gtk/gtktreeexpander.go
@@ -196,6 +196,77 @@ func (c *TreeExpander) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget with the actual contents.
+
+func (x *TreeExpander) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *TreeExpander) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// TreeExpander indents the child by the width of an expander-icon if it is not expandable.
+
+func (x *TreeExpander) SetPropertyIndentForIcon(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("indent-for-icon", &v)
+}
+
+func (x *TreeExpander) GetPropertyIndentForIcon() bool {
+	var v gobject.Value
+	x.GetProperty("indent-for-icon", &v)
+	return v.GetBoolean()
+}
+
+// The item held by this expander's row.
+
+func (x *TreeExpander) GetPropertyItem() *gobject.Object {
+	var v gobject.Value
+	x.GetProperty("item", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gobject.Object{}
+	result.Ptr = ptr
+	return result
+}
+
+// The list row to track for expander state.
+
+func (x *TreeExpander) SetPropertyListRow(value *TreeListRow) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("list-row", &v)
+}
+
+func (x *TreeExpander) GetPropertyListRow() *TreeListRow {
+	var v gobject.Value
+	x.GetProperty("list-row", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TreeListRow{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *TreeExpander) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtktreelistmodel.go b/v4/gtk/gtktreelistmodel.go
index 4c3589675ae8593ccbd5930d7224e823bb65a8ee..4178fab4644e17bd4f1867d7041702019e8119ff 100644
--- a/v4/gtk/gtktreelistmodel.go
+++ b/v4/gtk/gtktreelistmodel.go
@@ -202,6 +202,70 @@ func (c *TreeListModel) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If all rows should be expanded by default.
+
+func (x *TreeListModel) SetPropertyAutoexpand(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("autoexpand", &v)
+}
+
+func (x *TreeListModel) GetPropertyAutoexpand() bool {
+	var v gobject.Value
+	x.GetProperty("autoexpand", &v)
+	return v.GetBoolean()
+}
+
+// The type of items. See [method@Gio.ListModel.get_item_type].
+
+func (x *TreeListModel) GetPropertyItemType() types.GType {
+	var v gobject.Value
+	x.GetProperty("item-type", &v)
+	return v.GetGtype()
+}
+
+// The root model displayed.
+
+func (x *TreeListModel) GetPropertyModel() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The number of items. See [method@Gio.ListModel.get_n_items].
+
+func (x *TreeListModel) GetPropertyNItems() uint {
+	var v gobject.Value
+	x.GetProperty("n-items", &v)
+	return v.GetUint()
+}
+
+// Gets whether the model is in passthrough mode.
+//
+// If %FALSE, the `GListModel` functions for this object return custom
+// [class@Gtk.TreeListRow] objects. If %TRUE, the values of the child
+// models are pass through unmodified.
+
+func (x *TreeListModel) SetPropertyPassthrough(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("passthrough", &v)
+}
+
+func (x *TreeListModel) GetPropertyPassthrough() bool {
+	var v gobject.Value
+	x.GetProperty("passthrough", &v)
+	return v.GetBoolean()
+}
+
 // Get the item at @position.
 //
 // If @position is greater than the number of items in @list, %NULL is
@@ -476,6 +540,65 @@ }
 
 func (c *TreeListRow) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
+}
+
+// The model holding the row's children.
+
+func (x *TreeListRow) GetPropertyChildren() gio.ListModel {
+	var v gobject.Value
+	x.GetProperty("children", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.ListModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The depth in the tree of this row.
+
+func (x *TreeListRow) GetPropertyDepth() uint {
+	var v gobject.Value
+	x.GetProperty("depth", &v)
+	return v.GetUint()
+}
+
+// If this row can ever be expanded.
+
+func (x *TreeListRow) GetPropertyExpandable() bool {
+	var v gobject.Value
+	x.GetProperty("expandable", &v)
+	return v.GetBoolean()
+}
+
+// If this row is currently expanded.
+
+func (x *TreeListRow) SetPropertyExpanded(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("expanded", &v)
+}
+
+func (x *TreeListRow) GetPropertyExpanded() bool {
+	var v gobject.Value
+	x.GetProperty("expanded", &v)
+	return v.GetBoolean()
+}
+
+// The item held in this row.
+
+func (x *TreeListRow) GetPropertyItem() *gobject.Object {
+	var v gobject.Value
+	x.GetProperty("item", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gobject.Object{}
+	result.Ptr = ptr
+	return result
 }
 
 func init() {
diff --git a/v4/gtk/gtktreelistrowsorter.go b/v4/gtk/gtktreelistrowsorter.go
index 0b5a70d87784963b24206e62f0ffcf20c096a566..86057656f7c5bd0f88802c596724ed41c61505a7 100644
--- a/v4/gtk/gtktreelistrowsorter.go
+++ b/v4/gtk/gtktreelistrowsorter.go
@@ -110,6 +110,27 @@ func (c *TreeListRowSorter) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The underlying sorter
+
+func (x *TreeListRowSorter) SetPropertySorter(value *Sorter) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("sorter", &v)
+}
+
+func (x *TreeListRowSorter) GetPropertySorter() *Sorter {
+	var v gobject.Value
+	x.GetProperty("sorter", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Sorter{}
+	result.Ptr = ptr
+	return result
+}
+
 func init() {
 
 	core.SetPackageName("GTK", "gtk4")
diff --git a/v4/gtk/gtktreemodelfilter.go b/v4/gtk/gtktreemodelfilter.go
index 69e57dea532b78adc430dc39acb58949869caaa3..cc9fb7285c407e5bd608110a8d95c1a5039b51ec 100644
--- a/v4/gtk/gtktreemodelfilter.go
+++ b/v4/gtk/gtktreemodelfilter.go
@@ -368,6 +368,38 @@ func (c *TreeModelFilter) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *TreeModelFilter) SetPropertyChildModel(value TreeModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child-model", &v)
+}
+
+func (x *TreeModelFilter) GetPropertyChildModel() TreeModel {
+	var v gobject.Value
+	x.GetProperty("child-model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TreeModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *TreeModelFilter) SetPropertyVirtualRoot(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetPointer(value)
+	x.SetProperty("virtual-root", &v)
+}
+
+func (x *TreeModelFilter) GetPropertyVirtualRoot() uintptr {
+	var v gobject.Value
+	x.GetProperty("virtual-root", &v)
+	return v.GetPointer()
+}
+
 // Asks the `GtkTreeDragSource` to delete the row at @path, because
 // it was moved somewhere else via drag-and-drop. Returns %FALSE
 // if the deletion fails because @path no longer exists, or for
diff --git a/v4/gtk/gtktreemodelsort.go b/v4/gtk/gtktreemodelsort.go
index 0af5805b670520ddf6b05c1a1413de5143f7c8b7..74c14fbdbc77422ceb81fd6172068d356f86495e 100644
--- a/v4/gtk/gtktreemodelsort.go
+++ b/v4/gtk/gtktreemodelsort.go
@@ -276,6 +276,25 @@ func (c *TreeModelSort) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *TreeModelSort) SetPropertyModel(value TreeModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *TreeModelSort) GetPropertyModel() TreeModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TreeModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
 // Asks the `GtkTreeDragSource` to delete the row at @path, because
 // it was moved somewhere else via drag-and-drop. Returns %FALSE
 // if the deletion fails because @path no longer exists, or for
diff --git a/v4/gtk/gtktreeselection.go b/v4/gtk/gtktreeselection.go
index 8bc013ef9c7175beb0349de8bc5bf8c46b400fca..8c2673326ca6d195d29aa09f422096068edc5f96 100644
--- a/v4/gtk/gtktreeselection.go
+++ b/v4/gtk/gtktreeselection.go
@@ -289,6 +289,22 @@ func (c *TreeSelection) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Selection mode.
+// See gtk_tree_selection_set_mode() for more information on this property.
+
+func (x *TreeSelection) SetPropertyMode(value SelectionMode) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("mode", &v)
+}
+
+func (x *TreeSelection) GetPropertyMode() SelectionMode {
+	var v gobject.Value
+	x.GetProperty("mode", &v)
+	return SelectionMode(v.GetEnum())
+}
+
 // Emitted whenever the selection has (possibly) changed. Please note that
 // this signal is mostly a hint.  It may only be emitted once when a range
 // of rows are selected, and it may occasionally be emitted when nothing
diff --git a/v4/gtk/gtktreeview.go b/v4/gtk/gtktreeview.go
index fafab6349704eb9bdb91ae1e6b7097116d286058..9a75e4e570e5f9be5bdb23f1fb0f02eba09c5289 100644
--- a/v4/gtk/gtktreeview.go
+++ b/v4/gtk/gtktreeview.go
@@ -1693,6 +1693,267 @@ func (c *TreeView) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The activate-on-single-click property specifies whether the "row-activated" signal
+// will be emitted after a single click.
+
+func (x *TreeView) SetPropertyActivateOnSingleClick(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("activate-on-single-click", &v)
+}
+
+func (x *TreeView) GetPropertyActivateOnSingleClick() bool {
+	var v gobject.Value
+	x.GetProperty("activate-on-single-click", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeView) SetPropertyEnableGridLines(value TreeViewGridLines) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("enable-grid-lines", &v)
+}
+
+func (x *TreeView) GetPropertyEnableGridLines() TreeViewGridLines {
+	var v gobject.Value
+	x.GetProperty("enable-grid-lines", &v)
+	return TreeViewGridLines(v.GetEnum())
+}
+
+func (x *TreeView) SetPropertyEnableSearch(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-search", &v)
+}
+
+func (x *TreeView) GetPropertyEnableSearch() bool {
+	var v gobject.Value
+	x.GetProperty("enable-search", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeView) SetPropertyEnableTreeLines(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-tree-lines", &v)
+}
+
+func (x *TreeView) GetPropertyEnableTreeLines() bool {
+	var v gobject.Value
+	x.GetProperty("enable-tree-lines", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeView) SetPropertyExpanderColumn(value *TreeViewColumn) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("expander-column", &v)
+}
+
+func (x *TreeView) GetPropertyExpanderColumn() *TreeViewColumn {
+	var v gobject.Value
+	x.GetProperty("expander-column", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TreeViewColumn{}
+	result.Ptr = ptr
+	return result
+}
+
+// Setting the ::fixed-height-mode property to %TRUE speeds up
+// `GtkTreeView` by assuming that all rows have the same height.
+// Only enable this option if all rows are the same height.
+// Please see gtk_tree_view_set_fixed_height_mode() for more
+// information on this option.
+
+func (x *TreeView) SetPropertyFixedHeightMode(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("fixed-height-mode", &v)
+}
+
+func (x *TreeView) GetPropertyFixedHeightMode() bool {
+	var v gobject.Value
+	x.GetProperty("fixed-height-mode", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeView) SetPropertyHeadersClickable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("headers-clickable", &v)
+}
+
+func (x *TreeView) GetPropertyHeadersClickable() bool {
+	var v gobject.Value
+	x.GetProperty("headers-clickable", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeView) SetPropertyHeadersVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("headers-visible", &v)
+}
+
+func (x *TreeView) GetPropertyHeadersVisible() bool {
+	var v gobject.Value
+	x.GetProperty("headers-visible", &v)
+	return v.GetBoolean()
+}
+
+// Enables or disables the hover expansion mode of @tree_view.
+// Hover expansion makes rows expand or collapse if the pointer moves
+// over them.
+//
+// This mode is primarily intended for treeviews in popups, e.g.
+// in `GtkComboBox` or `GtkEntryCompletion`.
+
+func (x *TreeView) SetPropertyHoverExpand(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("hover-expand", &v)
+}
+
+func (x *TreeView) GetPropertyHoverExpand() bool {
+	var v gobject.Value
+	x.GetProperty("hover-expand", &v)
+	return v.GetBoolean()
+}
+
+// Enables or disables the hover selection mode of @tree_view.
+// Hover selection makes the selected row follow the pointer.
+// Currently, this works only for the selection modes
+// %GTK_SELECTION_SINGLE and %GTK_SELECTION_BROWSE.
+//
+// This mode is primarily intended for treeviews in popups, e.g.
+// in `GtkComboBox` or `GtkEntryCompletion`.
+
+func (x *TreeView) SetPropertyHoverSelection(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("hover-selection", &v)
+}
+
+func (x *TreeView) GetPropertyHoverSelection() bool {
+	var v gobject.Value
+	x.GetProperty("hover-selection", &v)
+	return v.GetBoolean()
+}
+
+// Extra indentation for each level.
+
+func (x *TreeView) SetPropertyLevelIndentation(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("level-indentation", &v)
+}
+
+func (x *TreeView) GetPropertyLevelIndentation() int {
+	var v gobject.Value
+	x.GetProperty("level-indentation", &v)
+	return v.GetInt()
+}
+
+func (x *TreeView) SetPropertyModel(value TreeModel) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("model", &v)
+}
+
+func (x *TreeView) GetPropertyModel() TreeModel {
+	var v gobject.Value
+	x.GetProperty("model", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &TreeModelBase{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *TreeView) SetPropertyReorderable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reorderable", &v)
+}
+
+func (x *TreeView) GetPropertyReorderable() bool {
+	var v gobject.Value
+	x.GetProperty("reorderable", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeView) SetPropertyRubberBanding(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("rubber-banding", &v)
+}
+
+func (x *TreeView) GetPropertyRubberBanding() bool {
+	var v gobject.Value
+	x.GetProperty("rubber-banding", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeView) SetPropertySearchColumn(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("search-column", &v)
+}
+
+func (x *TreeView) GetPropertySearchColumn() int {
+	var v gobject.Value
+	x.GetProperty("search-column", &v)
+	return v.GetInt()
+}
+
+// %TRUE if the view has expanders.
+
+func (x *TreeView) SetPropertyShowExpanders(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("show-expanders", &v)
+}
+
+func (x *TreeView) GetPropertyShowExpanders() bool {
+	var v gobject.Value
+	x.GetProperty("show-expanders", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeView) SetPropertyTooltipColumn(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("tooltip-column", &v)
+}
+
+func (x *TreeView) GetPropertyTooltipColumn() int {
+	var v gobject.Value
+	x.GetProperty("tooltip-column", &v)
+	return v.GetInt()
+}
+
 // The number of columns of the treeview has changed.
 func (x *TreeView) ConnectColumnsChanged(cb *func(TreeView)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gtk/gtktreeviewcolumn.go b/v4/gtk/gtktreeviewcolumn.go
index d1ad9f07874366f3b849549ed8d51e4bacfae1b1..879420ad3e9a072698c5133c357832738c76825e 100644
--- a/v4/gtk/gtktreeviewcolumn.go
+++ b/v4/gtk/gtktreeviewcolumn.go
@@ -716,6 +716,259 @@ func (c *TreeViewColumn) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+func (x *TreeViewColumn) SetPropertyAlignment(value float32) {
+	var v gobject.Value
+	v.Init(gobject.TypeFloatVal)
+	v.SetFloat(value)
+	x.SetProperty("alignment", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyAlignment() float32 {
+	var v gobject.Value
+	x.GetProperty("alignment", &v)
+	return v.GetFloat()
+}
+
+// The `GtkCellArea` used to layout cell renderers for this column.
+//
+// If no area is specified when creating the tree view column with gtk_tree_view_column_new_with_area()
+// a horizontally oriented `GtkCellAreaBox` will be used.
+
+func (x *TreeViewColumn) SetPropertyCellArea(value *CellArea) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("cell-area", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyCellArea() *CellArea {
+	var v gobject.Value
+	x.GetProperty("cell-area", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &CellArea{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *TreeViewColumn) SetPropertyClickable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("clickable", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyClickable() bool {
+	var v gobject.Value
+	x.GetProperty("clickable", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeViewColumn) SetPropertyExpand(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("expand", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyExpand() bool {
+	var v gobject.Value
+	x.GetProperty("expand", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeViewColumn) SetPropertyFixedWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("fixed-width", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyFixedWidth() int {
+	var v gobject.Value
+	x.GetProperty("fixed-width", &v)
+	return v.GetInt()
+}
+
+func (x *TreeViewColumn) SetPropertyMaxWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-width", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyMaxWidth() int {
+	var v gobject.Value
+	x.GetProperty("max-width", &v)
+	return v.GetInt()
+}
+
+func (x *TreeViewColumn) SetPropertyMinWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("min-width", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyMinWidth() int {
+	var v gobject.Value
+	x.GetProperty("min-width", &v)
+	return v.GetInt()
+}
+
+func (x *TreeViewColumn) SetPropertyReorderable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("reorderable", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyReorderable() bool {
+	var v gobject.Value
+	x.GetProperty("reorderable", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeViewColumn) SetPropertyResizable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("resizable", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyResizable() bool {
+	var v gobject.Value
+	x.GetProperty("resizable", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeViewColumn) SetPropertySizing(value TreeViewColumnSizing) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("sizing", &v)
+}
+
+func (x *TreeViewColumn) GetPropertySizing() TreeViewColumnSizing {
+	var v gobject.Value
+	x.GetProperty("sizing", &v)
+	return TreeViewColumnSizing(v.GetEnum())
+}
+
+// Logical sort column ID this column sorts on when selected for sorting. Setting the sort column ID makes the column header
+// clickable. Set to -1 to make the column unsortable.
+
+func (x *TreeViewColumn) SetPropertySortColumnId(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("sort-column-id", &v)
+}
+
+func (x *TreeViewColumn) GetPropertySortColumnId() int {
+	var v gobject.Value
+	x.GetProperty("sort-column-id", &v)
+	return v.GetInt()
+}
+
+func (x *TreeViewColumn) SetPropertySortIndicator(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("sort-indicator", &v)
+}
+
+func (x *TreeViewColumn) GetPropertySortIndicator() bool {
+	var v gobject.Value
+	x.GetProperty("sort-indicator", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeViewColumn) SetPropertySortOrder(value SortType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("sort-order", &v)
+}
+
+func (x *TreeViewColumn) GetPropertySortOrder() SortType {
+	var v gobject.Value
+	x.GetProperty("sort-order", &v)
+	return SortType(v.GetEnum())
+}
+
+func (x *TreeViewColumn) SetPropertySpacing(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("spacing", &v)
+}
+
+func (x *TreeViewColumn) GetPropertySpacing() int {
+	var v gobject.Value
+	x.GetProperty("spacing", &v)
+	return v.GetInt()
+}
+
+func (x *TreeViewColumn) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+func (x *TreeViewColumn) SetPropertyVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("visible", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyVisible() bool {
+	var v gobject.Value
+	x.GetProperty("visible", &v)
+	return v.GetBoolean()
+}
+
+func (x *TreeViewColumn) SetPropertyWidget(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("widget", &v)
+}
+
+func (x *TreeViewColumn) GetPropertyWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+func (x *TreeViewColumn) GetPropertyWidth() int {
+	var v gobject.Value
+	x.GetProperty("width", &v)
+	return v.GetInt()
+}
+
+func (x *TreeViewColumn) GetPropertyXOffset() int {
+	var v gobject.Value
+	x.GetProperty("x-offset", &v)
+	return v.GetInt()
+}
+
 // Emitted when the column's header has been clicked.
 func (x *TreeViewColumn) ConnectClicked(cb *func(TreeViewColumn)) uint32 {
 	cbPtr := uintptr(unsafe.Pointer(cb))
diff --git a/v4/gtk/gtkvideo.go b/v4/gtk/gtkvideo.go
index 981d972aa561d6bb05630efdf3ecfff43a64b598..c9d89fd6040b6959d82decede573096af54dc01c 100644
--- a/v4/gtk/gtkvideo.go
+++ b/v4/gtk/gtkvideo.go
@@ -273,6 +273,78 @@ func (c *Video) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// If the video should automatically begin playing.
+
+func (x *Video) SetPropertyAutoplay(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("autoplay", &v)
+}
+
+func (x *Video) GetPropertyAutoplay() bool {
+	var v gobject.Value
+	x.GetProperty("autoplay", &v)
+	return v.GetBoolean()
+}
+
+// The file played by this video if the video is playing a file.
+
+func (x *Video) SetPropertyFile(value gio.File) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("file", &v)
+}
+
+func (x *Video) GetPropertyFile() gio.File {
+	var v gobject.Value
+	x.GetProperty("file", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gio.FileBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// If new media files should be set to loop.
+
+func (x *Video) SetPropertyLoop(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("loop", &v)
+}
+
+func (x *Video) GetPropertyLoop() bool {
+	var v gobject.Value
+	x.GetProperty("loop", &v)
+	return v.GetBoolean()
+}
+
+// The media-stream played
+
+func (x *Video) SetPropertyMediaStream(value *MediaStream) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("media-stream", &v)
+}
+
+func (x *Video) GetPropertyMediaStream() *MediaStream {
+	var v gobject.Value
+	x.GetProperty("media-stream", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &MediaStream{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Video) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkviewport.go b/v4/gtk/gtkviewport.go
index dc032a029396ca2c617f7d4b1171036ac7004f33..8790e9e5eaeb87b4c0ca16b45b2dcb30105bdab9 100644
--- a/v4/gtk/gtkviewport.go
+++ b/v4/gtk/gtkviewport.go
@@ -117,6 +117,46 @@ func (c *Viewport) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *Viewport) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *Viewport) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether to scroll when the focus changes.
+//
+// Before 4.6.2, this property was mistakenly defaulting to FALSE, so if your
+// code needs to work with older versions, consider setting it explicitly to
+// TRUE.
+
+func (x *Viewport) SetPropertyScrollToFocus(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("scroll-to-focus", &v)
+}
+
+func (x *Viewport) GetPropertyScrollToFocus() bool {
+	var v gobject.Value
+	x.GetProperty("scroll-to-focus", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *Viewport) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkvolumebutton.go b/v4/gtk/gtkvolumebutton.go
index 7130c3dc0de4f5f88736aa3e25bedae07178d000..115a779596d28ceaddb1a09ae868f0cdef36dae3 100644
--- a/v4/gtk/gtkvolumebutton.go
+++ b/v4/gtk/gtkvolumebutton.go
@@ -60,6 +60,24 @@ func (c *VolumeButton) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether to use symbolic icons as the icons.
+//
+// Note that if the symbolic icons are not available in your installed
+// theme, then the normal (potentially colorful) icons will be used.
+
+func (x *VolumeButton) SetPropertyUseSymbolic(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("use-symbolic", &v)
+}
+
+func (x *VolumeButton) GetPropertyUseSymbolic() bool {
+	var v gobject.Value
+	x.GetProperty("use-symbolic", &v)
+	return v.GetBoolean()
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *VolumeButton) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkwidget.go b/v4/gtk/gtkwidget.go
index 07244782018bc7c38116913d45cfba527fe04e13..f1d8100a307ce25bc089fba52fa6e27c3c224c22 100644
--- a/v4/gtk/gtkwidget.go
+++ b/v4/gtk/gtkwidget.go
@@ -4103,6 +4103,573 @@ func (c *Widget) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// Whether the widget or any of its descendents can accept
+// the input focus.
+//
+// This property is meant to be set by widget implementations,
+// typically in their instance init function.
+
+func (x *Widget) SetPropertyCanFocus(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-focus", &v)
+}
+
+func (x *Widget) GetPropertyCanFocus() bool {
+	var v gobject.Value
+	x.GetProperty("can-focus", &v)
+	return v.GetBoolean()
+}
+
+// Whether the widget can receive pointer events.
+
+func (x *Widget) SetPropertyCanTarget(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("can-target", &v)
+}
+
+func (x *Widget) GetPropertyCanTarget() bool {
+	var v gobject.Value
+	x.GetProperty("can-target", &v)
+	return v.GetBoolean()
+}
+
+// A list of css classes applied to this widget.
+
+func (x *Widget) SetPropertyCssClasses(value []string) {
+	// Slice/array properties not supported
+}
+
+func (x *Widget) GetPropertyCssClasses() []string {
+	var v gobject.Value
+	x.GetProperty("css-classes", &v)
+	return nil
+}
+
+// The name of this widget in the CSS tree.
+//
+// This property is meant to be set by widget implementations,
+// typically in their instance init function.
+
+func (x *Widget) SetPropertyCssName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("css-name", &v)
+}
+
+func (x *Widget) GetPropertyCssName() string {
+	var v gobject.Value
+	x.GetProperty("css-name", &v)
+	return v.GetString()
+}
+
+// The cursor used by @widget.
+
+func (x *Widget) SetPropertyCursor(value *gdk.Cursor) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("cursor", &v)
+}
+
+func (x *Widget) GetPropertyCursor() *gdk.Cursor {
+	var v gobject.Value
+	x.GetProperty("cursor", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Cursor{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the widget should grab focus when it is clicked with the mouse.
+//
+// This property is only relevant for widgets that can take focus.
+
+func (x *Widget) SetPropertyFocusOnClick(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("focus-on-click", &v)
+}
+
+func (x *Widget) GetPropertyFocusOnClick() bool {
+	var v gobject.Value
+	x.GetProperty("focus-on-click", &v)
+	return v.GetBoolean()
+}
+
+// Whether this widget itself will accept the input focus.
+
+func (x *Widget) SetPropertyFocusable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("focusable", &v)
+}
+
+func (x *Widget) GetPropertyFocusable() bool {
+	var v gobject.Value
+	x.GetProperty("focusable", &v)
+	return v.GetBoolean()
+}
+
+// How to distribute horizontal space if widget gets extra space.
+
+func (x *Widget) SetPropertyHalign(value Align) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("halign", &v)
+}
+
+func (x *Widget) GetPropertyHalign() Align {
+	var v gobject.Value
+	x.GetProperty("halign", &v)
+	return Align(v.GetEnum())
+}
+
+// Whether the widget is the default widget.
+
+func (x *Widget) GetPropertyHasDefault() bool {
+	var v gobject.Value
+	x.GetProperty("has-default", &v)
+	return v.GetBoolean()
+}
+
+// Whether the widget has the input focus.
+
+func (x *Widget) GetPropertyHasFocus() bool {
+	var v gobject.Value
+	x.GetProperty("has-focus", &v)
+	return v.GetBoolean()
+}
+
+// Enables or disables the emission of the ::query-tooltip signal on @widget.
+//
+// A value of %TRUE indicates that @widget can have a tooltip, in this case
+// the widget will be queried using [signal@Gtk.Widget::query-tooltip] to
+// determine whether it will provide a tooltip or not.
+
+func (x *Widget) SetPropertyHasTooltip(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("has-tooltip", &v)
+}
+
+func (x *Widget) GetPropertyHasTooltip() bool {
+	var v gobject.Value
+	x.GetProperty("has-tooltip", &v)
+	return v.GetBoolean()
+}
+
+// Override for height request of the widget.
+//
+// If this is -1, the natural request will be used.
+
+func (x *Widget) SetPropertyHeightRequest(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("height-request", &v)
+}
+
+func (x *Widget) GetPropertyHeightRequest() int {
+	var v gobject.Value
+	x.GetProperty("height-request", &v)
+	return v.GetInt()
+}
+
+// Whether to expand horizontally.
+
+func (x *Widget) SetPropertyHexpand(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("hexpand", &v)
+}
+
+func (x *Widget) GetPropertyHexpand() bool {
+	var v gobject.Value
+	x.GetProperty("hexpand", &v)
+	return v.GetBoolean()
+}
+
+// Whether to use the `hexpand` property.
+
+func (x *Widget) SetPropertyHexpandSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("hexpand-set", &v)
+}
+
+func (x *Widget) GetPropertyHexpandSet() bool {
+	var v gobject.Value
+	x.GetProperty("hexpand-set", &v)
+	return v.GetBoolean()
+}
+
+// The `GtkLayoutManager` instance to use to compute the preferred size
+// of the widget, and allocate its children.
+//
+// This property is meant to be set by widget implementations,
+// typically in their instance init function.
+
+func (x *Widget) SetPropertyLayoutManager(value *LayoutManager) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("layout-manager", &v)
+}
+
+func (x *Widget) GetPropertyLayoutManager() *LayoutManager {
+	var v gobject.Value
+	x.GetProperty("layout-manager", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &LayoutManager{}
+	result.Ptr = ptr
+	return result
+}
+
+// Margin on bottom side of widget.
+//
+// This property adds margin outside of the widget's normal size
+// request, the margin will be added in addition to the size from
+// [method@Gtk.Widget.set_size_request] for example.
+
+func (x *Widget) SetPropertyMarginBottom(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("margin-bottom", &v)
+}
+
+func (x *Widget) GetPropertyMarginBottom() int {
+	var v gobject.Value
+	x.GetProperty("margin-bottom", &v)
+	return v.GetInt()
+}
+
+// Margin on end of widget, horizontally.
+//
+// This property supports left-to-right and right-to-left text
+// directions.
+//
+// This property adds margin outside of the widget's normal size
+// request, the margin will be added in addition to the size from
+// [method@Gtk.Widget.set_size_request] for example.
+
+func (x *Widget) SetPropertyMarginEnd(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("margin-end", &v)
+}
+
+func (x *Widget) GetPropertyMarginEnd() int {
+	var v gobject.Value
+	x.GetProperty("margin-end", &v)
+	return v.GetInt()
+}
+
+// Margin on start of widget, horizontally.
+//
+// This property supports left-to-right and right-to-left text
+// directions.
+//
+// This property adds margin outside of the widget's normal size
+// request, the margin will be added in addition to the size from
+// [method@Gtk.Widget.set_size_request] for example.
+
+func (x *Widget) SetPropertyMarginStart(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("margin-start", &v)
+}
+
+func (x *Widget) GetPropertyMarginStart() int {
+	var v gobject.Value
+	x.GetProperty("margin-start", &v)
+	return v.GetInt()
+}
+
+// Margin on top side of widget.
+//
+// This property adds margin outside of the widget's normal size
+// request, the margin will be added in addition to the size from
+// [method@Gtk.Widget.set_size_request] for example.
+
+func (x *Widget) SetPropertyMarginTop(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("margin-top", &v)
+}
+
+func (x *Widget) GetPropertyMarginTop() int {
+	var v gobject.Value
+	x.GetProperty("margin-top", &v)
+	return v.GetInt()
+}
+
+// The name of the widget.
+
+func (x *Widget) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+func (x *Widget) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// The requested opacity of the widget.
+
+func (x *Widget) SetPropertyOpacity(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("opacity", &v)
+}
+
+func (x *Widget) GetPropertyOpacity() float64 {
+	var v gobject.Value
+	x.GetProperty("opacity", &v)
+	return v.GetDouble()
+}
+
+// How content outside the widget's content area is treated.
+//
+// This property is meant to be set by widget implementations,
+// typically in their instance init function.
+
+func (x *Widget) SetPropertyOverflow(value Overflow) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("overflow", &v)
+}
+
+func (x *Widget) GetPropertyOverflow() Overflow {
+	var v gobject.Value
+	x.GetProperty("overflow", &v)
+	return Overflow(v.GetEnum())
+}
+
+// The parent widget of this widget.
+
+func (x *Widget) GetPropertyParent() *Widget {
+	var v gobject.Value
+	x.GetProperty("parent", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the widget will receive the default action when it is focused.
+
+func (x *Widget) SetPropertyReceivesDefault(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("receives-default", &v)
+}
+
+func (x *Widget) GetPropertyReceivesDefault() bool {
+	var v gobject.Value
+	x.GetProperty("receives-default", &v)
+	return v.GetBoolean()
+}
+
+// The `GtkRoot` widget of the widget tree containing this widget.
+//
+// This will be %NULL if the widget is not contained in a root widget.
+
+func (x *Widget) GetPropertyRoot() Root {
+	var v gobject.Value
+	x.GetProperty("root", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &RootBase{}
+	result.Ptr = ptr
+	return result
+}
+
+// The scale factor of the widget.
+
+func (x *Widget) GetPropertyScaleFactor() int {
+	var v gobject.Value
+	x.GetProperty("scale-factor", &v)
+	return v.GetInt()
+}
+
+// Whether the widget responds to input.
+
+func (x *Widget) SetPropertySensitive(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("sensitive", &v)
+}
+
+func (x *Widget) GetPropertySensitive() bool {
+	var v gobject.Value
+	x.GetProperty("sensitive", &v)
+	return v.GetBoolean()
+}
+
+// Sets the text of tooltip to be the given string, which is marked up
+// with Pango markup.
+//
+// Also see [method@Gtk.Tooltip.set_markup].
+//
+// This is a convenience property which will take care of getting the
+// tooltip shown if the given string is not %NULL:
+// [property@Gtk.Widget:has-tooltip] will automatically be set to %TRUE
+// and there will be taken care of [signal@Gtk.Widget::query-tooltip] in
+// the default signal handler.
+//
+// Note that if both [property@Gtk.Widget:tooltip-text] and
+// [property@Gtk.Widget:tooltip-markup] are set, the last one wins.
+
+func (x *Widget) SetPropertyTooltipMarkup(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("tooltip-markup", &v)
+}
+
+func (x *Widget) GetPropertyTooltipMarkup() string {
+	var v gobject.Value
+	x.GetProperty("tooltip-markup", &v)
+	return v.GetString()
+}
+
+// Sets the text of tooltip to be the given string.
+//
+// Also see [method@Gtk.Tooltip.set_text].
+//
+// This is a convenience property which will take care of getting the
+// tooltip shown if the given string is not %NULL:
+// [property@Gtk.Widget:has-tooltip] will automatically be set to %TRUE
+// and there will be taken care of [signal@Gtk.Widget::query-tooltip] in
+// the default signal handler.
+//
+// Note that if both [property@Gtk.Widget:tooltip-text] and
+// [property@Gtk.Widget:tooltip-markup] are set, the last one wins.
+
+func (x *Widget) SetPropertyTooltipText(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("tooltip-text", &v)
+}
+
+func (x *Widget) GetPropertyTooltipText() string {
+	var v gobject.Value
+	x.GetProperty("tooltip-text", &v)
+	return v.GetString()
+}
+
+// How to distribute vertical space if widget gets extra space.
+
+func (x *Widget) SetPropertyValign(value Align) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("valign", &v)
+}
+
+func (x *Widget) GetPropertyValign() Align {
+	var v gobject.Value
+	x.GetProperty("valign", &v)
+	return Align(v.GetEnum())
+}
+
+// Whether to expand vertically.
+
+func (x *Widget) SetPropertyVexpand(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("vexpand", &v)
+}
+
+func (x *Widget) GetPropertyVexpand() bool {
+	var v gobject.Value
+	x.GetProperty("vexpand", &v)
+	return v.GetBoolean()
+}
+
+// Whether to use the `vexpand` property.
+
+func (x *Widget) SetPropertyVexpandSet(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("vexpand-set", &v)
+}
+
+func (x *Widget) GetPropertyVexpandSet() bool {
+	var v gobject.Value
+	x.GetProperty("vexpand-set", &v)
+	return v.GetBoolean()
+}
+
+// Whether the widget is visible.
+
+func (x *Widget) SetPropertyVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("visible", &v)
+}
+
+func (x *Widget) GetPropertyVisible() bool {
+	var v gobject.Value
+	x.GetProperty("visible", &v)
+	return v.GetBoolean()
+}
+
+// Override for width request of the widget.
+//
+// If this is -1, the natural request will be used.
+
+func (x *Widget) SetPropertyWidthRequest(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("width-request", &v)
+}
+
+func (x *Widget) GetPropertyWidthRequest() int {
+	var v gobject.Value
+	x.GetProperty("width-request", &v)
+	return v.GetInt()
+}
+
 // Signals that all holders of a reference to the widget should release
 // the reference that they hold.
 //
diff --git a/v4/gtk/gtkwidgetpaintable.go b/v4/gtk/gtkwidgetpaintable.go
index 154a30dcbb17496716bde7178cf0c179fc10af0f..fc3d80644ccf63a7bc73f7dfacc01a2fce5fcc70 100644
--- a/v4/gtk/gtkwidgetpaintable.go
+++ b/v4/gtk/gtkwidgetpaintable.go
@@ -111,6 +111,27 @@ func (c *WidgetPaintable) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The observed widget or %NULL if none.
+
+func (x *WidgetPaintable) SetPropertyWidget(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("widget", &v)
+}
+
+func (x *WidgetPaintable) GetPropertyWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
 // Compute a concrete size for the `GdkPaintable`.
 //
 // Applies the sizing algorithm outlined in the
diff --git a/v4/gtk/gtkwindow.go b/v4/gtk/gtkwindow.go
index 2afb10df9d5ff705fe8901f5926cea543e3b1a45..67f00594381097ba9ace95b41829454079386066 100644
--- a/v4/gtk/gtkwindow.go
+++ b/v4/gtk/gtkwindow.go
@@ -1085,6 +1085,424 @@ func (c *Window) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The `GtkApplication` associated with the window.
+//
+// The application will be kept alive for at least as long as it
+// has any windows associated with it (see g_application_hold()
+// for a way to keep it alive without windows).
+//
+// Normally, the connection between the application and the window
+// will remain until the window is destroyed, but you can explicitly
+// remove it by setting the :application property to %NULL.
+
+func (x *Window) SetPropertyApplication(value *Application) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("application", &v)
+}
+
+func (x *Window) GetPropertyApplication() *Application {
+	var v gobject.Value
+	x.GetProperty("application", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Application{}
+	result.Ptr = ptr
+	return result
+}
+
+// The child widget.
+
+func (x *Window) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *Window) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the window should have a frame (also known as *decorations*).
+
+func (x *Window) SetPropertyDecorated(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("decorated", &v)
+}
+
+func (x *Window) GetPropertyDecorated() bool {
+	var v gobject.Value
+	x.GetProperty("decorated", &v)
+	return v.GetBoolean()
+}
+
+// The default height of the window.
+
+func (x *Window) SetPropertyDefaultHeight(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("default-height", &v)
+}
+
+func (x *Window) GetPropertyDefaultHeight() int {
+	var v gobject.Value
+	x.GetProperty("default-height", &v)
+	return v.GetInt()
+}
+
+// The default widget.
+
+func (x *Window) SetPropertyDefaultWidget(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("default-widget", &v)
+}
+
+func (x *Window) GetPropertyDefaultWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("default-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The default width of the window.
+
+func (x *Window) SetPropertyDefaultWidth(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("default-width", &v)
+}
+
+func (x *Window) GetPropertyDefaultWidth() int {
+	var v gobject.Value
+	x.GetProperty("default-width", &v)
+	return v.GetInt()
+}
+
+// Whether the window frame should have a close button.
+
+func (x *Window) SetPropertyDeletable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("deletable", &v)
+}
+
+func (x *Window) GetPropertyDeletable() bool {
+	var v gobject.Value
+	x.GetProperty("deletable", &v)
+	return v.GetBoolean()
+}
+
+// If this window should be destroyed when the parent is destroyed.
+
+func (x *Window) SetPropertyDestroyWithParent(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("destroy-with-parent", &v)
+}
+
+func (x *Window) GetPropertyDestroyWithParent() bool {
+	var v gobject.Value
+	x.GetProperty("destroy-with-parent", &v)
+	return v.GetBoolean()
+}
+
+// The display that will display this window.
+
+func (x *Window) SetPropertyDisplay(value *gdk.Display) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("display", &v)
+}
+
+func (x *Window) GetPropertyDisplay() *gdk.Display {
+	var v gobject.Value
+	x.GetProperty("display", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &gdk.Display{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether 'focus rectangles' are currently visible in this window.
+//
+// This property is maintained by GTK based on user input
+// and should not be set by applications.
+
+func (x *Window) SetPropertyFocusVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("focus-visible", &v)
+}
+
+func (x *Window) GetPropertyFocusVisible() bool {
+	var v gobject.Value
+	x.GetProperty("focus-visible", &v)
+	return v.GetBoolean()
+}
+
+// The focus widget.
+
+func (x *Window) SetPropertyFocusWidget(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("focus-widget", &v)
+}
+
+func (x *Window) GetPropertyFocusWidget() *Widget {
+	var v gobject.Value
+	x.GetProperty("focus-widget", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// Whether the window is fullscreen.
+//
+// Setting this property is the equivalent of calling
+// [method@Gtk.Window.fullscreen] or [method@Gtk.Window.unfullscreen];
+// either operation is asynchronous, which means you will need to
+// connect to the ::notify signal in order to know whether the
+// operation was successful.
+
+func (x *Window) SetPropertyFullscreened(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("fullscreened", &v)
+}
+
+func (x *Window) GetPropertyFullscreened() bool {
+	var v gobject.Value
+	x.GetProperty("fullscreened", &v)
+	return v.GetBoolean()
+}
+
+// Whether the window frame should handle F10 for activating
+// menubars.
+
+func (x *Window) SetPropertyHandleMenubarAccel(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("handle-menubar-accel", &v)
+}
+
+func (x *Window) GetPropertyHandleMenubarAccel() bool {
+	var v gobject.Value
+	x.GetProperty("handle-menubar-accel", &v)
+	return v.GetBoolean()
+}
+
+// If this window should be hidden when the users clicks the close button.
+
+func (x *Window) SetPropertyHideOnClose(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("hide-on-close", &v)
+}
+
+func (x *Window) GetPropertyHideOnClose() bool {
+	var v gobject.Value
+	x.GetProperty("hide-on-close", &v)
+	return v.GetBoolean()
+}
+
+// Specifies the name of the themed icon to use as the window icon.
+//
+// See [class@Gtk.IconTheme] for more details.
+
+func (x *Window) SetPropertyIconName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("icon-name", &v)
+}
+
+func (x *Window) GetPropertyIconName() string {
+	var v gobject.Value
+	x.GetProperty("icon-name", &v)
+	return v.GetString()
+}
+
+// Whether the toplevel is the currently active window.
+
+func (x *Window) GetPropertyIsActive() bool {
+	var v gobject.Value
+	x.GetProperty("is-active", &v)
+	return v.GetBoolean()
+}
+
+// Whether the window is maximized.
+//
+// Setting this property is the equivalent of calling
+// [method@Gtk.Window.maximize] or [method@Gtk.Window.unmaximize];
+// either operation is asynchronous, which means you will need to
+// connect to the ::notify signal in order to know whether the
+// operation was successful.
+
+func (x *Window) SetPropertyMaximized(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("maximized", &v)
+}
+
+func (x *Window) GetPropertyMaximized() bool {
+	var v gobject.Value
+	x.GetProperty("maximized", &v)
+	return v.GetBoolean()
+}
+
+// Whether mnemonics are currently visible in this window.
+//
+// This property is maintained by GTK based on user input,
+// and should not be set by applications.
+
+func (x *Window) SetPropertyMnemonicsVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("mnemonics-visible", &v)
+}
+
+func (x *Window) GetPropertyMnemonicsVisible() bool {
+	var v gobject.Value
+	x.GetProperty("mnemonics-visible", &v)
+	return v.GetBoolean()
+}
+
+// If %TRUE, the window is modal.
+
+func (x *Window) SetPropertyModal(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("modal", &v)
+}
+
+func (x *Window) GetPropertyModal() bool {
+	var v gobject.Value
+	x.GetProperty("modal", &v)
+	return v.GetBoolean()
+}
+
+// If %TRUE, users can resize the window.
+
+func (x *Window) SetPropertyResizable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("resizable", &v)
+}
+
+func (x *Window) GetPropertyResizable() bool {
+	var v gobject.Value
+	x.GetProperty("resizable", &v)
+	return v.GetBoolean()
+}
+
+// A write-only property for setting window's startup notification identifier.
+
+func (x *Window) SetPropertyStartupId(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("startup-id", &v)
+}
+
+// The title of the window.
+
+func (x *Window) SetPropertyTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("title", &v)
+}
+
+func (x *Window) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// The titlebar widget.
+
+func (x *Window) SetPropertyTitlebar(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("titlebar", &v)
+}
+
+func (x *Window) GetPropertyTitlebar() *Widget {
+	var v gobject.Value
+	x.GetProperty("titlebar", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
+// The transient parent of the window.
+
+func (x *Window) SetPropertyTransientFor(value *Window) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("transient-for", &v)
+}
+
+func (x *Window) GetPropertyTransientFor() *Window {
+	var v gobject.Value
+	x.GetProperty("transient-for", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Window{}
+	result.Ptr = ptr
+	return result
+}
+
 // Emitted when the user activates the default widget
 // of @window.
 //
diff --git a/v4/gtk/gtkwindowcontrols.go b/v4/gtk/gtkwindowcontrols.go
index 2078ee27c57c3d1ab31300fc6f98f8117ff42569..7331bbb5a9ff87b6044a0d7a8e8f2929f3eaa236 100644
--- a/v4/gtk/gtkwindowcontrols.go
+++ b/v4/gtk/gtkwindowcontrols.go
@@ -178,6 +178,49 @@ func (c *WindowControls) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The decoration layout for window buttons.
+//
+// If this property is not set, the
+// [property@Gtk.Settings:gtk-decoration-layout] setting is used.
+
+func (x *WindowControls) SetPropertyDecorationLayout(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("decoration-layout", &v)
+}
+
+func (x *WindowControls) GetPropertyDecorationLayout() string {
+	var v gobject.Value
+	x.GetProperty("decoration-layout", &v)
+	return v.GetString()
+}
+
+// Whether the widget has any window buttons.
+
+func (x *WindowControls) GetPropertyEmpty() bool {
+	var v gobject.Value
+	x.GetProperty("empty", &v)
+	return v.GetBoolean()
+}
+
+// Whether the widget shows start or end side of the decoration layout.
+//
+// See [property@Gtk.WindowControls:decoration_layout].
+
+func (x *WindowControls) SetPropertySide(value PackType) {
+	var v gobject.Value
+	v.Init(gobject.TypeEnumVal)
+	v.SetEnum(int(value))
+	x.SetProperty("side", &v)
+}
+
+func (x *WindowControls) GetPropertySide() PackType {
+	var v gobject.Value
+	x.GetProperty("side", &v)
+	return PackType(v.GetEnum())
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *WindowControls) GetAccessibleRole() AccessibleRole {
 
diff --git a/v4/gtk/gtkwindowhandle.go b/v4/gtk/gtkwindowhandle.go
index d8f1211be0a4648e0c474c138a7b41c980d3850b..e565d490a90b74f9bb5bcb90445a3cb21dee7cca 100644
--- a/v4/gtk/gtkwindowhandle.go
+++ b/v4/gtk/gtkwindowhandle.go
@@ -103,6 +103,27 @@ func (c *WindowHandle) SetGoPointer(ptr uintptr) {
 	c.Ptr = ptr
 }
 
+// The child widget.
+
+func (x *WindowHandle) SetPropertyChild(value *Widget) {
+	var v gobject.Value
+	v.Init(gobject.TypeObjectVal)
+	v.SetObject(&gobject.Object{Ptr: value.GoPointer()})
+	x.SetProperty("child", &v)
+}
+
+func (x *WindowHandle) GetPropertyChild() *Widget {
+	var v gobject.Value
+	x.GetProperty("child", &v)
+	ptr := v.GetObject().GoPointer()
+	if ptr == 0 {
+		return nil
+	}
+	result := &Widget{}
+	result.Ptr = ptr
+	return result
+}
+
 // Retrieves the `GtkAccessibleRole` for the given `GtkAccessible`.
 func (x *WindowHandle) GetAccessibleRole() AccessibleRole {
 

