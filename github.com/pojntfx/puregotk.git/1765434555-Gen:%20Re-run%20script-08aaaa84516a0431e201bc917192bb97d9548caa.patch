From 08aaaa84516a0431e201bc917192bb97d9548caa Mon Sep 17 00:00:00 2001
From: Felicitas Pojtinger <felicitas@pojtinger.com>
Date: Wed, 10 Dec 2025 22:29:15 -0800
Subject: [PATCH] Gen: Re-run script
---
diff --git a/v4/adw/adw-shortcut-label.go b/v4/adw/adw-shortcut-label.go
index 689203262ae59f0f287347cc4cc89082a2e0771a..10baede080699e58596560c8324ed4a94ad393c6 100644
--- a/v4/adw/adw-shortcut-label.go
+++ b/v4/adw/adw-shortcut-label.go
@@ -86,7 +86,7 @@ // labels separating them have the `.dimmed` style class.
 //
 // ## Accessibility
 //
-// `AdwShortcutLabel` uses the `GTK_ACCESSIBLE_ROLE_GENERIC` role.
+// `AdwShortcutLabel` uses the `GTK_ACCESSIBLE_ROLE_LABEL` role.
 //
 // See also: [class@ShortcutsDialog].
 type ShortcutLabel struct {
diff --git a/v4/adw/adw-version.go b/v4/adw/adw-version.go
index d1a9af118663df0422fbbed6e0c4bc95ebce7c11..76e7c07a1b8e34e9c8cde876c310e92950f79e58 100644
--- a/v4/adw/adw-version.go
+++ b/v4/adw/adw-version.go
@@ -10,12 +10,12 @@ const (
 	// Adwaita major version component (e.g. 1 if the version is 1.2.3).
 	MAJOR_VERSION int = 1
 	// Adwaita micro version component (e.g. 3 if the version is 1.2.3).
-	MICRO_VERSION int = 1
+	MICRO_VERSION int = 2
 	// Adwaita minor version component (e.g. 2 if the version is 1.2.3).
 	MINOR_VERSION int = 8
 	// Adwaita version, encoded as a string, useful for printing and
 	// concatenation.
-	VERSION_S string = "1.8.1"
+	VERSION_S string = "1.8.2"
 )
 
 var xGetMajorVersion func() uint
diff --git a/v4/gdkpixbuf/gdk-pixbuf-features.go b/v4/gdkpixbuf/gdk-pixbuf-features.go
index 9dbc7241fcd63fa2617563e75534ccfafa03e879..2524daaf169d05984fa3a1dad5b206335de66e6a 100644
--- a/v4/gdkpixbuf/gdk-pixbuf-features.go
+++ b/v4/gdkpixbuf/gdk-pixbuf-features.go
@@ -7,7 +7,7 @@ 	// "0.8.2" for example.
 	PIXBUF_MAJOR int = 2
 	// Micro version of gdk-pixbuf library, that is the "2" in
 	// "0.8.2" for example.
-	PIXBUF_MICRO int = 3
+	PIXBUF_MICRO int = 4
 	// Minor version of gdk-pixbuf library, that is the "8" in
 	// "0.8.2" for example.
 	PIXBUF_MINOR int = 44
@@ -15,5 +15,5 @@ 	// Contains the full version of GdkPixbuf as a string.
 	//
 	// This is the version being compiled against; contrast with
 	// `gdk_pixbuf_version`.
-	PIXBUF_VERSION string = "2.44.3"
+	PIXBUF_VERSION string = "2.44.4"
 )
diff --git a/v4/glib/glibconfig.go b/v4/glib/glibconfig.go
index 5e42e6ae3208f6429b126ef2864a000f135e55e1..31fecbb2c3849e6229e7e09ab2f0060f8b5811c8 100644
--- a/v4/glib/glibconfig.go
+++ b/v4/glib/glibconfig.go
@@ -70,7 +70,7 @@ 	//
 	// Like #gtk_micro_version, but from the headers used at
 	// application compile time, rather than from the library
 	// linked against at application run time.
-	MICRO_VERSION int = 0
+	MICRO_VERSION int = 2
 	// The minor version number of the GLib library.
 	//
 	// Like #gtk_minor_version, but from the headers used at
@@ -111,4 +111,6 @@
 	SYSDEF_MSG_OOB int = 1
 
 	SYSDEF_MSG_PEEK int = 2
+
+	VA_COPY_AS_ARRAY int = 1
 )
diff --git a/v4/gobject/gtype.go b/v4/gobject/gtype.go
index 318d6eb54b5975f2115184e2ce485b78633071fb..2dfdd79b07abf4ca0020a4517c59401a814044b9 100644
--- a/v4/gobject/gtype.go
+++ b/v4/gobject/gtype.go
@@ -1011,6 +1011,18 @@ 	cret := xTypeClassPeekStatic(TypeVar)
 	return cret
 }
 
+var xTypeClassRef func(types.GType) *TypeClass
+
+// Increments the reference count of the class structure belonging to
+// @type.
+//
+// This function will demand-create the class if it doesn't exist already.
+func TypeClassRef(TypeVar types.GType) *TypeClass {
+
+	cret := xTypeClassRef(TypeVar)
+	return cret
+}
+
 var xTypeCreateInstance func(types.GType) *TypeInstance
 
 // Creates and initializes an instance of @type if @type is valid and
@@ -1561,6 +1573,7 @@ 	core.PuregoSafeRegister(&xTypeClassAdjustPrivateOffset, libs, "g_type_class_adjust_private_offset")
 	core.PuregoSafeRegister(&xTypeClassGet, libs, "g_type_class_get")
 	core.PuregoSafeRegister(&xTypeClassPeek, libs, "g_type_class_peek")
 	core.PuregoSafeRegister(&xTypeClassPeekStatic, libs, "g_type_class_peek_static")
+	core.PuregoSafeRegister(&xTypeClassRef, libs, "g_type_class_ref")
 	core.PuregoSafeRegister(&xTypeCreateInstance, libs, "g_type_create_instance")
 	core.PuregoSafeRegister(&xTypeDefaultInterfaceGet, libs, "g_type_default_interface_get")
 	core.PuregoSafeRegister(&xTypeDefaultInterfacePeek, libs, "g_type_default_interface_peek")
diff --git a/v4/gsk/gsktypes.go b/v4/gsk/gsktypes.go
index c94c1bf15ce89563fa47ed3c2eeadc1de5081a7f..136e76d974d84aacdc4398fab282e6cabe7c1027 100644
--- a/v4/gsk/gsktypes.go
+++ b/v4/gsk/gsktypes.go
@@ -916,9 +916,10 @@ var xPathBuilderToPath func(uintptr) *Path
 
 // Creates a new path from the given builder.
 //
-// The given `GskPathBuilder` is reset once this function returns;
-// you cannot call this function multiple times on the same builder
-// instance.
+// The given `GskPathBuilder` is reset to the initial state once this
+// function returns. Calling this function again on the same builder
+// instance will therefore produce an empty path, not a copy of the same
+// path.
 //
 // This function is intended primarily for language bindings.
 // C code should use [method@Gsk.PathBuilder.free_to_path].
@@ -1489,7 +1490,7 @@ //
 //	gsk_transform_skew (
 //	    gsk_transform_scale (
 //	        gsk_transform_rotate (
-//	            gsk_transform_translate (NULL, &amp;GRAPHENE_POINT_T (dx, dy)),
+//	            gsk_transform_translate (NULL, &amp;GRAPHENE_POINT_INIT (dx, dy)),
 //	            angle),
 //	        scale_x, scale_y),
 //	    skew_x, skew_y)
diff --git a/v4/gtk/gtkversion.go b/v4/gtk/gtkversion.go
index ddcb85ed65076fbdf4a7c490adba34ab4c011d06..2107cf074b480b8b9111db41ed4364ae641e9f41 100644
--- a/v4/gtk/gtkversion.go
+++ b/v4/gtk/gtkversion.go
@@ -10,11 +10,11 @@ const (
 	// Like [func@get_binary_age], but from the headers used at
 	// application compile time, rather than from the library linked
 	// against at application run time.
-	BINARY_AGE int = 2002
+	BINARY_AGE int = 2003
 	// Like [func@get_interface_age], but from the headers used at
 	// application compile time, rather than from the library linked
 	// against at application run time.
-	INTERFACE_AGE int = 2
+	INTERFACE_AGE int = 3
 	// Like [func@get_major_version], but from the headers used at
 	// application compile time, rather than from the library linked
 	// against at application run time.
@@ -22,7 +22,7 @@ 	MAJOR_VERSION int = 4
 	// Like [func@get_micro_version], but from the headers used at
 	// application compile time, rather than from the library linked
 	// against at application run time.
-	MICRO_VERSION int = 2
+	MICRO_VERSION int = 3
 	// Like [func@get_minor_version], but from the headers used at
 	// application compile time, rather than from the library linked
 	// against at application run time.
diff --git a/v4/javascriptcore/JSCClass.go b/v4/javascriptcore/JSCClass.go
new file mode 100644
index 0000000000000000000000000000000000000000..34f4a113faf837faf504cd736f66e3296fd0bedc
--- /dev/null
+++ b/v4/javascriptcore/JSCClass.go
@@ -0,0 +1,509 @@
+// Package javascriptcore was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package javascriptcore
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// The type of delete_property in #JSCClassVTable. This is only required when you need to handle
+// external properties not added to the prototype.
+type ClassDeletePropertyFunction func(uintptr, uintptr, uintptr, string) bool
+
+// The type of enumerate_properties in #JSCClassVTable. This is only required when you need to handle
+// external properties not added to the prototype.
+type ClassEnumeratePropertiesFunction func(uintptr, uintptr, uintptr) []string
+
+// The type of get_property in #JSCClassVTable. This is only required when you need to handle
+// external properties not added to the prototype.
+type ClassGetPropertyFunction func(uintptr, uintptr, uintptr, string) uintptr
+
+// The type of has_property in #JSCClassVTable. This is only required when you need to handle
+// external properties not added to the prototype.
+type ClassHasPropertyFunction func(uintptr, uintptr, uintptr, string) bool
+
+// The type of set_property in #JSCClassVTable. This is only required when you need to handle
+// external properties not added to the prototype.
+type ClassSetPropertyFunction func(uintptr, uintptr, uintptr, string, uintptr) bool
+
+type ClassClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *ClassClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Virtual table for a JSCClass. This can be optionally used when registering a #JSCClass in a #JSCContext
+// to provide a custom implementation for the class. All virtual functions are optional and can be set to
+// %NULL to fallback to the default implementation.
+type ClassVTable struct {
+	_ structs.HostLayout
+
+	GetProperty ClassGetPropertyFunction
+
+	SetProperty ClassSetPropertyFunction
+
+	HasProperty ClassHasPropertyFunction
+
+	DeleteProperty ClassDeletePropertyFunction
+
+	EnumerateProperties ClassEnumeratePropertiesFunction
+
+	xJscReserved0 uintptr
+
+	xJscReserved1 uintptr
+
+	xJscReserved2 uintptr
+
+	xJscReserved3 uintptr
+
+	xJscReserved4 uintptr
+
+	xJscReserved5 uintptr
+
+	xJscReserved6 uintptr
+
+	xJscReserved7 uintptr
+}
+
+func (x *ClassVTable) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideJscReserved0 sets the "_jsc_reserved0" callback function.
+func (x *ClassVTable) OverrideJscReserved0(cb func()) {
+	if cb == nil {
+		x.xJscReserved0 = 0
+	} else {
+		x.xJscReserved0 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetJscReserved0 gets the "_jsc_reserved0" callback function.
+func (x *ClassVTable) GetJscReserved0() func() {
+	if x.xJscReserved0 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xJscReserved0)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideJscReserved1 sets the "_jsc_reserved1" callback function.
+func (x *ClassVTable) OverrideJscReserved1(cb func()) {
+	if cb == nil {
+		x.xJscReserved1 = 0
+	} else {
+		x.xJscReserved1 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetJscReserved1 gets the "_jsc_reserved1" callback function.
+func (x *ClassVTable) GetJscReserved1() func() {
+	if x.xJscReserved1 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xJscReserved1)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideJscReserved2 sets the "_jsc_reserved2" callback function.
+func (x *ClassVTable) OverrideJscReserved2(cb func()) {
+	if cb == nil {
+		x.xJscReserved2 = 0
+	} else {
+		x.xJscReserved2 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetJscReserved2 gets the "_jsc_reserved2" callback function.
+func (x *ClassVTable) GetJscReserved2() func() {
+	if x.xJscReserved2 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xJscReserved2)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideJscReserved3 sets the "_jsc_reserved3" callback function.
+func (x *ClassVTable) OverrideJscReserved3(cb func()) {
+	if cb == nil {
+		x.xJscReserved3 = 0
+	} else {
+		x.xJscReserved3 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetJscReserved3 gets the "_jsc_reserved3" callback function.
+func (x *ClassVTable) GetJscReserved3() func() {
+	if x.xJscReserved3 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xJscReserved3)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideJscReserved4 sets the "_jsc_reserved4" callback function.
+func (x *ClassVTable) OverrideJscReserved4(cb func()) {
+	if cb == nil {
+		x.xJscReserved4 = 0
+	} else {
+		x.xJscReserved4 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetJscReserved4 gets the "_jsc_reserved4" callback function.
+func (x *ClassVTable) GetJscReserved4() func() {
+	if x.xJscReserved4 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xJscReserved4)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideJscReserved5 sets the "_jsc_reserved5" callback function.
+func (x *ClassVTable) OverrideJscReserved5(cb func()) {
+	if cb == nil {
+		x.xJscReserved5 = 0
+	} else {
+		x.xJscReserved5 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetJscReserved5 gets the "_jsc_reserved5" callback function.
+func (x *ClassVTable) GetJscReserved5() func() {
+	if x.xJscReserved5 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xJscReserved5)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideJscReserved6 sets the "_jsc_reserved6" callback function.
+func (x *ClassVTable) OverrideJscReserved6(cb func()) {
+	if cb == nil {
+		x.xJscReserved6 = 0
+	} else {
+		x.xJscReserved6 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetJscReserved6 gets the "_jsc_reserved6" callback function.
+func (x *ClassVTable) GetJscReserved6() func() {
+	if x.xJscReserved6 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xJscReserved6)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideJscReserved7 sets the "_jsc_reserved7" callback function.
+func (x *ClassVTable) OverrideJscReserved7(cb func()) {
+	if cb == nil {
+		x.xJscReserved7 = 0
+	} else {
+		x.xJscReserved7 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetJscReserved7 gets the "_jsc_reserved7" callback function.
+func (x *ClassVTable) GetJscReserved7() func() {
+	if x.xJscReserved7 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xJscReserved7)
+	return func() {
+		rawCallback()
+	}
+}
+
+// A JSSClass represents a custom JavaScript class registered by the user in a #JSCContext.
+// It allows to create new JavaScripts objects whose instances are created by the user using
+// this API.
+// It's possible to add constructors, properties and methods for a JSSClass by providing
+// #GCallback&lt;!-- --&gt;s to implement them.
+type Class struct {
+	gobject.Object
+}
+
+var xClassGLibType func() types.GType
+
+func ClassGLibType() types.GType {
+	return xClassGLibType()
+}
+
+func ClassNewFromInternalPtr(ptr uintptr) *Class {
+	cls := &Class{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xClassAddConstructor func(uintptr, string, uintptr, uintptr, uintptr, types.GType, uint, ...interface{}) uintptr
+
+// Add a constructor to @jsc_class. If @name is %NULL, the class name will be used. When &lt;function&gt;new&lt;/function&gt;
+// is used with the constructor or jsc_value_constructor_call() is called, @callback is invoked receiving the
+// parameters and @user_data as the last parameter. When the constructor object is cleared in the #JSCClass context,
+// @destroy_notify is called with @user_data as parameter.
+//
+// This function creates the constructor, which needs to be added to an object as a property to be able to use it. Use
+// jsc_context_set_value() to make the constructor available in the global object.
+//
+// Note that the value returned by @callback is adopted by @jsc_class, and the #GDestroyNotify passed to
+// jsc_context_register_class() is responsible for disposing of it.
+func (x *Class) AddConstructor(NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParamsVar uint, varArgs ...interface{}) *Value {
+	var cls *Value
+
+	cret := xClassAddConstructor(x.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar, NParamsVar, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xClassAddConstructorVariadic func(uintptr, string, uintptr, uintptr, uintptr, types.GType) uintptr
+
+// Add a constructor to @jsc_class. If @name is %NULL, the class name will be used. When &lt;function&gt;new&lt;/function&gt;
+// is used with the constructor or jsc_value_constructor_call() is called, @callback is invoked receiving
+// a #GPtrArray of #JSCValue&lt;!-- --&gt;s as arguments and @user_data as the last parameter. When the constructor object
+// is cleared in the #JSCClass context, @destroy_notify is called with @user_data as parameter.
+//
+// This function creates the constructor, which needs to be added to an object as a property to be able to use it. Use
+// jsc_context_set_value() to make the constructor available in the global object.
+//
+// Note that the value returned by @callback is adopted by @jsc_class, and the #GDestroyNotify passed to
+// jsc_context_register_class() is responsible for disposing of it.
+func (x *Class) AddConstructorVariadic(NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType) *Value {
+	var cls *Value
+
+	cret := xClassAddConstructorVariadic(x.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xClassAddConstructorv func(uintptr, string, uintptr, uintptr, uintptr, types.GType, uint, []types.GType) uintptr
+
+// Add a constructor to @jsc_class. If @name is %NULL, the class name will be used. When &lt;function&gt;new&lt;/function&gt;
+// is used with the constructor or jsc_value_constructor_call() is called, @callback is invoked receiving the
+// parameters and @user_data as the last parameter. When the constructor object is cleared in the #JSCClass context,
+// @destroy_notify is called with @user_data as parameter.
+//
+// This function creates the constructor, which needs to be added to an object as a property to be able to use it. Use
+// jsc_context_set_value() to make the constructor available in the global object.
+//
+// Note that the value returned by @callback is adopted by @jsc_class, and the #GDestroyNotify passed to
+// jsc_context_register_class() is responsible for disposing of it.
+func (x *Class) AddConstructorv(NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParametersVar uint, ParameterTypesVar []types.GType) *Value {
+	var cls *Value
+
+	cret := xClassAddConstructorv(x.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar, NParametersVar, ParameterTypesVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xClassAddMethod func(uintptr, string, uintptr, uintptr, uintptr, types.GType, uint, ...interface{})
+
+// Add method with @name to @jsc_class. When the method is called by JavaScript or jsc_value_object_invoke_method(),
+// @callback is called receiving the class instance as first parameter, followed by the method parameters and then
+// @user_data as last parameter. When the method is cleared in the #JSCClass context, @destroy_notify is called with
+// @user_data as parameter.
+//
+// Note that the value returned by @callback must be transfer full. In case of non-refcounted boxed types, you should use
+// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
+// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
+// with jsc_value_new_object() that receives the copy as the instance parameter.
+func (x *Class) AddMethod(NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParamsVar uint, varArgs ...interface{}) {
+
+	xClassAddMethod(x.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar, NParamsVar, varArgs...)
+
+}
+
+var xClassAddMethodVariadic func(uintptr, string, uintptr, uintptr, uintptr, types.GType)
+
+// Add method with @name to @jsc_class. When the method is called by JavaScript or jsc_value_object_invoke_method(),
+// @callback is called receiving the class instance as first parameter, followed by a #GPtrArray of #JSCValue&lt;!-- --&gt;s
+// with the method arguments and then @user_data as last parameter. When the method is cleared in the #JSCClass context,
+// @destroy_notify is called with @user_data as parameter.
+//
+// Note that the value returned by @callback must be transfer full. In case of non-refcounted boxed types, you should use
+// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
+// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
+// with jsc_value_new_object() that receives the copy as the instance parameter.
+func (x *Class) AddMethodVariadic(NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType) {
+
+	xClassAddMethodVariadic(x.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar)
+
+}
+
+var xClassAddMethodv func(uintptr, string, uintptr, uintptr, uintptr, types.GType, uint, []types.GType)
+
+// Add method with @name to @jsc_class. When the method is called by JavaScript or jsc_value_object_invoke_method(),
+// @callback is called receiving the class instance as first parameter, followed by the method parameters and then
+// @user_data as last parameter. When the method is cleared in the #JSCClass context, @destroy_notify is called with
+// @user_data as parameter.
+//
+// Note that the value returned by @callback must be transfer full. In case of non-refcounted boxed types, you should use
+// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
+// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
+// with jsc_value_new_object() that receives the copy as the instance parameter.
+func (x *Class) AddMethodv(NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParametersVar uint, ParameterTypesVar []types.GType) {
+
+	xClassAddMethodv(x.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar, NParametersVar, ParameterTypesVar)
+
+}
+
+var xClassAddProperty func(uintptr, string, types.GType, uintptr, uintptr, uintptr, uintptr)
+
+// Add a property with @name to @jsc_class. When the property value needs to be getted, @getter is called
+// receiving the the class instance as first parameter and @user_data as last parameter. When the property
+// value needs to be set, @setter is called receiving the the class instance as first parameter, followed
+// by the value to be set and then @user_data as the last parameter. When the property is cleared in the
+// #JSCClass context, @destroy_notify is called with @user_data as parameter.
+//
+// Note that the value returned by @getter must be transfer full. In case of non-refcounted boxed types, you should use
+// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
+// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
+// with jsc_value_new_object() that receives the copy as the instance parameter.
+func (x *Class) AddProperty(NameVar string, PropertyTypeVar types.GType, GetterVar *gobject.Callback, SetterVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify) {
+
+	xClassAddProperty(x.GoPointer(), NameVar, PropertyTypeVar, glib.NewCallbackNullable(GetterVar), glib.NewCallbackNullable(SetterVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar))
+
+}
+
+var xClassGetName func(uintptr) string
+
+// Get the class name of @jsc_class
+func (x *Class) GetName() string {
+
+	cret := xClassGetName(x.GoPointer())
+	return cret
+}
+
+var xClassGetParent func(uintptr) uintptr
+
+// Get the parent class of @jsc_class
+func (x *Class) GetParent() *Class {
+	var cls *Class
+
+	cret := xClassGetParent(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &Class{}
+	cls.Ptr = cret
+	return cls
+}
+
+func (c *Class) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Class) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyName sets the "name" property.
+// The name of the class.
+func (x *Class) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+// GetPropertyName gets the "name" property.
+// The name of the class.
+func (x *Class) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+func init() {
+	core.SetPackageName("JAVASCRIPTCORE", "javascriptcoregtk-6.0")
+	core.SetSharedLibraries("JAVASCRIPTCORE", []string{"libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("JAVASCRIPTCORE") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xClassGLibType, libs, "jsc_class_get_type")
+
+	core.PuregoSafeRegister(&xClassAddConstructor, libs, "jsc_class_add_constructor")
+	core.PuregoSafeRegister(&xClassAddConstructorVariadic, libs, "jsc_class_add_constructor_variadic")
+	core.PuregoSafeRegister(&xClassAddConstructorv, libs, "jsc_class_add_constructorv")
+	core.PuregoSafeRegister(&xClassAddMethod, libs, "jsc_class_add_method")
+	core.PuregoSafeRegister(&xClassAddMethodVariadic, libs, "jsc_class_add_method_variadic")
+	core.PuregoSafeRegister(&xClassAddMethodv, libs, "jsc_class_add_methodv")
+	core.PuregoSafeRegister(&xClassAddProperty, libs, "jsc_class_add_property")
+	core.PuregoSafeRegister(&xClassGetName, libs, "jsc_class_get_name")
+	core.PuregoSafeRegister(&xClassGetParent, libs, "jsc_class_get_parent")
+
+}
diff --git a/v4/javascriptcore/JSCContext.go b/v4/javascriptcore/JSCContext.go
new file mode 100644
index 0000000000000000000000000000000000000000..f30cf397710c3e1569de6678d13a23cc14424aba
--- /dev/null
+++ b/v4/javascriptcore/JSCContext.go
@@ -0,0 +1,429 @@
+// Package javascriptcore was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package javascriptcore
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Function used to handle JavaScript exceptions in a #JSCContext.
+type ExceptionHandler func(uintptr, uintptr, uintptr)
+
+type ContextClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *ContextClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values to specify a mode to check for syntax errors in jsc_context_check_syntax().
+type CheckSyntaxMode int
+
+const (
+
+	// mode to check syntax of a script
+	JscCheckSyntaxModeScriptValue CheckSyntaxMode = 0
+	// mode to check syntax of a module
+	JscCheckSyntaxModeModuleValue CheckSyntaxMode = 1
+)
+
+// Enum values to specify the result of jsc_context_check_syntax().
+type CheckSyntaxResult int
+
+const (
+
+	// no errors
+	JscCheckSyntaxResultSuccessValue CheckSyntaxResult = 0
+	// recoverable syntax error
+	JscCheckSyntaxResultRecoverableErrorValue CheckSyntaxResult = 1
+	// irrecoverable syntax error
+	JscCheckSyntaxResultIrrecoverableErrorValue CheckSyntaxResult = 2
+	// unterminated literal error
+	JscCheckSyntaxResultUnterminatedLiteralErrorValue CheckSyntaxResult = 3
+	// out of memory error
+	JscCheckSyntaxResultOutOfMemoryErrorValue CheckSyntaxResult = 4
+	// stack overflow error
+	JscCheckSyntaxResultStackOverflowErrorValue CheckSyntaxResult = 5
+)
+
+// JSCContext represents a JavaScript execution context, where all operations
+// take place and where the values will be associated.
+//
+// When a new context is created, a global object is allocated and the built-in JavaScript
+// objects (Object, Function, String, Array) are populated. You can execute JavaScript in
+// the context by using jsc_context_evaluate() or jsc_context_evaluate_with_source_uri().
+// It's also possible to register custom objects in the context with jsc_context_register_class().
+type Context struct {
+	gobject.Object
+}
+
+var xContextGLibType func() types.GType
+
+func ContextGLibType() types.GType {
+	return xContextGLibType()
+}
+
+func ContextNewFromInternalPtr(ptr uintptr) *Context {
+	cls := &Context{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewContext func() uintptr
+
+// Create a new #JSCContext. The context is created in a new #JSCVirtualMachine.
+// Use jsc_context_new_with_virtual_machine() to create a new #JSCContext in an
+// existing #JSCVirtualMachine.
+func NewContext() *Context {
+	var cls *Context
+
+	cret := xNewContext()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Context{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewContextWithVirtualMachine func(uintptr) uintptr
+
+// Create a new #JSCContext in @virtual_machine.
+func NewContextWithVirtualMachine(VmVar *VirtualMachine) *Context {
+	var cls *Context
+
+	cret := xNewContextWithVirtualMachine(VmVar.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Context{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextCheckSyntax func(uintptr, string, int, CheckSyntaxMode, string, uint, **Exception) CheckSyntaxResult
+
+// Check the given @code in @context for syntax errors. The @line_number is the starting line number in @uri;
+// the value is one-based so the first line is 1. @uri and @line_number are only used to fill the @exception.
+// In case of errors @exception will be set to a new #JSCException with the details. You can pass %NULL to
+// @exception to ignore the error details.
+func (x *Context) CheckSyntax(CodeVar string, LengthVar int, ModeVar CheckSyntaxMode, UriVar string, LineNumberVar uint, ExceptionVar **Exception) CheckSyntaxResult {
+
+	cret := xContextCheckSyntax(x.GoPointer(), CodeVar, LengthVar, ModeVar, UriVar, LineNumberVar, ExceptionVar)
+	return cret
+}
+
+var xContextClearException func(uintptr)
+
+// Clear the uncaught exception in @context if any.
+func (x *Context) ClearException() {
+
+	xContextClearException(x.GoPointer())
+
+}
+
+var xContextEvaluate func(uintptr, string, int) uintptr
+
+// Evaluate @code in @context.
+func (x *Context) Evaluate(CodeVar string, LengthVar int) *Value {
+	var cls *Value
+
+	cret := xContextEvaluate(x.GoPointer(), CodeVar, LengthVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextEvaluateInObject func(uintptr, string, int, uintptr, uintptr, string, uint, **Value) uintptr
+
+// Evaluate @code and create an new object where symbols defined in @code will be added as properties,
+// instead of being added to @context global object. The new object is returned as @object parameter.
+// Similar to how jsc_value_new_object() works, if @object_instance is not %NULL @object_class must be provided too.
+// The @line_number is the starting line number in @uri; the value is one-based so the first line is 1.
+// @uri and @line_number will be shown in exceptions and they don't affect the behavior of the script.
+func (x *Context) EvaluateInObject(CodeVar string, LengthVar int, ObjectInstanceVar uintptr, ObjectClassVar *Class, UriVar string, LineNumberVar uint, ObjectVar **Value) *Value {
+	var cls *Value
+
+	cret := xContextEvaluateInObject(x.GoPointer(), CodeVar, LengthVar, ObjectInstanceVar, ObjectClassVar.GoPointer(), UriVar, LineNumberVar, ObjectVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextEvaluateWithSourceUri func(uintptr, string, int, string, uint) uintptr
+
+// Evaluate @code in @context using @uri as the source URI. The @line_number is the starting line number
+// in @uri; the value is one-based so the first line is 1. @uri and @line_number will be shown in exceptions and
+// they don't affect the behavior of the script.
+func (x *Context) EvaluateWithSourceUri(CodeVar string, LengthVar int, UriVar string, LineNumberVar uint) *Value {
+	var cls *Value
+
+	cret := xContextEvaluateWithSourceUri(x.GoPointer(), CodeVar, LengthVar, UriVar, LineNumberVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextGetException func(uintptr) uintptr
+
+// Get the last unhandled exception thrown in @context by API functions calls.
+func (x *Context) GetException() *Exception {
+	var cls *Exception
+
+	cret := xContextGetException(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &Exception{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextGetGlobalObject func(uintptr) uintptr
+
+// Get a #JSCValue referencing the @context global object
+func (x *Context) GetGlobalObject() *Value {
+	var cls *Value
+
+	cret := xContextGetGlobalObject(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextGetValue func(uintptr, string) uintptr
+
+// Get a property of @context global object with @name.
+func (x *Context) GetValue(NameVar string) *Value {
+	var cls *Value
+
+	cret := xContextGetValue(x.GoPointer(), NameVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextGetVirtualMachine func(uintptr) uintptr
+
+// Get the #JSCVirtualMachine where @context was created.
+func (x *Context) GetVirtualMachine() *VirtualMachine {
+	var cls *VirtualMachine
+
+	cret := xContextGetVirtualMachine(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &VirtualMachine{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextPopExceptionHandler func(uintptr)
+
+// Remove the last #JSCExceptionHandler previously pushed to @context with
+// jsc_context_push_exception_handler().
+func (x *Context) PopExceptionHandler() {
+
+	xContextPopExceptionHandler(x.GoPointer())
+
+}
+
+var xContextPushExceptionHandler func(uintptr, uintptr, uintptr, uintptr)
+
+// Push an exception handler in @context. Whenever a JavaScript exception happens in
+// the #JSCContext, the given @handler will be called. The default #JSCExceptionHandler
+// simply calls jsc_context_throw_exception() to throw the exception to the #JSCContext.
+// If you don't want to catch the exception, but only get notified about it, call
+// jsc_context_throw_exception() in @handler like the default one does.
+// The last exception handler pushed is the only one used by the #JSCContext, use
+// jsc_context_pop_exception_handler() to remove it and set the previous one. When @handler
+// is removed from the context, @destroy_notify i called with @user_data as parameter.
+func (x *Context) PushExceptionHandler(HandlerVar *ExceptionHandler, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify) {
+
+	xContextPushExceptionHandler(x.GoPointer(), glib.NewCallback(HandlerVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar))
+
+}
+
+var xContextRegisterClass func(uintptr, string, uintptr, *ClassVTable, uintptr) uintptr
+
+// Register a custom class in @context using the given @name. If the new class inherits from
+// another #JSCClass, the parent should be passed as @parent_class, otherwise %NULL should be
+// used. The optional @vtable parameter allows to provide a custom implementation for handling
+// the class, for example, to handle external properties not added to the prototype.
+// When an instance of the #JSCClass is cleared in the context, @destroy_notify is called with
+// the instance as parameter.
+func (x *Context) RegisterClass(NameVar string, ParentClassVar *Class, VtableVar *ClassVTable, DestroyNotifyVar *glib.DestroyNotify) *Class {
+	var cls *Class
+
+	cret := xContextRegisterClass(x.GoPointer(), NameVar, ParentClassVar.GoPointer(), VtableVar, glib.NewCallbackNullable(DestroyNotifyVar))
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &Class{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextSetValue func(uintptr, string, uintptr)
+
+// Set a property of @context global object with @name and @value.
+func (x *Context) SetValue(NameVar string, ValueVar *Value) {
+
+	xContextSetValue(x.GoPointer(), NameVar, ValueVar.GoPointer())
+
+}
+
+var xContextThrow func(uintptr, string)
+
+// Throw an exception to @context using the given error message. The created #JSCException
+// can be retrieved with jsc_context_get_exception().
+func (x *Context) Throw(ErrorMessageVar string) {
+
+	xContextThrow(x.GoPointer(), ErrorMessageVar)
+
+}
+
+var xContextThrowException func(uintptr, uintptr)
+
+// Throw @exception to @context.
+func (x *Context) ThrowException(ExceptionVar *Exception) {
+
+	xContextThrowException(x.GoPointer(), ExceptionVar.GoPointer())
+
+}
+
+var xContextThrowPrintf func(uintptr, string, ...interface{})
+
+// Throw an exception to @context using the given formatted string as error message.
+// The created #JSCException can be retrieved with jsc_context_get_exception().
+func (x *Context) ThrowPrintf(FormatVar string, varArgs ...interface{}) {
+
+	xContextThrowPrintf(x.GoPointer(), FormatVar, varArgs...)
+
+}
+
+var xContextThrowWithName func(uintptr, string, string)
+
+// Throw an exception to @context using the given error name and message. The created #JSCException
+// can be retrieved with jsc_context_get_exception().
+func (x *Context) ThrowWithName(ErrorNameVar string, ErrorMessageVar string) {
+
+	xContextThrowWithName(x.GoPointer(), ErrorNameVar, ErrorMessageVar)
+
+}
+
+var xContextThrowWithNamePrintf func(uintptr, string, string, ...interface{})
+
+// Throw an exception to @context using the given error name and the formatted string as error message.
+// The created #JSCException can be retrieved with jsc_context_get_exception().
+func (x *Context) ThrowWithNamePrintf(ErrorNameVar string, FormatVar string, varArgs ...interface{}) {
+
+	xContextThrowWithNamePrintf(x.GoPointer(), ErrorNameVar, FormatVar, varArgs...)
+
+}
+
+func (c *Context) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Context) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+var xContextGetCurrent func() uintptr
+
+// Get the #JSCContext that is currently executing a function. This should only be
+// called within a function or method callback, otherwise %NULL will be returned.
+func ContextGetCurrent() *Context {
+	var cls *Context
+
+	cret := xContextGetCurrent()
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &Context{}
+	cls.Ptr = cret
+	return cls
+}
+
+func init() {
+	core.SetPackageName("JAVASCRIPTCORE", "javascriptcoregtk-6.0")
+	core.SetSharedLibraries("JAVASCRIPTCORE", []string{"libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("JAVASCRIPTCORE") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xContextGLibType, libs, "jsc_context_get_type")
+
+	core.PuregoSafeRegister(&xNewContext, libs, "jsc_context_new")
+	core.PuregoSafeRegister(&xNewContextWithVirtualMachine, libs, "jsc_context_new_with_virtual_machine")
+
+	core.PuregoSafeRegister(&xContextCheckSyntax, libs, "jsc_context_check_syntax")
+	core.PuregoSafeRegister(&xContextClearException, libs, "jsc_context_clear_exception")
+	core.PuregoSafeRegister(&xContextEvaluate, libs, "jsc_context_evaluate")
+	core.PuregoSafeRegister(&xContextEvaluateInObject, libs, "jsc_context_evaluate_in_object")
+	core.PuregoSafeRegister(&xContextEvaluateWithSourceUri, libs, "jsc_context_evaluate_with_source_uri")
+	core.PuregoSafeRegister(&xContextGetException, libs, "jsc_context_get_exception")
+	core.PuregoSafeRegister(&xContextGetGlobalObject, libs, "jsc_context_get_global_object")
+	core.PuregoSafeRegister(&xContextGetValue, libs, "jsc_context_get_value")
+	core.PuregoSafeRegister(&xContextGetVirtualMachine, libs, "jsc_context_get_virtual_machine")
+	core.PuregoSafeRegister(&xContextPopExceptionHandler, libs, "jsc_context_pop_exception_handler")
+	core.PuregoSafeRegister(&xContextPushExceptionHandler, libs, "jsc_context_push_exception_handler")
+	core.PuregoSafeRegister(&xContextRegisterClass, libs, "jsc_context_register_class")
+	core.PuregoSafeRegister(&xContextSetValue, libs, "jsc_context_set_value")
+	core.PuregoSafeRegister(&xContextThrow, libs, "jsc_context_throw")
+	core.PuregoSafeRegister(&xContextThrowException, libs, "jsc_context_throw_exception")
+	core.PuregoSafeRegister(&xContextThrowPrintf, libs, "jsc_context_throw_printf")
+	core.PuregoSafeRegister(&xContextThrowWithName, libs, "jsc_context_throw_with_name")
+	core.PuregoSafeRegister(&xContextThrowWithNamePrintf, libs, "jsc_context_throw_with_name_printf")
+
+	core.PuregoSafeRegister(&xContextGetCurrent, libs, "jsc_context_get_current")
+
+}
diff --git a/v4/javascriptcore/JSCException.go b/v4/javascriptcore/JSCException.go
new file mode 100644
index 0000000000000000000000000000000000000000..df3d83c12b3622d9e061201a0bde8b9d31df795e
--- /dev/null
+++ b/v4/javascriptcore/JSCException.go
@@ -0,0 +1,257 @@
+// Package javascriptcore was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package javascriptcore
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type ExceptionClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *ExceptionClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// JSCException represents a JavaScript exception.
+type Exception struct {
+	gobject.Object
+}
+
+var xExceptionGLibType func() types.GType
+
+func ExceptionGLibType() types.GType {
+	return xExceptionGLibType()
+}
+
+func ExceptionNewFromInternalPtr(ptr uintptr) *Exception {
+	cls := &Exception{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewException func(uintptr, string) uintptr
+
+// Create a new #JSCException in @context with @message.
+func NewException(ContextVar *Context, MessageVar string) *Exception {
+	var cls *Exception
+
+	cret := xNewException(ContextVar.GoPointer(), MessageVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Exception{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewExceptionPrintf func(uintptr, string, ...interface{}) uintptr
+
+// Create a new #JSCException in @context using a formatted string
+// for the message.
+func NewExceptionPrintf(ContextVar *Context, FormatVar string, varArgs ...interface{}) *Exception {
+	var cls *Exception
+
+	cret := xNewExceptionPrintf(ContextVar.GoPointer(), FormatVar, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Exception{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewExceptionVprintf func(uintptr, string, []interface{}) uintptr
+
+// Create a new #JSCException in @context using a formatted string
+// for the message. This is similar to jsc_exception_new_printf()
+// except that the arguments to the format string are passed as a va_list.
+func NewExceptionVprintf(ContextVar *Context, FormatVar string, ArgsVar []interface{}) *Exception {
+	var cls *Exception
+
+	cret := xNewExceptionVprintf(ContextVar.GoPointer(), FormatVar, ArgsVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Exception{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewExceptionWithName func(uintptr, string, string) uintptr
+
+// Create a new #JSCException in @context with @name and @message.
+func NewExceptionWithName(ContextVar *Context, NameVar string, MessageVar string) *Exception {
+	var cls *Exception
+
+	cret := xNewExceptionWithName(ContextVar.GoPointer(), NameVar, MessageVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Exception{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewExceptionWithNamePrintf func(uintptr, string, string, ...interface{}) uintptr
+
+// Create a new #JSCException in @context with @name and using a formatted string
+// for the message.
+func NewExceptionWithNamePrintf(ContextVar *Context, NameVar string, FormatVar string, varArgs ...interface{}) *Exception {
+	var cls *Exception
+
+	cret := xNewExceptionWithNamePrintf(ContextVar.GoPointer(), NameVar, FormatVar, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Exception{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewExceptionWithNameVprintf func(uintptr, string, string, []interface{}) uintptr
+
+// Create a new #JSCException in @context with @name and using a formatted string
+// for the message. This is similar to jsc_exception_new_with_name_printf()
+// except that the arguments to the format string are passed as a va_list.
+func NewExceptionWithNameVprintf(ContextVar *Context, NameVar string, FormatVar string, ArgsVar []interface{}) *Exception {
+	var cls *Exception
+
+	cret := xNewExceptionWithNameVprintf(ContextVar.GoPointer(), NameVar, FormatVar, ArgsVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Exception{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xExceptionGetBacktraceString func(uintptr) string
+
+// Get a string with the exception backtrace.
+func (x *Exception) GetBacktraceString() string {
+
+	cret := xExceptionGetBacktraceString(x.GoPointer())
+	return cret
+}
+
+var xExceptionGetColumnNumber func(uintptr) uint
+
+// Get the column number at which @exception happened.
+func (x *Exception) GetColumnNumber() uint {
+
+	cret := xExceptionGetColumnNumber(x.GoPointer())
+	return cret
+}
+
+var xExceptionGetLineNumber func(uintptr) uint
+
+// Get the line number at which @exception happened.
+func (x *Exception) GetLineNumber() uint {
+
+	cret := xExceptionGetLineNumber(x.GoPointer())
+	return cret
+}
+
+var xExceptionGetMessage func(uintptr) string
+
+// Get the error message of @exception.
+func (x *Exception) GetMessage() string {
+
+	cret := xExceptionGetMessage(x.GoPointer())
+	return cret
+}
+
+var xExceptionGetName func(uintptr) string
+
+// Get the error name of @exception
+func (x *Exception) GetName() string {
+
+	cret := xExceptionGetName(x.GoPointer())
+	return cret
+}
+
+var xExceptionGetSourceUri func(uintptr) string
+
+// Get the source URI of @exception.
+func (x *Exception) GetSourceUri() string {
+
+	cret := xExceptionGetSourceUri(x.GoPointer())
+	return cret
+}
+
+var xExceptionReport func(uintptr) string
+
+// Return a report message of @exception, containing all the possible details such us
+// source URI, line, column and backtrace, and formatted to be printed.
+func (x *Exception) Report() string {
+
+	cret := xExceptionReport(x.GoPointer())
+	return cret
+}
+
+var xExceptionToString func(uintptr) string
+
+// Get the string representation of @exception error.
+func (x *Exception) ToString() string {
+
+	cret := xExceptionToString(x.GoPointer())
+	return cret
+}
+
+func (c *Exception) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Exception) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("JAVASCRIPTCORE", "javascriptcoregtk-6.0")
+	core.SetSharedLibraries("JAVASCRIPTCORE", []string{"libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("JAVASCRIPTCORE") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xExceptionGLibType, libs, "jsc_exception_get_type")
+
+	core.PuregoSafeRegister(&xNewException, libs, "jsc_exception_new")
+	core.PuregoSafeRegister(&xNewExceptionPrintf, libs, "jsc_exception_new_printf")
+	core.PuregoSafeRegister(&xNewExceptionVprintf, libs, "jsc_exception_new_vprintf")
+	core.PuregoSafeRegister(&xNewExceptionWithName, libs, "jsc_exception_new_with_name")
+	core.PuregoSafeRegister(&xNewExceptionWithNamePrintf, libs, "jsc_exception_new_with_name_printf")
+	core.PuregoSafeRegister(&xNewExceptionWithNameVprintf, libs, "jsc_exception_new_with_name_vprintf")
+
+	core.PuregoSafeRegister(&xExceptionGetBacktraceString, libs, "jsc_exception_get_backtrace_string")
+	core.PuregoSafeRegister(&xExceptionGetColumnNumber, libs, "jsc_exception_get_column_number")
+	core.PuregoSafeRegister(&xExceptionGetLineNumber, libs, "jsc_exception_get_line_number")
+	core.PuregoSafeRegister(&xExceptionGetMessage, libs, "jsc_exception_get_message")
+	core.PuregoSafeRegister(&xExceptionGetName, libs, "jsc_exception_get_name")
+	core.PuregoSafeRegister(&xExceptionGetSourceUri, libs, "jsc_exception_get_source_uri")
+	core.PuregoSafeRegister(&xExceptionReport, libs, "jsc_exception_report")
+	core.PuregoSafeRegister(&xExceptionToString, libs, "jsc_exception_to_string")
+
+}
diff --git a/v4/javascriptcore/JSCOptions.go b/v4/javascriptcore/JSCOptions.go
new file mode 100644
index 0000000000000000000000000000000000000000..7b0ec64f9f79b35d915ee983596fa8b70b904bca
--- /dev/null
+++ b/v4/javascriptcore/JSCOptions.go
@@ -0,0 +1,241 @@
+// Package javascriptcore was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package javascriptcore
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+)
+
+// Function used to iterate options.
+//
+// Not that @description string is not localized.
+type OptionsFunc func(string, OptionType, string, uintptr) bool
+
+const (
+	// Allows the DFG JIT to be used if %TRUE.
+	// Option type: %JSC_OPTION_BOOLEAN
+	// Default value: %TRUE.
+	OPTIONS_USE_DFG string = "useDFGJIT"
+	// Allows the FTL JIT to be used if %TRUE.
+	// Option type: %JSC_OPTION_BOOLEAN
+	// Default value: %TRUE.
+	OPTIONS_USE_FTL string = "useFTLJIT"
+	// Allows the executable pages to be allocated for JIT and thunks if %TRUE.
+	// Option type: %JSC_OPTION_BOOLEAN
+	// Default value: %TRUE.
+	OPTIONS_USE_JIT string = "useJIT"
+	// Allows the LLINT to be used if %TRUE.
+	// Option type: %JSC_OPTION_BOOLEAN
+	// Default value: %TRUE.
+	OPTIONS_USE_LLINT string = "useLLInt"
+)
+
+// Enum values for options types.
+type OptionType int
+
+const (
+
+	// A #gboolean option type.
+	JscOptionBooleanValue OptionType = 0
+	// A #gint option type.
+	JscOptionIntValue OptionType = 1
+	// A #guint option type.
+	JscOptionUintValue OptionType = 2
+	// A #gsize options type.
+	JscOptionSizeValue OptionType = 3
+	// A #gdouble options type.
+	JscOptionDoubleValue OptionType = 4
+	// A string option type.
+	JscOptionStringValue OptionType = 5
+	// A range string option type.
+	JscOptionRangeStringValue OptionType = 6
+)
+
+var xOptionsForeach func(uintptr, uintptr)
+
+// Iterates all available options calling @function for each one. Iteration can
+// stop early if @function returns %FALSE.
+func OptionsForeach(FunctionVar *OptionsFunc, UserDataVar uintptr) {
+
+	xOptionsForeach(glib.NewCallback(FunctionVar), UserDataVar)
+
+}
+
+var xOptionsGetBoolean func(string, *bool) bool
+
+// Get @option as a #gboolean value.
+func OptionsGetBoolean(OptionVar string, ValueVar *bool) bool {
+
+	cret := xOptionsGetBoolean(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsGetDouble func(string, *float64) bool
+
+// Get @option as a #gdouble value.
+func OptionsGetDouble(OptionVar string, ValueVar *float64) bool {
+
+	cret := xOptionsGetDouble(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsGetInt func(string, *int) bool
+
+// Get @option as a #gint value.
+func OptionsGetInt(OptionVar string, ValueVar *int) bool {
+
+	cret := xOptionsGetInt(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsGetOptionGroup func() *glib.OptionGroup
+
+// Create a #GOptionGroup to handle JSCOptions as command line arguments.
+// The options will be exposed as command line arguments with the form
+// &lt;emphasis&gt;--jsc-&amp;lt;option&amp;gt;=&amp;lt;value&amp;gt;&lt;/emphasis&gt;.
+// Each entry in the returned #GOptionGroup is configured to apply the
+// corresponding option during command line parsing. Applications only need to
+// pass the returned group to g_option_context_add_group(), and the rest will
+// be taken care for automatically.
+func OptionsGetOptionGroup() *glib.OptionGroup {
+
+	cret := xOptionsGetOptionGroup()
+	return cret
+}
+
+var xOptionsGetRangeString func(string, *string) bool
+
+// Get @option as a range string. The string must be in the
+// format &lt;emphasis&gt;[!]&amp;lt;low&amp;gt;[:&amp;lt;high&amp;gt;]&lt;/emphasis&gt; where low and high are #guint values.
+// Values between low and high (both included) will be considered in
+// the range, unless &lt;emphasis&gt;!&lt;/emphasis&gt; is used to invert the range.
+func OptionsGetRangeString(OptionVar string, ValueVar *string) bool {
+
+	cret := xOptionsGetRangeString(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsGetSize func(string, *uint) bool
+
+// Get @option as a #gsize value.
+func OptionsGetSize(OptionVar string, ValueVar *uint) bool {
+
+	cret := xOptionsGetSize(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsGetString func(string, *string) bool
+
+// Get @option as a string.
+func OptionsGetString(OptionVar string, ValueVar *string) bool {
+
+	cret := xOptionsGetString(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsGetUint func(string, *uint) bool
+
+// Get @option as a #guint value.
+func OptionsGetUint(OptionVar string, ValueVar *uint) bool {
+
+	cret := xOptionsGetUint(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsSetBoolean func(string, bool) bool
+
+// Set @option as a #gboolean value.
+func OptionsSetBoolean(OptionVar string, ValueVar bool) bool {
+
+	cret := xOptionsSetBoolean(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsSetDouble func(string, float64) bool
+
+// Set @option as a #gdouble value.
+func OptionsSetDouble(OptionVar string, ValueVar float64) bool {
+
+	cret := xOptionsSetDouble(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsSetInt func(string, int) bool
+
+// Set @option as a #gint value.
+func OptionsSetInt(OptionVar string, ValueVar int) bool {
+
+	cret := xOptionsSetInt(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsSetRangeString func(string, string) bool
+
+// Set @option as a range string. The string must be in the
+// format &lt;emphasis&gt;[!]&amp;lt;low&amp;gt;[:&amp;lt;high&amp;gt;]&lt;/emphasis&gt; where low and high are #guint values.
+// Values between low and high (both included) will be considered in
+// the range, unless &lt;emphasis&gt;!&lt;/emphasis&gt; is used to invert the range.
+func OptionsSetRangeString(OptionVar string, ValueVar string) bool {
+
+	cret := xOptionsSetRangeString(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsSetSize func(string, uint) bool
+
+// Set @option as a #gsize value.
+func OptionsSetSize(OptionVar string, ValueVar uint) bool {
+
+	cret := xOptionsSetSize(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsSetString func(string, string) bool
+
+// Set @option as a string.
+func OptionsSetString(OptionVar string, ValueVar string) bool {
+
+	cret := xOptionsSetString(OptionVar, ValueVar)
+	return cret
+}
+
+var xOptionsSetUint func(string, uint) bool
+
+// Set @option as a #guint value.
+func OptionsSetUint(OptionVar string, ValueVar uint) bool {
+
+	cret := xOptionsSetUint(OptionVar, ValueVar)
+	return cret
+}
+
+func init() {
+	core.SetPackageName("JAVASCRIPTCORE", "javascriptcoregtk-6.0")
+	core.SetSharedLibraries("JAVASCRIPTCORE", []string{"libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("JAVASCRIPTCORE") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xOptionsForeach, libs, "jsc_options_foreach")
+	core.PuregoSafeRegister(&xOptionsGetBoolean, libs, "jsc_options_get_boolean")
+	core.PuregoSafeRegister(&xOptionsGetDouble, libs, "jsc_options_get_double")
+	core.PuregoSafeRegister(&xOptionsGetInt, libs, "jsc_options_get_int")
+	core.PuregoSafeRegister(&xOptionsGetOptionGroup, libs, "jsc_options_get_option_group")
+	core.PuregoSafeRegister(&xOptionsGetRangeString, libs, "jsc_options_get_range_string")
+	core.PuregoSafeRegister(&xOptionsGetSize, libs, "jsc_options_get_size")
+	core.PuregoSafeRegister(&xOptionsGetString, libs, "jsc_options_get_string")
+	core.PuregoSafeRegister(&xOptionsGetUint, libs, "jsc_options_get_uint")
+	core.PuregoSafeRegister(&xOptionsSetBoolean, libs, "jsc_options_set_boolean")
+	core.PuregoSafeRegister(&xOptionsSetDouble, libs, "jsc_options_set_double")
+	core.PuregoSafeRegister(&xOptionsSetInt, libs, "jsc_options_set_int")
+	core.PuregoSafeRegister(&xOptionsSetRangeString, libs, "jsc_options_set_range_string")
+	core.PuregoSafeRegister(&xOptionsSetSize, libs, "jsc_options_set_size")
+	core.PuregoSafeRegister(&xOptionsSetString, libs, "jsc_options_set_string")
+	core.PuregoSafeRegister(&xOptionsSetUint, libs, "jsc_options_set_uint")
+
+}
diff --git a/v4/javascriptcore/JSCValue.go b/v4/javascriptcore/JSCValue.go
new file mode 100644
index 0000000000000000000000000000000000000000..5e276ec75d50c38f9bb2e5bedca5fc876c54c813
--- /dev/null
+++ b/v4/javascriptcore/JSCValue.go
@@ -0,0 +1,1086 @@
+// Package javascriptcore was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package javascriptcore
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// A function passed to @jsc_value_new_promise called during initialization
+//
+// It is called like a JavaScript function, so exceptions raised will not be propagated
+// to the context, but handled by the promise causing a rejection.
+// @resolve and @reject can be reffed for later use to handle async task completion.
+type Executor func(uintptr, uintptr, uintptr)
+
+type ValueClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *ValueClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Flags used when defining properties with jsc_value_object_define_property_data() and
+// jsc_value_object_define_property_accessor().
+type ValuePropertyFlags int
+
+const (
+
+	// the type of the property descriptor may be changed and the
+	//  property may be deleted from the corresponding object.
+	JscValuePropertyConfigurableValue ValuePropertyFlags = 1
+	// the property shows up during enumeration of the properties on
+	//  the corresponding object.
+	JscValuePropertyEnumerableValue ValuePropertyFlags = 2
+	// the value associated with the property may be changed with an
+	//  assignment operator. This doesn't have any effect when passed to jsc_value_object_define_property_accessor().
+	JscValuePropertyWritableValue ValuePropertyFlags = 4
+)
+
+// Possible types of the elements contained in a typed array.
+type TypedArrayType int
+
+const (
+
+	// Not a typed array, or type unsupported.
+	JscTypedArrayNoneValue TypedArrayType = 0
+	// Array elements are 8-bit signed integers (int8_t).
+	JscTypedArrayInt8Value TypedArrayType = 1
+	// Array elements are 16-bit signed integers (int16_t).
+	JscTypedArrayInt16Value TypedArrayType = 2
+	// Array elements are 32-bit signed integers (int32_t).
+	JscTypedArrayInt32Value TypedArrayType = 3
+	// Array elements are 64-bit signed integers (int64_t).
+	JscTypedArrayInt64Value TypedArrayType = 4
+	// Array elements are 8-bit unsigned integers (uint8_t).
+	JscTypedArrayUint8Value TypedArrayType = 5
+	// Array elements are 8-bit unsigned integers (uint8_t).
+	JscTypedArrayUint8ClampedValue TypedArrayType = 6
+	// Array elements are 16-bit unsigned integers (uint16_t).
+	JscTypedArrayUint16Value TypedArrayType = 7
+	// Array elements are 32-bit unsigned integers (uint32_t).
+	JscTypedArrayUint32Value TypedArrayType = 8
+	// Array elements are 64-bit unsigned integers (uint64_t).
+	JscTypedArrayUint64Value TypedArrayType = 9
+	// Array elements are 32-bit floating point numbers (float).
+	JscTypedArrayFloat32Value TypedArrayType = 10
+	// Array elements are 64-bit floating point numbers (double).
+	JscTypedArrayFloat64Value TypedArrayType = 11
+)
+
+// JSCValue represents a reference to a value in a #JSCContext. The JSCValue
+// protects the referenced value from being garbage collected.
+type Value struct {
+	gobject.Object
+}
+
+var xValueGLibType func() types.GType
+
+func ValueGLibType() types.GType {
+	return xValueGLibType()
+}
+
+func ValueNewFromInternalPtr(ptr uintptr) *Value {
+	cls := &Value{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewValueArray func(uintptr, types.GType, ...interface{}) uintptr
+
+// Create a new #JSCValue referencing an array with the given items. If @first_item_type
+// is %G_TYPE_NONE an empty array is created.
+func NewValueArray(ContextVar *Context, FirstItemTypeVar types.GType, varArgs ...interface{}) *Value {
+	var cls *Value
+
+	cret := xNewValueArray(ContextVar.GoPointer(), FirstItemTypeVar, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueArrayBuffer func(uintptr, uintptr, uint, uintptr, uintptr) uintptr
+
+// Creates a new %ArrayBuffer from existing @data in memory.
+//
+// The @data is not copied: while this allows sharing data with JavaScript
+// efficiently, the caller must ensure that the memory region remains valid
+// until the newly created object is released by JSC.
+//
+// Optionally, a @destroy_notify callback can be provided, which will be
+// invoked with @user_data as parameter when the %ArrayBuffer object is
+// released. This is intended to be used for freeing resources related to
+// the memory region which contains the data:
+//
+// |[!&lt;-- language="C" --&gt;
+// GMappedFile *f = g_mapped_file_new (file_path, TRUE, NULL);
+// JSCValue *value = jsc_value_new_array_buffer (context,
+//
+//	g_mapped_file_get_contents (f), g_mapped_file_get_length (f),
+//	(GDestroyNotify) g_mapped_file_unref, f);
+//
+// ]|
+//
+// Note that the @user_data can be the same value as @data:
+//
+// |[!&lt;-- language="C" --&gt;
+// void *bytes = g_malloc0 (100);
+// JSCValue *value = jsc_value_new_array_buffer (context, bytes, 100, g_free, bytes);
+// ]|
+func NewValueArrayBuffer(ContextVar *Context, DataVar uintptr, SizeVar uint, DestroyNotifyVar *glib.DestroyNotify, UserDataVar uintptr) *Value {
+	var cls *Value
+
+	cret := xNewValueArrayBuffer(ContextVar.GoPointer(), DataVar, SizeVar, glib.NewCallbackNullable(DestroyNotifyVar), UserDataVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueArrayFromGarray func(uintptr, []Value) uintptr
+
+// Create a new #JSCValue referencing an array with the items from @array. If @array
+// is %NULL or empty a new empty array will be created. Elements of @array should be
+// pointers to a #JSCValue.
+func NewValueArrayFromGarray(ContextVar *Context, ArrayVar []Value) *Value {
+	var cls *Value
+
+	cret := xNewValueArrayFromGarray(ContextVar.GoPointer(), ArrayVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueArrayFromStrv func(uintptr, []string) uintptr
+
+// Create a new #JSCValue referencing an array of strings with the items from @strv. If @array
+// is %NULL or empty a new empty array will be created.
+func NewValueArrayFromStrv(ContextVar *Context, StrvVar []string) *Value {
+	var cls *Value
+
+	cret := xNewValueArrayFromStrv(ContextVar.GoPointer(), StrvVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueBoolean func(uintptr, bool) uintptr
+
+// Create a new #JSCValue from @value
+func NewValueBoolean(ContextVar *Context, ValueVar bool) *Value {
+	var cls *Value
+
+	cret := xNewValueBoolean(ContextVar.GoPointer(), ValueVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueFromJson func(uintptr, string) uintptr
+
+// Create a new #JSCValue referencing a new value created by parsing @json.
+func NewValueFromJson(ContextVar *Context, JsonVar string) *Value {
+	var cls *Value
+
+	cret := xNewValueFromJson(ContextVar.GoPointer(), JsonVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueFunction func(uintptr, string, uintptr, uintptr, uintptr, types.GType, uint, ...interface{}) uintptr
+
+// Create a function in @context. If @name is %NULL an anonymous function will be created.
+// When the function is called by JavaScript or jsc_value_function_call(), @callback is called
+// receiving the function parameters and then @user_data as last parameter. When the function is
+// cleared in @context, @destroy_notify is called with @user_data as parameter.
+//
+// Note that the value returned by @callback must be fully transferred. In case of boxed types, you could use
+// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
+// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
+// with jsc_value_new_object() that receives the copy as instance parameter.
+func NewValueFunction(ContextVar *Context, NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParamsVar uint, varArgs ...interface{}) *Value {
+	var cls *Value
+
+	cret := xNewValueFunction(ContextVar.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar, NParamsVar, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueFunctionVariadic func(uintptr, string, uintptr, uintptr, uintptr, types.GType) uintptr
+
+// Create a function in @context. If @name is %NULL an anonymous function will be created.
+// When the function is called by JavaScript or jsc_value_function_call(), @callback is called
+// receiving an #GPtrArray of #JSCValue&lt;!-- --&gt;s with the arguments and then @user_data as last parameter.
+// When the function is cleared in @context, @destroy_notify is called with @user_data as parameter.
+//
+// Note that the value returned by @callback must be fully transferred. In case of boxed types, you could use
+// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
+// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
+// with jsc_value_new_object() that receives the copy as instance parameter.
+func NewValueFunctionVariadic(ContextVar *Context, NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType) *Value {
+	var cls *Value
+
+	cret := xNewValueFunctionVariadic(ContextVar.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueFunctionv func(uintptr, string, uintptr, uintptr, uintptr, types.GType, uint, []types.GType) uintptr
+
+// Create a function in @context. If @name is %NULL an anonymous function will be created.
+// When the function is called by JavaScript or jsc_value_function_call(), @callback is called
+// receiving the function parameters and then @user_data as last parameter. When the function is
+// cleared in @context, @destroy_notify is called with @user_data as parameter.
+//
+// Note that the value returned by @callback must be fully transferred. In case of boxed types, you could use
+// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
+// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
+// with jsc_value_new_object() that receives the copy as instance parameter.
+func NewValueFunctionv(ContextVar *Context, NameVar string, CallbackVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify, ReturnTypeVar types.GType, NParametersVar uint, ParameterTypesVar []types.GType) *Value {
+	var cls *Value
+
+	cret := xNewValueFunctionv(ContextVar.GoPointer(), NameVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar), ReturnTypeVar, NParametersVar, ParameterTypesVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueNull func(uintptr) uintptr
+
+// Create a new #JSCValue referencing &lt;function&gt;null&lt;/function&gt; in @context.
+func NewValueNull(ContextVar *Context) *Value {
+	var cls *Value
+
+	cret := xNewValueNull(ContextVar.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueNumber func(uintptr, float64) uintptr
+
+// Create a new #JSCValue from @number.
+func NewValueNumber(ContextVar *Context, NumberVar float64) *Value {
+	var cls *Value
+
+	cret := xNewValueNumber(ContextVar.GoPointer(), NumberVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueObject func(uintptr, uintptr, uintptr) uintptr
+
+// Create a new #JSCValue from @instance. If @instance is %NULL a new empty object is created.
+// When @instance is provided, @jsc_class must be provided too. @jsc_class takes ownership of
+// @instance that will be freed by the #GDestroyNotify passed to jsc_context_register_class().
+func NewValueObject(ContextVar *Context, InstanceVar uintptr, JscClassVar *Class) *Value {
+	var cls *Value
+
+	cret := xNewValueObject(ContextVar.GoPointer(), InstanceVar, JscClassVar.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValuePromise func(uintptr, uintptr, uintptr) uintptr
+
+// Creates a new Promise. @executor will be invoked during promise initialization
+// and it receives the @resolve and @reject objects than can be called to resolve
+// or reject the promise. It is called like a JavaScript function, so exceptions raised
+// during the executor invocation will not be propagated to the context, but
+// handled by the promise causing a rejection.
+func NewValuePromise(ContextVar *Context, ExecutorVar *Executor, UserDataVar uintptr) *Value {
+	var cls *Value
+
+	cret := xNewValuePromise(ContextVar.GoPointer(), glib.NewCallback(ExecutorVar), UserDataVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueString func(uintptr, string) uintptr
+
+// Create a new #JSCValue from @string. If you need to create a #JSCValue from a
+// string containing null characters, use jsc_value_new_string_from_bytes() instead.
+func NewValueString(ContextVar *Context, StringVar string) *Value {
+	var cls *Value
+
+	cret := xNewValueString(ContextVar.GoPointer(), StringVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueStringFromBytes func(uintptr, *glib.Bytes) uintptr
+
+// Create a new #JSCValue from @bytes.
+func NewValueStringFromBytes(ContextVar *Context, BytesVar *glib.Bytes) *Value {
+	var cls *Value
+
+	cret := xNewValueStringFromBytes(ContextVar.GoPointer(), BytesVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueTypedArray func(uintptr, TypedArrayType, uint) uintptr
+
+// Create a new typed array containing a given amount of elements.
+//
+// Create a #JSCValue referencing a new typed array with space for @length
+// elements of a given @type. As all typed arrays must have an associated
+// `ArrayBuffer`, a new one of suitable size will be allocated to store
+// the elements, which will be initialized to zero.
+//
+// The @type must *not* be %JSC_TYPED_ARRAY_NONE.
+func NewValueTypedArray(ContextVar *Context, TypeVar TypedArrayType, LengthVar uint) *Value {
+	var cls *Value
+
+	cret := xNewValueTypedArray(ContextVar.GoPointer(), TypeVar, LengthVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewValueUndefined func(uintptr) uintptr
+
+// Create a new #JSCValue referencing &lt;function&gt;undefined&lt;/function&gt; in @context.
+func NewValueUndefined(ContextVar *Context) *Value {
+	var cls *Value
+
+	cret := xNewValueUndefined(ContextVar.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueArrayBufferGetData func(uintptr, *uint) uintptr
+
+// Gets a pointer to memory that contains the array buffer data.
+//
+// Obtains a pointer to the memory region that holds the contents of the
+// %ArrayBuffer; modifications done to the data will be visible to JavaScript
+// code. If @size is not %NULL, the size in bytes of the memory region
+// will also be stored in the pointed location.
+//
+// Note that the pointer returned by this function is not guaranteed to remain
+// the same after calls to other JSC API functions. If you plan to access the
+// data of the %ArrayBuffer later, you can keep a reference to the @value and
+// obtain the data pointer at a later point. Keep in mind that if JavaScript
+// code has a chance to run, for example due to main loop events that result
+// in JSC being called, the contents of the memory region might be modified in
+// the meantime. Consider taking a copy of the data and using the copy instead
+// in asynchronous code.
+func (x *Value) ArrayBufferGetData(SizeVar *uint) uintptr {
+
+	cret := xValueArrayBufferGetData(x.GoPointer(), SizeVar)
+	return cret
+}
+
+var xValueArrayBufferGetSize func(uintptr) uint
+
+// Gets the size in bytes of the array buffer.
+//
+// Obtains the size in bytes of the memory region that holds the contents of
+// an %ArrayBuffer.
+func (x *Value) ArrayBufferGetSize() uint {
+
+	cret := xValueArrayBufferGetSize(x.GoPointer())
+	return cret
+}
+
+var xValueConstructorCall func(uintptr, types.GType, ...interface{}) uintptr
+
+// Invoke &lt;function&gt;new&lt;/function&gt; with constructor referenced by @value. If @first_parameter_type
+// is %G_TYPE_NONE no parameters will be passed to the constructor.
+func (x *Value) ConstructorCall(FirstParameterTypeVar types.GType, varArgs ...interface{}) *Value {
+	var cls *Value
+
+	cret := xValueConstructorCall(x.GoPointer(), FirstParameterTypeVar, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueConstructorCallv func(uintptr, uint, []Value) uintptr
+
+// Invoke &lt;function&gt;new&lt;/function&gt; with constructor referenced by @value. If @n_parameters
+// is 0 no parameters will be passed to the constructor.
+func (x *Value) ConstructorCallv(NParametersVar uint, ParametersVar []Value) *Value {
+	var cls *Value
+
+	cret := xValueConstructorCallv(x.GoPointer(), NParametersVar, ParametersVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueFunctionCall func(uintptr, types.GType, ...interface{}) uintptr
+
+// Call function referenced by @value, passing the given parameters. If @first_parameter_type
+// is %G_TYPE_NONE no parameters will be passed to the function.
+//
+// This function always returns a #JSCValue, in case of void functions a #JSCValue referencing
+// &lt;function&gt;undefined&lt;/function&gt; is returned
+func (x *Value) FunctionCall(FirstParameterTypeVar types.GType, varArgs ...interface{}) *Value {
+	var cls *Value
+
+	cret := xValueFunctionCall(x.GoPointer(), FirstParameterTypeVar, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueFunctionCallv func(uintptr, uint, []Value) uintptr
+
+// Call function referenced by @value, passing the given @parameters. If @n_parameters
+// is 0 no parameters will be passed to the function.
+//
+// This function always returns a #JSCValue, in case of void functions a #JSCValue referencing
+// &lt;function&gt;undefined&lt;/function&gt; is returned
+func (x *Value) FunctionCallv(NParametersVar uint, ParametersVar []Value) *Value {
+	var cls *Value
+
+	cret := xValueFunctionCallv(x.GoPointer(), NParametersVar, ParametersVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueGetContext func(uintptr) uintptr
+
+// Get the #JSCContext in which @value was created.
+func (x *Value) GetContext() *Context {
+	var cls *Context
+
+	cret := xValueGetContext(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &Context{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueIsArray func(uintptr) bool
+
+// Get whether the value referenced by @value is an array.
+func (x *Value) IsArray() bool {
+
+	cret := xValueIsArray(x.GoPointer())
+	return cret
+}
+
+var xValueIsArrayBuffer func(uintptr) bool
+
+// Check whether the @value is an %ArrayBuffer.
+func (x *Value) IsArrayBuffer() bool {
+
+	cret := xValueIsArrayBuffer(x.GoPointer())
+	return cret
+}
+
+var xValueIsBoolean func(uintptr) bool
+
+// Get whether the value referenced by @value is a boolean.
+func (x *Value) IsBoolean() bool {
+
+	cret := xValueIsBoolean(x.GoPointer())
+	return cret
+}
+
+var xValueIsConstructor func(uintptr) bool
+
+// Get whether the value referenced by @value is a constructor.
+func (x *Value) IsConstructor() bool {
+
+	cret := xValueIsConstructor(x.GoPointer())
+	return cret
+}
+
+var xValueIsFunction func(uintptr) bool
+
+// Get whether the value referenced by @value is a function
+func (x *Value) IsFunction() bool {
+
+	cret := xValueIsFunction(x.GoPointer())
+	return cret
+}
+
+var xValueIsNull func(uintptr) bool
+
+// Get whether the value referenced by @value is &lt;function&gt;null&lt;/function&gt;.
+func (x *Value) IsNull() bool {
+
+	cret := xValueIsNull(x.GoPointer())
+	return cret
+}
+
+var xValueIsNumber func(uintptr) bool
+
+// Get whether the value referenced by @value is a number.
+func (x *Value) IsNumber() bool {
+
+	cret := xValueIsNumber(x.GoPointer())
+	return cret
+}
+
+var xValueIsObject func(uintptr) bool
+
+// Get whether the value referenced by @value is an object.
+func (x *Value) IsObject() bool {
+
+	cret := xValueIsObject(x.GoPointer())
+	return cret
+}
+
+var xValueIsString func(uintptr) bool
+
+// Get whether the value referenced by @value is a string
+func (x *Value) IsString() bool {
+
+	cret := xValueIsString(x.GoPointer())
+	return cret
+}
+
+var xValueIsTypedArray func(uintptr) bool
+
+// Determines whether a value is a typed array.
+func (x *Value) IsTypedArray() bool {
+
+	cret := xValueIsTypedArray(x.GoPointer())
+	return cret
+}
+
+var xValueIsUndefined func(uintptr) bool
+
+// Get whether the value referenced by @value is &lt;function&gt;undefined&lt;/function&gt;.
+func (x *Value) IsUndefined() bool {
+
+	cret := xValueIsUndefined(x.GoPointer())
+	return cret
+}
+
+var xValueNewTypedArrayWithBuffer func(uintptr, TypedArrayType, uint, int) uintptr
+
+// Create a new typed array value with elements from an array buffer.
+//
+// Create a #JSCValue referencing a new typed array value containing
+// elements of the given @type, where the elements are stored at the memory
+// region represented by the @array_buffer.
+//
+// The @type must *not* be %JSC_TYPED_ARRAY_NONE.
+//
+// The @offset and @length parameters can be used to indicate which part of
+// the array buffer can be accessed through the typed array. If both are
+// omitted (passing zero as @offset, and `-1` as @length), the whole
+// @array_buffer is exposed through the typed array. Omitting the @length
+// with a non-zero @offset will expose the remainder of the @array_buffer
+// starting at the indicated offset.
+func (x *Value) NewTypedArrayWithBuffer(TypeVar TypedArrayType, OffsetVar uint, LengthVar int) *Value {
+	var cls *Value
+
+	cret := xValueNewTypedArrayWithBuffer(x.GoPointer(), TypeVar, OffsetVar, LengthVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueObjectDefinePropertyAccessor func(uintptr, string, ValuePropertyFlags, types.GType, uintptr, uintptr, uintptr, uintptr)
+
+// Define or modify a property with @property_name in object referenced by @value. When the
+// property value needs to be getted or set, @getter and @setter callbacks will be called.
+// When the property is cleared in the #JSCClass context, @destroy_notify is called with
+// @user_data as parameter. This is equivalent to JavaScript &lt;function&gt;Object.defineProperty()&lt;/function&gt;
+// when used with an accessor descriptor.
+//
+// Note that the value returned by @getter must be fully transferred. In case of boxed types, you could use
+// %G_TYPE_POINTER instead of the actual boxed #GType to ensure that the instance owned by #JSCClass is used.
+// If you really want to return a new copy of the boxed type, use #JSC_TYPE_VALUE and return a #JSCValue created
+// with jsc_value_new_object() that receives the copy as instance parameter.
+//
+// Note that @getter and @setter are called as functions and not methods, so they don't receive an instance as
+// first parameter. Use jsc_class_add_property() if you want to add property accessor invoked as a method.
+func (x *Value) ObjectDefinePropertyAccessor(PropertyNameVar string, FlagsVar ValuePropertyFlags, PropertyTypeVar types.GType, GetterVar *gobject.Callback, SetterVar *gobject.Callback, UserDataVar uintptr, DestroyNotifyVar *glib.DestroyNotify) {
+
+	xValueObjectDefinePropertyAccessor(x.GoPointer(), PropertyNameVar, FlagsVar, PropertyTypeVar, glib.NewCallbackNullable(GetterVar), glib.NewCallbackNullable(SetterVar), UserDataVar, glib.NewCallbackNullable(DestroyNotifyVar))
+
+}
+
+var xValueObjectDefinePropertyData func(uintptr, string, ValuePropertyFlags, uintptr)
+
+// Define or modify a property with @property_name in object referenced by @value. This is equivalent to
+// JavaScript &lt;function&gt;Object.defineProperty()&lt;/function&gt; when used with a data descriptor.
+func (x *Value) ObjectDefinePropertyData(PropertyNameVar string, FlagsVar ValuePropertyFlags, PropertyValueVar *Value) {
+
+	xValueObjectDefinePropertyData(x.GoPointer(), PropertyNameVar, FlagsVar, PropertyValueVar.GoPointer())
+
+}
+
+var xValueObjectDeleteProperty func(uintptr, string) bool
+
+// Try to delete property with @name from @value. This function will return %FALSE if
+// the property was defined without %JSC_VALUE_PROPERTY_CONFIGURABLE flag.
+func (x *Value) ObjectDeleteProperty(NameVar string) bool {
+
+	cret := xValueObjectDeleteProperty(x.GoPointer(), NameVar)
+	return cret
+}
+
+var xValueObjectEnumerateProperties func(uintptr) []string
+
+// Get the list of property names of @value. Only properties defined with %JSC_VALUE_PROPERTY_ENUMERABLE
+// flag will be collected.
+func (x *Value) ObjectEnumerateProperties() []string {
+
+	cret := xValueObjectEnumerateProperties(x.GoPointer())
+	return cret
+}
+
+var xValueObjectGetProperty func(uintptr, string) uintptr
+
+// Get property with @name from @value.
+func (x *Value) ObjectGetProperty(NameVar string) *Value {
+	var cls *Value
+
+	cret := xValueObjectGetProperty(x.GoPointer(), NameVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueObjectGetPropertyAtIndex func(uintptr, uint) uintptr
+
+// Get property at @index from @value.
+func (x *Value) ObjectGetPropertyAtIndex(IndexVar uint) *Value {
+	var cls *Value
+
+	cret := xValueObjectGetPropertyAtIndex(x.GoPointer(), IndexVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueObjectHasProperty func(uintptr, string) bool
+
+// Get whether @value has property with @name.
+func (x *Value) ObjectHasProperty(NameVar string) bool {
+
+	cret := xValueObjectHasProperty(x.GoPointer(), NameVar)
+	return cret
+}
+
+var xValueObjectInvokeMethod func(uintptr, string, types.GType, ...interface{}) uintptr
+
+// Invoke method with @name on object referenced by @value, passing the given parameters. If
+// @first_parameter_type is %G_TYPE_NONE no parameters will be passed to the method.
+// The object instance will be handled automatically even when the method is a custom one
+// registered with jsc_class_add_method(), so it should never be passed explicitly as parameter
+// of this function.
+//
+// This function always returns a #JSCValue, in case of void methods a #JSCValue referencing
+// &lt;function&gt;undefined&lt;/function&gt; is returned.
+func (x *Value) ObjectInvokeMethod(NameVar string, FirstParameterTypeVar types.GType, varArgs ...interface{}) *Value {
+	var cls *Value
+
+	cret := xValueObjectInvokeMethod(x.GoPointer(), NameVar, FirstParameterTypeVar, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueObjectInvokeMethodv func(uintptr, string, uint, []Value) uintptr
+
+// Invoke method with @name on object referenced by @value, passing the given @parameters. If
+// @n_parameters is 0 no parameters will be passed to the method.
+// The object instance will be handled automatically even when the method is a custom one
+// registered with jsc_class_add_method(), so it should never be passed explicitly as parameter
+// of this function.
+//
+// This function always returns a #JSCValue, in case of void methods a #JSCValue referencing
+// &lt;function&gt;undefined&lt;/function&gt; is returned.
+func (x *Value) ObjectInvokeMethodv(NameVar string, NParametersVar uint, ParametersVar []Value) *Value {
+	var cls *Value
+
+	cret := xValueObjectInvokeMethodv(x.GoPointer(), NameVar, NParametersVar, ParametersVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueObjectIsInstanceOf func(uintptr, string) bool
+
+// Get whether the value referenced by @value is an instance of class @name.
+func (x *Value) ObjectIsInstanceOf(NameVar string) bool {
+
+	cret := xValueObjectIsInstanceOf(x.GoPointer(), NameVar)
+	return cret
+}
+
+var xValueObjectSetProperty func(uintptr, string, uintptr)
+
+// Set @property with @name on @value.
+func (x *Value) ObjectSetProperty(NameVar string, PropertyVar *Value) {
+
+	xValueObjectSetProperty(x.GoPointer(), NameVar, PropertyVar.GoPointer())
+
+}
+
+var xValueObjectSetPropertyAtIndex func(uintptr, uint, uintptr)
+
+// Set @property at @index on @value.
+func (x *Value) ObjectSetPropertyAtIndex(IndexVar uint, PropertyVar *Value) {
+
+	xValueObjectSetPropertyAtIndex(x.GoPointer(), IndexVar, PropertyVar.GoPointer())
+
+}
+
+var xValueToBoolean func(uintptr) bool
+
+// Convert @value to a boolean.
+func (x *Value) ToBoolean() bool {
+
+	cret := xValueToBoolean(x.GoPointer())
+	return cret
+}
+
+var xValueToDouble func(uintptr) float64
+
+// Convert @value to a double.
+func (x *Value) ToDouble() float64 {
+
+	cret := xValueToDouble(x.GoPointer())
+	return cret
+}
+
+var xValueToInt32 func(uintptr) int32
+
+// Convert @value to a #gint32.
+func (x *Value) ToInt32() int32 {
+
+	cret := xValueToInt32(x.GoPointer())
+	return cret
+}
+
+var xValueToJson func(uintptr, uint) string
+
+// Create a JSON string of @value serialization. If @indent is 0, the resulting JSON will
+// not contain newlines. The size of the indent is clamped to 10 spaces.
+func (x *Value) ToJson(IndentVar uint) string {
+
+	cret := xValueToJson(x.GoPointer(), IndentVar)
+	return cret
+}
+
+var xValueToString func(uintptr) string
+
+// Convert @value to a string. Use jsc_value_to_string_as_bytes() instead, if you need to
+// handle strings containing null characters.
+func (x *Value) ToString() string {
+
+	cret := xValueToString(x.GoPointer())
+	return cret
+}
+
+var xValueToStringAsBytes func(uintptr) *glib.Bytes
+
+// Convert @value to a string and return the results as #GBytes. This is needed
+// to handle strings with null characters.
+func (x *Value) ToStringAsBytes() *glib.Bytes {
+
+	cret := xValueToStringAsBytes(x.GoPointer())
+	return cret
+}
+
+var xValueTypedArrayGetBuffer func(uintptr) uintptr
+
+// Obtain the %ArrayBuffer for the memory region of the typed array elements.
+func (x *Value) TypedArrayGetBuffer() *Value {
+	var cls *Value
+
+	cret := xValueTypedArrayGetBuffer(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xValueTypedArrayGetData func(uintptr, *uint) uintptr
+
+// Obtains a pointer to the memory region that holds the elements of the typed
+// array; modifications done to them will be visible to JavaScript code. If
+// @length is not %NULL, the number of elements contained in the typed array
+// are also stored in the pointed location.
+//
+// The returned pointer needs to be casted to the appropriate type (see
+// #JSCTypedArrayType), and has the `offset` over the underlying array
+// buffer data appliedthat is, points to the first element of the typed
+// array:
+//
+// |[&lt;!-- language="C" --&gt;
+// if (jsc_value_typed_array_get_type(value) != JSC_TYPED_ARRAY_UINT32)
+//
+//	g_error ("Only arrays of uint32_t are supported");
+//
+// gsize count = 0;
+// uint32_t *elements = jsc_value_typed_array_get_contents (value, &amp;count);
+// for (gsize i = 0; i &lt; count; i++)
+//
+//	g_print ("index %zu, value %" PRIu32 "\n", i, elements[i]);
+//
+// ]|
+//
+// Note that the pointer returned by this function is not guaranteed to remain
+// the same after calls to other JSC API functions. See
+// jsc_value_array_buffer_get_data() for details.
+func (x *Value) TypedArrayGetData(LengthVar *uint) uintptr {
+
+	cret := xValueTypedArrayGetData(x.GoPointer(), LengthVar)
+	return cret
+}
+
+var xValueTypedArrayGetLength func(uintptr) uint
+
+// Gets the number of elements in a typed array.
+func (x *Value) TypedArrayGetLength() uint {
+
+	cret := xValueTypedArrayGetLength(x.GoPointer())
+	return cret
+}
+
+var xValueTypedArrayGetOffset func(uintptr) uint
+
+// Gets the offset over the underlying array buffer data.
+func (x *Value) TypedArrayGetOffset() uint {
+
+	cret := xValueTypedArrayGetOffset(x.GoPointer())
+	return cret
+}
+
+var xValueTypedArrayGetSize func(uintptr) uint
+
+// Gets the size of a typed array.
+func (x *Value) TypedArrayGetSize() uint {
+
+	cret := xValueTypedArrayGetSize(x.GoPointer())
+	return cret
+}
+
+var xValueTypedArrayGetType func(uintptr) TypedArrayType
+
+// Gets the type of elements contained in a typed array.
+func (x *Value) TypedArrayGetType() TypedArrayType {
+
+	cret := xValueTypedArrayGetType(x.GoPointer())
+	return cret
+}
+
+func (c *Value) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Value) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("JAVASCRIPTCORE", "javascriptcoregtk-6.0")
+	core.SetSharedLibraries("JAVASCRIPTCORE", []string{"libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("JAVASCRIPTCORE") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xValueGLibType, libs, "jsc_value_get_type")
+
+	core.PuregoSafeRegister(&xNewValueArray, libs, "jsc_value_new_array")
+	core.PuregoSafeRegister(&xNewValueArrayBuffer, libs, "jsc_value_new_array_buffer")
+	core.PuregoSafeRegister(&xNewValueArrayFromGarray, libs, "jsc_value_new_array_from_garray")
+	core.PuregoSafeRegister(&xNewValueArrayFromStrv, libs, "jsc_value_new_array_from_strv")
+	core.PuregoSafeRegister(&xNewValueBoolean, libs, "jsc_value_new_boolean")
+	core.PuregoSafeRegister(&xNewValueFromJson, libs, "jsc_value_new_from_json")
+	core.PuregoSafeRegister(&xNewValueFunction, libs, "jsc_value_new_function")
+	core.PuregoSafeRegister(&xNewValueFunctionVariadic, libs, "jsc_value_new_function_variadic")
+	core.PuregoSafeRegister(&xNewValueFunctionv, libs, "jsc_value_new_functionv")
+	core.PuregoSafeRegister(&xNewValueNull, libs, "jsc_value_new_null")
+	core.PuregoSafeRegister(&xNewValueNumber, libs, "jsc_value_new_number")
+	core.PuregoSafeRegister(&xNewValueObject, libs, "jsc_value_new_object")
+	core.PuregoSafeRegister(&xNewValuePromise, libs, "jsc_value_new_promise")
+	core.PuregoSafeRegister(&xNewValueString, libs, "jsc_value_new_string")
+	core.PuregoSafeRegister(&xNewValueStringFromBytes, libs, "jsc_value_new_string_from_bytes")
+	core.PuregoSafeRegister(&xNewValueTypedArray, libs, "jsc_value_new_typed_array")
+	core.PuregoSafeRegister(&xNewValueUndefined, libs, "jsc_value_new_undefined")
+
+	core.PuregoSafeRegister(&xValueArrayBufferGetData, libs, "jsc_value_array_buffer_get_data")
+	core.PuregoSafeRegister(&xValueArrayBufferGetSize, libs, "jsc_value_array_buffer_get_size")
+	core.PuregoSafeRegister(&xValueConstructorCall, libs, "jsc_value_constructor_call")
+	core.PuregoSafeRegister(&xValueConstructorCallv, libs, "jsc_value_constructor_callv")
+	core.PuregoSafeRegister(&xValueFunctionCall, libs, "jsc_value_function_call")
+	core.PuregoSafeRegister(&xValueFunctionCallv, libs, "jsc_value_function_callv")
+	core.PuregoSafeRegister(&xValueGetContext, libs, "jsc_value_get_context")
+	core.PuregoSafeRegister(&xValueIsArray, libs, "jsc_value_is_array")
+	core.PuregoSafeRegister(&xValueIsArrayBuffer, libs, "jsc_value_is_array_buffer")
+	core.PuregoSafeRegister(&xValueIsBoolean, libs, "jsc_value_is_boolean")
+	core.PuregoSafeRegister(&xValueIsConstructor, libs, "jsc_value_is_constructor")
+	core.PuregoSafeRegister(&xValueIsFunction, libs, "jsc_value_is_function")
+	core.PuregoSafeRegister(&xValueIsNull, libs, "jsc_value_is_null")
+	core.PuregoSafeRegister(&xValueIsNumber, libs, "jsc_value_is_number")
+	core.PuregoSafeRegister(&xValueIsObject, libs, "jsc_value_is_object")
+	core.PuregoSafeRegister(&xValueIsString, libs, "jsc_value_is_string")
+	core.PuregoSafeRegister(&xValueIsTypedArray, libs, "jsc_value_is_typed_array")
+	core.PuregoSafeRegister(&xValueIsUndefined, libs, "jsc_value_is_undefined")
+	core.PuregoSafeRegister(&xValueNewTypedArrayWithBuffer, libs, "jsc_value_new_typed_array_with_buffer")
+	core.PuregoSafeRegister(&xValueObjectDefinePropertyAccessor, libs, "jsc_value_object_define_property_accessor")
+	core.PuregoSafeRegister(&xValueObjectDefinePropertyData, libs, "jsc_value_object_define_property_data")
+	core.PuregoSafeRegister(&xValueObjectDeleteProperty, libs, "jsc_value_object_delete_property")
+	core.PuregoSafeRegister(&xValueObjectEnumerateProperties, libs, "jsc_value_object_enumerate_properties")
+	core.PuregoSafeRegister(&xValueObjectGetProperty, libs, "jsc_value_object_get_property")
+	core.PuregoSafeRegister(&xValueObjectGetPropertyAtIndex, libs, "jsc_value_object_get_property_at_index")
+	core.PuregoSafeRegister(&xValueObjectHasProperty, libs, "jsc_value_object_has_property")
+	core.PuregoSafeRegister(&xValueObjectInvokeMethod, libs, "jsc_value_object_invoke_method")
+	core.PuregoSafeRegister(&xValueObjectInvokeMethodv, libs, "jsc_value_object_invoke_methodv")
+	core.PuregoSafeRegister(&xValueObjectIsInstanceOf, libs, "jsc_value_object_is_instance_of")
+	core.PuregoSafeRegister(&xValueObjectSetProperty, libs, "jsc_value_object_set_property")
+	core.PuregoSafeRegister(&xValueObjectSetPropertyAtIndex, libs, "jsc_value_object_set_property_at_index")
+	core.PuregoSafeRegister(&xValueToBoolean, libs, "jsc_value_to_boolean")
+	core.PuregoSafeRegister(&xValueToDouble, libs, "jsc_value_to_double")
+	core.PuregoSafeRegister(&xValueToInt32, libs, "jsc_value_to_int32")
+	core.PuregoSafeRegister(&xValueToJson, libs, "jsc_value_to_json")
+	core.PuregoSafeRegister(&xValueToString, libs, "jsc_value_to_string")
+	core.PuregoSafeRegister(&xValueToStringAsBytes, libs, "jsc_value_to_string_as_bytes")
+	core.PuregoSafeRegister(&xValueTypedArrayGetBuffer, libs, "jsc_value_typed_array_get_buffer")
+	core.PuregoSafeRegister(&xValueTypedArrayGetData, libs, "jsc_value_typed_array_get_data")
+	core.PuregoSafeRegister(&xValueTypedArrayGetLength, libs, "jsc_value_typed_array_get_length")
+	core.PuregoSafeRegister(&xValueTypedArrayGetOffset, libs, "jsc_value_typed_array_get_offset")
+	core.PuregoSafeRegister(&xValueTypedArrayGetSize, libs, "jsc_value_typed_array_get_size")
+	core.PuregoSafeRegister(&xValueTypedArrayGetType, libs, "jsc_value_typed_array_get_type")
+
+}
diff --git a/v4/javascriptcore/JSCVersion.go b/v4/javascriptcore/JSCVersion.go
new file mode 100644
index 0000000000000000000000000000000000000000..efa0f29c00a2669a1b0b7ff29775da0ab6e9e4bc
--- /dev/null
+++ b/v4/javascriptcore/JSCVersion.go
@@ -0,0 +1,85 @@
+// Package javascriptcore was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package javascriptcore
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+)
+
+const (
+	// Like jsc_get_major_version(), but from the headers used at
+	// application compile time, rather than from the library linked
+	// against at application run time.
+	MAJOR_VERSION int = 2
+	// Like jsc_get_micro_version(), but from the headers used at
+	// application compile time, rather than from the library linked
+	// against at application run time.
+	MICRO_VERSION int = 3
+	// Like jsc_get_minor_version(), but from the headers used at
+	// application compile time, rather than from the library linked
+	// against at application run time.
+	MINOR_VERSION int = 50
+)
+
+var xGetMajorVersion func() uint
+
+// Returns the major version number of the JavaScriptCore library.
+// (e.g. in JavaScriptCore version 1.8.3 this is 1.)
+//
+// This function is in the library, so it represents the JavaScriptCore library
+// your code is running against. Contrast with the #JSC_MAJOR_VERSION
+// macro, which represents the major version of the JavaScriptCore headers you
+// have included when compiling your code.
+func GetMajorVersion() uint {
+
+	cret := xGetMajorVersion()
+	return cret
+}
+
+var xGetMicroVersion func() uint
+
+// Returns the micro version number of the JavaScriptCore library.
+// (e.g. in JavaScriptCore version 1.8.3 this is 3.)
+//
+// This function is in the library, so it represents the JavaScriptCore library
+// your code is running against. Contrast with the #JSC_MICRO_VERSION
+// macro, which represents the micro version of the JavaScriptCore headers you
+// have included when compiling your code.
+func GetMicroVersion() uint {
+
+	cret := xGetMicroVersion()
+	return cret
+}
+
+var xGetMinorVersion func() uint
+
+// Returns the minor version number of the JavaScriptCore library.
+// (e.g. in JavaScriptCore version 1.8.3 this is 8.)
+//
+// This function is in the library, so it represents the JavaScriptCore library
+// your code is running against. Contrast with the #JSC_MINOR_VERSION
+// macro, which represents the minor version of the JavaScriptCore headers you
+// have included when compiling your code.
+func GetMinorVersion() uint {
+
+	cret := xGetMinorVersion()
+	return cret
+}
+
+func init() {
+	core.SetPackageName("JAVASCRIPTCORE", "javascriptcoregtk-6.0")
+	core.SetSharedLibraries("JAVASCRIPTCORE", []string{"libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("JAVASCRIPTCORE") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xGetMajorVersion, libs, "jsc_get_major_version")
+	core.PuregoSafeRegister(&xGetMicroVersion, libs, "jsc_get_micro_version")
+	core.PuregoSafeRegister(&xGetMinorVersion, libs, "jsc_get_minor_version")
+
+}
diff --git a/v4/javascriptcore/JSCVirtualMachine.go b/v4/javascriptcore/JSCVirtualMachine.go
new file mode 100644
index 0000000000000000000000000000000000000000..29e686179915f57dfa763011239a299fd088d0ff
--- /dev/null
+++ b/v4/javascriptcore/JSCVirtualMachine.go
@@ -0,0 +1,89 @@
+// Package javascriptcore was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package javascriptcore
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type VirtualMachineClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *VirtualMachineClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// JSCVirtualMachine represents a group of JSCContext&lt;!-- --&gt;s. It allows
+// concurrent JavaScript execution by creating a different instance of
+// JSCVirtualMachine in each thread.
+//
+// To create a group of JSCContext&lt;!-- --&gt;s pass the same JSCVirtualMachine
+// instance to every JSCContext constructor.
+type VirtualMachine struct {
+	gobject.Object
+}
+
+var xVirtualMachineGLibType func() types.GType
+
+func VirtualMachineGLibType() types.GType {
+	return xVirtualMachineGLibType()
+}
+
+func VirtualMachineNewFromInternalPtr(ptr uintptr) *VirtualMachine {
+	cls := &VirtualMachine{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewVirtualMachine func() uintptr
+
+// Create a new #JSCVirtualMachine.
+func NewVirtualMachine() *VirtualMachine {
+	var cls *VirtualMachine
+
+	cret := xNewVirtualMachine()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &VirtualMachine{}
+	cls.Ptr = cret
+	return cls
+}
+
+func (c *VirtualMachine) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *VirtualMachine) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("JAVASCRIPTCORE", "javascriptcoregtk-6.0")
+	core.SetSharedLibraries("JAVASCRIPTCORE", []string{"libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("JAVASCRIPTCORE") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xVirtualMachineGLibType, libs, "jsc_virtual_machine_get_type")
+
+	core.PuregoSafeRegister(&xNewVirtualMachine, libs, "jsc_virtual_machine_new")
+
+}
diff --git a/v4/javascriptcore/JSCWeakValue.go b/v4/javascriptcore/JSCWeakValue.go
new file mode 100644
index 0000000000000000000000000000000000000000..c659c45b5ba9422d0a2339dc016dd5fd6da1721b
--- /dev/null
+++ b/v4/javascriptcore/JSCWeakValue.go
@@ -0,0 +1,125 @@
+// Package javascriptcore was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package javascriptcore
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type WeakValueClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *WeakValueClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// JSCWeakValue represents a weak reference to a value in a #JSCContext. It can be used
+// to keep a reference to a JavaScript value without protecting it from being garbage
+// collected and without referencing the #JSCContext either.
+type WeakValue struct {
+	gobject.Object
+}
+
+var xWeakValueGLibType func() types.GType
+
+func WeakValueGLibType() types.GType {
+	return xWeakValueGLibType()
+}
+
+func WeakValueNewFromInternalPtr(ptr uintptr) *WeakValue {
+	cls := &WeakValue{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewWeakValue func(uintptr) uintptr
+
+// Create a new #JSCWeakValue for the JavaScript value referenced by @value.
+func NewWeakValue(ValueVar *Value) *WeakValue {
+	var cls *WeakValue
+
+	cret := xNewWeakValue(ValueVar.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &WeakValue{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWeakValueGetValue func(uintptr) uintptr
+
+// Get a #JSCValue referencing the JavaScript value of @weak_value.
+func (x *WeakValue) GetValue() *Value {
+	var cls *Value
+
+	cret := xWeakValueGetValue(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Value{}
+	cls.Ptr = cret
+	return cls
+}
+
+func (c *WeakValue) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WeakValue) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// This signal is emitted when the JavaScript value is destroyed.
+func (x *WeakValue) ConnectCleared(cb *func(WeakValue)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "cleared", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := WeakValue{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "cleared", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("JAVASCRIPTCORE", "javascriptcoregtk-6.0")
+	core.SetSharedLibraries("JAVASCRIPTCORE", []string{"libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("JAVASCRIPTCORE") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xWeakValueGLibType, libs, "jsc_weak_value_get_type")
+
+	core.PuregoSafeRegister(&xNewWeakValue, libs, "jsc_weak_value_new")
+
+	core.PuregoSafeRegister(&xWeakValueGetValue, libs, "jsc_weak_value_get_value")
+
+}
diff --git a/v4/soup/soup-auth-basic.go b/v4/soup/soup-auth-basic.go
new file mode 100644
index 0000000000000000000000000000000000000000..7114e694d0a0931d52a20fcece77e6b3b7a8edf8
--- /dev/null
+++ b/v4/soup/soup-auth-basic.go
@@ -0,0 +1,36 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import "github.com/jwijenbergh/puregotk/v4/gobject/types"
+
+// HTTP "Basic" authentication.
+//
+// [class@Session]s support this by default; if you want to disable
+// support for it, call [method@Session.remove_feature_by_type],
+// passing %SOUP_TYPE_AUTH_BASIC.
+type AuthBasic struct {
+	Auth
+}
+
+var xAuthBasicGLibType func() types.GType
+
+func AuthBasicGLibType() types.GType {
+	return xAuthBasicGLibType()
+}
+
+func AuthBasicNewFromInternalPtr(ptr uintptr) *AuthBasic {
+	cls := &AuthBasic{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *AuthBasic) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *AuthBasic) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
diff --git a/v4/soup/soup-auth-digest.go b/v4/soup/soup-auth-digest.go
new file mode 100644
index 0000000000000000000000000000000000000000..4811a5c478980cf6aba95fe3800723dd192188b2
--- /dev/null
+++ b/v4/soup/soup-auth-digest.go
@@ -0,0 +1,36 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import "github.com/jwijenbergh/puregotk/v4/gobject/types"
+
+// HTTP "Digest" authentication.
+//
+// [class@Session]s support this by default; if you want to disable
+// support for it, call [method@Session.remove_feature_by_type]
+// passing %SOUP_TYPE_AUTH_DIGEST.
+type AuthDigest struct {
+	Auth
+}
+
+var xAuthDigestGLibType func() types.GType
+
+func AuthDigestGLibType() types.GType {
+	return xAuthDigestGLibType()
+}
+
+func AuthDigestNewFromInternalPtr(ptr uintptr) *AuthDigest {
+	cls := &AuthDigest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *AuthDigest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *AuthDigest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
diff --git a/v4/soup/soup-auth-domain-basic.go b/v4/soup/soup-auth-domain-basic.go
new file mode 100644
index 0000000000000000000000000000000000000000..6a64773bba94dc17330355aef84228dcb6a5b132
--- /dev/null
+++ b/v4/soup/soup-auth-domain-basic.go
@@ -0,0 +1,147 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Callback used by #SoupAuthDomainBasic for authentication purposes.
+//
+// The application should verify that @username and @password and valid
+// and return %TRUE or %FALSE.
+//
+// If you are maintaining your own password database (rather than
+// using the password to authenticate against some other system like
+// PAM or a remote server), you should make sure you know what you are
+// doing. In particular, don't store cleartext passwords, or
+// easily-computed hashes of cleartext passwords, even if you don't
+// care that much about the security of your server, because users
+// will frequently use the same password for multiple sites, and so
+// compromising any site with a cleartext (or easily-cracked) password
+// database may give attackers access to other more-interesting sites
+// as well.
+type AuthDomainBasicAuthCallback func(uintptr, uintptr, string, string, uintptr) bool
+
+type AuthDomainBasicClass struct {
+	_ structs.HostLayout
+
+	ParentClass AuthDomainClass
+}
+
+func (x *AuthDomainBasicClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Server-side "Basic" authentication.
+//
+// #SoupAuthDomainBasic handles the server side of HTTP "Basic" (ie,
+// cleartext password) authentication.
+type AuthDomainBasic struct {
+	AuthDomain
+}
+
+var xAuthDomainBasicGLibType func() types.GType
+
+func AuthDomainBasicGLibType() types.GType {
+	return xAuthDomainBasicGLibType()
+}
+
+func AuthDomainBasicNewFromInternalPtr(ptr uintptr) *AuthDomainBasic {
+	cls := &AuthDomainBasic{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewAuthDomainBasic func(string, ...interface{}) uintptr
+
+// Creates a #SoupAuthDomainBasic.
+//
+// You must set the [property@AuthDomain:realm] property, to indicate the realm
+// name to be returned with the authentication challenge to the client. Other
+// parameters are optional.
+func NewAuthDomainBasic(Optname1Var string, varArgs ...interface{}) *AuthDomainBasic {
+	var cls *AuthDomainBasic
+
+	cret := xNewAuthDomainBasic(Optname1Var, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &AuthDomainBasic{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xAuthDomainBasicSetAuthCallback func(uintptr, uintptr, uintptr, uintptr)
+
+// Sets the callback that @domain will use to authenticate incoming
+// requests.
+//
+// For each request containing authorization, @domain will invoke the callback,
+// and then either accept or reject the request based on @callback's return
+// value.
+//
+// You can also set the auth callback by setting the
+// [property@AuthDomainBasic:auth-callback] and
+// [property@AuthDomainBasic:auth-data] properties, which can also be used to
+// set the callback at construct time.
+func (x *AuthDomainBasic) SetAuthCallback(CallbackVar *AuthDomainBasicAuthCallback, UserDataVar uintptr, DnotifyVar *glib.DestroyNotify) {
+
+	xAuthDomainBasicSetAuthCallback(x.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallback(DnotifyVar))
+
+}
+
+func (c *AuthDomainBasic) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *AuthDomainBasic) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyAuthData sets the "auth-data" property.
+// The data to pass to the [callback@AuthDomainBasicAuthCallback].
+func (x *AuthDomainBasic) SetPropertyAuthData(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("auth-data", &v)
+}
+
+// GetPropertyAuthData gets the "auth-data" property.
+// The data to pass to the [callback@AuthDomainBasicAuthCallback].
+func (x *AuthDomainBasic) GetPropertyAuthData() uintptr {
+	var v gobject.Value
+	x.GetProperty("auth-data", &v)
+	return v.GetPointer()
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xAuthDomainBasicGLibType, libs, "soup_auth_domain_basic_get_type")
+
+	core.PuregoSafeRegister(&xNewAuthDomainBasic, libs, "soup_auth_domain_basic_new")
+
+	core.PuregoSafeRegister(&xAuthDomainBasicSetAuthCallback, libs, "soup_auth_domain_basic_set_auth_callback")
+
+}
diff --git a/v4/soup/soup-auth-domain-digest.go b/v4/soup/soup-auth-domain-digest.go
new file mode 100644
index 0000000000000000000000000000000000000000..2233666285dfe408c43d8cdc92beea45a45e2aa7
--- /dev/null
+++ b/v4/soup/soup-auth-domain-digest.go
@@ -0,0 +1,162 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Callback used by #SoupAuthDomainDigest for authentication purposes.
+//
+// The application should look up @username in its password database,
+// and return the corresponding encoded password (see
+// [func@AuthDomainDigest.encode_password].
+type AuthDomainDigestAuthCallback func(uintptr, uintptr, string, uintptr) string
+
+type AuthDomainDigestClass struct {
+	_ structs.HostLayout
+
+	ParentClass AuthDomainClass
+}
+
+func (x *AuthDomainDigestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Server-side "Digest" authentication.
+//
+// #SoupAuthDomainDigest handles the server side of HTTP "Digest"
+// authentication.
+type AuthDomainDigest struct {
+	AuthDomain
+}
+
+var xAuthDomainDigestGLibType func() types.GType
+
+func AuthDomainDigestGLibType() types.GType {
+	return xAuthDomainDigestGLibType()
+}
+
+func AuthDomainDigestNewFromInternalPtr(ptr uintptr) *AuthDomainDigest {
+	cls := &AuthDomainDigest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewAuthDomainDigest func(string, ...interface{}) uintptr
+
+// Creates a #SoupAuthDomainDigest.
+//
+// You must set the [property@AuthDomain:realm] property, to indicate the realm name to
+// be returned with the authentication challenge to the client. Other parameters
+// are optional.
+func NewAuthDomainDigest(Optname1Var string, varArgs ...interface{}) *AuthDomainDigest {
+	var cls *AuthDomainDigest
+
+	cret := xNewAuthDomainDigest(Optname1Var, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &AuthDomainDigest{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xAuthDomainDigestSetAuthCallback func(uintptr, uintptr, uintptr, uintptr)
+
+// Sets the callback that @domain will use to authenticate incoming
+// requests.
+//
+// For each request containing authorization, @domain will
+// invoke the callback, and then either accept or reject the request
+// based on @callback's return value.
+//
+// You can also set the auth callback by setting the
+// [property@AuthDomainDigest:auth-callback] and
+// [property@AuthDomainDigest:auth-data] properties, which can also be used to
+// set the callback at construct time.
+func (x *AuthDomainDigest) SetAuthCallback(CallbackVar *AuthDomainDigestAuthCallback, UserDataVar uintptr, DnotifyVar *glib.DestroyNotify) {
+
+	xAuthDomainDigestSetAuthCallback(x.GoPointer(), glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallback(DnotifyVar))
+
+}
+
+func (c *AuthDomainDigest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *AuthDomainDigest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyAuthData sets the "auth-data" property.
+// The data to pass to the [callback@AuthDomainDigestAuthCallback].
+func (x *AuthDomainDigest) SetPropertyAuthData(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("auth-data", &v)
+}
+
+// GetPropertyAuthData gets the "auth-data" property.
+// The data to pass to the [callback@AuthDomainDigestAuthCallback].
+func (x *AuthDomainDigest) GetPropertyAuthData() uintptr {
+	var v gobject.Value
+	x.GetProperty("auth-data", &v)
+	return v.GetPointer()
+}
+
+var xAuthDomainDigestEncodePassword func(string, string, string) string
+
+// Encodes the username/realm/password triplet for Digest
+// authentication.
+//
+// That is, it returns a stringified MD5 hash of
+// @username, @realm, and @password concatenated together. This is
+// the form that is needed as the return value of
+// #SoupAuthDomainDigest's auth handler.
+//
+// For security reasons, you should store the encoded hash, rather
+// than storing the cleartext password itself and calling this method
+// only when you need to verify it. This way, if your server is
+// compromised, the attackers will not gain access to cleartext
+// passwords which might also be usable at other sites. (Note also
+// that the encoded password returned by this method is identical to
+// the encoded password stored in an Apache .htdigest file.)
+func AuthDomainDigestEncodePassword(UsernameVar string, RealmVar string, PasswordVar string) string {
+
+	cret := xAuthDomainDigestEncodePassword(UsernameVar, RealmVar, PasswordVar)
+	return cret
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xAuthDomainDigestGLibType, libs, "soup_auth_domain_digest_get_type")
+
+	core.PuregoSafeRegister(&xNewAuthDomainDigest, libs, "soup_auth_domain_digest_new")
+
+	core.PuregoSafeRegister(&xAuthDomainDigestSetAuthCallback, libs, "soup_auth_domain_digest_set_auth_callback")
+
+	core.PuregoSafeRegister(&xAuthDomainDigestEncodePassword, libs, "soup_auth_domain_digest_encode_password")
+
+}
diff --git a/v4/soup/soup-auth-domain.go b/v4/soup/soup-auth-domain.go
new file mode 100644
index 0000000000000000000000000000000000000000..0ff5985a72d4db057a7c2021a1ce73d5e03e21e6
--- /dev/null
+++ b/v4/soup/soup-auth-domain.go
@@ -0,0 +1,410 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// The prototype for a #SoupAuthDomain filter.
+//
+// See [method@AuthDomain.set_filter] for details.
+type AuthDomainFilter func(uintptr, uintptr, uintptr) bool
+
+// The prototype for a #SoupAuthDomain generic authentication callback.
+//
+// The callback should look up the user's password, call
+// [method@AuthDomain.check_password], and use the return value from that method
+// as its own return value.
+//
+// In general, for security reasons, it is preferable to use the
+// auth-domain-specific auth callbacks (eg,
+// [callback@AuthDomainBasicAuthCallback] and
+// [callback@AuthDomainDigestAuthCallback]), because they don't require
+// keeping a cleartext password database. Most users will use the same
+// password for many different sites, meaning if any site with a
+// cleartext password database is compromised, accounts on other
+// servers might be compromised as well. For many of the cases where
+// [class@Server] is used, this is not really relevant, but it may still
+// be worth considering.
+type AuthDomainGenericAuthCallback func(uintptr, uintptr, string, uintptr) bool
+
+type AuthDomainClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+
+	xAccepts uintptr
+
+	xChallenge uintptr
+
+	xCheckPassword uintptr
+
+	Padding [6]uintptr
+}
+
+func (x *AuthDomainClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideAccepts sets the "accepts" callback function.
+func (x *AuthDomainClass) OverrideAccepts(cb func(*AuthDomain, *ServerMessage, string) string) {
+	if cb == nil {
+		x.xAccepts = 0
+	} else {
+		x.xAccepts = purego.NewCallback(func(DomainVarp uintptr, MsgVarp uintptr, HeaderVarp string) string {
+			return cb(AuthDomainNewFromInternalPtr(DomainVarp), ServerMessageNewFromInternalPtr(MsgVarp), HeaderVarp)
+		})
+	}
+}
+
+// GetAccepts gets the "accepts" callback function.
+func (x *AuthDomainClass) GetAccepts() func(*AuthDomain, *ServerMessage, string) string {
+	if x.xAccepts == 0 {
+		return nil
+	}
+	var rawCallback func(DomainVarp uintptr, MsgVarp uintptr, HeaderVarp string) string
+	purego.RegisterFunc(&rawCallback, x.xAccepts)
+	return func(DomainVar *AuthDomain, MsgVar *ServerMessage, HeaderVar string) string {
+		return rawCallback(DomainVar.GoPointer(), MsgVar.GoPointer(), HeaderVar)
+	}
+}
+
+// OverrideChallenge sets the "challenge" callback function.
+func (x *AuthDomainClass) OverrideChallenge(cb func(*AuthDomain, *ServerMessage) string) {
+	if cb == nil {
+		x.xChallenge = 0
+	} else {
+		x.xChallenge = purego.NewCallback(func(DomainVarp uintptr, MsgVarp uintptr) string {
+			return cb(AuthDomainNewFromInternalPtr(DomainVarp), ServerMessageNewFromInternalPtr(MsgVarp))
+		})
+	}
+}
+
+// GetChallenge gets the "challenge" callback function.
+func (x *AuthDomainClass) GetChallenge() func(*AuthDomain, *ServerMessage) string {
+	if x.xChallenge == 0 {
+		return nil
+	}
+	var rawCallback func(DomainVarp uintptr, MsgVarp uintptr) string
+	purego.RegisterFunc(&rawCallback, x.xChallenge)
+	return func(DomainVar *AuthDomain, MsgVar *ServerMessage) string {
+		return rawCallback(DomainVar.GoPointer(), MsgVar.GoPointer())
+	}
+}
+
+// OverrideCheckPassword sets the "check_password" callback function.
+func (x *AuthDomainClass) OverrideCheckPassword(cb func(*AuthDomain, *ServerMessage, string, string) bool) {
+	if cb == nil {
+		x.xCheckPassword = 0
+	} else {
+		x.xCheckPassword = purego.NewCallback(func(DomainVarp uintptr, MsgVarp uintptr, UsernameVarp string, PasswordVarp string) bool {
+			return cb(AuthDomainNewFromInternalPtr(DomainVarp), ServerMessageNewFromInternalPtr(MsgVarp), UsernameVarp, PasswordVarp)
+		})
+	}
+}
+
+// GetCheckPassword gets the "check_password" callback function.
+func (x *AuthDomainClass) GetCheckPassword() func(*AuthDomain, *ServerMessage, string, string) bool {
+	if x.xCheckPassword == 0 {
+		return nil
+	}
+	var rawCallback func(DomainVarp uintptr, MsgVarp uintptr, UsernameVarp string, PasswordVarp string) bool
+	purego.RegisterFunc(&rawCallback, x.xCheckPassword)
+	return func(DomainVar *AuthDomain, MsgVar *ServerMessage, UsernameVar string, PasswordVar string) bool {
+		return rawCallback(DomainVar.GoPointer(), MsgVar.GoPointer(), UsernameVar, PasswordVar)
+	}
+}
+
+// Server-side authentication.
+//
+// A #SoupAuthDomain manages authentication for all or part of a
+// [class@Server]. To make a server require authentication, first create
+// an appropriate subclass of #SoupAuthDomain, and then add it to the
+// server with [method@Server.add_auth_domain].
+//
+// In order for an auth domain to have any effect, you must add one or more
+// paths to it (via [method@AuthDomain.add_path]). To require authentication for
+// all ordinary requests, add the path `"/"`. (Note that this does not include
+// the special `"*"` URI (eg, "OPTIONS *"), which must be added as a separate
+// path if you want to cover it.)
+//
+// If you need greater control over which requests should and shouldn't be
+// authenticated, add paths covering everything you *might* want authenticated,
+// and then use a filter ([method@AuthDomain.set_filter] to bypass
+// authentication for those requests that don't need it.
+type AuthDomain struct {
+	gobject.Object
+}
+
+var xAuthDomainGLibType func() types.GType
+
+func AuthDomainGLibType() types.GType {
+	return xAuthDomainGLibType()
+}
+
+func AuthDomainNewFromInternalPtr(ptr uintptr) *AuthDomain {
+	cls := &AuthDomain{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xAuthDomainAccepts func(uintptr, uintptr) string
+
+// Checks if @msg contains appropriate authorization for @domain to
+// accept it.
+//
+// Mirroring [method@AuthDomain.covers], this does not check whether or not
+// @domain *cares* if @msg is authorized.
+//
+// This is used by [class@Server] internally and is probably of no use to
+// anyone else.
+func (x *AuthDomain) Accepts(MsgVar *ServerMessage) string {
+
+	cret := xAuthDomainAccepts(x.GoPointer(), MsgVar.GoPointer())
+	return cret
+}
+
+var xAuthDomainAddPath func(uintptr, string)
+
+// Adds @path to @domain.
+//
+// Requests under @path on @domain's server will require authentication (unless
+// overridden by [method@AuthDomain.remove_path] or
+// [method@AuthDomain.set_filter]).
+func (x *AuthDomain) AddPath(PathVar string) {
+
+	xAuthDomainAddPath(x.GoPointer(), PathVar)
+
+}
+
+var xAuthDomainChallenge func(uintptr, uintptr)
+
+// Adds a "WWW-Authenticate" or "Proxy-Authenticate" header to @msg.
+//
+// It requests that the client authenticate, and sets @msg's status accordingly.
+//
+// This is used by [class@Server] internally and is probably of no use to
+// anyone else.
+func (x *AuthDomain) Challenge(MsgVar *ServerMessage) {
+
+	xAuthDomainChallenge(x.GoPointer(), MsgVar.GoPointer())
+
+}
+
+var xAuthDomainCheckPassword func(uintptr, uintptr, string, string) bool
+
+// Checks if @msg authenticates to @domain via @username and
+// @password.
+//
+// This would normally be called from a
+// [callback@AuthDomainGenericAuthCallback].
+func (x *AuthDomain) CheckPassword(MsgVar *ServerMessage, UsernameVar string, PasswordVar string) bool {
+
+	cret := xAuthDomainCheckPassword(x.GoPointer(), MsgVar.GoPointer(), UsernameVar, PasswordVar)
+	return cret
+}
+
+var xAuthDomainCovers func(uintptr, uintptr) bool
+
+// Checks if @domain requires @msg to be authenticated (according to
+// its paths and filter function).
+//
+// This does not actually look at whether @msg *is* authenticated, merely
+// whether or not it needs to be.
+//
+// This is used by [class@Server] internally and is probably of no use to
+// anyone else.
+func (x *AuthDomain) Covers(MsgVar *ServerMessage) bool {
+
+	cret := xAuthDomainCovers(x.GoPointer(), MsgVar.GoPointer())
+	return cret
+}
+
+var xAuthDomainGetRealm func(uintptr) string
+
+// Gets the realm name associated with @domain.
+func (x *AuthDomain) GetRealm() string {
+
+	cret := xAuthDomainGetRealm(x.GoPointer())
+	return cret
+}
+
+var xAuthDomainRemovePath func(uintptr, string)
+
+// Removes @path from @domain.
+//
+// Requests under @path on @domain's server will NOT require
+// authentication.
+//
+// This is not simply an undo-er for [method@AuthDomain.add_path]; it
+// can be used to "carve out" a subtree that does not require
+// authentication inside a hierarchy that does. Note also that unlike
+// with [method@AuthDomain.add_path], this cannot be overridden by
+// adding a filter, as filters can only bypass authentication that
+// would otherwise be required, not require it where it would
+// otherwise be unnecessary.
+func (x *AuthDomain) RemovePath(PathVar string) {
+
+	xAuthDomainRemovePath(x.GoPointer(), PathVar)
+
+}
+
+var xAuthDomainSetFilter func(uintptr, uintptr, uintptr, uintptr)
+
+// Adds @filter as an authentication filter to @domain.
+//
+// The filter gets a chance to bypass authentication for certain requests that
+// would otherwise require it. Eg, it might check the message's path in some way
+// that is too complicated to do via the other methods, or it might check the
+// message's method, and allow GETs but not PUTs.
+//
+// The filter function returns %TRUE if the request should still
+// require authentication, or %FALSE if authentication is unnecessary
+// for this request.
+//
+// To help prevent security holes, your filter should return %TRUE by
+// default, and only return %FALSE under specifically-tested
+// circumstances, rather than the other way around. Eg, in the example
+// above, where you want to authenticate PUTs but not GETs, you should
+// check if the method is GET and return %FALSE in that case, and then
+// return %TRUE for all other methods (rather than returning %TRUE for
+// PUT and %FALSE for all other methods). This way if it turned out
+// (now or later) that some paths supported additional methods besides
+// GET and PUT, those methods would default to being NOT allowed for
+// unauthenticated users.
+//
+// You can also set the filter by setting the SoupAuthDomain:filter
+// and [property@AuthDomain:filter-data properties], which can also be
+// used to set the filter at construct time.
+func (x *AuthDomain) SetFilter(FilterVar *AuthDomainFilter, FilterDataVar uintptr, DnotifyVar *glib.DestroyNotify) {
+
+	xAuthDomainSetFilter(x.GoPointer(), glib.NewCallback(FilterVar), FilterDataVar, glib.NewCallback(DnotifyVar))
+
+}
+
+var xAuthDomainSetGenericAuthCallback func(uintptr, uintptr, uintptr, uintptr)
+
+// Sets @auth_callback as an authentication-handling callback for @domain.
+//
+// Whenever a request comes in to @domain which cannot be authenticated via a
+// domain-specific auth callback (eg, [callback@AuthDomainDigestAuthCallback]),
+// the generic auth callback will be invoked. See
+// [callback@AuthDomainGenericAuthCallback] for information on what the callback
+// should do.
+func (x *AuthDomain) SetGenericAuthCallback(AuthCallbackVar *AuthDomainGenericAuthCallback, AuthDataVar uintptr, DnotifyVar *glib.DestroyNotify) {
+
+	xAuthDomainSetGenericAuthCallback(x.GoPointer(), glib.NewCallback(AuthCallbackVar), AuthDataVar, glib.NewCallback(DnotifyVar))
+
+}
+
+func (c *AuthDomain) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *AuthDomain) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyFilterData sets the "filter-data" property.
+// Data to pass to the [callback@AuthDomainFilter].
+func (x *AuthDomain) SetPropertyFilterData(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("filter-data", &v)
+}
+
+// GetPropertyFilterData gets the "filter-data" property.
+// Data to pass to the [callback@AuthDomainFilter].
+func (x *AuthDomain) GetPropertyFilterData() uintptr {
+	var v gobject.Value
+	x.GetProperty("filter-data", &v)
+	return v.GetPointer()
+}
+
+// SetPropertyGenericAuthData sets the "generic-auth-data" property.
+// The data to pass to the [callback@AuthDomainGenericAuthCallback].
+func (x *AuthDomain) SetPropertyGenericAuthData(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("generic-auth-data", &v)
+}
+
+// GetPropertyGenericAuthData gets the "generic-auth-data" property.
+// The data to pass to the [callback@AuthDomainGenericAuthCallback].
+func (x *AuthDomain) GetPropertyGenericAuthData() uintptr {
+	var v gobject.Value
+	x.GetProperty("generic-auth-data", &v)
+	return v.GetPointer()
+}
+
+// SetPropertyProxy sets the "proxy" property.
+// Whether or not this is a proxy auth domain.
+func (x *AuthDomain) SetPropertyProxy(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("proxy", &v)
+}
+
+// GetPropertyProxy gets the "proxy" property.
+// Whether or not this is a proxy auth domain.
+func (x *AuthDomain) GetPropertyProxy() bool {
+	var v gobject.Value
+	x.GetProperty("proxy", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyRealm sets the "realm" property.
+// The realm of this auth domain.
+func (x *AuthDomain) SetPropertyRealm(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("realm", &v)
+}
+
+// GetPropertyRealm gets the "realm" property.
+// The realm of this auth domain.
+func (x *AuthDomain) GetPropertyRealm() string {
+	var v gobject.Value
+	x.GetProperty("realm", &v)
+	return v.GetString()
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xAuthDomainGLibType, libs, "soup_auth_domain_get_type")
+
+	core.PuregoSafeRegister(&xAuthDomainAccepts, libs, "soup_auth_domain_accepts")
+	core.PuregoSafeRegister(&xAuthDomainAddPath, libs, "soup_auth_domain_add_path")
+	core.PuregoSafeRegister(&xAuthDomainChallenge, libs, "soup_auth_domain_challenge")
+	core.PuregoSafeRegister(&xAuthDomainCheckPassword, libs, "soup_auth_domain_check_password")
+	core.PuregoSafeRegister(&xAuthDomainCovers, libs, "soup_auth_domain_covers")
+	core.PuregoSafeRegister(&xAuthDomainGetRealm, libs, "soup_auth_domain_get_realm")
+	core.PuregoSafeRegister(&xAuthDomainRemovePath, libs, "soup_auth_domain_remove_path")
+	core.PuregoSafeRegister(&xAuthDomainSetFilter, libs, "soup_auth_domain_set_filter")
+	core.PuregoSafeRegister(&xAuthDomainSetGenericAuthCallback, libs, "soup_auth_domain_set_generic_auth_callback")
+
+}
diff --git a/v4/soup/soup-auth-manager.go b/v4/soup/soup-auth-manager.go
new file mode 100644
index 0000000000000000000000000000000000000000..617f910ef05b683c82f19c8d5de29cad9593efb3
--- /dev/null
+++ b/v4/soup/soup-auth-manager.go
@@ -0,0 +1,113 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type AuthManagerClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *AuthManagerClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// HTTP client-side authentication handler.
+//
+// #SoupAuthManager is the [iface@SessionFeature] that handles HTTP
+// authentication for a [class@Session].
+//
+// A #SoupAuthManager is added to the session by default, and normally
+// you don't need to worry about it at all. However, if you want to
+// disable HTTP authentication, you can remove the feature from the
+// session with [method@Session.remove_feature_by_type] or disable it on
+// individual requests with [method@Message.disable_feature].
+//
+// You can use this with [method@Session.remove_feature_by_type] or
+// [method@Message.disable_feature].
+//
+// (Although this type has only been publicly visible since libsoup 2.42, it has
+// always existed in the background, and you can use `g_type_from_name
+// ("SoupAuthManager")` to get its [alias@GObject.Type] in earlier releases.)
+type AuthManager struct {
+	gobject.Object
+}
+
+var xAuthManagerGLibType func() types.GType
+
+func AuthManagerGLibType() types.GType {
+	return xAuthManagerGLibType()
+}
+
+func AuthManagerNewFromInternalPtr(ptr uintptr) *AuthManager {
+	cls := &AuthManager{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xAuthManagerClearCachedCredentials func(uintptr)
+
+// Clear all credentials cached by @manager.
+func (x *AuthManager) ClearCachedCredentials() {
+
+	xAuthManagerClearCachedCredentials(x.GoPointer())
+
+}
+
+var xAuthManagerUseAuth func(uintptr, *glib.Uri, uintptr)
+
+// Records that @auth is to be used under @uri, as though a
+// WWW-Authenticate header had been received at that URI.
+//
+// This can be used to "preload" @manager's auth cache, to avoid an extra HTTP
+// round trip in the case where you know ahead of time that a 401 response will
+// be returned.
+//
+// This is only useful for authentication types where the initial
+// Authorization header does not depend on any additional information
+// from the server. (Eg, Basic or NTLM, but not Digest.)
+func (x *AuthManager) UseAuth(UriVar *glib.Uri, AuthVar *Auth) {
+
+	xAuthManagerUseAuth(x.GoPointer(), UriVar, AuthVar.GoPointer())
+
+}
+
+func (c *AuthManager) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *AuthManager) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xAuthManagerGLibType, libs, "soup_auth_manager_get_type")
+
+	core.PuregoSafeRegister(&xAuthManagerClearCachedCredentials, libs, "soup_auth_manager_clear_cached_credentials")
+	core.PuregoSafeRegister(&xAuthManagerUseAuth, libs, "soup_auth_manager_use_auth")
+
+}
diff --git a/v4/soup/soup-auth-negotiate.go b/v4/soup/soup-auth-negotiate.go
new file mode 100644
index 0000000000000000000000000000000000000000..ca0424c142d54142d726f0bc2c681233c3576e35
--- /dev/null
+++ b/v4/soup/soup-auth-negotiate.go
@@ -0,0 +1,76 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// HTTP-based GSS-Negotiate authentication, as defined by
+// [RFC 4559](https://datatracker.ietf.org/doc/html/rfc4559).
+//
+// [class@Session]s do not support this type by default; if you want to
+// enable support for it, call [method@Session.add_feature_by_type],
+// passing %SOUP_TYPE_AUTH_NEGOTIATE.
+//
+// This auth type will only work if libsoup was compiled with GSSAPI
+// support; you can check [func@AuthNegotiate.supported] to see if it
+// was.
+type AuthNegotiate struct {
+	Auth
+}
+
+var xAuthNegotiateGLibType func() types.GType
+
+func AuthNegotiateGLibType() types.GType {
+	return xAuthNegotiateGLibType()
+}
+
+func AuthNegotiateNewFromInternalPtr(ptr uintptr) *AuthNegotiate {
+	cls := &AuthNegotiate{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *AuthNegotiate) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *AuthNegotiate) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+var xAuthNegotiateSupported func() bool
+
+// Indicates whether libsoup was built with GSSAPI support.
+//
+// If this is %FALSE, %SOUP_TYPE_AUTH_NEGOTIATE will still be defined and can
+// still be added to a [class@Session], but libsoup will never attempt to
+// actually use this auth type.
+func AuthNegotiateSupported() bool {
+
+	cret := xAuthNegotiateSupported()
+	return cret
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xAuthNegotiateGLibType, libs, "soup_auth_negotiate_get_type")
+
+	core.PuregoSafeRegister(&xAuthNegotiateSupported, libs, "soup_auth_negotiate_supported")
+
+}
diff --git a/v4/soup/soup-auth-ntlm.go b/v4/soup/soup-auth-ntlm.go
new file mode 100644
index 0000000000000000000000000000000000000000..77d2a6fbe299aed1dcd4cdb9ad5dd04810dd31d9
--- /dev/null
+++ b/v4/soup/soup-auth-ntlm.go
@@ -0,0 +1,36 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import "github.com/jwijenbergh/puregotk/v4/gobject/types"
+
+// HTTP-based NTLM authentication.
+//
+// [class@Session]s do not support this type by default; if you want to
+// enable support for it, call [method@Session.add_feature_by_type],
+// passing %SOUP_TYPE_AUTH_NTLM.
+type AuthNTLM struct {
+	Auth
+}
+
+var xAuthNTLMGLibType func() types.GType
+
+func AuthNTLMGLibType() types.GType {
+	return xAuthNTLMGLibType()
+}
+
+func AuthNTLMNewFromInternalPtr(ptr uintptr) *AuthNTLM {
+	cls := &AuthNTLM{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *AuthNTLM) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *AuthNTLM) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
diff --git a/v4/soup/soup-auth.go b/v4/soup/soup-auth.go
new file mode 100644
index 0000000000000000000000000000000000000000..635708c34211feb4e5b42c8fd7c7d562613ce637
--- /dev/null
+++ b/v4/soup/soup-auth.go
@@ -0,0 +1,536 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type AuthClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+
+	SchemeName uintptr
+
+	Strength uint
+
+	xUpdate uintptr
+
+	xGetProtectionSpace uintptr
+
+	xAuthenticate uintptr
+
+	xIsAuthenticated uintptr
+
+	xGetAuthorization uintptr
+
+	xIsReady uintptr
+
+	xCanAuthenticate uintptr
+
+	Padding [6]uintptr
+}
+
+func (x *AuthClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideUpdate sets the "update" callback function.
+func (x *AuthClass) OverrideUpdate(cb func(*Auth, *Message, *glib.HashTable) bool) {
+	if cb == nil {
+		x.xUpdate = 0
+	} else {
+		x.xUpdate = purego.NewCallback(func(AuthVarp uintptr, MsgVarp uintptr, AuthHeaderVarp *glib.HashTable) bool {
+			return cb(AuthNewFromInternalPtr(AuthVarp), MessageNewFromInternalPtr(MsgVarp), AuthHeaderVarp)
+		})
+	}
+}
+
+// GetUpdate gets the "update" callback function.
+func (x *AuthClass) GetUpdate() func(*Auth, *Message, *glib.HashTable) bool {
+	if x.xUpdate == 0 {
+		return nil
+	}
+	var rawCallback func(AuthVarp uintptr, MsgVarp uintptr, AuthHeaderVarp *glib.HashTable) bool
+	purego.RegisterFunc(&rawCallback, x.xUpdate)
+	return func(AuthVar *Auth, MsgVar *Message, AuthHeaderVar *glib.HashTable) bool {
+		return rawCallback(AuthVar.GoPointer(), MsgVar.GoPointer(), AuthHeaderVar)
+	}
+}
+
+// OverrideGetProtectionSpace sets the "get_protection_space" callback function.
+func (x *AuthClass) OverrideGetProtectionSpace(cb func(*Auth, *glib.Uri) *glib.SList) {
+	if cb == nil {
+		x.xGetProtectionSpace = 0
+	} else {
+		x.xGetProtectionSpace = purego.NewCallback(func(AuthVarp uintptr, SourceUriVarp *glib.Uri) *glib.SList {
+			return cb(AuthNewFromInternalPtr(AuthVarp), SourceUriVarp)
+		})
+	}
+}
+
+// GetGetProtectionSpace gets the "get_protection_space" callback function.
+func (x *AuthClass) GetGetProtectionSpace() func(*Auth, *glib.Uri) *glib.SList {
+	if x.xGetProtectionSpace == 0 {
+		return nil
+	}
+	var rawCallback func(AuthVarp uintptr, SourceUriVarp *glib.Uri) *glib.SList
+	purego.RegisterFunc(&rawCallback, x.xGetProtectionSpace)
+	return func(AuthVar *Auth, SourceUriVar *glib.Uri) *glib.SList {
+		return rawCallback(AuthVar.GoPointer(), SourceUriVar)
+	}
+}
+
+// OverrideAuthenticate sets the "authenticate" callback function.
+func (x *AuthClass) OverrideAuthenticate(cb func(*Auth, string, string)) {
+	if cb == nil {
+		x.xAuthenticate = 0
+	} else {
+		x.xAuthenticate = purego.NewCallback(func(AuthVarp uintptr, UsernameVarp string, PasswordVarp string) {
+			cb(AuthNewFromInternalPtr(AuthVarp), UsernameVarp, PasswordVarp)
+		})
+	}
+}
+
+// GetAuthenticate gets the "authenticate" callback function.
+func (x *AuthClass) GetAuthenticate() func(*Auth, string, string) {
+	if x.xAuthenticate == 0 {
+		return nil
+	}
+	var rawCallback func(AuthVarp uintptr, UsernameVarp string, PasswordVarp string)
+	purego.RegisterFunc(&rawCallback, x.xAuthenticate)
+	return func(AuthVar *Auth, UsernameVar string, PasswordVar string) {
+		rawCallback(AuthVar.GoPointer(), UsernameVar, PasswordVar)
+	}
+}
+
+// OverrideIsAuthenticated sets the "is_authenticated" callback function.
+func (x *AuthClass) OverrideIsAuthenticated(cb func(*Auth) bool) {
+	if cb == nil {
+		x.xIsAuthenticated = 0
+	} else {
+		x.xIsAuthenticated = purego.NewCallback(func(AuthVarp uintptr) bool {
+			return cb(AuthNewFromInternalPtr(AuthVarp))
+		})
+	}
+}
+
+// GetIsAuthenticated gets the "is_authenticated" callback function.
+func (x *AuthClass) GetIsAuthenticated() func(*Auth) bool {
+	if x.xIsAuthenticated == 0 {
+		return nil
+	}
+	var rawCallback func(AuthVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xIsAuthenticated)
+	return func(AuthVar *Auth) bool {
+		return rawCallback(AuthVar.GoPointer())
+	}
+}
+
+// OverrideGetAuthorization sets the "get_authorization" callback function.
+func (x *AuthClass) OverrideGetAuthorization(cb func(*Auth, *Message) string) {
+	if cb == nil {
+		x.xGetAuthorization = 0
+	} else {
+		x.xGetAuthorization = purego.NewCallback(func(AuthVarp uintptr, MsgVarp uintptr) string {
+			return cb(AuthNewFromInternalPtr(AuthVarp), MessageNewFromInternalPtr(MsgVarp))
+		})
+	}
+}
+
+// GetGetAuthorization gets the "get_authorization" callback function.
+func (x *AuthClass) GetGetAuthorization() func(*Auth, *Message) string {
+	if x.xGetAuthorization == 0 {
+		return nil
+	}
+	var rawCallback func(AuthVarp uintptr, MsgVarp uintptr) string
+	purego.RegisterFunc(&rawCallback, x.xGetAuthorization)
+	return func(AuthVar *Auth, MsgVar *Message) string {
+		return rawCallback(AuthVar.GoPointer(), MsgVar.GoPointer())
+	}
+}
+
+// OverrideIsReady sets the "is_ready" callback function.
+func (x *AuthClass) OverrideIsReady(cb func(*Auth, *Message) bool) {
+	if cb == nil {
+		x.xIsReady = 0
+	} else {
+		x.xIsReady = purego.NewCallback(func(AuthVarp uintptr, MsgVarp uintptr) bool {
+			return cb(AuthNewFromInternalPtr(AuthVarp), MessageNewFromInternalPtr(MsgVarp))
+		})
+	}
+}
+
+// GetIsReady gets the "is_ready" callback function.
+func (x *AuthClass) GetIsReady() func(*Auth, *Message) bool {
+	if x.xIsReady == 0 {
+		return nil
+	}
+	var rawCallback func(AuthVarp uintptr, MsgVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xIsReady)
+	return func(AuthVar *Auth, MsgVar *Message) bool {
+		return rawCallback(AuthVar.GoPointer(), MsgVar.GoPointer())
+	}
+}
+
+// OverrideCanAuthenticate sets the "can_authenticate" callback function.
+func (x *AuthClass) OverrideCanAuthenticate(cb func(*Auth) bool) {
+	if cb == nil {
+		x.xCanAuthenticate = 0
+	} else {
+		x.xCanAuthenticate = purego.NewCallback(func(AuthVarp uintptr) bool {
+			return cb(AuthNewFromInternalPtr(AuthVarp))
+		})
+	}
+}
+
+// GetCanAuthenticate gets the "can_authenticate" callback function.
+func (x *AuthClass) GetCanAuthenticate() func(*Auth) bool {
+	if x.xCanAuthenticate == 0 {
+		return nil
+	}
+	var rawCallback func(AuthVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xCanAuthenticate)
+	return func(AuthVar *Auth) bool {
+		return rawCallback(AuthVar.GoPointer())
+	}
+}
+
+// The abstract base class for handling authentication.
+//
+// Specific HTTP Authentication mechanisms are implemented by its subclasses,
+// but applications never need to be aware of the specific subclasses being
+// used.
+//
+// #SoupAuth objects store the authentication data associated with a given bit
+// of web space. They are created automatically by [class@Session].
+type Auth struct {
+	gobject.Object
+}
+
+var xAuthGLibType func() types.GType
+
+func AuthGLibType() types.GType {
+	return xAuthGLibType()
+}
+
+func AuthNewFromInternalPtr(ptr uintptr) *Auth {
+	cls := &Auth{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewAuth func(types.GType, uintptr, string) uintptr
+
+// Creates a new #SoupAuth of type @type with the information from
+// @msg and @auth_header.
+//
+// This is called by [class@Session]; you will normally not create auths
+// yourself.
+func NewAuth(TypeVar types.GType, MsgVar *Message, AuthHeaderVar string) *Auth {
+	var cls *Auth
+
+	cret := xNewAuth(TypeVar, MsgVar.GoPointer(), AuthHeaderVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Auth{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xAuthAuthenticate func(uintptr, string, string)
+
+// Call this on an auth to authenticate it.
+//
+// Normally this will cause the auth's message to be requeued with the new
+// authentication info.
+func (x *Auth) Authenticate(UsernameVar string, PasswordVar string) {
+
+	xAuthAuthenticate(x.GoPointer(), UsernameVar, PasswordVar)
+
+}
+
+var xAuthCanAuthenticate func(uintptr) bool
+
+// Tests if @auth is able to authenticate by providing credentials to the
+// [method@Auth.authenticate].
+func (x *Auth) CanAuthenticate() bool {
+
+	cret := xAuthCanAuthenticate(x.GoPointer())
+	return cret
+}
+
+var xAuthCancel func(uintptr)
+
+// Call this on an auth to cancel it.
+//
+// You need to cancel an auth to complete an asynchronous authenticate operation
+// when no credentials are provided ([method@Auth.authenticate] is not called).
+// The #SoupAuth will be cancelled on dispose if it hans't been authenticated.
+func (x *Auth) Cancel() {
+
+	xAuthCancel(x.GoPointer())
+
+}
+
+var xAuthFreeProtectionSpace func(uintptr, *glib.SList)
+
+// Frees @space.
+func (x *Auth) FreeProtectionSpace(SpaceVar *glib.SList) {
+
+	xAuthFreeProtectionSpace(x.GoPointer(), SpaceVar)
+
+}
+
+var xAuthGetAuthority func(uintptr) string
+
+// Returns the authority (host:port) that @auth is associated with.
+func (x *Auth) GetAuthority() string {
+
+	cret := xAuthGetAuthority(x.GoPointer())
+	return cret
+}
+
+var xAuthGetAuthorization func(uintptr, uintptr) string
+
+// Generates an appropriate "Authorization" header for @msg.
+//
+// (The session will only call this if [method@Auth.is_authenticated] returned
+// %TRUE.)
+func (x *Auth) GetAuthorization(MsgVar *Message) string {
+
+	cret := xAuthGetAuthorization(x.GoPointer(), MsgVar.GoPointer())
+	return cret
+}
+
+var xAuthGetInfo func(uintptr) string
+
+// Gets an opaque identifier for @auth.
+//
+// The identifier can be used as a hash key or the like. #SoupAuth objects from
+// the same server with the same identifier refer to the same authentication
+// domain (eg, the URLs associated with them take the same usernames and
+// passwords).
+func (x *Auth) GetInfo() string {
+
+	cret := xAuthGetInfo(x.GoPointer())
+	return cret
+}
+
+var xAuthGetProtectionSpace func(uintptr, *glib.Uri) *glib.SList
+
+// Returns a list of paths on the server which @auth extends over.
+//
+// (All subdirectories of these paths are also assumed to be part
+// of @auth's protection space, unless otherwise discovered not to
+// be.)
+func (x *Auth) GetProtectionSpace(SourceUriVar *glib.Uri) *glib.SList {
+
+	cret := xAuthGetProtectionSpace(x.GoPointer(), SourceUriVar)
+	return cret
+}
+
+var xAuthGetRealm func(uintptr) string
+
+// Returns @auth's realm.
+//
+// This is an identifier that distinguishes separate authentication spaces on a
+// given server, and may be some string that is meaningful to the user.
+// (Although it is probably not localized.)
+func (x *Auth) GetRealm() string {
+
+	cret := xAuthGetRealm(x.GoPointer())
+	return cret
+}
+
+var xAuthGetSchemeName func(uintptr) string
+
+// soup_auth_get_scheme_name: (attributes org.gtk.Method.get_property=scheme-name)
+// Returns @auth's scheme name. (Eg, "Basic", "Digest", or "NTLM")
+func (x *Auth) GetSchemeName() string {
+
+	cret := xAuthGetSchemeName(x.GoPointer())
+	return cret
+}
+
+var xAuthIsAuthenticated func(uintptr) bool
+
+// Tests if @auth has been given a username and password.
+func (x *Auth) IsAuthenticated() bool {
+
+	cret := xAuthIsAuthenticated(x.GoPointer())
+	return cret
+}
+
+var xAuthIsCancelled func(uintptr) bool
+
+// Tests if @auth has been cancelled
+func (x *Auth) IsCancelled() bool {
+
+	cret := xAuthIsCancelled(x.GoPointer())
+	return cret
+}
+
+var xAuthIsForProxy func(uintptr) bool
+
+// Tests whether or not @auth is associated with a proxy server rather
+// than an "origin" server.
+func (x *Auth) IsForProxy() bool {
+
+	cret := xAuthIsForProxy(x.GoPointer())
+	return cret
+}
+
+var xAuthIsReady func(uintptr, uintptr) bool
+
+// Tests if @auth is ready to make a request for @msg with.
+//
+// For most auths, this is equivalent to [method@Auth.is_authenticated], but for
+// some auth types (eg, NTLM), the auth may be sendable (eg, as an
+// authentication request) even before it is authenticated.
+func (x *Auth) IsReady(MsgVar *Message) bool {
+
+	cret := xAuthIsReady(x.GoPointer(), MsgVar.GoPointer())
+	return cret
+}
+
+var xAuthUpdate func(uintptr, uintptr, string) bool
+
+// Updates @auth with the information from @msg and @auth_header,
+// possibly un-authenticating it.
+//
+// As with [ctor@Auth.new], this is normally only used by [class@Session].
+func (x *Auth) Update(MsgVar *Message, AuthHeaderVar string) bool {
+
+	cret := xAuthUpdate(x.GoPointer(), MsgVar.GoPointer(), AuthHeaderVar)
+	return cret
+}
+
+func (c *Auth) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Auth) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyAuthority sets the "authority" property.
+// The authority (host:port) being authenticated to.
+func (x *Auth) SetPropertyAuthority(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("authority", &v)
+}
+
+// GetPropertyAuthority gets the "authority" property.
+// The authority (host:port) being authenticated to.
+func (x *Auth) GetPropertyAuthority() string {
+	var v gobject.Value
+	x.GetProperty("authority", &v)
+	return v.GetString()
+}
+
+// GetPropertyIsAuthenticated gets the "is-authenticated" property.
+// Whether or not the auth has been authenticated.
+func (x *Auth) GetPropertyIsAuthenticated() bool {
+	var v gobject.Value
+	x.GetProperty("is-authenticated", &v)
+	return v.GetBoolean()
+}
+
+// GetPropertyIsCancelled gets the "is-cancelled" property.
+// Whether or not the auth has been cancelled.
+func (x *Auth) GetPropertyIsCancelled() bool {
+	var v gobject.Value
+	x.GetProperty("is-cancelled", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyIsForProxy sets the "is-for-proxy" property.
+// Whether or not the auth is for a proxy server.
+func (x *Auth) SetPropertyIsForProxy(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-for-proxy", &v)
+}
+
+// GetPropertyIsForProxy gets the "is-for-proxy" property.
+// Whether or not the auth is for a proxy server.
+func (x *Auth) GetPropertyIsForProxy() bool {
+	var v gobject.Value
+	x.GetProperty("is-for-proxy", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyRealm sets the "realm" property.
+// The authentication realm.
+func (x *Auth) SetPropertyRealm(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("realm", &v)
+}
+
+// GetPropertyRealm gets the "realm" property.
+// The authentication realm.
+func (x *Auth) GetPropertyRealm() string {
+	var v gobject.Value
+	x.GetProperty("realm", &v)
+	return v.GetString()
+}
+
+// GetPropertySchemeName gets the "scheme-name" property.
+// The authentication scheme name.
+func (x *Auth) GetPropertySchemeName() string {
+	var v gobject.Value
+	x.GetProperty("scheme-name", &v)
+	return v.GetString()
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xAuthGLibType, libs, "soup_auth_get_type")
+
+	core.PuregoSafeRegister(&xNewAuth, libs, "soup_auth_new")
+
+	core.PuregoSafeRegister(&xAuthAuthenticate, libs, "soup_auth_authenticate")
+	core.PuregoSafeRegister(&xAuthCanAuthenticate, libs, "soup_auth_can_authenticate")
+	core.PuregoSafeRegister(&xAuthCancel, libs, "soup_auth_cancel")
+	core.PuregoSafeRegister(&xAuthFreeProtectionSpace, libs, "soup_auth_free_protection_space")
+	core.PuregoSafeRegister(&xAuthGetAuthority, libs, "soup_auth_get_authority")
+	core.PuregoSafeRegister(&xAuthGetAuthorization, libs, "soup_auth_get_authorization")
+	core.PuregoSafeRegister(&xAuthGetInfo, libs, "soup_auth_get_info")
+	core.PuregoSafeRegister(&xAuthGetProtectionSpace, libs, "soup_auth_get_protection_space")
+	core.PuregoSafeRegister(&xAuthGetRealm, libs, "soup_auth_get_realm")
+	core.PuregoSafeRegister(&xAuthGetSchemeName, libs, "soup_auth_get_scheme_name")
+	core.PuregoSafeRegister(&xAuthIsAuthenticated, libs, "soup_auth_is_authenticated")
+	core.PuregoSafeRegister(&xAuthIsCancelled, libs, "soup_auth_is_cancelled")
+	core.PuregoSafeRegister(&xAuthIsForProxy, libs, "soup_auth_is_for_proxy")
+	core.PuregoSafeRegister(&xAuthIsReady, libs, "soup_auth_is_ready")
+	core.PuregoSafeRegister(&xAuthUpdate, libs, "soup_auth_update")
+
+}
diff --git a/v4/soup/soup-cache.go b/v4/soup/soup-cache.go
new file mode 100644
index 0000000000000000000000000000000000000000..fe16795a4daf3cf13fe4f68f9de81cc229cdefdd
--- /dev/null
+++ b/v4/soup/soup-cache.go
@@ -0,0 +1,250 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type CacheClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+
+	xGetCacheability uintptr
+
+	Padding [4]uintptr
+}
+
+func (x *CacheClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideGetCacheability sets the "get_cacheability" callback function.
+func (x *CacheClass) OverrideGetCacheability(cb func(*Cache, *Message) Cacheability) {
+	if cb == nil {
+		x.xGetCacheability = 0
+	} else {
+		x.xGetCacheability = purego.NewCallback(func(CacheVarp uintptr, MsgVarp uintptr) Cacheability {
+			return cb(CacheNewFromInternalPtr(CacheVarp), MessageNewFromInternalPtr(MsgVarp))
+		})
+	}
+}
+
+// GetGetCacheability gets the "get_cacheability" callback function.
+func (x *CacheClass) GetGetCacheability() func(*Cache, *Message) Cacheability {
+	if x.xGetCacheability == 0 {
+		return nil
+	}
+	var rawCallback func(CacheVarp uintptr, MsgVarp uintptr) Cacheability
+	purego.RegisterFunc(&rawCallback, x.xGetCacheability)
+	return func(CacheVar *Cache, MsgVar *Message) Cacheability {
+		return rawCallback(CacheVar.GoPointer(), MsgVar.GoPointer())
+	}
+}
+
+// Indicates if a message should or shouldn't be cached.
+type Cacheability int
+
+var xCacheabilityGLibType func() types.GType
+
+func CacheabilityGLibType() types.GType {
+	return xCacheabilityGLibType()
+}
+
+const (
+
+	// The message should be cached
+	CacheCacheableValue Cacheability = 1
+	// The message shouldn't be cached
+	CacheUncacheableValue Cacheability = 2
+	// The messages cache should be invalidated
+	CacheInvalidatesValue Cacheability = 4
+	// The messages cache should be updated
+	CacheValidatesValue Cacheability = 8
+)
+
+// The type of cache; this affects what kinds of responses will be
+// saved.
+type CacheType int
+
+var xCacheTypeGLibType func() types.GType
+
+func CacheTypeGLibType() types.GType {
+	return xCacheTypeGLibType()
+}
+
+const (
+
+	// a single-user cache
+	CacheSingleUserValue CacheType = 0
+	// a shared cache
+	CacheSharedValue CacheType = 1
+)
+
+// File-based cache for HTTP resources.
+type Cache struct {
+	gobject.Object
+}
+
+var xCacheGLibType func() types.GType
+
+func CacheGLibType() types.GType {
+	return xCacheGLibType()
+}
+
+func CacheNewFromInternalPtr(ptr uintptr) *Cache {
+	cls := &Cache{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewCache func(string, CacheType) uintptr
+
+// Creates a new #SoupCache.
+func NewCache(CacheDirVar string, CacheTypeVar CacheType) *Cache {
+	var cls *Cache
+
+	cret := xNewCache(CacheDirVar, CacheTypeVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Cache{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xCacheClear func(uintptr)
+
+// Will remove all entries in the @cache plus all the cache files.
+//
+// This is not thread safe and must be called only from the thread that created the #SoupCache
+func (x *Cache) Clear() {
+
+	xCacheClear(x.GoPointer())
+
+}
+
+var xCacheDump func(uintptr)
+
+// Synchronously writes the cache index out to disk.
+//
+// Contrast with [method@Cache.flush], which writes pending cache *entries* to
+// disk.
+//
+// You must call this before exiting if you want your cache data to
+// persist between sessions.
+//
+// This is not thread safe and must be called only from the thread that created the #SoupCache
+func (x *Cache) Dump() {
+
+	xCacheDump(x.GoPointer())
+
+}
+
+var xCacheFlush func(uintptr)
+
+// Forces all pending writes in the @cache to be
+// committed to disk.
+//
+// For doing so it will iterate the [struct@GLib.MainContext] associated with
+// @cache's session as long as needed.
+//
+// Contrast with [method@Cache.dump], which writes out the cache index file.
+func (x *Cache) Flush() {
+
+	xCacheFlush(x.GoPointer())
+
+}
+
+var xCacheGetMaxSize func(uintptr) uint
+
+// Gets the maximum size of the cache.
+func (x *Cache) GetMaxSize() uint {
+
+	cret := xCacheGetMaxSize(x.GoPointer())
+	return cret
+}
+
+var xCacheLoad func(uintptr)
+
+// Loads the contents of @cache's index into memory.
+//
+// This is not thread safe and must be called only from the thread that created the #SoupCache
+func (x *Cache) Load() {
+
+	xCacheLoad(x.GoPointer())
+
+}
+
+var xCacheSetMaxSize func(uintptr, uint)
+
+// Sets the maximum size of the cache.
+func (x *Cache) SetMaxSize(MaxSizeVar uint) {
+
+	xCacheSetMaxSize(x.GoPointer(), MaxSizeVar)
+
+}
+
+func (c *Cache) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Cache) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyCacheDir sets the "cache-dir" property.
+// The directory to store the cache files.
+func (x *Cache) SetPropertyCacheDir(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("cache-dir", &v)
+}
+
+// GetPropertyCacheDir gets the "cache-dir" property.
+// The directory to store the cache files.
+func (x *Cache) GetPropertyCacheDir() string {
+	var v gobject.Value
+	x.GetProperty("cache-dir", &v)
+	return v.GetString()
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xCacheabilityGLibType, libs, "soup_cacheability_get_type")
+
+	core.PuregoSafeRegister(&xCacheTypeGLibType, libs, "soup_cache_type_get_type")
+
+	core.PuregoSafeRegister(&xCacheGLibType, libs, "soup_cache_get_type")
+
+	core.PuregoSafeRegister(&xNewCache, libs, "soup_cache_new")
+
+	core.PuregoSafeRegister(&xCacheClear, libs, "soup_cache_clear")
+	core.PuregoSafeRegister(&xCacheDump, libs, "soup_cache_dump")
+	core.PuregoSafeRegister(&xCacheFlush, libs, "soup_cache_flush")
+	core.PuregoSafeRegister(&xCacheGetMaxSize, libs, "soup_cache_get_max_size")
+	core.PuregoSafeRegister(&xCacheLoad, libs, "soup_cache_load")
+	core.PuregoSafeRegister(&xCacheSetMaxSize, libs, "soup_cache_set_max_size")
+
+}
diff --git a/v4/soup/soup-content-decoder.go b/v4/soup/soup-content-decoder.go
new file mode 100644
index 0000000000000000000000000000000000000000..35d61633bb807fb65f4801d7f98e33f06ca1092b
--- /dev/null
+++ b/v4/soup/soup-content-decoder.go
@@ -0,0 +1,71 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type ContentDecoderClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *ContentDecoderClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Handles decoding of HTTP messages.
+//
+// #SoupContentDecoder handles adding the "Accept-Encoding" header on
+// outgoing messages, and processing the "Content-Encoding" header on
+// incoming ones. Currently it supports the "gzip", "deflate", and "br"
+// content codings.
+//
+// A #SoupContentDecoder will automatically be
+// added to the session by default. (You can use
+// [method@Session.remove_feature_by_type] if you don't
+// want this.)
+//
+// If #SoupContentDecoder successfully decodes the Content-Encoding,
+// the message body will contain the decoded data; however, the message headers
+// will be unchanged (and so "Content-Encoding" will still be present,
+// "Content-Length" will describe the original encoded length, etc).
+//
+// If "Content-Encoding" contains any encoding types that
+// #SoupContentDecoder doesn't recognize, then none of the encodings
+// will be decoded.
+//
+// (Note that currently there is no way to (automatically) use
+// Content-Encoding when sending a request body, or to pick specific
+// encoding types to support.)
+type ContentDecoder struct {
+	gobject.Object
+}
+
+var xContentDecoderGLibType func() types.GType
+
+func ContentDecoderGLibType() types.GType {
+	return xContentDecoderGLibType()
+}
+
+func ContentDecoderNewFromInternalPtr(ptr uintptr) *ContentDecoder {
+	cls := &ContentDecoder{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *ContentDecoder) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *ContentDecoder) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
diff --git a/v4/soup/soup-content-sniffer.go b/v4/soup/soup-content-sniffer.go
new file mode 100644
index 0000000000000000000000000000000000000000..e9288bf65dfde6339e0a5b60dadbc72ff2611b65
--- /dev/null
+++ b/v4/soup/soup-content-sniffer.go
@@ -0,0 +1,106 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type ContentSnifferClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *ContentSnifferClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Sniffs the mime type of messages.
+//
+// A #SoupContentSniffer tries to detect the actual content type of
+// the files that are being downloaded by looking at some of the data
+// before the [class@Message] emits its [signal@Message::got-headers] signal.
+// #SoupContentSniffer implements [iface@SessionFeature], so you can add
+// content sniffing to a session with [method@Session.add_feature] or
+// [method@Session.add_feature_by_type].
+type ContentSniffer struct {
+	gobject.Object
+}
+
+var xContentSnifferGLibType func() types.GType
+
+func ContentSnifferGLibType() types.GType {
+	return xContentSnifferGLibType()
+}
+
+func ContentSnifferNewFromInternalPtr(ptr uintptr) *ContentSniffer {
+	cls := &ContentSniffer{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewContentSniffer func() uintptr
+
+// Creates a new #SoupContentSniffer.
+func NewContentSniffer() *ContentSniffer {
+	var cls *ContentSniffer
+
+	cret := xNewContentSniffer()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &ContentSniffer{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContentSnifferSniff func(uintptr, uintptr, *glib.Bytes, **glib.HashTable) string
+
+// Sniffs @buffer to determine its Content-Type.
+//
+// The result may also be influenced by the Content-Type declared in @msg's
+// response headers.
+func (x *ContentSniffer) Sniff(MsgVar *Message, BufferVar *glib.Bytes, ParamsVar **glib.HashTable) string {
+
+	cret := xContentSnifferSniff(x.GoPointer(), MsgVar.GoPointer(), BufferVar, ParamsVar)
+	return cret
+}
+
+func (c *ContentSniffer) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *ContentSniffer) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xContentSnifferGLibType, libs, "soup_content_sniffer_get_type")
+
+	core.PuregoSafeRegister(&xNewContentSniffer, libs, "soup_content_sniffer_new")
+
+	core.PuregoSafeRegister(&xContentSnifferSniff, libs, "soup_content_sniffer_sniff")
+
+}
diff --git a/v4/soup/soup-cookie-jar-db.go b/v4/soup/soup-cookie-jar-db.go
new file mode 100644
index 0000000000000000000000000000000000000000..b3a1bdbae8a32fcea32b6243da34f5fedaa4178f
--- /dev/null
+++ b/v4/soup/soup-cookie-jar-db.go
@@ -0,0 +1,114 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type CookieJarDBClass struct {
+	_ structs.HostLayout
+
+	ParentClass CookieJarClass
+}
+
+func (x *CookieJarDBClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Database-based Cookie Jar.
+//
+// #SoupCookieJarDB is a [class@CookieJar] that reads cookies from and writes
+// them to a sqlite database in the new Mozilla format.
+//
+// (This is identical to `SoupCookieJarSqlite` in
+// libsoup-gnome; it has just been moved into libsoup proper, and
+// renamed to avoid conflicting.)
+type CookieJarDB struct {
+	CookieJar
+}
+
+var xCookieJarDBGLibType func() types.GType
+
+func CookieJarDBGLibType() types.GType {
+	return xCookieJarDBGLibType()
+}
+
+func CookieJarDBNewFromInternalPtr(ptr uintptr) *CookieJarDB {
+	cls := &CookieJarDB{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewCookieJarDB func(string, bool) uintptr
+
+// Creates a #SoupCookieJarDB.
+//
+// @filename will be read in at startup to create an initial set of cookies. If
+// @read_only is %FALSE, then the non-session cookies will be written to
+// @filename when the [signal@CookieJar::changed] signal is emitted from the
+// jar. (If @read_only is %TRUE, then the cookie jar will only be used for this
+// session, and changes made to it will be lost when the jar is destroyed.)
+func NewCookieJarDB(FilenameVar string, ReadOnlyVar bool) *CookieJarDB {
+	var cls *CookieJarDB
+
+	cret := xNewCookieJarDB(FilenameVar, ReadOnlyVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &CookieJarDB{}
+	cls.Ptr = cret
+	return cls
+}
+
+func (c *CookieJarDB) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *CookieJarDB) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyFilename sets the "filename" property.
+// Cookie-storage filename.
+func (x *CookieJarDB) SetPropertyFilename(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("filename", &v)
+}
+
+// GetPropertyFilename gets the "filename" property.
+// Cookie-storage filename.
+func (x *CookieJarDB) GetPropertyFilename() string {
+	var v gobject.Value
+	x.GetProperty("filename", &v)
+	return v.GetString()
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xCookieJarDBGLibType, libs, "soup_cookie_jar_db_get_type")
+
+	core.PuregoSafeRegister(&xNewCookieJarDB, libs, "soup_cookie_jar_db_new")
+
+}
diff --git a/v4/soup/soup-cookie-jar-text.go b/v4/soup/soup-cookie-jar-text.go
new file mode 100644
index 0000000000000000000000000000000000000000..79a840695dd5b9b3afba2009382e7e3e7b8d31b1
--- /dev/null
+++ b/v4/soup/soup-cookie-jar-text.go
@@ -0,0 +1,110 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type CookieJarTextClass struct {
+	_ structs.HostLayout
+
+	ParentClass CookieJarClass
+}
+
+func (x *CookieJarTextClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Text-file-based ("cookies.txt") Cookie Jar
+//
+// #SoupCookieJarText is a [class@CookieJar] that reads cookies from and writes
+// them to a text file in format similar to Mozilla's "cookies.txt".
+type CookieJarText struct {
+	CookieJar
+}
+
+var xCookieJarTextGLibType func() types.GType
+
+func CookieJarTextGLibType() types.GType {
+	return xCookieJarTextGLibType()
+}
+
+func CookieJarTextNewFromInternalPtr(ptr uintptr) *CookieJarText {
+	cls := &CookieJarText{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewCookieJarText func(string, bool) uintptr
+
+// Creates a #SoupCookieJarText.
+//
+// @filename will be read in at startup to create an initial set of cookies. If
+// @read_only is %FALSE, then the non-session cookies will be written to
+// @filename when the [signal@CookieJar::changed] signal is emitted from the
+// jar. (If @read_only is %TRUE, then the cookie jar will only be used for this
+// session, and changes made to it will be lost when the jar is destroyed.)
+func NewCookieJarText(FilenameVar string, ReadOnlyVar bool) *CookieJarText {
+	var cls *CookieJarText
+
+	cret := xNewCookieJarText(FilenameVar, ReadOnlyVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &CookieJarText{}
+	cls.Ptr = cret
+	return cls
+}
+
+func (c *CookieJarText) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *CookieJarText) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyFilename sets the "filename" property.
+// Cookie-storage filename.
+func (x *CookieJarText) SetPropertyFilename(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("filename", &v)
+}
+
+// GetPropertyFilename gets the "filename" property.
+// Cookie-storage filename.
+func (x *CookieJarText) GetPropertyFilename() string {
+	var v gobject.Value
+	x.GetProperty("filename", &v)
+	return v.GetString()
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xCookieJarTextGLibType, libs, "soup_cookie_jar_text_get_type")
+
+	core.PuregoSafeRegister(&xNewCookieJarText, libs, "soup_cookie_jar_text_new")
+
+}
diff --git a/v4/soup/soup-cookie-jar.go b/v4/soup/soup-cookie-jar.go
new file mode 100644
index 0000000000000000000000000000000000000000..842fd8a55eb785b8bd3ada04e9ca20a755c8213d
--- /dev/null
+++ b/v4/soup/soup-cookie-jar.go
@@ -0,0 +1,467 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type CookieJarClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+
+	xSave uintptr
+
+	xIsPersistent uintptr
+
+	xChanged uintptr
+
+	Padding [6]uintptr
+}
+
+func (x *CookieJarClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideSave sets the "save" callback function.
+func (x *CookieJarClass) OverrideSave(cb func(*CookieJar)) {
+	if cb == nil {
+		x.xSave = 0
+	} else {
+		x.xSave = purego.NewCallback(func(JarVarp uintptr) {
+			cb(CookieJarNewFromInternalPtr(JarVarp))
+		})
+	}
+}
+
+// GetSave gets the "save" callback function.
+func (x *CookieJarClass) GetSave() func(*CookieJar) {
+	if x.xSave == 0 {
+		return nil
+	}
+	var rawCallback func(JarVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xSave)
+	return func(JarVar *CookieJar) {
+		rawCallback(JarVar.GoPointer())
+	}
+}
+
+// OverrideIsPersistent sets the "is_persistent" callback function.
+func (x *CookieJarClass) OverrideIsPersistent(cb func(*CookieJar) bool) {
+	if cb == nil {
+		x.xIsPersistent = 0
+	} else {
+		x.xIsPersistent = purego.NewCallback(func(JarVarp uintptr) bool {
+			return cb(CookieJarNewFromInternalPtr(JarVarp))
+		})
+	}
+}
+
+// GetIsPersistent gets the "is_persistent" callback function.
+func (x *CookieJarClass) GetIsPersistent() func(*CookieJar) bool {
+	if x.xIsPersistent == 0 {
+		return nil
+	}
+	var rawCallback func(JarVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xIsPersistent)
+	return func(JarVar *CookieJar) bool {
+		return rawCallback(JarVar.GoPointer())
+	}
+}
+
+// OverrideChanged sets the "changed" callback function.
+func (x *CookieJarClass) OverrideChanged(cb func(*CookieJar, *Cookie, *Cookie)) {
+	if cb == nil {
+		x.xChanged = 0
+	} else {
+		x.xChanged = purego.NewCallback(func(JarVarp uintptr, OldCookieVarp *Cookie, NewCookieVarp *Cookie) {
+			cb(CookieJarNewFromInternalPtr(JarVarp), OldCookieVarp, NewCookieVarp)
+		})
+	}
+}
+
+// GetChanged gets the "changed" callback function.
+func (x *CookieJarClass) GetChanged() func(*CookieJar, *Cookie, *Cookie) {
+	if x.xChanged == 0 {
+		return nil
+	}
+	var rawCallback func(JarVarp uintptr, OldCookieVarp *Cookie, NewCookieVarp *Cookie)
+	purego.RegisterFunc(&rawCallback, x.xChanged)
+	return func(JarVar *CookieJar, OldCookieVar *Cookie, NewCookieVar *Cookie) {
+		rawCallback(JarVar.GoPointer(), OldCookieVar, NewCookieVar)
+	}
+}
+
+// The policy for accepting or rejecting cookies returned in
+// responses.
+type CookieJarAcceptPolicy int
+
+var xCookieJarAcceptPolicyGLibType func() types.GType
+
+func CookieJarAcceptPolicyGLibType() types.GType {
+	return xCookieJarAcceptPolicyGLibType()
+}
+
+const (
+
+	// accept all cookies unconditionally.
+	CookieJarAcceptAlwaysValue CookieJarAcceptPolicy = 0
+	// reject all cookies unconditionally.
+	CookieJarAcceptNeverValue CookieJarAcceptPolicy = 1
+	// accept all cookies set by the main
+	//   document loaded in the application using libsoup. An example of the most
+	//   common case, web browsers, would be: If http://www.example.com is the page
+	//   loaded, accept all cookies set by example.com, but if a resource from
+	//   http://www.third-party.com is loaded from that page reject any cookie that
+	//   it could try to set. For libsoup to be able to tell apart first party
+	//   cookies from the rest, the application must call
+	//   [method@Message.set_first_party] on each outgoing [class@Message], setting
+	//   the [struct@GLib.Uri] of the main document. If no first party is set in a
+	//   message when this policy is in effect, cookies will be assumed to be third
+	//   party by default.
+	CookieJarAcceptNoThirdPartyValue CookieJarAcceptPolicy = 2
+	// accept all cookies set by
+	//   the main document loaded in the application using libsoup, and from domains
+	//   that have previously set at least one cookie when loaded as the main
+	//   document. An example of the most common case, web browsers, would be: if
+	//   http://www.example.com is the page loaded, accept all cookies set by
+	//   example.com, but if a resource from http://www.third-party.com is loaded
+	//   from that page, reject any cookie that it could try to set unless it
+	//   already has a cookie in the cookie jar. For libsoup to be able to tell
+	//   apart first party cookies from the rest, the application must call
+	//   [method@Message.set_first_party] on each outgoing #SoupMessage, setting the
+	//   [struct@GLib.Uri] of the main document. If no first party is set in a
+	//   message when this policy is in effect, cookies will be assumed to be third
+	//   party by default.
+	CookieJarAcceptGrandfatheredThirdPartyValue CookieJarAcceptPolicy = 3
+)
+
+// Automatic cookie handling for SoupSession.
+//
+// A #SoupCookieJar stores [struct@Cookie]s and arrange for them to be sent with
+// the appropriate [class@Message]s. #SoupCookieJar implements
+// [iface@SessionFeature], so you can add a cookie jar to a session with
+// [method@Session.add_feature] or [method@Session.add_feature_by_type].
+//
+// Note that the base #SoupCookieJar class does not support any form
+// of long-term cookie persistence.
+type CookieJar struct {
+	gobject.Object
+}
+
+var xCookieJarGLibType func() types.GType
+
+func CookieJarGLibType() types.GType {
+	return xCookieJarGLibType()
+}
+
+func CookieJarNewFromInternalPtr(ptr uintptr) *CookieJar {
+	cls := &CookieJar{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewCookieJar func() uintptr
+
+// Creates a new #SoupCookieJar.
+//
+// The base #SoupCookieJar class does not support persistent storage of cookies;
+// use a subclass for that.
+func NewCookieJar() *CookieJar {
+	var cls *CookieJar
+
+	cret := xNewCookieJar()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &CookieJar{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xCookieJarAddCookie func(uintptr, *Cookie)
+
+// Adds @cookie to @jar.
+//
+// Emits the [signal@CookieJar::changed] signal if we are modifying
+// an existing cookie or adding a valid new cookie ('valid' means
+// that the cookie's expire date is not in the past).
+//
+// @cookie will be 'stolen' by the jar, so don't free it afterwards.
+func (x *CookieJar) AddCookie(CookieVar *Cookie) {
+
+	xCookieJarAddCookie(x.GoPointer(), CookieVar)
+
+}
+
+var xCookieJarAddCookieFull func(uintptr, *Cookie, *glib.Uri, *glib.Uri)
+
+// Adds @cookie to @jar.
+//
+// Emits the [signal@CookieJar::changed] signal if we are modifying an existing
+// cookie or adding a valid new cookie ('valid' means that the cookie's expire
+// date is not in the past).
+//
+// @first_party will be used to reject cookies coming from third party
+// resources in case such a security policy is set in the @jar.
+//
+// @uri will be used to reject setting or overwriting secure cookies
+// from insecure origins. %NULL is treated as secure.
+//
+// @cookie will be 'stolen' by the jar, so don't free it afterwards.
+func (x *CookieJar) AddCookieFull(CookieVar *Cookie, UriVar *glib.Uri, FirstPartyVar *glib.Uri) {
+
+	xCookieJarAddCookieFull(x.GoPointer(), CookieVar, UriVar, FirstPartyVar)
+
+}
+
+var xCookieJarAddCookieWithFirstParty func(uintptr, *glib.Uri, *Cookie)
+
+// Adds @cookie to @jar.
+//
+// Emits the [signal@CookieJar::changed] signal if we are modifying
+// an existing cookie or adding a valid new cookie ('valid' means
+// that the cookie's expire date is not in the past).
+//
+// @first_party will be used to reject cookies coming from third party
+// resources in case such a security policy is set in the @jar.
+//
+// @cookie will be 'stolen' by the jar, so don't free it afterwards.
+//
+// For secure cookies to work properly you may want to use
+// [method@CookieJar.add_cookie_full].
+func (x *CookieJar) AddCookieWithFirstParty(FirstPartyVar *glib.Uri, CookieVar *Cookie) {
+
+	xCookieJarAddCookieWithFirstParty(x.GoPointer(), FirstPartyVar, CookieVar)
+
+}
+
+var xCookieJarAllCookies func(uintptr) *glib.SList
+
+// Constructs a [struct@GLib.List] with every cookie inside the @jar.
+//
+// The cookies in the list are a copy of the original, so
+// you have to free them when you are done with them.
+//
+// For historical reasons this list is in reverse order.
+func (x *CookieJar) AllCookies() *glib.SList {
+
+	cret := xCookieJarAllCookies(x.GoPointer())
+	return cret
+}
+
+var xCookieJarDeleteCookie func(uintptr, *Cookie)
+
+// Deletes @cookie from @jar.
+//
+// Emits the [signal@CookieJar::changed] signal.
+func (x *CookieJar) DeleteCookie(CookieVar *Cookie) {
+
+	xCookieJarDeleteCookie(x.GoPointer(), CookieVar)
+
+}
+
+var xCookieJarGetAcceptPolicy func(uintptr) CookieJarAcceptPolicy
+
+// Gets @jar's [enum@CookieJarAcceptPolicy].
+func (x *CookieJar) GetAcceptPolicy() CookieJarAcceptPolicy {
+
+	cret := xCookieJarGetAcceptPolicy(x.GoPointer())
+	return cret
+}
+
+var xCookieJarGetCookieList func(uintptr, *glib.Uri, bool) *glib.SList
+
+// Retrieves the list of cookies that would be sent with a request to @uri
+// as a [struct@GLib.List] of #SoupCookie objects.
+//
+// If @for_http is %TRUE, the return value will include cookies marked
+// "HttpOnly" (that is, cookies that the server wishes to keep hidden
+// from client-side scripting operations such as the JavaScript
+// document.cookies property). Since #SoupCookieJar sets the Cookie
+// header itself when making the actual HTTP request, you should
+// almost certainly be setting @for_http to %FALSE if you are calling
+// this.
+func (x *CookieJar) GetCookieList(UriVar *glib.Uri, ForHttpVar bool) *glib.SList {
+
+	cret := xCookieJarGetCookieList(x.GoPointer(), UriVar, ForHttpVar)
+	return cret
+}
+
+var xCookieJarGetCookieListWithSameSiteInfo func(uintptr, *glib.Uri, *glib.Uri, *glib.Uri, bool, bool, bool) *glib.SList
+
+// This is an extended version of [method@CookieJar.get_cookie_list] that
+// provides more information required to use SameSite cookies.
+//
+// See the [SameSite cookies
+// spec](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00) for
+// more detailed information.
+func (x *CookieJar) GetCookieListWithSameSiteInfo(UriVar *glib.Uri, TopLevelVar *glib.Uri, SiteForCookiesVar *glib.Uri, ForHttpVar bool, IsSafeMethodVar bool, IsTopLevelNavigationVar bool) *glib.SList {
+
+	cret := xCookieJarGetCookieListWithSameSiteInfo(x.GoPointer(), UriVar, TopLevelVar, SiteForCookiesVar, ForHttpVar, IsSafeMethodVar, IsTopLevelNavigationVar)
+	return cret
+}
+
+var xCookieJarGetCookies func(uintptr, *glib.Uri, bool) string
+
+// Retrieves (in Cookie-header form) the list of cookies that would
+// be sent with a request to @uri.
+//
+// If @for_http is %TRUE, the return value will include cookies marked
+// "HttpOnly" (that is, cookies that the server wishes to keep hidden
+// from client-side scripting operations such as the JavaScript
+// document.cookies property). Since #SoupCookieJar sets the Cookie
+// header itself when making the actual HTTP request, you should
+// almost certainly be setting @for_http to %FALSE if you are calling
+// this.
+func (x *CookieJar) GetCookies(UriVar *glib.Uri, ForHttpVar bool) string {
+
+	cret := xCookieJarGetCookies(x.GoPointer(), UriVar, ForHttpVar)
+	return cret
+}
+
+var xCookieJarIsPersistent func(uintptr) bool
+
+// Gets whether @jar stores cookies persistenly.
+func (x *CookieJar) IsPersistent() bool {
+
+	cret := xCookieJarIsPersistent(x.GoPointer())
+	return cret
+}
+
+var xCookieJarSetAcceptPolicy func(uintptr, CookieJarAcceptPolicy)
+
+// Sets @policy as the cookie acceptance policy for @jar.
+func (x *CookieJar) SetAcceptPolicy(PolicyVar CookieJarAcceptPolicy) {
+
+	xCookieJarSetAcceptPolicy(x.GoPointer(), PolicyVar)
+
+}
+
+var xCookieJarSetCookie func(uintptr, *glib.Uri, string)
+
+// Adds @cookie to @jar, exactly as though it had appeared in a
+// Set-Cookie header returned from a request to @uri.
+//
+// Keep in mind that if the [enum@CookieJarAcceptPolicy] set is either
+// %SOUP_COOKIE_JAR_ACCEPT_NO_THIRD_PARTY or
+// %SOUP_COOKIE_JAR_ACCEPT_GRANDFATHERED_THIRD_PARTY you'll need to use
+// [method@CookieJar.set_cookie_with_first_party], otherwise the jar
+// will have no way of knowing if the cookie is being set by a third
+// party or not.
+func (x *CookieJar) SetCookie(UriVar *glib.Uri, CookieVar string) {
+
+	xCookieJarSetCookie(x.GoPointer(), UriVar, CookieVar)
+
+}
+
+var xCookieJarSetCookieWithFirstParty func(uintptr, *glib.Uri, *glib.Uri, string)
+
+// Adds @cookie to @jar, exactly as though it had appeared in a
+// Set-Cookie header returned from a request to @uri.
+//
+// @first_party will be used to reject cookies coming from third party resources
+// in case such a security policy is set in the @jar.
+func (x *CookieJar) SetCookieWithFirstParty(UriVar *glib.Uri, FirstPartyVar *glib.Uri, CookieVar string) {
+
+	xCookieJarSetCookieWithFirstParty(x.GoPointer(), UriVar, FirstPartyVar, CookieVar)
+
+}
+
+func (c *CookieJar) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *CookieJar) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyReadOnly sets the "read-only" property.
+// Whether or not the cookie jar is read-only.
+func (x *CookieJar) SetPropertyReadOnly(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("read-only", &v)
+}
+
+// GetPropertyReadOnly gets the "read-only" property.
+// Whether or not the cookie jar is read-only.
+func (x *CookieJar) GetPropertyReadOnly() bool {
+	var v gobject.Value
+	x.GetProperty("read-only", &v)
+	return v.GetBoolean()
+}
+
+// Emitted when @jar changes.
+//
+// If a cookie has been added,
+// @new_cookie will contain the newly-added cookie and
+// @old_cookie will be %NULL. If a cookie has been deleted,
+// @old_cookie will contain the to-be-deleted cookie and
+// @new_cookie will be %NULL. If a cookie has been changed,
+// @old_cookie will contain its old value, and @new_cookie its
+// new value.
+func (x *CookieJar) ConnectChanged(cb *func(CookieJar, uintptr, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, OldCookieVarp uintptr, NewCookieVarp uintptr) {
+		fa := CookieJar{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, OldCookieVarp, NewCookieVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xCookieJarAcceptPolicyGLibType, libs, "soup_cookie_jar_accept_policy_get_type")
+
+	core.PuregoSafeRegister(&xCookieJarGLibType, libs, "soup_cookie_jar_get_type")
+
+	core.PuregoSafeRegister(&xNewCookieJar, libs, "soup_cookie_jar_new")
+
+	core.PuregoSafeRegister(&xCookieJarAddCookie, libs, "soup_cookie_jar_add_cookie")
+	core.PuregoSafeRegister(&xCookieJarAddCookieFull, libs, "soup_cookie_jar_add_cookie_full")
+	core.PuregoSafeRegister(&xCookieJarAddCookieWithFirstParty, libs, "soup_cookie_jar_add_cookie_with_first_party")
+	core.PuregoSafeRegister(&xCookieJarAllCookies, libs, "soup_cookie_jar_all_cookies")
+	core.PuregoSafeRegister(&xCookieJarDeleteCookie, libs, "soup_cookie_jar_delete_cookie")
+	core.PuregoSafeRegister(&xCookieJarGetAcceptPolicy, libs, "soup_cookie_jar_get_accept_policy")
+	core.PuregoSafeRegister(&xCookieJarGetCookieList, libs, "soup_cookie_jar_get_cookie_list")
+	core.PuregoSafeRegister(&xCookieJarGetCookieListWithSameSiteInfo, libs, "soup_cookie_jar_get_cookie_list_with_same_site_info")
+	core.PuregoSafeRegister(&xCookieJarGetCookies, libs, "soup_cookie_jar_get_cookies")
+	core.PuregoSafeRegister(&xCookieJarIsPersistent, libs, "soup_cookie_jar_is_persistent")
+	core.PuregoSafeRegister(&xCookieJarSetAcceptPolicy, libs, "soup_cookie_jar_set_accept_policy")
+	core.PuregoSafeRegister(&xCookieJarSetCookie, libs, "soup_cookie_jar_set_cookie")
+	core.PuregoSafeRegister(&xCookieJarSetCookieWithFirstParty, libs, "soup_cookie_jar_set_cookie_with_first_party")
+
+}
diff --git a/v4/soup/soup-cookie.go b/v4/soup/soup-cookie.go
new file mode 100644
index 0000000000000000000000000000000000000000..ab66e7714eff2c47422401f1f96508da61f0166d
--- /dev/null
+++ b/v4/soup/soup-cookie.go
@@ -0,0 +1,166 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+const (
+	// A constant corresponding to 1 day.
+	//
+	// For use with [ctor@Cookie.new] and [method@Cookie.set_max_age].
+	COOKIE_MAX_AGE_ONE_DAY int = 0
+	// A constant corresponding to 1 hour.
+	//
+	// For use with [ctor@Cookie.new] and [method@Cookie.set_max_age].
+	COOKIE_MAX_AGE_ONE_HOUR int = 3600
+	// A constant corresponding to 1 week.
+	//
+	// For use with [ctor@Cookie.new] and [method@Cookie.set_max_age].
+	COOKIE_MAX_AGE_ONE_WEEK int = 0
+	// A constant corresponding to 1 year.
+	//
+	// For use with [ctor@Cookie.new] and [method@Cookie.set_max_age].
+	COOKIE_MAX_AGE_ONE_YEAR int = 0
+)
+
+// Represents the same-site policies of a cookie.
+type SameSitePolicy int
+
+var xSameSitePolicyGLibType func() types.GType
+
+func SameSitePolicyGLibType() types.GType {
+	return xSameSitePolicyGLibType()
+}
+
+const (
+
+	// The cookie is exposed with both cross-site and same-site requests
+	SameSitePolicyNoneValue SameSitePolicy = 0
+	// The cookie is withheld on cross-site requests but exposed on cross-site navigations
+	SameSitePolicyLaxValue SameSitePolicy = 1
+	// The cookie is only exposed for same-site requests
+	SameSitePolicyStrictValue SameSitePolicy = 2
+)
+
+var xCookieParse func(string, *glib.Uri) *Cookie
+
+// Parses @header and returns a #SoupCookie.
+//
+// If @header contains multiple cookies, only the first one will be parsed.
+//
+// If @header does not have "path" or "domain" attributes, they will
+// be defaulted from @origin. If @origin is %NULL, path will default
+// to "/", but domain will be left as %NULL. Note that this is not a
+// valid state for a #SoupCookie, and you will need to fill in some
+// appropriate string for the domain if you want to actually make use
+// of the cookie.
+//
+// As of version 3.4.0 the default value of a cookie's same-site-policy
+// is %SOUP_SAME_SITE_POLICY_LAX.
+func CookieParse(HeaderVar string, OriginVar *glib.Uri) *Cookie {
+
+	cret := xCookieParse(HeaderVar, OriginVar)
+	return cret
+}
+
+var xCookiesFree func(*glib.SList)
+
+// Frees @cookies.
+func CookiesFree(CookiesVar *glib.SList) {
+
+	xCookiesFree(CookiesVar)
+
+}
+
+var xCookiesFromRequest func(uintptr) *glib.SList
+
+// Parses @msg's Cookie request header and returns a [struct@GLib.SList] of
+// `SoupCookie`s.
+//
+// As the "Cookie" header, unlike "Set-Cookie", only contains cookie names and
+// values, none of the other #SoupCookie fields will be filled in. (Thus, you
+// can't generally pass a cookie returned from this method directly to
+// [func@cookies_to_response].)
+func CookiesFromRequest(MsgVar *Message) *glib.SList {
+
+	cret := xCookiesFromRequest(MsgVar.GoPointer())
+	return cret
+}
+
+var xCookiesFromResponse func(uintptr) *glib.SList
+
+// Parses @msg's Set-Cookie response headers and returns a [struct@GLib.SList]
+// of `SoupCookie`s.
+//
+// Cookies that do not specify "path" or "domain" attributes will have their
+// values defaulted from @msg.
+func CookiesFromResponse(MsgVar *Message) *glib.SList {
+
+	cret := xCookiesFromResponse(MsgVar.GoPointer())
+	return cret
+}
+
+var xCookiesToCookieHeader func(*glib.SList) string
+
+// Serializes a [struct@GLib.SList] of #SoupCookie into a string suitable for
+// setting as the value of the "Cookie" header.
+func CookiesToCookieHeader(CookiesVar *glib.SList) string {
+
+	cret := xCookiesToCookieHeader(CookiesVar)
+	return cret
+}
+
+var xCookiesToRequest func(*glib.SList, uintptr)
+
+// Adds the name and value of each cookie in @cookies to @msg's
+// "Cookie" request.
+//
+// If @msg already has a "Cookie" request header, these cookies will be appended
+// to the cookies already present. Be careful that you do not append the same
+// cookies twice, eg, when requeuing a message.
+func CookiesToRequest(CookiesVar *glib.SList, MsgVar *Message) {
+
+	xCookiesToRequest(CookiesVar, MsgVar.GoPointer())
+
+}
+
+var xCookiesToResponse func(*glib.SList, uintptr)
+
+// Appends a "Set-Cookie" response header to @msg for each cookie in
+// @cookies.
+//
+// This is in addition to any other "Set-Cookie" headers
+// @msg may already have.
+func CookiesToResponse(CookiesVar *glib.SList, MsgVar *Message) {
+
+	xCookiesToResponse(CookiesVar, MsgVar.GoPointer())
+
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xSameSitePolicyGLibType, libs, "soup_same_site_policy_get_type")
+
+	core.PuregoSafeRegister(&xCookieParse, libs, "soup_cookie_parse")
+	core.PuregoSafeRegister(&xCookiesFree, libs, "soup_cookies_free")
+	core.PuregoSafeRegister(&xCookiesFromRequest, libs, "soup_cookies_from_request")
+	core.PuregoSafeRegister(&xCookiesFromResponse, libs, "soup_cookies_from_response")
+	core.PuregoSafeRegister(&xCookiesToCookieHeader, libs, "soup_cookies_to_cookie_header")
+	core.PuregoSafeRegister(&xCookiesToRequest, libs, "soup_cookies_to_request")
+	core.PuregoSafeRegister(&xCookiesToResponse, libs, "soup_cookies_to_response")
+
+}
diff --git a/v4/soup/soup-date-utils.go b/v4/soup/soup-date-utils.go
new file mode 100644
index 0000000000000000000000000000000000000000..8489626630ff767d36f761ebd011d7acc93c90e8
--- /dev/null
+++ b/v4/soup/soup-date-utils.go
@@ -0,0 +1,74 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Date formats that [func@date_time_to_string] can use.
+//
+// @SOUP_DATE_HTTP and @SOUP_DATE_COOKIE always coerce the time to
+// UTC.
+//
+// This enum may be extended with more values in future releases.
+type DateFormat int
+
+var xDateFormatGLibType func() types.GType
+
+func DateFormatGLibType() types.GType {
+	return xDateFormatGLibType()
+}
+
+const (
+
+	// RFC 1123 format, used by the HTTP "Date" header. Eg
+	//   "Sun, 06 Nov 1994 08:49:37 GMT".
+	DateHttpValue DateFormat = 1
+	// The format for the "Expires" timestamp in the
+	//   Netscape cookie specification. Eg, "Sun, 06-Nov-1994 08:49:37 GMT".
+	DateCookieValue DateFormat = 2
+)
+
+var xDateTimeNewFromHttpString func(string) *glib.DateTime
+
+// Parses @date_string and tries to extract a date from it.
+//
+// This recognizes all of the "HTTP-date" formats from RFC 2616, RFC 2822 dates,
+// and reasonable approximations thereof. (Eg, it is lenient about whitespace,
+// leading "0"s, etc.)
+func DateTimeNewFromHttpString(DateStringVar string) *glib.DateTime {
+
+	cret := xDateTimeNewFromHttpString(DateStringVar)
+	return cret
+}
+
+var xDateTimeToString func(*glib.DateTime, DateFormat) string
+
+// Converts @date to a string in the format described by @format.
+func DateTimeToString(DateVar *glib.DateTime, FormatVar DateFormat) string {
+
+	cret := xDateTimeToString(DateVar, FormatVar)
+	return cret
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xDateFormatGLibType, libs, "soup_date_format_get_type")
+
+	core.PuregoSafeRegister(&xDateTimeNewFromHttpString, libs, "soup_date_time_new_from_http_string")
+	core.PuregoSafeRegister(&xDateTimeToString, libs, "soup_date_time_to_string")
+
+}
diff --git a/v4/soup/soup-form.go b/v4/soup/soup-form.go
new file mode 100644
index 0000000000000000000000000000000000000000..d2f318465083d1529a061b9eb94d00b1d23cb64e
--- /dev/null
+++ b/v4/soup/soup-form.go
@@ -0,0 +1,146 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+)
+
+const (
+	// A macro containing the value
+	// `multipart/form-data`; the MIME type used for
+	// posting form data that contains files to be uploaded.
+	FORM_MIME_TYPE_MULTIPART string = "multipart/form-data"
+	// A macro containing the value
+	// `application/x-www-form-urlencoded`; the default
+	// MIME type for POSTing HTML form data.
+	FORM_MIME_TYPE_URLENCODED string = "application/x-www-form-urlencoded"
+)
+
+var xFormDecode func(string) *glib.HashTable
+
+// Decodes @form.
+//
+// which is an urlencoded dataset as defined in the HTML 4.01 spec.
+func FormDecode(EncodedFormVar string) *glib.HashTable {
+
+	cret := xFormDecode(EncodedFormVar)
+	return cret
+}
+
+var xFormDecodeMultipart func(*Multipart, string, *string, *string, **glib.Bytes) *glib.HashTable
+
+// Decodes the "multipart/form-data" request in @multipart.
+//
+// this is a convenience method for the case when you have a single file upload
+// control in a form. (Or when you don't have any file upload controls, but are
+// still using "multipart/form-data" anyway.) Pass the name of the file upload
+// control in @file_control_name, and [func@form_decode_multipart] will extract
+// the uploaded file data into @filename, @content_type, and @file. All of the
+// other form control data will be returned (as strings, as with
+// [func@form_decode] in the returned [struct@GLib.HashTable].
+//
+// You may pass %NULL for @filename, @content_type and/or @file if you do not
+// care about those fields. [func@form_decode_multipart] may also
+// return %NULL in those fields if the client did not provide that
+// information. You must free the returned filename and content-type
+// with [func@GLib.free], and the returned file data with [method@Glib.Bytes.unref].
+//
+// If you have a form with more than one file upload control, you will
+// need to decode it manually, using [ctor@Multipart.new_from_message]
+// and [method@Multipart.get_part].
+func FormDecodeMultipart(MultipartVar *Multipart, FileControlNameVar string, FilenameVar *string, ContentTypeVar *string, FileVar **glib.Bytes) *glib.HashTable {
+
+	cret := xFormDecodeMultipart(MultipartVar, FileControlNameVar, FilenameVar, ContentTypeVar, FileVar)
+	return cret
+}
+
+var xFormEncode func(string, ...interface{}) string
+
+// Encodes the given field names and values into a value of type
+// "application/x-www-form-urlencoded".
+//
+// Encodes as defined in the HTML 4.01 spec.
+//
+// This method requires you to know the names of the form fields (or
+// at the very least, the total number of fields) at compile time; for
+// working with dynamic forms, use [func@form_encode_hash] or
+// [func@form_encode_datalist].
+//
+// See also: [ctor@Message.new_from_encoded_form].
+func FormEncode(FirstFieldVar string, varArgs ...interface{}) string {
+
+	cret := xFormEncode(FirstFieldVar, varArgs...)
+	return cret
+}
+
+var xFormEncodeDatalist func(**glib.Data) string
+
+// Encodes @form_data_set into a value of type
+// "application/x-www-form-urlencoded".
+//
+// Encodes as defined in the HTML 4.01 spec. Unlike [func@form_encode_hash],
+// this preserves the ordering of the form elements, which may be required in
+// some situations.
+//
+// See also: [ctor@Message.new_from_encoded_form].
+func FormEncodeDatalist(FormDataSetVar **glib.Data) string {
+
+	cret := xFormEncodeDatalist(FormDataSetVar)
+	return cret
+}
+
+var xFormEncodeHash func(*glib.HashTable) string
+
+// Encodes @form_data_set into a value of type
+// "application/x-www-form-urlencoded".
+//
+// Encodes as defined in the HTML 4.01 spec.
+//
+// Note that the HTML spec states that "The control names/values are
+// listed in the order they appear in the document." Since this method
+// takes a hash table, it cannot enforce that; if you care about the
+// ordering of the form fields, use [func@form_encode_datalist].
+//
+// See also: [ctor@Message.new_from_encoded_form].
+func FormEncodeHash(FormDataSetVar *glib.HashTable) string {
+
+	cret := xFormEncodeHash(FormDataSetVar)
+	return cret
+}
+
+var xFormEncodeValist func(string, []interface{}) string
+
+// See [func@form_encode].
+//
+// This is mostly an internal method, used by various other methods such as
+// [func@form_encode].
+//
+// See also: [ctor@Message.new_from_encoded_form].
+func FormEncodeValist(FirstFieldVar string, ArgsVar []interface{}) string {
+
+	cret := xFormEncodeValist(FirstFieldVar, ArgsVar)
+	return cret
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xFormDecode, libs, "soup_form_decode")
+	core.PuregoSafeRegister(&xFormDecodeMultipart, libs, "soup_form_decode_multipart")
+	core.PuregoSafeRegister(&xFormEncode, libs, "soup_form_encode")
+	core.PuregoSafeRegister(&xFormEncodeDatalist, libs, "soup_form_encode_datalist")
+	core.PuregoSafeRegister(&xFormEncodeHash, libs, "soup_form_encode_hash")
+	core.PuregoSafeRegister(&xFormEncodeValist, libs, "soup_form_encode_valist")
+
+}
diff --git a/v4/soup/soup-headers.go b/v4/soup/soup-headers.go
new file mode 100644
index 0000000000000000000000000000000000000000..5c60110fc5d301ac87c5f1089b0d6ff3d7718dad
--- /dev/null
+++ b/v4/soup/soup-headers.go
@@ -0,0 +1,242 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+)
+
+var xHeaderContains func(string, string) bool
+
+// Parses @header to see if it contains the token @token (matched
+// case-insensitively).
+//
+// Note that this can't be used with lists that have qvalues.
+func HeaderContains(HeaderVar string, TokenVar string) bool {
+
+	cret := xHeaderContains(HeaderVar, TokenVar)
+	return cret
+}
+
+var xHeaderFreeList func(*glib.SList)
+
+// Frees @list.
+func HeaderFreeList(ListVar *glib.SList) {
+
+	xHeaderFreeList(ListVar)
+
+}
+
+var xHeaderFreeParamList func(*glib.HashTable)
+
+// Frees @param_list.
+func HeaderFreeParamList(ParamListVar *glib.HashTable) {
+
+	xHeaderFreeParamList(ParamListVar)
+
+}
+
+var xHeaderGStringAppendParam func(*glib.String, string, string)
+
+// Appends something like `name=value` to @string, taking care to quote @value
+// if needed, and if so, to escape any quotes or backslashes in @value.
+//
+// Alternatively, if @value is a non-ASCII UTF-8 string, it will be
+// appended using RFC5987 syntax. Although in theory this is supposed
+// to work anywhere in HTTP that uses this style of parameter, in
+// reality, it can only be used portably with the Content-Disposition
+// "filename" parameter.
+//
+// If @value is %NULL, this will just append @name to @string.
+func HeaderGStringAppendParam(StringVar *glib.String, NameVar string, ValueVar string) {
+
+	xHeaderGStringAppendParam(StringVar, NameVar, ValueVar)
+
+}
+
+var xHeaderGStringAppendParamQuoted func(*glib.String, string, string)
+
+// Appends something like `name="value"` to
+// @string, taking care to escape any quotes or backslashes in @value.
+//
+// If @value is (non-ASCII) UTF-8, this will instead use RFC 5987
+// encoding, just like [func@header_g_string_append_param].
+func HeaderGStringAppendParamQuoted(StringVar *glib.String, NameVar string, ValueVar string) {
+
+	xHeaderGStringAppendParamQuoted(StringVar, NameVar, ValueVar)
+
+}
+
+var xHeaderParseList func(string) *glib.SList
+
+// Parses a header whose content is described by RFC2616 as `#something`.
+//
+// "something" does not itself contain commas, except as part of quoted-strings.
+func HeaderParseList(HeaderVar string) *glib.SList {
+
+	cret := xHeaderParseList(HeaderVar)
+	return cret
+}
+
+var xHeaderParseParamList func(string) *glib.HashTable
+
+// Parses a header which is a comma-delimited list of something like:
+// `token [ "=" ( token | quoted-string ) ]`.
+//
+// Tokens that don't have an associated value will still be added to
+// the resulting hash table, but with a %NULL value.
+//
+// This also handles RFC5987 encoding (which in HTTP is mostly used
+// for giving UTF8-encoded filenames in the Content-Disposition
+// header).
+func HeaderParseParamList(HeaderVar string) *glib.HashTable {
+
+	cret := xHeaderParseParamList(HeaderVar)
+	return cret
+}
+
+var xHeaderParseParamListStrict func(string) *glib.HashTable
+
+// A strict version of [func@header_parse_param_list]
+// that bails out if there are duplicate parameters.
+//
+// Note that this function will treat RFC5987-encoded
+// parameters as duplicated if an ASCII version is also
+// present. For header fields that might contain
+// RFC5987-encoded parameters, use
+// [func@header_parse_param_list] instead.
+func HeaderParseParamListStrict(HeaderVar string) *glib.HashTable {
+
+	cret := xHeaderParseParamListStrict(HeaderVar)
+	return cret
+}
+
+var xHeaderParseQualityList func(string, **glib.SList) *glib.SList
+
+// Parses a header whose content is a list of items with optional
+// "qvalue"s (eg, Accept, Accept-Charset, Accept-Encoding,
+// Accept-Language, TE).
+//
+// If @unacceptable is not %NULL, then on return, it will contain the
+// items with qvalue 0. Either way, those items will be removed from
+// the main list.
+func HeaderParseQualityList(HeaderVar string, UnacceptableVar **glib.SList) *glib.SList {
+
+	cret := xHeaderParseQualityList(HeaderVar, UnacceptableVar)
+	return cret
+}
+
+var xHeaderParseSemiParamList func(string) *glib.HashTable
+
+// Parses a header which is a semicolon-delimited list of something
+// like: `token [ "=" ( token | quoted-string ) ]`.
+//
+// Tokens that don't have an associated value will still be added to
+// the resulting hash table, but with a %NULL value.
+//
+// This also handles RFC5987 encoding (which in HTTP is mostly used
+// for giving UTF8-encoded filenames in the Content-Disposition
+// header).
+func HeaderParseSemiParamList(HeaderVar string) *glib.HashTable {
+
+	cret := xHeaderParseSemiParamList(HeaderVar)
+	return cret
+}
+
+var xHeaderParseSemiParamListStrict func(string) *glib.HashTable
+
+// A strict version of [func@header_parse_semi_param_list]
+// that bails out if there are duplicate parameters.
+//
+// Note that this function will treat RFC5987-encoded
+// parameters as duplicated if an ASCII version is also
+// present. For header fields that might contain
+// RFC5987-encoded parameters, use
+// [func@header_parse_semi_param_list] instead.
+func HeaderParseSemiParamListStrict(HeaderVar string) *glib.HashTable {
+
+	cret := xHeaderParseSemiParamListStrict(HeaderVar)
+	return cret
+}
+
+var xHeadersParse func(string, int, *MessageHeaders) bool
+
+// Parses the headers of an HTTP request or response in @str and
+// stores the results in @dest.
+//
+// Beware that @dest may be modified even on failure.
+//
+// This is a low-level method; normally you would use
+// [func@headers_parse_request] or [func@headers_parse_response].
+func HeadersParse(StrVar string, LenVar int, DestVar *MessageHeaders) bool {
+
+	cret := xHeadersParse(StrVar, LenVar, DestVar)
+	return cret
+}
+
+var xHeadersParseRequest func(string, int, *MessageHeaders, *string, *string, *HTTPVersion) uint
+
+// Parses the headers of an HTTP request in @str and stores the
+// results in @req_method, @req_path, @ver, and @req_headers.
+//
+// Beware that @req_headers may be modified even on failure.
+func HeadersParseRequest(StrVar string, LenVar int, ReqHeadersVar *MessageHeaders, ReqMethodVar *string, ReqPathVar *string, VerVar *HTTPVersion) uint {
+
+	cret := xHeadersParseRequest(StrVar, LenVar, ReqHeadersVar, ReqMethodVar, ReqPathVar, VerVar)
+	return cret
+}
+
+var xHeadersParseResponse func(string, int, *MessageHeaders, *HTTPVersion, *uint, *string) bool
+
+// Parses the headers of an HTTP response in @str and stores the
+// results in @ver, @status_code, @reason_phrase, and @headers.
+//
+// Beware that @headers may be modified even on failure.
+func HeadersParseResponse(StrVar string, LenVar int, HeadersVar *MessageHeaders, VerVar *HTTPVersion, StatusCodeVar *uint, ReasonPhraseVar *string) bool {
+
+	cret := xHeadersParseResponse(StrVar, LenVar, HeadersVar, VerVar, StatusCodeVar, ReasonPhraseVar)
+	return cret
+}
+
+var xHeadersParseStatusLine func(string, *HTTPVersion, *uint, *string) bool
+
+// Parses the HTTP Status-Line string in @status_line into @ver,
+// @status_code, and @reason_phrase.
+//
+// @status_line must be terminated by either "\0" or "\r\n".
+func HeadersParseStatusLine(StatusLineVar string, VerVar *HTTPVersion, StatusCodeVar *uint, ReasonPhraseVar *string) bool {
+
+	cret := xHeadersParseStatusLine(StatusLineVar, VerVar, StatusCodeVar, ReasonPhraseVar)
+	return cret
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xHeaderContains, libs, "soup_header_contains")
+	core.PuregoSafeRegister(&xHeaderFreeList, libs, "soup_header_free_list")
+	core.PuregoSafeRegister(&xHeaderFreeParamList, libs, "soup_header_free_param_list")
+	core.PuregoSafeRegister(&xHeaderGStringAppendParam, libs, "soup_header_g_string_append_param")
+	core.PuregoSafeRegister(&xHeaderGStringAppendParamQuoted, libs, "soup_header_g_string_append_param_quoted")
+	core.PuregoSafeRegister(&xHeaderParseList, libs, "soup_header_parse_list")
+	core.PuregoSafeRegister(&xHeaderParseParamList, libs, "soup_header_parse_param_list")
+	core.PuregoSafeRegister(&xHeaderParseParamListStrict, libs, "soup_header_parse_param_list_strict")
+	core.PuregoSafeRegister(&xHeaderParseQualityList, libs, "soup_header_parse_quality_list")
+	core.PuregoSafeRegister(&xHeaderParseSemiParamList, libs, "soup_header_parse_semi_param_list")
+	core.PuregoSafeRegister(&xHeaderParseSemiParamListStrict, libs, "soup_header_parse_semi_param_list_strict")
+	core.PuregoSafeRegister(&xHeadersParse, libs, "soup_headers_parse")
+	core.PuregoSafeRegister(&xHeadersParseRequest, libs, "soup_headers_parse_request")
+	core.PuregoSafeRegister(&xHeadersParseResponse, libs, "soup_headers_parse_response")
+	core.PuregoSafeRegister(&xHeadersParseStatusLine, libs, "soup_headers_parse_status_line")
+
+}
diff --git a/v4/soup/soup-hsts-enforcer-db.go b/v4/soup/soup-hsts-enforcer-db.go
new file mode 100644
index 0000000000000000000000000000000000000000..8679e79a1c36b33728de6a62d66a849ba3fc6ae0
--- /dev/null
+++ b/v4/soup/soup-hsts-enforcer-db.go
@@ -0,0 +1,111 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type HSTSEnforcerDBClass struct {
+	_ structs.HostLayout
+
+	ParentClass HSTSEnforcerClass
+}
+
+func (x *HSTSEnforcerDBClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Persistent HTTP Strict Transport Security enforcer.
+//
+// #SoupHSTSEnforcerDB is a [class@HSTSEnforcer] that uses a SQLite
+// database as a backend for persistency.
+type HSTSEnforcerDB struct {
+	HSTSEnforcer
+}
+
+var xHSTSEnforcerDBGLibType func() types.GType
+
+func HSTSEnforcerDBGLibType() types.GType {
+	return xHSTSEnforcerDBGLibType()
+}
+
+func HSTSEnforcerDBNewFromInternalPtr(ptr uintptr) *HSTSEnforcerDB {
+	cls := &HSTSEnforcerDB{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewHSTSEnforcerDB func(string) uintptr
+
+// Creates a #SoupHSTSEnforcerDB.
+//
+// @filename will be read in during the initialization of a
+// #SoupHSTSEnforcerDB, in order to create an initial set of HSTS
+// policies. If the file doesn't exist, a new database will be created
+// and initialized. Changes to the policies during the lifetime of a
+// #SoupHSTSEnforcerDB will be written to @filename when
+// [signal@HSTSEnforcer::changed] is emitted.
+func NewHSTSEnforcerDB(FilenameVar string) *HSTSEnforcerDB {
+	var cls *HSTSEnforcerDB
+
+	cret := xNewHSTSEnforcerDB(FilenameVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &HSTSEnforcerDB{}
+	cls.Ptr = cret
+	return cls
+}
+
+func (c *HSTSEnforcerDB) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *HSTSEnforcerDB) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyFilename sets the "filename" property.
+// The filename of the SQLite database where HSTS policies are stored.
+func (x *HSTSEnforcerDB) SetPropertyFilename(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("filename", &v)
+}
+
+// GetPropertyFilename gets the "filename" property.
+// The filename of the SQLite database where HSTS policies are stored.
+func (x *HSTSEnforcerDB) GetPropertyFilename() string {
+	var v gobject.Value
+	x.GetProperty("filename", &v)
+	return v.GetString()
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xHSTSEnforcerDBGLibType, libs, "soup_hsts_enforcer_db_get_type")
+
+	core.PuregoSafeRegister(&xNewHSTSEnforcerDB, libs, "soup_hsts_enforcer_db_new")
+
+}
diff --git a/v4/soup/soup-hsts-enforcer.go b/v4/soup/soup-hsts-enforcer.go
new file mode 100644
index 0000000000000000000000000000000000000000..67fd4c06036c0dfb678f05ab23a8ac1b9c4147da
--- /dev/null
+++ b/v4/soup/soup-hsts-enforcer.go
@@ -0,0 +1,305 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Class structure for #SoupHSTSEnforcer.
+type HSTSEnforcerClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+
+	xIsPersistent uintptr
+
+	xHasValidPolicy uintptr
+
+	xChanged uintptr
+
+	Padding [4]uintptr
+}
+
+func (x *HSTSEnforcerClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideIsPersistent sets the "is_persistent" callback function.
+// The @is_persistent function advertises whether the enforcer is persistent or
+// whether changes made to it will be lost when the underlying [class@Session] is finished.
+func (x *HSTSEnforcerClass) OverrideIsPersistent(cb func(*HSTSEnforcer) bool) {
+	if cb == nil {
+		x.xIsPersistent = 0
+	} else {
+		x.xIsPersistent = purego.NewCallback(func(HstsEnforcerVarp uintptr) bool {
+			return cb(HSTSEnforcerNewFromInternalPtr(HstsEnforcerVarp))
+		})
+	}
+}
+
+// GetIsPersistent gets the "is_persistent" callback function.
+// The @is_persistent function advertises whether the enforcer is persistent or
+// whether changes made to it will be lost when the underlying [class@Session] is finished.
+func (x *HSTSEnforcerClass) GetIsPersistent() func(*HSTSEnforcer) bool {
+	if x.xIsPersistent == 0 {
+		return nil
+	}
+	var rawCallback func(HstsEnforcerVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xIsPersistent)
+	return func(HstsEnforcerVar *HSTSEnforcer) bool {
+		return rawCallback(HstsEnforcerVar.GoPointer())
+	}
+}
+
+// OverrideHasValidPolicy sets the "has_valid_policy" callback function.
+// The @has_valid_policy function is called to check whether there is a valid
+// policy for the given domain. This method should return %TRUE for #SoupHSTSEnforcer to
+// change the scheme of the #GUri in the #SoupMessage to HTTPS. Implementations might want to
+// chain up to the @has_valid_policy in the parent class to check, for instance, for runtime
+// policies.
+func (x *HSTSEnforcerClass) OverrideHasValidPolicy(cb func(*HSTSEnforcer, string) bool) {
+	if cb == nil {
+		x.xHasValidPolicy = 0
+	} else {
+		x.xHasValidPolicy = purego.NewCallback(func(HstsEnforcerVarp uintptr, DomainVarp string) bool {
+			return cb(HSTSEnforcerNewFromInternalPtr(HstsEnforcerVarp), DomainVarp)
+		})
+	}
+}
+
+// GetHasValidPolicy gets the "has_valid_policy" callback function.
+// The @has_valid_policy function is called to check whether there is a valid
+// policy for the given domain. This method should return %TRUE for #SoupHSTSEnforcer to
+// change the scheme of the #GUri in the #SoupMessage to HTTPS. Implementations might want to
+// chain up to the @has_valid_policy in the parent class to check, for instance, for runtime
+// policies.
+func (x *HSTSEnforcerClass) GetHasValidPolicy() func(*HSTSEnforcer, string) bool {
+	if x.xHasValidPolicy == 0 {
+		return nil
+	}
+	var rawCallback func(HstsEnforcerVarp uintptr, DomainVarp string) bool
+	purego.RegisterFunc(&rawCallback, x.xHasValidPolicy)
+	return func(HstsEnforcerVar *HSTSEnforcer, DomainVar string) bool {
+		return rawCallback(HstsEnforcerVar.GoPointer(), DomainVar)
+	}
+}
+
+// OverrideChanged sets the "changed" callback function.
+// The class closure for the #SoupHSTSEnforcer::changed signal.
+func (x *HSTSEnforcerClass) OverrideChanged(cb func(*HSTSEnforcer, *HSTSPolicy, *HSTSPolicy)) {
+	if cb == nil {
+		x.xChanged = 0
+	} else {
+		x.xChanged = purego.NewCallback(func(EnforcerVarp uintptr, OldPolicyVarp *HSTSPolicy, NewPolicyVarp *HSTSPolicy) {
+			cb(HSTSEnforcerNewFromInternalPtr(EnforcerVarp), OldPolicyVarp, NewPolicyVarp)
+		})
+	}
+}
+
+// GetChanged gets the "changed" callback function.
+// The class closure for the #SoupHSTSEnforcer::changed signal.
+func (x *HSTSEnforcerClass) GetChanged() func(*HSTSEnforcer, *HSTSPolicy, *HSTSPolicy) {
+	if x.xChanged == 0 {
+		return nil
+	}
+	var rawCallback func(EnforcerVarp uintptr, OldPolicyVarp *HSTSPolicy, NewPolicyVarp *HSTSPolicy)
+	purego.RegisterFunc(&rawCallback, x.xChanged)
+	return func(EnforcerVar *HSTSEnforcer, OldPolicyVar *HSTSPolicy, NewPolicyVar *HSTSPolicy) {
+		rawCallback(EnforcerVar.GoPointer(), OldPolicyVar, NewPolicyVar)
+	}
+}
+
+// Automatic HTTP Strict Transport Security enforcing for [class@Session].
+//
+// A #SoupHSTSEnforcer stores HSTS policies and enforces them when
+// required. #SoupHSTSEnforcer implements [iface@SessionFeature], so you
+// can add an HSTS enforcer to a session with
+// [method@Session.add_feature] or [method@Session.add_feature_by_type].
+//
+// #SoupHSTSEnforcer keeps track of all the HTTPS destinations that,
+// when connected to, return the Strict-Transport-Security header with
+// valid values. #SoupHSTSEnforcer will forget those destinations
+// upon expiry or when the server requests it.
+//
+// When the [class@Session] the #SoupHSTSEnforcer is attached to queues or
+// restarts a message, the #SoupHSTSEnforcer will rewrite the URI to HTTPS if
+// the destination is a known HSTS host and is contacted over an insecure
+// transport protocol (HTTP). Users of #SoupHSTSEnforcer are advised to listen
+// to changes in the [property@Message:uri] property in order to be aware of
+// changes in the message URI.
+//
+// Note that #SoupHSTSEnforcer does not support any form of long-term
+// HSTS policy persistence. See [class@HSTSEnforcerDB] for a persistent
+// enforcer.
+type HSTSEnforcer struct {
+	gobject.Object
+}
+
+var xHSTSEnforcerGLibType func() types.GType
+
+func HSTSEnforcerGLibType() types.GType {
+	return xHSTSEnforcerGLibType()
+}
+
+func HSTSEnforcerNewFromInternalPtr(ptr uintptr) *HSTSEnforcer {
+	cls := &HSTSEnforcer{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewHSTSEnforcer func() uintptr
+
+// Creates a new #SoupHSTSEnforcer.
+//
+// The base #SoupHSTSEnforcer class does not support persistent storage of HSTS
+// policies, see [class@HSTSEnforcerDB] for that.
+func NewHSTSEnforcer() *HSTSEnforcer {
+	var cls *HSTSEnforcer
+
+	cret := xNewHSTSEnforcer()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &HSTSEnforcer{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xHSTSEnforcerGetDomains func(uintptr, bool) *glib.List
+
+// Gets a list of domains for which there are policies in @enforcer.
+func (x *HSTSEnforcer) GetDomains(SessionPoliciesVar bool) *glib.List {
+
+	cret := xHSTSEnforcerGetDomains(x.GoPointer(), SessionPoliciesVar)
+	return cret
+}
+
+var xHSTSEnforcerGetPolicies func(uintptr, bool) *glib.List
+
+// Gets a list with the policies in @enforcer.
+func (x *HSTSEnforcer) GetPolicies(SessionPoliciesVar bool) *glib.List {
+
+	cret := xHSTSEnforcerGetPolicies(x.GoPointer(), SessionPoliciesVar)
+	return cret
+}
+
+var xHSTSEnforcerHasValidPolicy func(uintptr, string) bool
+
+// Gets whether @hsts_enforcer has a currently valid policy for @domain.
+func (x *HSTSEnforcer) HasValidPolicy(DomainVar string) bool {
+
+	cret := xHSTSEnforcerHasValidPolicy(x.GoPointer(), DomainVar)
+	return cret
+}
+
+var xHSTSEnforcerIsPersistent func(uintptr) bool
+
+// Gets whether @hsts_enforcer stores policies persistenly.
+func (x *HSTSEnforcer) IsPersistent() bool {
+
+	cret := xHSTSEnforcerIsPersistent(x.GoPointer())
+	return cret
+}
+
+var xHSTSEnforcerSetPolicy func(uintptr, *HSTSPolicy)
+
+// Sets @policy to @hsts_enforcer.
+//
+// If @policy is expired, any existing HSTS policy for its host will be removed
+// instead. If a policy existed for this host, it will be replaced. Otherwise,
+// the new policy will be inserted. If the policy is a session policy, that is,
+// one created with [ctor@HSTSPolicy.new_session_policy], the policy will not
+// expire and will be enforced during the lifetime of @hsts_enforcer's
+// [class@Session].
+func (x *HSTSEnforcer) SetPolicy(PolicyVar *HSTSPolicy) {
+
+	xHSTSEnforcerSetPolicy(x.GoPointer(), PolicyVar)
+
+}
+
+var xHSTSEnforcerSetSessionPolicy func(uintptr, string, bool)
+
+// Sets a session policy for @domain.
+//
+// A session policy is a policy that is permanent to the lifetime of
+// @hsts_enforcer's [class@Session] and doesn't expire.
+func (x *HSTSEnforcer) SetSessionPolicy(DomainVar string, IncludeSubdomainsVar bool) {
+
+	xHSTSEnforcerSetSessionPolicy(x.GoPointer(), DomainVar, IncludeSubdomainsVar)
+
+}
+
+func (c *HSTSEnforcer) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *HSTSEnforcer) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Emitted when @hsts_enforcer changes.
+//
+// If a policy has been added,
+// @new_policy will contain the newly-added policy and
+// @old_policy will be %NULL. If a policy has been deleted,
+// @old_policy will contain the to-be-deleted policy and
+// @new_policy will be %NULL. If a policy has been changed,
+// @old_policy will contain its old value, and @new_policy its
+// new value.
+//
+// Note that you shouldn't modify the policies from a callback to
+// this signal.
+func (x *HSTSEnforcer) ConnectChanged(cb *func(HSTSEnforcer, uintptr, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, OldPolicyVarp uintptr, NewPolicyVarp uintptr) {
+		fa := HSTSEnforcer{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, OldPolicyVarp, NewPolicyVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xHSTSEnforcerGLibType, libs, "soup_hsts_enforcer_get_type")
+
+	core.PuregoSafeRegister(&xNewHSTSEnforcer, libs, "soup_hsts_enforcer_new")
+
+	core.PuregoSafeRegister(&xHSTSEnforcerGetDomains, libs, "soup_hsts_enforcer_get_domains")
+	core.PuregoSafeRegister(&xHSTSEnforcerGetPolicies, libs, "soup_hsts_enforcer_get_policies")
+	core.PuregoSafeRegister(&xHSTSEnforcerHasValidPolicy, libs, "soup_hsts_enforcer_has_valid_policy")
+	core.PuregoSafeRegister(&xHSTSEnforcerIsPersistent, libs, "soup_hsts_enforcer_is_persistent")
+	core.PuregoSafeRegister(&xHSTSEnforcerSetPolicy, libs, "soup_hsts_enforcer_set_policy")
+	core.PuregoSafeRegister(&xHSTSEnforcerSetSessionPolicy, libs, "soup_hsts_enforcer_set_session_policy")
+
+}
diff --git a/v4/soup/soup-hsts-policy.go b/v4/soup/soup-hsts-policy.go
new file mode 100644
index 0000000000000000000000000000000000000000..c7ea75b436c43b3a03ab8610ab55cc380009ec9d
--- /dev/null
+++ b/v4/soup/soup-hsts-policy.go
@@ -0,0 +1,7 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+const (
+	// An expiration date that is always in the past.
+	HSTS_POLICY_MAX_AGE_PAST int = 0
+)
diff --git a/v4/soup/soup-logger.go b/v4/soup/soup-logger.go
new file mode 100644
index 0000000000000000000000000000000000000000..b14ee8a3d872b9f1ca889be72ee1094a469d98b7
--- /dev/null
+++ b/v4/soup/soup-logger.go
@@ -0,0 +1,275 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// The prototype for a logging filter.
+//
+// The filter callback will be invoked for each request or response, and should
+// analyze it and return a [enum@LoggerLogLevel] value indicating how much of
+// the message to log.
+type LoggerFilter func(uintptr, uintptr, uintptr) LoggerLogLevel
+
+// The prototype for a custom printing callback.
+//
+// @level indicates what kind of information is being printed. Eg, it
+// will be %SOUP_LOGGER_LOG_HEADERS if @data is header data.
+//
+// @direction is either '&lt;', '&gt;', or ' ', and @data is the single line
+// to print; the printer is expected to add a terminating newline.
+//
+// To get the effect of the default printer, you would do:
+//
+// ```c
+// printf ("%c %s\n", direction, data);
+// ```
+type LoggerPrinter func(uintptr, LoggerLogLevel, byte, string, uintptr)
+
+type LoggerClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *LoggerClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Describes the level of logging output to provide.
+type LoggerLogLevel int
+
+var xLoggerLogLevelGLibType func() types.GType
+
+func LoggerLogLevelGLibType() types.GType {
+	return xLoggerLogLevelGLibType()
+}
+
+const (
+
+	// No logging
+	LoggerLogNoneValue LoggerLogLevel = 0
+	// Log the Request-Line or Status-Line and
+	//   the Soup-Debug pseudo-headers
+	LoggerLogMinimalValue LoggerLogLevel = 1
+	// Log the full request/response headers
+	LoggerLogHeadersValue LoggerLogLevel = 2
+	// Log the full headers and request/response bodies
+	LoggerLogBodyValue LoggerLogLevel = 3
+)
+
+// Debug logging support
+//
+// #SoupLogger watches a [class@Session] and logs the HTTP traffic that
+// it generates, for debugging purposes. Many applications use an
+// environment variable to determine whether or not to use
+// #SoupLogger, and to determine the amount of debugging output.
+//
+// To use #SoupLogger, first create a logger with [ctor@Logger.new], optionally
+// configure it with [method@Logger.set_request_filter],
+// [method@Logger.set_response_filter], and [method@Logger.set_printer], and
+// then attach it to a session (or multiple sessions) with
+// [method@Session.add_feature].
+//
+// By default, the debugging output is sent to `stdout`, and looks something
+// like:
+//
+// ```
+// &gt; POST /unauth HTTP/1.1
+// &gt; Soup-Debug-Timestamp: 1200171744
+// &gt; Soup-Debug: SoupSession 1 (0x612190), SoupMessage 1 (0x617000), GSocket 1 (0x612220)
+// &gt; Host: localhost
+// &gt; Content-Type: text/plain
+// &gt; Connection: close
+//
+// &amp;lt; HTTP/1.1 201 Created
+// &amp;lt; Soup-Debug-Timestamp: 1200171744
+// &amp;lt; Soup-Debug: SoupMessage 1 (0x617000)
+// &amp;lt; Date: Sun, 12 Jan 2008 21:02:24 GMT
+// &amp;lt; Content-Length: 0
+// ```
+//
+// The `Soup-Debug-Timestamp` line gives the time (as a `time_t`) when the
+// request was sent, or the response fully received.
+//
+// The `Soup-Debug` line gives further debugging information about the
+// [class@Session], [class@Message], and [class@Gio.Socket] involved; the hex
+// numbers are the addresses of the objects in question (which may be useful if
+// you are running in a debugger). The decimal IDs are simply counters that
+// uniquely identify objects across the lifetime of the #SoupLogger. In
+// particular, this can be used to identify when multiple messages are sent
+// across the same connection.
+//
+// Currently, the request half of the message is logged just before
+// the first byte of the request gets written to the network (from the
+// [signal@Message::starting] signal).
+//
+// The response is logged just after the last byte of the response body is read
+// from the network (from the [signal@Message::got-body] or
+// [signal@Message::got-informational] signal), which means that the
+// [signal@Message::got-headers] signal, and anything triggered off it (such as
+// #SoupMessage::authenticate) will be emitted *before* the response headers are
+// actually logged.
+//
+// If the response doesn't happen to trigger the [signal@Message::got-body] nor
+// [signal@Message::got-informational] signals due to, for example, a
+// cancellation before receiving the last byte of the response body, the
+// response will still be logged on the event of the [signal@Message::finished]
+// signal.
+type Logger struct {
+	gobject.Object
+}
+
+var xLoggerGLibType func() types.GType
+
+func LoggerGLibType() types.GType {
+	return xLoggerGLibType()
+}
+
+func LoggerNewFromInternalPtr(ptr uintptr) *Logger {
+	cls := &Logger{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewLogger func(LoggerLogLevel) uintptr
+
+// Creates a new #SoupLogger with the given debug level.
+//
+// If you need finer control over what message parts are and aren't
+// logged, use [method@Logger.set_request_filter] and
+// [method@Logger.set_response_filter].
+func NewLogger(LevelVar LoggerLogLevel) *Logger {
+	var cls *Logger
+
+	cret := xNewLogger(LevelVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Logger{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xLoggerGetMaxBodySize func(uintptr) int
+
+// Get the maximum body size for @logger.
+func (x *Logger) GetMaxBodySize() int {
+
+	cret := xLoggerGetMaxBodySize(x.GoPointer())
+	return cret
+}
+
+var xLoggerSetMaxBodySize func(uintptr, int)
+
+// Sets the maximum body size for @logger (-1 means no limit).
+func (x *Logger) SetMaxBodySize(MaxBodySizeVar int) {
+
+	xLoggerSetMaxBodySize(x.GoPointer(), MaxBodySizeVar)
+
+}
+
+var xLoggerSetPrinter func(uintptr, uintptr, uintptr, uintptr)
+
+// Sets up an alternate log printing routine, if you don't want
+// the log to go to `stdout`.
+func (x *Logger) SetPrinter(PrinterVar *LoggerPrinter, PrinterDataVar uintptr, DestroyVar *glib.DestroyNotify) {
+
+	xLoggerSetPrinter(x.GoPointer(), glib.NewCallback(PrinterVar), PrinterDataVar, glib.NewCallback(DestroyVar))
+
+}
+
+var xLoggerSetRequestFilter func(uintptr, uintptr, uintptr, uintptr)
+
+// Sets up a filter to determine the log level for a given request.
+//
+// For each HTTP request @logger will invoke @request_filter to
+// determine how much (if any) of that request to log. (If you do not
+// set a request filter, @logger will just always log requests at the
+// level passed to [ctor@Logger.new].)
+func (x *Logger) SetRequestFilter(RequestFilterVar *LoggerFilter, FilterDataVar uintptr, DestroyVar *glib.DestroyNotify) {
+
+	xLoggerSetRequestFilter(x.GoPointer(), glib.NewCallback(RequestFilterVar), FilterDataVar, glib.NewCallback(DestroyVar))
+
+}
+
+var xLoggerSetResponseFilter func(uintptr, uintptr, uintptr, uintptr)
+
+// Sets up a filter to determine the log level for a given response.
+//
+// For each HTTP response @logger will invoke @response_filter to
+// determine how much (if any) of that response to log. (If you do not
+// set a response filter, @logger will just always log responses at
+// the level passed to [ctor@Logger.new].)
+func (x *Logger) SetResponseFilter(ResponseFilterVar *LoggerFilter, FilterDataVar uintptr, DestroyVar *glib.DestroyNotify) {
+
+	xLoggerSetResponseFilter(x.GoPointer(), glib.NewCallback(ResponseFilterVar), FilterDataVar, glib.NewCallback(DestroyVar))
+
+}
+
+func (c *Logger) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Logger) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyMaxBodySize sets the "max-body-size" property.
+// If [property@Logger:level] is %SOUP_LOGGER_LOG_BODY, this gives
+// the maximum number of bytes of the body that will be logged.
+// (-1 means "no limit".)
+func (x *Logger) SetPropertyMaxBodySize(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-body-size", &v)
+}
+
+// GetPropertyMaxBodySize gets the "max-body-size" property.
+// If [property@Logger:level] is %SOUP_LOGGER_LOG_BODY, this gives
+// the maximum number of bytes of the body that will be logged.
+// (-1 means "no limit".)
+func (x *Logger) GetPropertyMaxBodySize() int {
+	var v gobject.Value
+	x.GetProperty("max-body-size", &v)
+	return v.GetInt()
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xLoggerLogLevelGLibType, libs, "soup_logger_log_level_get_type")
+
+	core.PuregoSafeRegister(&xLoggerGLibType, libs, "soup_logger_get_type")
+
+	core.PuregoSafeRegister(&xNewLogger, libs, "soup_logger_new")
+
+	core.PuregoSafeRegister(&xLoggerGetMaxBodySize, libs, "soup_logger_get_max_body_size")
+	core.PuregoSafeRegister(&xLoggerSetMaxBodySize, libs, "soup_logger_set_max_body_size")
+	core.PuregoSafeRegister(&xLoggerSetPrinter, libs, "soup_logger_set_printer")
+	core.PuregoSafeRegister(&xLoggerSetRequestFilter, libs, "soup_logger_set_request_filter")
+	core.PuregoSafeRegister(&xLoggerSetResponseFilter, libs, "soup_logger_set_response_filter")
+
+}
diff --git a/v4/soup/soup-message-body.go b/v4/soup/soup-message-body.go
new file mode 100644
index 0000000000000000000000000000000000000000..079ea4d31050e221dd5f1b51a98b91716265d5d4
--- /dev/null
+++ b/v4/soup/soup-message-body.go
@@ -0,0 +1,288 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// #SoupMessageBody represents the request or response body of a
+// [class@Message].
+//
+// Note that while @length always reflects the full length of the
+// message body, @data is normally %NULL, and will only be filled in
+// after [method@MessageBody.flatten] is called. For client-side
+// messages, this automatically happens for the response body after it
+// has been fully read. Likewise, for server-side
+// messages, the request body is automatically filled in after being
+// read.
+//
+// As an added bonus, when @data is filled in, it is always terminated
+// with a `\0` byte (which is not reflected in @length).
+type MessageBody struct {
+	_ structs.HostLayout
+
+	Data uintptr
+
+	Length int64
+}
+
+var xMessageBodyGLibType func() types.GType
+
+func MessageBodyGLibType() types.GType {
+	return xMessageBodyGLibType()
+}
+
+func (x *MessageBody) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewMessageBody func() *MessageBody
+
+// Creates a new #SoupMessageBody.
+//
+// [class@Message] uses this internally; you
+// will not normally need to call it yourself.
+func NewMessageBody() *MessageBody {
+
+	cret := xNewMessageBody()
+	return cret
+}
+
+var xMessageBodyAppend func(uintptr, MemoryUse, []byte, uint)
+
+// Appends @length bytes from @data to @body according to @use.
+func (x *MessageBody) Append(UseVar MemoryUse, DataVar []byte, LengthVar uint) {
+
+	xMessageBodyAppend(x.GoPointer(), UseVar, DataVar, LengthVar)
+
+}
+
+var xMessageBodyAppendBytes func(uintptr, *glib.Bytes)
+
+// Appends the data from @buffer to @body.
+func (x *MessageBody) AppendBytes(BufferVar *glib.Bytes) {
+
+	xMessageBodyAppendBytes(x.GoPointer(), BufferVar)
+
+}
+
+var xMessageBodyAppendTake func(uintptr, []byte, uint)
+
+// Appends @length bytes from @data to @body.
+//
+// This function is exactly equivalent to [method@MessageBody.append]
+// with %SOUP_MEMORY_TAKE as second argument; it exists mainly for
+// convenience and simplifying language bindings.
+func (x *MessageBody) AppendTake(DataVar []byte, LengthVar uint) {
+
+	xMessageBodyAppendTake(x.GoPointer(), DataVar, LengthVar)
+
+}
+
+var xMessageBodyComplete func(uintptr)
+
+// Tags @body as being complete.
+//
+// Call this when using chunked encoding after you have appended the last chunk.
+func (x *MessageBody) Complete() {
+
+	xMessageBodyComplete(x.GoPointer())
+
+}
+
+var xMessageBodyFlatten func(uintptr) *glib.Bytes
+
+// Fills in @body's data field with a buffer containing all of the
+// data in @body.
+//
+// Adds an additional `\0` byte not counted by @body's
+// length field.
+func (x *MessageBody) Flatten() *glib.Bytes {
+
+	cret := xMessageBodyFlatten(x.GoPointer())
+	return cret
+}
+
+var xMessageBodyGetAccumulate func(uintptr) bool
+
+// Gets the accumulate flag on @body.
+//
+// See [method@MessageBody.set_accumulate. for details.
+func (x *MessageBody) GetAccumulate() bool {
+
+	cret := xMessageBodyGetAccumulate(x.GoPointer())
+	return cret
+}
+
+var xMessageBodyGetChunk func(uintptr, int64) *glib.Bytes
+
+// Gets a [struct@GLib.Bytes] containing data from @body starting at @offset.
+//
+// The size of the returned chunk is unspecified. You can iterate
+// through the entire body by first calling
+// [method@MessageBody.get_chunk] with an offset of 0, and then on each
+// successive call, increment the offset by the length of the
+// previously-returned chunk.
+//
+// If @offset is greater than or equal to the total length of @body,
+// then the return value depends on whether or not
+// [method@MessageBody.complete] has been called or not; if it has,
+// then [method@MessageBody.get_chunk] will return a 0-length chunk
+// (indicating the end of @body). If it has not, then
+// [method@MessageBody.get_chunk] will return %NULL (indicating that
+// @body may still potentially have more data, but that data is not
+// currently available).
+func (x *MessageBody) GetChunk(OffsetVar int64) *glib.Bytes {
+
+	cret := xMessageBodyGetChunk(x.GoPointer(), OffsetVar)
+	return cret
+}
+
+var xMessageBodyGotChunk func(uintptr, *glib.Bytes)
+
+// Handles the #SoupMessageBody part of receiving a chunk of data from
+// the network.
+//
+// Normally this means appending @chunk to @body, exactly as with
+// [method@MessageBody.append_bytes], but if you have set @body's accumulate
+// flag to %FALSE, then that will not happen.
+//
+// This is a low-level method which you should not normally need to
+// use.
+func (x *MessageBody) GotChunk(ChunkVar *glib.Bytes) {
+
+	xMessageBodyGotChunk(x.GoPointer(), ChunkVar)
+
+}
+
+var xMessageBodyRef func(uintptr) *MessageBody
+
+// Atomically increments the reference count of @body by one.
+func (x *MessageBody) Ref() *MessageBody {
+
+	cret := xMessageBodyRef(x.GoPointer())
+	return cret
+}
+
+var xMessageBodySetAccumulate func(uintptr, bool)
+
+// Sets or clears the accumulate flag on @body.
+//
+// (The default value is %TRUE.) If set to %FALSE, @body's data field will not
+// be filled in after the body is fully sent/received, and the chunks that make
+// up @body may be discarded when they are no longer needed.
+//
+// If you set the flag to %FALSE on the [class@Message] request_body of a
+// client-side message, it will block the accumulation of chunks into
+// @body's data field, but it will not normally cause the chunks to
+// be discarded after being written like in the server-side
+// [class@Message] response_body case, because the request body needs to
+// be kept around in case the request needs to be sent a second time
+// due to redirection or authentication.
+func (x *MessageBody) SetAccumulate(AccumulateVar bool) {
+
+	xMessageBodySetAccumulate(x.GoPointer(), AccumulateVar)
+
+}
+
+var xMessageBodyTruncate func(uintptr)
+
+// Deletes all of the data in @body.
+func (x *MessageBody) Truncate() {
+
+	xMessageBodyTruncate(x.GoPointer())
+
+}
+
+var xMessageBodyUnref func(uintptr)
+
+// Atomically decrements the reference count of @body by one.
+//
+// When the reference count reaches zero, the resources allocated by
+// @body are freed
+func (x *MessageBody) Unref() {
+
+	xMessageBodyUnref(x.GoPointer())
+
+}
+
+var xMessageBodyWroteChunk func(uintptr, *glib.Bytes)
+
+// Handles the #SoupMessageBody part of writing a chunk of data to the
+// network.
+//
+// Normally this is a no-op, but if you have set @body's accumulate flag to
+// %FALSE, then this will cause @chunk to be discarded to free up memory.
+//
+// This is a low-level method which you should not need to use, and
+// there are further restrictions on its proper use which are not
+// documented here.
+func (x *MessageBody) WroteChunk(ChunkVar *glib.Bytes) {
+
+	xMessageBodyWroteChunk(x.GoPointer(), ChunkVar)
+
+}
+
+// The lifetime of the memory being passed.
+type MemoryUse int
+
+var xMemoryUseGLibType func() types.GType
+
+func MemoryUseGLibType() types.GType {
+	return xMemoryUseGLibType()
+}
+
+const (
+
+	// The memory is statically allocated and
+	//   constant; libsoup can use the passed-in buffer directly and not
+	//   need to worry about it being modified or freed.
+	MemoryStaticValue MemoryUse = 0
+	// The caller has allocated the memory and libsoup
+	//   will assume ownership of it and free it with [func@GLib.free].
+	MemoryTakeValue MemoryUse = 1
+	// The passed-in data belongs to the caller and
+	//   libsoup will copy it into new memory leaving the caller free
+	//   to reuse the original memory.
+	MemoryCopyValue MemoryUse = 2
+)
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xMemoryUseGLibType, libs, "soup_memory_use_get_type")
+
+	core.PuregoSafeRegister(&xMessageBodyGLibType, libs, "soup_message_body_get_type")
+
+	core.PuregoSafeRegister(&xNewMessageBody, libs, "soup_message_body_new")
+
+	core.PuregoSafeRegister(&xMessageBodyAppend, libs, "soup_message_body_append")
+	core.PuregoSafeRegister(&xMessageBodyAppendBytes, libs, "soup_message_body_append_bytes")
+	core.PuregoSafeRegister(&xMessageBodyAppendTake, libs, "soup_message_body_append_take")
+	core.PuregoSafeRegister(&xMessageBodyComplete, libs, "soup_message_body_complete")
+	core.PuregoSafeRegister(&xMessageBodyFlatten, libs, "soup_message_body_flatten")
+	core.PuregoSafeRegister(&xMessageBodyGetAccumulate, libs, "soup_message_body_get_accumulate")
+	core.PuregoSafeRegister(&xMessageBodyGetChunk, libs, "soup_message_body_get_chunk")
+	core.PuregoSafeRegister(&xMessageBodyGotChunk, libs, "soup_message_body_got_chunk")
+	core.PuregoSafeRegister(&xMessageBodyRef, libs, "soup_message_body_ref")
+	core.PuregoSafeRegister(&xMessageBodySetAccumulate, libs, "soup_message_body_set_accumulate")
+	core.PuregoSafeRegister(&xMessageBodyTruncate, libs, "soup_message_body_truncate")
+	core.PuregoSafeRegister(&xMessageBodyUnref, libs, "soup_message_body_unref")
+	core.PuregoSafeRegister(&xMessageBodyWroteChunk, libs, "soup_message_body_wrote_chunk")
+
+}
diff --git a/v4/soup/soup-message-headers.go b/v4/soup/soup-message-headers.go
new file mode 100644
index 0000000000000000000000000000000000000000..d06b8632fc2e79864121a7bc8cde7721f58bd42c
--- /dev/null
+++ b/v4/soup/soup-message-headers.go
@@ -0,0 +1,647 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// The callback passed to [method@MessageHeaders.foreach].
+type MessageHeadersForeachFunc func(string, string, uintptr)
+
+// The HTTP message headers associated with a request or response.
+type MessageHeaders struct {
+	_ structs.HostLayout
+}
+
+var xMessageHeadersGLibType func() types.GType
+
+func MessageHeadersGLibType() types.GType {
+	return xMessageHeadersGLibType()
+}
+
+func (x *MessageHeaders) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewMessageHeaders func(MessageHeadersType) *MessageHeaders
+
+// Creates a #SoupMessageHeaders.
+//
+// ([class@Message] does this automatically for its own headers. You would only
+// need to use this method if you are manually parsing or generating message
+// headers.)
+func NewMessageHeaders(TypeVar MessageHeadersType) *MessageHeaders {
+
+	cret := xNewMessageHeaders(TypeVar)
+	return cret
+}
+
+var xMessageHeadersAppend func(uintptr, string, string)
+
+// Appends a new header with name @name and value @value to @hdrs.
+//
+// (If there is an existing header with name @name, then this creates a second
+// one, which is only allowed for list-valued headers; see also
+// [method@MessageHeaders.replace].)
+//
+// The caller is expected to make sure that @name and @value are
+// syntactically correct.
+func (x *MessageHeaders) Append(NameVar string, ValueVar string) {
+
+	xMessageHeadersAppend(x.GoPointer(), NameVar, ValueVar)
+
+}
+
+var xMessageHeadersCleanConnectionHeaders func(uintptr)
+
+// Removes all the headers listed in the Connection header.
+func (x *MessageHeaders) CleanConnectionHeaders() {
+
+	xMessageHeadersCleanConnectionHeaders(x.GoPointer())
+
+}
+
+var xMessageHeadersClear func(uintptr)
+
+// Clears @hdrs.
+func (x *MessageHeaders) Clear() {
+
+	xMessageHeadersClear(x.GoPointer())
+
+}
+
+var xMessageHeadersForeach func(uintptr, uintptr, uintptr)
+
+// Calls @func once for each header value in @hdrs.
+//
+// Beware that unlike [method@MessageHeaders.get_list], this processes the
+// headers in exactly the way they were added, rather than
+// concatenating multiple same-named headers into a single value.
+// (This is intentional; it ensures that if you call
+// [method@MessageHeaders.append] multiple times with the same name,
+// then the I/O code will output multiple copies of the header when
+// sending the message to the remote implementation, which may be
+// required for interoperability in some cases.)
+//
+// You may not modify the headers from @func.
+func (x *MessageHeaders) Foreach(FuncVar *MessageHeadersForeachFunc, UserDataVar uintptr) {
+
+	xMessageHeadersForeach(x.GoPointer(), glib.NewCallback(FuncVar), UserDataVar)
+
+}
+
+var xMessageHeadersFreeRanges func(uintptr, *Range)
+
+// Frees the array of ranges returned from [method@MessageHeaders.get_ranges].
+func (x *MessageHeaders) FreeRanges(RangesVar *Range) {
+
+	xMessageHeadersFreeRanges(x.GoPointer(), RangesVar)
+
+}
+
+var xMessageHeadersGetContentDisposition func(uintptr, *string, **glib.HashTable) bool
+
+// Looks up the "Content-Disposition" header in @hdrs, parses it, and
+// returns its value in *@disposition and *@params.
+//
+// @params can be %NULL if you are only interested in the disposition-type.
+//
+// In HTTP, the most common use of this header is to set a
+// disposition-type of "attachment", to suggest to the browser that a
+// response should be saved to disk rather than displayed in the
+// browser. If @params contains a "filename" parameter, this is a
+// suggestion of a filename to use. (If the parameter value in the
+// header contains an absolute or relative path, libsoup will truncate
+// it down to just the final path component, so you do not need to
+// test this yourself.)
+//
+// Content-Disposition is also used in "multipart/form-data", however
+// this is handled automatically by [struct@Multipart] and the associated
+// form methods.
+func (x *MessageHeaders) GetContentDisposition(DispositionVar *string, ParamsVar **glib.HashTable) bool {
+
+	cret := xMessageHeadersGetContentDisposition(x.GoPointer(), DispositionVar, ParamsVar)
+	return cret
+}
+
+var xMessageHeadersGetContentLength func(uintptr) int64
+
+// Gets the message body length that @hdrs declare.
+//
+// This will only be non-0 if [method@MessageHeaders.get_encoding] returns
+// %SOUP_ENCODING_CONTENT_LENGTH.
+func (x *MessageHeaders) GetContentLength() int64 {
+
+	cret := xMessageHeadersGetContentLength(x.GoPointer())
+	return cret
+}
+
+var xMessageHeadersGetContentRange func(uintptr, *int64, *int64, *int64) bool
+
+// Parses @hdrs's Content-Range header and returns it in @start,
+// @end, and @total_length. If the total length field in the header
+// was specified as "*", then @total_length will be set to -1.
+func (x *MessageHeaders) GetContentRange(StartVar *int64, EndVar *int64, TotalLengthVar *int64) bool {
+
+	cret := xMessageHeadersGetContentRange(x.GoPointer(), StartVar, EndVar, TotalLengthVar)
+	return cret
+}
+
+var xMessageHeadersGetContentType func(uintptr, **glib.HashTable) string
+
+// Looks up the "Content-Type" header in @hdrs, parses it, and returns
+// its value in *@content_type and *@params.
+//
+// @params can be %NULL if you are only interested in the content type itself.
+func (x *MessageHeaders) GetContentType(ParamsVar **glib.HashTable) string {
+
+	cret := xMessageHeadersGetContentType(x.GoPointer(), ParamsVar)
+	return cret
+}
+
+var xMessageHeadersGetEncoding func(uintptr) Encoding
+
+// Gets the message body encoding that @hdrs declare.
+//
+// This may not always correspond to the encoding used on the wire; eg, a HEAD
+// response may declare a Content-Length or Transfer-Encoding, but it will never
+// actually include a body.
+func (x *MessageHeaders) GetEncoding() Encoding {
+
+	cret := xMessageHeadersGetEncoding(x.GoPointer())
+	return cret
+}
+
+var xMessageHeadersGetExpectations func(uintptr) Expectation
+
+// Gets the expectations declared by @hdrs's "Expect" header.
+//
+// Currently this will either be %SOUP_EXPECTATION_CONTINUE or
+// %SOUP_EXPECTATION_UNRECOGNIZED.
+func (x *MessageHeaders) GetExpectations() Expectation {
+
+	cret := xMessageHeadersGetExpectations(x.GoPointer())
+	return cret
+}
+
+var xMessageHeadersGetHeadersType func(uintptr) MessageHeadersType
+
+// Gets the type of headers.
+func (x *MessageHeaders) GetHeadersType() MessageHeadersType {
+
+	cret := xMessageHeadersGetHeadersType(x.GoPointer())
+	return cret
+}
+
+var xMessageHeadersGetList func(uintptr, string) string
+
+// Gets the value of header @name in @hdrs.
+//
+// Use this for headers whose values are comma-delimited lists, and which are
+// therefore allowed to appear multiple times in the headers. For
+// non-list-valued headers, use [method@MessageHeaders.get_one].
+//
+// If @name appears multiple times in @hdrs,
+// [method@MessageHeaders.get_list] will concatenate all of the values
+// together, separated by commas. This is sometimes awkward to parse
+// (eg, WWW-Authenticate, Set-Cookie), but you have to be able to deal
+// with it anyway, because the HTTP spec explicitly states that this
+// transformation is allowed, and so an upstream proxy could do the
+// same thing.
+func (x *MessageHeaders) GetList(NameVar string) string {
+
+	cret := xMessageHeadersGetList(x.GoPointer(), NameVar)
+	return cret
+}
+
+var xMessageHeadersGetOne func(uintptr, string) string
+
+// Gets the value of header @name in @hdrs.
+//
+// Use this for headers whose values are *not* comma-delimited lists, and which
+// therefore can only appear at most once in the headers. For list-valued
+// headers, use [method@MessageHeaders.get_list].
+//
+// If @hdrs does erroneously contain multiple copies of the header, it
+// is not defined which one will be returned. (Ideally, it will return
+// whichever one makes libsoup most compatible with other HTTP
+// implementations.)
+func (x *MessageHeaders) GetOne(NameVar string) string {
+
+	cret := xMessageHeadersGetOne(x.GoPointer(), NameVar)
+	return cret
+}
+
+var xMessageHeadersGetRanges func(uintptr, int64, *uintptr, *int) bool
+
+// Parses @hdrs's Range header and returns an array of the requested
+// byte ranges.
+//
+// The returned array must be freed with [method@MessageHeaders.free_ranges].
+//
+// If @total_length is non-0, its value will be used to adjust the
+// returned ranges to have explicit start and end values, and the
+// returned ranges will be sorted and non-overlapping. If
+// @total_length is 0, then some ranges may have an end value of -1,
+// as described under [struct@Range], and some of the ranges may be
+// redundant.
+//
+// Beware that even if given a @total_length, this function does not
+// check that the ranges are satisfiable.
+//
+// #SoupServer has built-in handling for range requests. If your
+// server handler returns a %SOUP_STATUS_OK response containing the
+// complete response body (rather than pausing the message and
+// returning some of the response body later), and there is a Range
+// header in the request, then libsoup will automatically convert the
+// response to a %SOUP_STATUS_PARTIAL_CONTENT response containing only
+// the range(s) requested by the client.
+//
+// The only time you need to process the Range header yourself is if
+// either you need to stream the response body rather than returning
+// it all at once, or you do not already have the complete response
+// body available, and only want to generate the parts that were
+// actually requested by the client.
+func (x *MessageHeaders) GetRanges(TotalLengthVar int64, RangesVar *uintptr, LengthVar *int) bool {
+
+	cret := xMessageHeadersGetRanges(x.GoPointer(), TotalLengthVar, RangesVar, LengthVar)
+	return cret
+}
+
+var xMessageHeadersHeaderContains func(uintptr, string, string) bool
+
+// Checks whether the list-valued header @name is present in @hdrs,
+// and contains a case-insensitive match for @token.
+//
+// (If @name is present in @hdrs, then this is equivalent to calling
+// [func@header_contains] on its value.)
+func (x *MessageHeaders) HeaderContains(NameVar string, TokenVar string) bool {
+
+	cret := xMessageHeadersHeaderContains(x.GoPointer(), NameVar, TokenVar)
+	return cret
+}
+
+var xMessageHeadersHeaderEquals func(uintptr, string, string) bool
+
+// Checks whether the header @name is present in @hdrs and is
+// (case-insensitively) equal to @value.
+func (x *MessageHeaders) HeaderEquals(NameVar string, ValueVar string) bool {
+
+	cret := xMessageHeadersHeaderEquals(x.GoPointer(), NameVar, ValueVar)
+	return cret
+}
+
+var xMessageHeadersRef func(uintptr) *MessageHeaders
+
+// Atomically increments the reference count of @hdrs by one.
+func (x *MessageHeaders) Ref() *MessageHeaders {
+
+	cret := xMessageHeadersRef(x.GoPointer())
+	return cret
+}
+
+var xMessageHeadersRemove func(uintptr, string)
+
+// Removes @name from @hdrs.
+//
+// If there are multiple values for @name, they are all removed.
+func (x *MessageHeaders) Remove(NameVar string) {
+
+	xMessageHeadersRemove(x.GoPointer(), NameVar)
+
+}
+
+var xMessageHeadersReplace func(uintptr, string, string)
+
+// Replaces the value of the header @name in @hdrs with @value.
+//
+// See also [method@MessageHeaders.append].
+//
+// The caller is expected to make sure that @name and @value are
+// syntactically correct.
+func (x *MessageHeaders) Replace(NameVar string, ValueVar string) {
+
+	xMessageHeadersReplace(x.GoPointer(), NameVar, ValueVar)
+
+}
+
+var xMessageHeadersSetContentDisposition func(uintptr, string, *glib.HashTable)
+
+// Sets the "Content-Disposition" header in @hdrs to @disposition,
+// optionally with additional parameters specified in @params.
+//
+// See [method@MessageHeaders.get_content_disposition] for a discussion
+// of how Content-Disposition is used in HTTP.
+func (x *MessageHeaders) SetContentDisposition(DispositionVar string, ParamsVar *glib.HashTable) {
+
+	xMessageHeadersSetContentDisposition(x.GoPointer(), DispositionVar, ParamsVar)
+
+}
+
+var xMessageHeadersSetContentLength func(uintptr, int64)
+
+// Sets the message body length that @hdrs will declare, and sets
+// @hdrs's encoding to %SOUP_ENCODING_CONTENT_LENGTH.
+//
+// You do not normally need to call this; if @hdrs is set to use
+// Content-Length encoding, libsoup will automatically set its
+// Content-Length header for you immediately before sending the
+// headers. One situation in which this method is useful is when
+// generating the response to a HEAD request; Calling
+// [method@MessageHeaders.set_content_length] allows you to put the
+// correct content length into the response without needing to waste
+// memory by filling in a response body which won't actually be sent.
+func (x *MessageHeaders) SetContentLength(ContentLengthVar int64) {
+
+	xMessageHeadersSetContentLength(x.GoPointer(), ContentLengthVar)
+
+}
+
+var xMessageHeadersSetContentRange func(uintptr, int64, int64, int64)
+
+// Sets @hdrs's Content-Range header according to the given values.
+//
+// (Note that @total_length is the total length of the entire resource
+// that this is a range of, not simply @end - @start + 1.)
+//
+// [class@Server] has built-in handling for range requests, and you do
+// not normally need to call this function youself. See
+// [method@MessageHeaders.get_ranges] for more details.
+func (x *MessageHeaders) SetContentRange(StartVar int64, EndVar int64, TotalLengthVar int64) {
+
+	xMessageHeadersSetContentRange(x.GoPointer(), StartVar, EndVar, TotalLengthVar)
+
+}
+
+var xMessageHeadersSetContentType func(uintptr, string, *glib.HashTable)
+
+// Sets the "Content-Type" header in @hdrs to @content_type.
+//
+// Accepts additional parameters specified in @params.
+func (x *MessageHeaders) SetContentType(ContentTypeVar string, ParamsVar *glib.HashTable) {
+
+	xMessageHeadersSetContentType(x.GoPointer(), ContentTypeVar, ParamsVar)
+
+}
+
+var xMessageHeadersSetEncoding func(uintptr, Encoding)
+
+// Sets the message body encoding that @hdrs will declare.
+//
+// In particular, you should use this if you are going to send a request or
+// response in chunked encoding.
+func (x *MessageHeaders) SetEncoding(EncodingVar Encoding) {
+
+	xMessageHeadersSetEncoding(x.GoPointer(), EncodingVar)
+
+}
+
+var xMessageHeadersSetExpectations func(uintptr, Expectation)
+
+// Sets @hdrs's "Expect" header according to @expectations.
+//
+// Currently %SOUP_EXPECTATION_CONTINUE is the only known expectation
+// value. You should set this value on a request if you are sending a
+// large message body (eg, via POST or PUT), and want to give the
+// server a chance to reject the request after seeing just the headers
+// (eg, because it will require authentication before allowing you to
+// post, or because you're POSTing to a URL that doesn't exist). This
+// saves you from having to transmit the large request body when the
+// server is just going to ignore it anyway.
+func (x *MessageHeaders) SetExpectations(ExpectationsVar Expectation) {
+
+	xMessageHeadersSetExpectations(x.GoPointer(), ExpectationsVar)
+
+}
+
+var xMessageHeadersSetRange func(uintptr, int64, int64)
+
+// Sets @hdrs's Range header to request the indicated range.
+//
+// @start and @end are interpreted as in a [struct@Range].
+//
+// If you need to request multiple ranges, use
+// [method@MessageHeaders.set_ranges].
+func (x *MessageHeaders) SetRange(StartVar int64, EndVar int64) {
+
+	xMessageHeadersSetRange(x.GoPointer(), StartVar, EndVar)
+
+}
+
+var xMessageHeadersSetRanges func(uintptr, *Range, int)
+
+// Sets @hdrs's Range header to request the indicated ranges.
+//
+// If you only want to request a single range, you can use
+// [method@MessageHeaders.set_range].
+func (x *MessageHeaders) SetRanges(RangesVar *Range, LengthVar int) {
+
+	xMessageHeadersSetRanges(x.GoPointer(), RangesVar, LengthVar)
+
+}
+
+var xMessageHeadersUnref func(uintptr)
+
+// Atomically decrements the reference count of @hdrs by one.
+//
+// When the reference count reaches zero, the resources allocated by
+// @hdrs are freed
+func (x *MessageHeaders) Unref() {
+
+	xMessageHeadersUnref(x.GoPointer())
+
+}
+
+// An opaque type used to iterate over a %SoupMessageHeaders
+// structure.
+//
+// After intializing the iterator with [func@MessageHeadersIter.init], call
+// [method@MessageHeadersIter.next] to fetch data from it.
+//
+// You may not modify the headers while iterating over them.
+type MessageHeadersIter struct {
+	_ structs.HostLayout
+
+	Dummy [3]uintptr
+}
+
+func (x *MessageHeadersIter) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Represents a byte range as used in the Range header.
+//
+// If @end is non-negative, then @start and @end represent the bounds
+// of of the range, counting from 0. (Eg, the first 500 bytes would be
+// represented as @start = 0 and @end = 499.)
+//
+// If @end is -1 and @start is non-negative, then this represents a
+// range starting at @start and ending with the last byte of the
+// requested resource body. (Eg, all but the first 500 bytes would be
+// @start = 500, and @end = -1.)
+//
+// If @end is -1 and @start is negative, then it represents a "suffix
+// range", referring to the last -@start bytes of the resource body.
+// (Eg, the last 500 bytes would be @start = -500 and @end = -1.)
+type Range struct {
+	_ structs.HostLayout
+
+	Start int64
+
+	End int64
+}
+
+func (x *Range) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Represents the parsed value of the "Expect" header.
+type Expectation int
+
+var xExpectationGLibType func() types.GType
+
+func ExpectationGLibType() types.GType {
+	return xExpectationGLibType()
+}
+
+const (
+
+	// any unrecognized expectation
+	ExpectationUnrecognizedValue Expectation = 1
+	// "100-continue"
+	ExpectationContinueValue Expectation = 2
+)
+
+// How a message body is encoded for transport
+type Encoding int
+
+var xEncodingGLibType func() types.GType
+
+func EncodingGLibType() types.GType {
+	return xEncodingGLibType()
+}
+
+const (
+
+	// unknown / error
+	EncodingUnrecognizedValue Encoding = 0
+	// no body is present (which is not the same as a
+	//   0-length body, and only occurs in certain places)
+	EncodingNoneValue Encoding = 1
+	// Content-Length encoding
+	EncodingContentLengthValue Encoding = 2
+	// Response body ends when the connection is closed
+	EncodingEofValue Encoding = 3
+	// chunked encoding (currently only supported
+	//   for response)
+	EncodingChunkedValue Encoding = 4
+	// multipart/byteranges (Reserved for future
+	//   use: NOT CURRENTLY IMPLEMENTED)
+	EncodingByterangesValue Encoding = 5
+)
+
+// Value passed to [ctor@MessageHeaders.new] to set certain default
+// behaviors.
+type MessageHeadersType int
+
+var xMessageHeadersTypeGLibType func() types.GType
+
+func MessageHeadersTypeGLibType() types.GType {
+	return xMessageHeadersTypeGLibType()
+}
+
+const (
+
+	// request headers
+	MessageHeadersRequestValue MessageHeadersType = 0
+	// response headers
+	MessageHeadersResponseValue MessageHeadersType = 1
+	// multipart body part headers
+	MessageHeadersMultipartValue MessageHeadersType = 2
+)
+
+var xMessageHeadersIterInit func(*MessageHeadersIter, *MessageHeaders)
+
+// Initializes @iter for iterating @hdrs.
+func MessageHeadersIterInit(IterVar *MessageHeadersIter, HdrsVar *MessageHeaders) {
+
+	xMessageHeadersIterInit(IterVar, HdrsVar)
+
+}
+
+var xMessageHeadersIterNext func(*MessageHeadersIter, *string, *string) bool
+
+// Yields the next name/value pair in the [struct@MessageHeaders] being
+// iterated by @iter.
+//
+// If @iter has already yielded the last header, then
+// [method@MessageHeadersIter.next] will return %FALSE and @name and @value
+// will be unchanged.
+func MessageHeadersIterNext(IterVar *MessageHeadersIter, NameVar *string, ValueVar *string) bool {
+
+	cret := xMessageHeadersIterNext(IterVar, NameVar, ValueVar)
+	return cret
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xExpectationGLibType, libs, "soup_expectation_get_type")
+
+	core.PuregoSafeRegister(&xEncodingGLibType, libs, "soup_encoding_get_type")
+
+	core.PuregoSafeRegister(&xMessageHeadersTypeGLibType, libs, "soup_message_headers_type_get_type")
+
+	core.PuregoSafeRegister(&xMessageHeadersIterInit, libs, "soup_message_headers_iter_init")
+	core.PuregoSafeRegister(&xMessageHeadersIterNext, libs, "soup_message_headers_iter_next")
+
+	core.PuregoSafeRegister(&xMessageHeadersGLibType, libs, "soup_message_headers_get_type")
+
+	core.PuregoSafeRegister(&xNewMessageHeaders, libs, "soup_message_headers_new")
+
+	core.PuregoSafeRegister(&xMessageHeadersAppend, libs, "soup_message_headers_append")
+	core.PuregoSafeRegister(&xMessageHeadersCleanConnectionHeaders, libs, "soup_message_headers_clean_connection_headers")
+	core.PuregoSafeRegister(&xMessageHeadersClear, libs, "soup_message_headers_clear")
+	core.PuregoSafeRegister(&xMessageHeadersForeach, libs, "soup_message_headers_foreach")
+	core.PuregoSafeRegister(&xMessageHeadersFreeRanges, libs, "soup_message_headers_free_ranges")
+	core.PuregoSafeRegister(&xMessageHeadersGetContentDisposition, libs, "soup_message_headers_get_content_disposition")
+	core.PuregoSafeRegister(&xMessageHeadersGetContentLength, libs, "soup_message_headers_get_content_length")
+	core.PuregoSafeRegister(&xMessageHeadersGetContentRange, libs, "soup_message_headers_get_content_range")
+	core.PuregoSafeRegister(&xMessageHeadersGetContentType, libs, "soup_message_headers_get_content_type")
+	core.PuregoSafeRegister(&xMessageHeadersGetEncoding, libs, "soup_message_headers_get_encoding")
+	core.PuregoSafeRegister(&xMessageHeadersGetExpectations, libs, "soup_message_headers_get_expectations")
+	core.PuregoSafeRegister(&xMessageHeadersGetHeadersType, libs, "soup_message_headers_get_headers_type")
+	core.PuregoSafeRegister(&xMessageHeadersGetList, libs, "soup_message_headers_get_list")
+	core.PuregoSafeRegister(&xMessageHeadersGetOne, libs, "soup_message_headers_get_one")
+	core.PuregoSafeRegister(&xMessageHeadersGetRanges, libs, "soup_message_headers_get_ranges")
+	core.PuregoSafeRegister(&xMessageHeadersHeaderContains, libs, "soup_message_headers_header_contains")
+	core.PuregoSafeRegister(&xMessageHeadersHeaderEquals, libs, "soup_message_headers_header_equals")
+	core.PuregoSafeRegister(&xMessageHeadersRef, libs, "soup_message_headers_ref")
+	core.PuregoSafeRegister(&xMessageHeadersRemove, libs, "soup_message_headers_remove")
+	core.PuregoSafeRegister(&xMessageHeadersReplace, libs, "soup_message_headers_replace")
+	core.PuregoSafeRegister(&xMessageHeadersSetContentDisposition, libs, "soup_message_headers_set_content_disposition")
+	core.PuregoSafeRegister(&xMessageHeadersSetContentLength, libs, "soup_message_headers_set_content_length")
+	core.PuregoSafeRegister(&xMessageHeadersSetContentRange, libs, "soup_message_headers_set_content_range")
+	core.PuregoSafeRegister(&xMessageHeadersSetContentType, libs, "soup_message_headers_set_content_type")
+	core.PuregoSafeRegister(&xMessageHeadersSetEncoding, libs, "soup_message_headers_set_encoding")
+	core.PuregoSafeRegister(&xMessageHeadersSetExpectations, libs, "soup_message_headers_set_expectations")
+	core.PuregoSafeRegister(&xMessageHeadersSetRange, libs, "soup_message_headers_set_range")
+	core.PuregoSafeRegister(&xMessageHeadersSetRanges, libs, "soup_message_headers_set_ranges")
+	core.PuregoSafeRegister(&xMessageHeadersUnref, libs, "soup_message_headers_unref")
+
+}
diff --git a/v4/soup/soup-message.go b/v4/soup/soup-message.go
new file mode 100644
index 0000000000000000000000000000000000000000..1a18e8d7c6348ebe98967a71dfd86962dc90c052
--- /dev/null
+++ b/v4/soup/soup-message.go
@@ -0,0 +1,1386 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type MessageClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *MessageClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Various flags that can be set on a #SoupMessage to alter its
+// behavior.
+type MessageFlags int
+
+var xMessageFlagsGLibType func() types.GType
+
+func MessageFlagsGLibType() types.GType {
+	return xMessageFlagsGLibType()
+}
+
+const (
+
+	// The session should not follow redirect
+	//   (3xx) responses received by this message.
+	MessageNoRedirectValue MessageFlags = 2
+	// Requests that the message should be
+	//   sent on a newly-created connection, not reusing an existing
+	//   persistent connection. Note that messages with non-idempotent
+	//   [property@Message:method]s behave this way by default, unless
+	//   #SOUP_MESSAGE_IDEMPOTENT is set.
+	MessageNewConnectionValue MessageFlags = 4
+	// The message is considered idempotent,
+	//   regardless its [property@Message:method], and allows reuse of existing
+	//   idle connections, instead of always requiring a new one, unless
+	//   #SOUP_MESSAGE_NEW_CONNECTION is set.
+	MessageIdempotentValue MessageFlags = 8
+	// The [class@AuthManager] should not use
+	//   the credentials cache for this message, neither to use cached credentials
+	//   to automatically authenticate this message nor to cache the credentials
+	//   after the message is successfully authenticated. This applies to both server
+	//   and proxy authentication. Note that [signal@Message::authenticate] signal will
+	//   be emitted, if you want to disable authentication for a message use
+	//   [method@Message.disable_feature] passing #SOUP_TYPE_AUTH_MANAGER instead.
+	MessageDoNotUseAuthCacheValue MessageFlags = 16
+	// Metrics will be collected for this message.
+	MessageCollectMetricsValue MessageFlags = 32
+)
+
+// Priorities that can be set on a [class@Message] to instruct the message queue
+// to process it before any other message with lower priority.
+type MessagePriority int
+
+var xMessagePriorityGLibType func() types.GType
+
+func MessagePriorityGLibType() types.GType {
+	return xMessagePriorityGLibType()
+}
+
+const (
+
+	// The lowest priority, the messages
+	//   with this priority will be the last ones to be attended.
+	MessagePriorityVeryLowValue MessagePriority = 0
+	// Use this for low priority messages, a
+	//   #SoupMessage with the default priority will be processed first.
+	MessagePriorityLowValue MessagePriority = 1
+	// The default priotity, this is the
+	//   priority assigned to the #SoupMessage by default.
+	MessagePriorityNormalValue MessagePriority = 2
+	// High priority, a #SoupMessage with
+	//   this priority will be processed before the ones with the default
+	//   priority.
+	MessagePriorityHighValue MessagePriority = 3
+	// The highest priority, use this
+	//   for very urgent #SoupMessage as they will be the first ones to be
+	//   attended.
+	MessagePriorityVeryHighValue MessagePriority = 4
+)
+
+// Represents an HTTP message being sent or received.
+//
+// A #SoupMessage represents an HTTP message that is being sent or
+// received.
+//
+// You would create a #SoupMessage with [ctor@Message.new] or
+// [ctor@Message.new_from_uri], set up its fields appropriately, and send it.
+//
+// [property@Message:status-code] will normally be a [enum@Status] value, eg,
+// %SOUP_STATUS_OK, though of course it might actually be an unknown status
+// code. [property@Message:reason-phrase] is the actual text returned from the
+// server, which may or may not correspond to the "standard" description of
+// @status_code. At any rate, it is almost certainly not localized, and not very
+// descriptive even if it is in the user's language; you should not use
+// [property@Message:reason-phrase] in user-visible messages. Rather, you should
+// look at [property@Message:status-code], and determine an end-user-appropriate
+// message based on that and on what you were trying to do.
+//
+// Note that libsoup's terminology here does not quite match the HTTP
+// specification: in RFC 2616, an "HTTP-message" is *either* a Request, *or* a
+// Response. In libsoup, a #SoupMessage combines both the request and the
+// response.
+type Message struct {
+	gobject.Object
+}
+
+var xMessageGLibType func() types.GType
+
+func MessageGLibType() types.GType {
+	return xMessageGLibType()
+}
+
+func MessageNewFromInternalPtr(ptr uintptr) *Message {
+	cls := &Message{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewMessage func(string, string) uintptr
+
+// Creates a new empty #SoupMessage, which will connect to @uri.
+func NewMessage(MethodVar string, UriStringVar string) *Message {
+	var cls *Message
+
+	cret := xNewMessage(MethodVar, UriStringVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Message{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewMessageFromEncodedForm func(string, string, string) uintptr
+
+// Creates a new #SoupMessage and sets it up to send the given @encoded_form
+// to @uri via @method. If @method is "GET", it will include the form data
+// into @uri's query field, and if @method is "POST" or "PUT", it will be set as
+// request body.
+//
+// This function takes the ownership of @encoded_form, that will be released
+// with [func@GLib.free] when no longer in use. See also [func@form_encode],
+// [func@form_encode_hash] and [func@form_encode_datalist].
+func NewMessageFromEncodedForm(MethodVar string, UriStringVar string, EncodedFormVar string) *Message {
+	var cls *Message
+
+	cret := xNewMessageFromEncodedForm(MethodVar, UriStringVar, EncodedFormVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Message{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewMessageFromMultipart func(string, *Multipart) uintptr
+
+// Creates a new #SoupMessage and sets it up to send @multipart to
+// @uri_string via POST.
+func NewMessageFromMultipart(UriStringVar string, MultipartVar *Multipart) *Message {
+	var cls *Message
+
+	cret := xNewMessageFromMultipart(UriStringVar, MultipartVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Message{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewMessageFromUri func(string, *glib.Uri) uintptr
+
+// Creates a new empty #SoupMessage, which will connect to @uri.
+func NewMessageFromUri(MethodVar string, UriVar *glib.Uri) *Message {
+	var cls *Message
+
+	cret := xNewMessageFromUri(MethodVar, UriVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Message{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewMessageOptionsPing func(*glib.Uri) uintptr
+
+// Creates a new #SoupMessage to send `OPTIONS *` to a server. The path of
+// @base_uri will be ignored.
+func NewMessageOptionsPing(BaseUriVar *glib.Uri) *Message {
+	var cls *Message
+
+	cret := xNewMessageOptionsPing(BaseUriVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Message{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xMessageAddFlags func(uintptr, MessageFlags)
+
+// Adds @flags to the set of @msg's flags.
+func (x *Message) AddFlags(FlagsVar MessageFlags) {
+
+	xMessageAddFlags(x.GoPointer(), FlagsVar)
+
+}
+
+var xMessageAddHeaderHandler func(uintptr, string, string, uintptr, uintptr) uint
+
+// Adds a signal handler to @msg for @signal.
+//
+// Similar to [func@GObject.signal_connect], but the @callback will only be run
+// if @msg's incoming messages headers (that is, the `request_headers`) contain
+// a header named @header.
+func (x *Message) AddHeaderHandler(SignalVar string, HeaderVar string, CallbackVar *gobject.Callback, UserDataVar uintptr) uint {
+
+	cret := xMessageAddHeaderHandler(x.GoPointer(), SignalVar, HeaderVar, glib.NewCallback(CallbackVar), UserDataVar)
+	return cret
+}
+
+var xMessageAddStatusCodeHandler func(uintptr, string, uint, uintptr, uintptr) uint
+
+// Adds a signal handler to @msg for @signal.
+//
+// Similar to [func@GObject.signal_connect], but the @callback will only be run
+// if @msg has the status @status_code.
+//
+// @signal must be a signal that will be emitted after @msg's status
+// is set (this means it can't be a "wrote" signal).
+func (x *Message) AddStatusCodeHandler(SignalVar string, StatusCodeVar uint, CallbackVar *gobject.Callback, UserDataVar uintptr) uint {
+
+	cret := xMessageAddStatusCodeHandler(x.GoPointer(), SignalVar, StatusCodeVar, glib.NewCallback(CallbackVar), UserDataVar)
+	return cret
+}
+
+var xMessageDisableFeature func(uintptr, types.GType)
+
+// Disables the actions of [iface@SessionFeature]s with the
+// given @feature_type (or a subclass of that type) on @msg.
+//
+// @msg is processed as though the feature(s) hadn't been added to the
+// session. Eg, passing #SOUP_TYPE_CONTENT_SNIFFER for @feature_type
+// will disable Content-Type sniffing on the message.
+//
+// You must call this before queueing @msg on a session; calling it on
+// a message that has already been queued is undefined. In particular,
+// you cannot call this on a message that is being requeued after a
+// redirect or authentication.
+func (x *Message) DisableFeature(FeatureTypeVar types.GType) {
+
+	xMessageDisableFeature(x.GoPointer(), FeatureTypeVar)
+
+}
+
+var xMessageGetConnectionId func(uintptr) uint64
+
+// Returns the unique idenfier for the last connection used.
+//
+// This may be 0 if it was a cached resource or it has not gotten
+// a connection yet.
+func (x *Message) GetConnectionId() uint64 {
+
+	cret := xMessageGetConnectionId(x.GoPointer())
+	return cret
+}
+
+var xMessageGetFirstParty func(uintptr) *glib.Uri
+
+// Gets @msg's first-party [struct@GLib.Uri].
+func (x *Message) GetFirstParty() *glib.Uri {
+
+	cret := xMessageGetFirstParty(x.GoPointer())
+	return cret
+}
+
+var xMessageGetFlags func(uintptr) MessageFlags
+
+// Gets the flags on @msg.
+func (x *Message) GetFlags() MessageFlags {
+
+	cret := xMessageGetFlags(x.GoPointer())
+	return cret
+}
+
+var xMessageGetForceHttp1 func(uintptr) bool
+
+// Returns whether HTTP/1 version is currently demanded for the @msg send.
+func (x *Message) GetForceHttp1() bool {
+
+	cret := xMessageGetForceHttp1(x.GoPointer())
+	return cret
+}
+
+var xMessageGetHttpVersion func(uintptr) HTTPVersion
+
+// Gets the HTTP version of @msg.
+//
+// This is the minimum of the version from the request and the version from the
+// response.
+func (x *Message) GetHttpVersion() HTTPVersion {
+
+	cret := xMessageGetHttpVersion(x.GoPointer())
+	return cret
+}
+
+var xMessageGetIsOptionsPing func(uintptr) bool
+
+// Gets whether @msg is intended to be used to send `OPTIONS *` to a server.
+func (x *Message) GetIsOptionsPing() bool {
+
+	cret := xMessageGetIsOptionsPing(x.GoPointer())
+	return cret
+}
+
+var xMessageGetIsTopLevelNavigation func(uintptr) bool
+
+// Returns if this message is set as a top level navigation.
+//
+// Used for same-site policy checks.
+func (x *Message) GetIsTopLevelNavigation() bool {
+
+	cret := xMessageGetIsTopLevelNavigation(x.GoPointer())
+	return cret
+}
+
+var xMessageGetMethod func(uintptr) string
+
+// Returns the method of this message.
+func (x *Message) GetMethod() string {
+
+	cret := xMessageGetMethod(x.GoPointer())
+	return cret
+}
+
+var xMessageGetMetrics func(uintptr) *MessageMetrics
+
+// Get the [struct@MessageMetrics] of @msg.
+//
+// If the flag %SOUP_MESSAGE_COLLECT_METRICS is not enabled for @msg this will
+// return %NULL.
+func (x *Message) GetMetrics() *MessageMetrics {
+
+	cret := xMessageGetMetrics(x.GoPointer())
+	return cret
+}
+
+var xMessageGetPriority func(uintptr) MessagePriority
+
+// Retrieves the [enum@MessagePriority].
+//
+// If not set this value defaults to #SOUP_MESSAGE_PRIORITY_NORMAL.
+func (x *Message) GetPriority() MessagePriority {
+
+	cret := xMessageGetPriority(x.GoPointer())
+	return cret
+}
+
+var xMessageGetReasonPhrase func(uintptr) string
+
+// Returns the reason phrase for the status of this message.
+func (x *Message) GetReasonPhrase() string {
+
+	cret := xMessageGetReasonPhrase(x.GoPointer())
+	return cret
+}
+
+var xMessageGetRemoteAddress func(uintptr) uintptr
+
+// Get the remote [class@Gio.SocketAddress] of the connection associated with
+// the message.
+//
+// The returned address can be %NULL if the connection hasn't been established
+// yet, or the resource was loaded from the disk cache. In case of proxy
+// connections, the remote address returned is a [class@Gio.ProxyAddress]. If
+// [property@Session:remote-connectable] is set the returned address id for the
+// connection to the session's remote connectable.
+func (x *Message) GetRemoteAddress() *gio.SocketAddress {
+	var cls *gio.SocketAddress
+
+	cret := xMessageGetRemoteAddress(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.SocketAddress{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xMessageGetRequestHeaders func(uintptr) *MessageHeaders
+
+// Returns the headers sent with the request.
+func (x *Message) GetRequestHeaders() *MessageHeaders {
+
+	cret := xMessageGetRequestHeaders(x.GoPointer())
+	return cret
+}
+
+var xMessageGetResponseHeaders func(uintptr) *MessageHeaders
+
+// Returns the headers recieved with the response.
+func (x *Message) GetResponseHeaders() *MessageHeaders {
+
+	cret := xMessageGetResponseHeaders(x.GoPointer())
+	return cret
+}
+
+var xMessageGetSiteForCookies func(uintptr) *glib.Uri
+
+// Gets @msg's site for cookies #GUri.
+func (x *Message) GetSiteForCookies() *glib.Uri {
+
+	cret := xMessageGetSiteForCookies(x.GoPointer())
+	return cret
+}
+
+var xMessageGetStatus func(uintptr) Status
+
+// Returns the set status of this message.
+func (x *Message) GetStatus() Status {
+
+	cret := xMessageGetStatus(x.GoPointer())
+	return cret
+}
+
+var xMessageGetTlsCiphersuiteName func(uintptr) string
+
+// Gets the name of the TLS ciphersuite negotiated for @msg's connection.
+func (x *Message) GetTlsCiphersuiteName() string {
+
+	cret := xMessageGetTlsCiphersuiteName(x.GoPointer())
+	return cret
+}
+
+var xMessageGetTlsPeerCertificate func(uintptr) uintptr
+
+// Gets the peer's [class@Gio.TlsCertificate] associated with @msg's connection.
+//
+// Note that this is not set yet during the emission of
+// [signal@Message::accept-certificate] signal.
+func (x *Message) GetTlsPeerCertificate() *gio.TlsCertificate {
+	var cls *gio.TlsCertificate
+
+	cret := xMessageGetTlsPeerCertificate(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.TlsCertificate{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xMessageGetTlsPeerCertificateErrors func(uintptr) gio.TlsCertificateFlags
+
+// Gets the errors associated with validating @msg's TLS peer certificate.
+// Note that this is not set yet during the emission of
+// [signal@Message::accept-certificate] signal.
+func (x *Message) GetTlsPeerCertificateErrors() gio.TlsCertificateFlags {
+
+	cret := xMessageGetTlsPeerCertificateErrors(x.GoPointer())
+	return cret
+}
+
+var xMessageGetTlsProtocolVersion func(uintptr) gio.TlsProtocolVersion
+
+// Gets the TLS protocol version negotiated for @msg's connection.
+//
+// If the message connection is not SSL, %G_TLS_PROTOCOL_VERSION_UNKNOWN is returned.
+func (x *Message) GetTlsProtocolVersion() gio.TlsProtocolVersion {
+
+	cret := xMessageGetTlsProtocolVersion(x.GoPointer())
+	return cret
+}
+
+var xMessageGetUri func(uintptr) *glib.Uri
+
+// Gets @msg's URI.
+func (x *Message) GetUri() *glib.Uri {
+
+	cret := xMessageGetUri(x.GoPointer())
+	return cret
+}
+
+var xMessageIsFeatureDisabled func(uintptr, types.GType) bool
+
+// Get whether [iface@SessionFeature]s of the given @feature_type
+// (or a subclass of that type) are disabled on @msg.
+//
+// See [method@Message.disable_feature].
+func (x *Message) IsFeatureDisabled(FeatureTypeVar types.GType) bool {
+
+	cret := xMessageIsFeatureDisabled(x.GoPointer(), FeatureTypeVar)
+	return cret
+}
+
+var xMessageIsKeepalive func(uintptr) bool
+
+// Determines whether or not @msg's connection can be kept alive for
+// further requests after processing @msg.
+//
+// The result is based on the HTTP version, Connection header, etc.
+func (x *Message) IsKeepalive() bool {
+
+	cret := xMessageIsKeepalive(x.GoPointer())
+	return cret
+}
+
+var xMessageQueryFlags func(uintptr, MessageFlags) bool
+
+// Queries if @flags are present in the set of @msg's flags.
+func (x *Message) QueryFlags(FlagsVar MessageFlags) bool {
+
+	cret := xMessageQueryFlags(x.GoPointer(), FlagsVar)
+	return cret
+}
+
+var xMessageRemoveFlags func(uintptr, MessageFlags)
+
+// Removes @flags from the set of @msg's flags.
+func (x *Message) RemoveFlags(FlagsVar MessageFlags) {
+
+	xMessageRemoveFlags(x.GoPointer(), FlagsVar)
+
+}
+
+var xMessageSetFirstParty func(uintptr, *glib.Uri)
+
+// Sets @first_party as the main document #GUri for @msg.
+//
+// For details of when and how this is used refer to the documentation for
+// [enum@CookieJarAcceptPolicy].
+func (x *Message) SetFirstParty(FirstPartyVar *glib.Uri) {
+
+	xMessageSetFirstParty(x.GoPointer(), FirstPartyVar)
+
+}
+
+var xMessageSetFlags func(uintptr, MessageFlags)
+
+// Sets the specified flags on @msg.
+func (x *Message) SetFlags(FlagsVar MessageFlags) {
+
+	xMessageSetFlags(x.GoPointer(), FlagsVar)
+
+}
+
+var xMessageSetForceHttp1 func(uintptr, bool)
+
+// Sets whether HTTP/1 version should be used when sending this message.
+// Some connections can still override it, if needed.
+//
+// Note the value is unset after the message send is finished.
+func (x *Message) SetForceHttp1(ValueVar bool) {
+
+	xMessageSetForceHttp1(x.GoPointer(), ValueVar)
+
+}
+
+var xMessageSetIsOptionsPing func(uintptr, bool)
+
+// Set whether @msg is intended to be used to send `OPTIONS *` to a server.
+//
+// When set to %TRUE, the path of [property@Message:uri] will be ignored and
+// [property@Message:method] set to %SOUP_METHOD_OPTIONS.
+func (x *Message) SetIsOptionsPing(IsOptionsPingVar bool) {
+
+	xMessageSetIsOptionsPing(x.GoPointer(), IsOptionsPingVar)
+
+}
+
+var xMessageSetIsTopLevelNavigation func(uintptr, bool)
+
+// Sets whether the current request is a top-level navitation.
+//
+// See the [same-site spec](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00)
+// for more information.
+func (x *Message) SetIsTopLevelNavigation(IsTopLevelNavigationVar bool) {
+
+	xMessageSetIsTopLevelNavigation(x.GoPointer(), IsTopLevelNavigationVar)
+
+}
+
+var xMessageSetMethod func(uintptr, string)
+
+// Set @msg's HTTP method to @method.
+func (x *Message) SetMethod(MethodVar string) {
+
+	xMessageSetMethod(x.GoPointer(), MethodVar)
+
+}
+
+var xMessageSetPriority func(uintptr, MessagePriority)
+
+// Sets the priority of a message.
+//
+// Note that this won't have any effect unless used before the message is added
+// to the session's message processing queue.
+//
+// The message will be placed just before any other previously added
+// message with lower priority (messages with the same priority are
+// processed on a FIFO basis).
+//
+// Setting priorities does not currently work with synchronous messages
+// because in the synchronous/blocking case, priority ends up being determined
+// semi-randomly by thread scheduling.
+func (x *Message) SetPriority(PriorityVar MessagePriority) {
+
+	xMessageSetPriority(x.GoPointer(), PriorityVar)
+
+}
+
+var xMessageSetRequestBody func(uintptr, string, uintptr, int)
+
+// Set the request body of a #SoupMessage.
+//
+// If @content_type is %NULL and @stream is not %NULL the Content-Type header will
+// not be changed if present.
+// The request body needs to be set again in case @msg is restarted
+// (in case of redirection or authentication).
+func (x *Message) SetRequestBody(ContentTypeVar string, StreamVar *gio.InputStream, ContentLengthVar int) {
+
+	xMessageSetRequestBody(x.GoPointer(), ContentTypeVar, StreamVar.GoPointer(), ContentLengthVar)
+
+}
+
+var xMessageSetRequestBodyFromBytes func(uintptr, string, *glib.Bytes)
+
+// Set the request body of a #SoupMessage from [struct@GLib.Bytes].
+//
+// If @content_type is %NULL and @bytes is not %NULL the Content-Type header will
+// not be changed if present.
+// The request body needs to be set again in case @msg is restarted
+// (in case of redirection or authentication).
+func (x *Message) SetRequestBodyFromBytes(ContentTypeVar string, BytesVar *glib.Bytes) {
+
+	xMessageSetRequestBodyFromBytes(x.GoPointer(), ContentTypeVar, BytesVar)
+
+}
+
+var xMessageSetSiteForCookies func(uintptr, *glib.Uri)
+
+// Sets @site_for_cookies as the policy URL for same-site cookies for @msg.
+//
+// It is either the URL of the top-level document or %NULL depending on whether
+// the registrable domain of this document's URL matches the registrable domain
+// of its parent's/opener's URL. For the top-level document it is set to the
+// document's URL.
+//
+// See the [same-site spec](https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00)
+// for more information.
+func (x *Message) SetSiteForCookies(SiteForCookiesVar *glib.Uri) {
+
+	xMessageSetSiteForCookies(x.GoPointer(), SiteForCookiesVar)
+
+}
+
+var xMessageSetTlsClientCertificate func(uintptr, uintptr)
+
+// Sets the @certificate to be used by @msg's connection when a
+// client certificate is requested during the TLS handshake.
+//
+// You can call this as a response to [signal@Message::request-certificate]
+// signal, or before the connection is started. If @certificate is %NULL
+// the handshake will continue without providing a GTlsCertificate.
+// Note that the [class@Gio.TlsCertificate] set by this function will be ignored if
+// [property@Session:tls-interaction] is not %NULL.
+func (x *Message) SetTlsClientCertificate(CertificateVar *gio.TlsCertificate) {
+
+	xMessageSetTlsClientCertificate(x.GoPointer(), CertificateVar.GoPointer())
+
+}
+
+var xMessageSetUri func(uintptr, *glib.Uri)
+
+// Sets @msg's URI to @uri.
+//
+// If @msg has already been sent and you want to re-send it with the new URI,
+// you need to send it again.
+func (x *Message) SetUri(UriVar *glib.Uri) {
+
+	xMessageSetUri(x.GoPointer(), UriVar)
+
+}
+
+var xMessageTlsClientCertificatePasswordRequestComplete func(uintptr)
+
+// Completes a certificate password request.
+//
+// You must call this as a response to
+// [signal@Message::request-certificate-password] signal, to notify @msg that
+// the [class@Gio.TlsPassword] has already been updated.
+func (x *Message) TlsClientCertificatePasswordRequestComplete() {
+
+	xMessageTlsClientCertificatePasswordRequestComplete(x.GoPointer())
+
+}
+
+func (c *Message) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Message) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyFirstParty sets the "first-party" property.
+// The [struct@GLib.Uri] loaded in the application when the message was
+// queued.
+func (x *Message) SetPropertyFirstParty(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("first-party", &v)
+}
+
+// GetPropertyFirstParty gets the "first-party" property.
+// The [struct@GLib.Uri] loaded in the application when the message was
+// queued.
+func (x *Message) GetPropertyFirstParty() uintptr {
+	var v gobject.Value
+	x.GetProperty("first-party", &v)
+	return v.GetPointer()
+}
+
+// SetPropertyIsOptionsPing sets the "is-options-ping" property.
+// Whether the message is an OPTIONS ping.
+//
+// The #SoupMessage is intended to be used to send
+// `OPTIONS *` to a server. When set to %TRUE, the
+// path of [property@Message:uri] will be ignored and
+// [property@Message:method] set to %SOUP_METHOD_OPTIONS.
+func (x *Message) SetPropertyIsOptionsPing(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-options-ping", &v)
+}
+
+// GetPropertyIsOptionsPing gets the "is-options-ping" property.
+// Whether the message is an OPTIONS ping.
+//
+// The #SoupMessage is intended to be used to send
+// `OPTIONS *` to a server. When set to %TRUE, the
+// path of [property@Message:uri] will be ignored and
+// [property@Message:method] set to %SOUP_METHOD_OPTIONS.
+func (x *Message) GetPropertyIsOptionsPing() bool {
+	var v gobject.Value
+	x.GetProperty("is-options-ping", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyIsTopLevelNavigation sets the "is-top-level-navigation" property.
+// Set when the message is navigating between top level domains.
+func (x *Message) SetPropertyIsTopLevelNavigation(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-top-level-navigation", &v)
+}
+
+// GetPropertyIsTopLevelNavigation gets the "is-top-level-navigation" property.
+// Set when the message is navigating between top level domains.
+func (x *Message) GetPropertyIsTopLevelNavigation() bool {
+	var v gobject.Value
+	x.GetProperty("is-top-level-navigation", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyMethod sets the "method" property.
+// The message's HTTP method.
+func (x *Message) SetPropertyMethod(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("method", &v)
+}
+
+// GetPropertyMethod gets the "method" property.
+// The message's HTTP method.
+func (x *Message) GetPropertyMethod() string {
+	var v gobject.Value
+	x.GetProperty("method", &v)
+	return v.GetString()
+}
+
+// GetPropertyReasonPhrase gets the "reason-phrase" property.
+// The HTTP response reason phrase.
+func (x *Message) GetPropertyReasonPhrase() string {
+	var v gobject.Value
+	x.GetProperty("reason-phrase", &v)
+	return v.GetString()
+}
+
+// GetPropertyRequestHeaders gets the "request-headers" property.
+// The HTTP request headers.
+func (x *Message) GetPropertyRequestHeaders() uintptr {
+	var v gobject.Value
+	x.GetProperty("request-headers", &v)
+	return v.GetPointer()
+}
+
+// GetPropertyResponseHeaders gets the "response-headers" property.
+// The HTTP response headers.
+func (x *Message) GetPropertyResponseHeaders() uintptr {
+	var v gobject.Value
+	x.GetProperty("response-headers", &v)
+	return v.GetPointer()
+}
+
+// SetPropertySiteForCookies sets the "site-for-cookies" property.
+// Site used to compare cookies against. Used for SameSite cookie support.
+func (x *Message) SetPropertySiteForCookies(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("site-for-cookies", &v)
+}
+
+// GetPropertySiteForCookies gets the "site-for-cookies" property.
+// Site used to compare cookies against. Used for SameSite cookie support.
+func (x *Message) GetPropertySiteForCookies() uintptr {
+	var v gobject.Value
+	x.GetProperty("site-for-cookies", &v)
+	return v.GetPointer()
+}
+
+// GetPropertyStatusCode gets the "status-code" property.
+// The HTTP response status code.
+func (x *Message) GetPropertyStatusCode() uint {
+	var v gobject.Value
+	x.GetProperty("status-code", &v)
+	return v.GetUint()
+}
+
+// GetPropertyTlsCiphersuiteName gets the "tls-ciphersuite-name" property.
+// The Name of TLS ciphersuite negotiated for this message connection.
+func (x *Message) GetPropertyTlsCiphersuiteName() string {
+	var v gobject.Value
+	x.GetProperty("tls-ciphersuite-name", &v)
+	return v.GetString()
+}
+
+// SetPropertyUri sets the "uri" property.
+// The message's Request-URI.
+func (x *Message) SetPropertyUri(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("uri", &v)
+}
+
+// GetPropertyUri gets the "uri" property.
+// The message's Request-URI.
+func (x *Message) GetPropertyUri() uintptr {
+	var v gobject.Value
+	x.GetProperty("uri", &v)
+	return v.GetPointer()
+}
+
+// Emitted during the @msg's connection TLS handshake
+// after an unacceptable TLS certificate has been received.
+//
+// You can return %TRUE to accept @tls_certificate despite
+// @tls_errors.
+func (x *Message) ConnectAcceptCertificate(cb *func(Message, uintptr, gio.TlsCertificateFlags) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "accept-certificate", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, TlsPeerCertificateVarp uintptr, TlsPeerErrorsVarp gio.TlsCertificateFlags) bool {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, TlsPeerCertificateVarp, TlsPeerErrorsVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "accept-certificate", cbRefPtr)
+}
+
+// Emitted when the message requires authentication.
+//
+// If credentials are available call [method@Auth.authenticate] on
+// @auth. If these credentials fail, the signal will be emitted again,
+// with @retrying set to %TRUE, which will continue until you return
+// without calling [method@Auth.authenticate] on @auth.
+//
+// Note that this may be emitted before @msg's body has been
+// fully read.
+//
+// You can authenticate @auth asynchronously by calling
+// [method@GObject.Object.ref] on @auth and returning %TRUE. The operation will
+// complete once either [method@Auth.authenticate] or
+// [method@Auth.cancel] are called.
+func (x *Message) ConnectAuthenticate(cb *func(Message, uintptr, bool) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "authenticate", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, AuthVarp uintptr, RetryingVarp bool) bool {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, AuthVarp, RetryingVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "authenticate", cbRefPtr)
+}
+
+// This signal is emitted after [signal@Message::got-headers].
+//
+// If content sniffing is disabled, or no content sniffing will be
+// performed, due to the sniffer deciding to trust the
+// Content-Type sent by the server, this signal is emitted
+// immediately after [signal@Message::got-headers], and @type is
+// %NULL.
+func (x *Message) ConnectContentSniffed(cb *func(Message, string, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "content-sniffed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, TypeVarp string, ParamsVarp uintptr) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, TypeVarp, ParamsVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "content-sniffed", cbRefPtr)
+}
+
+// Emitted when all HTTP processing is finished for a message.
+//
+// (After [signal@Message::got_body]).
+func (x *Message) ConnectFinished(cb *func(Message)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+}
+
+// Emitted after receiving the complete message response body.
+func (x *Message) ConnectGotBody(cb *func(Message)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "got-body", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "got-body", cbRefPtr)
+}
+
+// Emitted after reading a portion of the message
+// body from the network.
+func (x *Message) ConnectGotBodyData(cb *func(Message, uint)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "got-body-data", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ChunkSizeVarp uint) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ChunkSizeVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "got-body-data", cbRefPtr)
+}
+
+// Emitted after receiving the Status-Line and response headers.
+//
+// See also [method@Message.add_header_handler] and
+// [method@Message.add_status_code_handler], which can be used to
+// connect to a subset of emissions of this signal.
+//
+// If you cancel or requeue @msg while processing this signal,
+// then the current HTTP I/O will be stopped after this signal
+// emission finished, and @msg's connection will be closed.
+// (If you need to requeue a message--eg, after handling
+// authentication or redirection--it is usually better to
+// requeue it from a [signal@Message::got-body] handler rather
+// than a [signal@Message::got_headers] handler, so that the
+// existing HTTP connection can be reused.)
+func (x *Message) ConnectGotHeaders(cb *func(Message)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "got-headers", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "got-headers", cbRefPtr)
+}
+
+// Emitted after receiving a 1xx (Informational) response for
+// a (client-side) message.
+//
+// The response_headers will be filled in with the headers associated
+// with the informational response; however, those header values will be
+// erased after this signal is done.
+//
+// If you cancel or requeue @msg while processing this signal,
+// then the current HTTP I/O will be stopped after this signal
+// emission finished, and @msg's connection will be closed.
+func (x *Message) ConnectGotInformational(cb *func(Message)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "got-informational", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "got-informational", cbRefPtr)
+}
+
+// Emitted when [class@HSTSEnforcer] has upgraded the protocol
+// for @msg to HTTPS as a result of matching its domain with
+// a HSTS policy.
+func (x *Message) ConnectHstsEnforced(cb *func(Message)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "hsts-enforced", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "hsts-enforced", cbRefPtr)
+}
+
+// Emitted to indicate that some network-related event
+// related to @msg has occurred.
+//
+// This essentially proxies the [signal@Gio.SocketClient::event] signal,
+// but only for events that occur while @msg "owns" the connection; if
+// @msg is sent on an existing persistent connection, then this signal
+// will not be emitted. (If you want to force the message to be sent on
+// a new connection, set the %SOUP_MESSAGE_NEW_CONNECTION flag on it.)
+//
+// See [signal@Gio.SocketClient::event] for more information on what
+// the different values of @event correspond to, and what
+// @connection will be in each case.
+func (x *Message) ConnectNetworkEvent(cb *func(Message, gio.SocketClientEvent, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "network-event", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, EventVarp gio.SocketClientEvent, ConnectionVarp uintptr) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, EventVarp, ConnectionVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "network-event", cbRefPtr)
+}
+
+// Emitted during the @msg's connection TLS handshake when
+// @tls_connection requests a certificate from the client.
+//
+// You can set the client certificate by calling
+// [method@Message.set_tls_client_certificate] and returning %TRUE. It's
+// possible to handle the request asynchornously by returning %TRUE and
+// call [method@Message.set_tls_client_certificate] later once the
+// certificate is available. Note that this signal is not emitted if
+// [property@Session:tls-interaction] was set, or if
+// [method@Message.set_tls_client_certificate] was called before the
+// connection TLS handshake started.
+func (x *Message) ConnectRequestCertificate(cb *func(Message, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "request-certificate", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, TlsConnectionVarp uintptr) bool {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, TlsConnectionVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "request-certificate", cbRefPtr)
+}
+
+// Emitted during the @msg's connection TLS handshake when
+// @tls_connection requests a certificate password from the client.
+//
+// You can set the certificate password on @password, then call
+// [method@Message.tls_client_certificate_password_request_complete] and
+// return %TRUE to handle the signal synchronously. It's possible to
+// handle the request asynchornously by calling
+// [method@GObject.Object.ref] on @password, then returning %TRUE and
+// call
+// [method@Message.tls_client_certificate_password_request_complete]
+// later after setting the password on @password. Note that this signal
+// is not emitted if [property@Session:tls-interaction] was set.
+func (x *Message) ConnectRequestCertificatePassword(cb *func(Message, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "request-certificate-password", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, TlsPasswordVarp uintptr) bool {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, TlsPasswordVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "request-certificate-password", cbRefPtr)
+}
+
+// Emitted when a request that was already sent once is now
+// being sent again.
+//
+// e.g. because the first attempt received a
+// redirection response, or because we needed to use
+// authentication.
+func (x *Message) ConnectRestarted(cb *func(Message)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "restarted", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "restarted", cbRefPtr)
+}
+
+// Emitted just before a message is sent.
+func (x *Message) ConnectStarting(cb *func(Message)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "starting", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "starting", cbRefPtr)
+}
+
+// Emitted immediately after writing the complete body for a
+// message.
+func (x *Message) ConnectWroteBody(cb *func(Message)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "wrote-body", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "wrote-body", cbRefPtr)
+}
+
+// Emitted immediately after writing a portion of the message
+// body to the network.
+func (x *Message) ConnectWroteBodyData(cb *func(Message, uint)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "wrote-body-data", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ChunkSizeVarp uint) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ChunkSizeVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "wrote-body-data", cbRefPtr)
+}
+
+// Emitted immediately after writing the request headers for a
+// message.
+func (x *Message) ConnectWroteHeaders(cb *func(Message)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "wrote-headers", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Message{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "wrote-headers", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xMessageFlagsGLibType, libs, "soup_message_flags_get_type")
+
+	core.PuregoSafeRegister(&xMessagePriorityGLibType, libs, "soup_message_priority_get_type")
+
+	core.PuregoSafeRegister(&xMessageGLibType, libs, "soup_message_get_type")
+
+	core.PuregoSafeRegister(&xNewMessage, libs, "soup_message_new")
+	core.PuregoSafeRegister(&xNewMessageFromEncodedForm, libs, "soup_message_new_from_encoded_form")
+	core.PuregoSafeRegister(&xNewMessageFromMultipart, libs, "soup_message_new_from_multipart")
+	core.PuregoSafeRegister(&xNewMessageFromUri, libs, "soup_message_new_from_uri")
+	core.PuregoSafeRegister(&xNewMessageOptionsPing, libs, "soup_message_new_options_ping")
+
+	core.PuregoSafeRegister(&xMessageAddFlags, libs, "soup_message_add_flags")
+	core.PuregoSafeRegister(&xMessageAddHeaderHandler, libs, "soup_message_add_header_handler")
+	core.PuregoSafeRegister(&xMessageAddStatusCodeHandler, libs, "soup_message_add_status_code_handler")
+	core.PuregoSafeRegister(&xMessageDisableFeature, libs, "soup_message_disable_feature")
+	core.PuregoSafeRegister(&xMessageGetConnectionId, libs, "soup_message_get_connection_id")
+	core.PuregoSafeRegister(&xMessageGetFirstParty, libs, "soup_message_get_first_party")
+	core.PuregoSafeRegister(&xMessageGetFlags, libs, "soup_message_get_flags")
+	core.PuregoSafeRegister(&xMessageGetForceHttp1, libs, "soup_message_get_force_http1")
+	core.PuregoSafeRegister(&xMessageGetHttpVersion, libs, "soup_message_get_http_version")
+	core.PuregoSafeRegister(&xMessageGetIsOptionsPing, libs, "soup_message_get_is_options_ping")
+	core.PuregoSafeRegister(&xMessageGetIsTopLevelNavigation, libs, "soup_message_get_is_top_level_navigation")
+	core.PuregoSafeRegister(&xMessageGetMethod, libs, "soup_message_get_method")
+	core.PuregoSafeRegister(&xMessageGetMetrics, libs, "soup_message_get_metrics")
+	core.PuregoSafeRegister(&xMessageGetPriority, libs, "soup_message_get_priority")
+	core.PuregoSafeRegister(&xMessageGetReasonPhrase, libs, "soup_message_get_reason_phrase")
+	core.PuregoSafeRegister(&xMessageGetRemoteAddress, libs, "soup_message_get_remote_address")
+	core.PuregoSafeRegister(&xMessageGetRequestHeaders, libs, "soup_message_get_request_headers")
+	core.PuregoSafeRegister(&xMessageGetResponseHeaders, libs, "soup_message_get_response_headers")
+	core.PuregoSafeRegister(&xMessageGetSiteForCookies, libs, "soup_message_get_site_for_cookies")
+	core.PuregoSafeRegister(&xMessageGetStatus, libs, "soup_message_get_status")
+	core.PuregoSafeRegister(&xMessageGetTlsCiphersuiteName, libs, "soup_message_get_tls_ciphersuite_name")
+	core.PuregoSafeRegister(&xMessageGetTlsPeerCertificate, libs, "soup_message_get_tls_peer_certificate")
+	core.PuregoSafeRegister(&xMessageGetTlsPeerCertificateErrors, libs, "soup_message_get_tls_peer_certificate_errors")
+	core.PuregoSafeRegister(&xMessageGetTlsProtocolVersion, libs, "soup_message_get_tls_protocol_version")
+	core.PuregoSafeRegister(&xMessageGetUri, libs, "soup_message_get_uri")
+	core.PuregoSafeRegister(&xMessageIsFeatureDisabled, libs, "soup_message_is_feature_disabled")
+	core.PuregoSafeRegister(&xMessageIsKeepalive, libs, "soup_message_is_keepalive")
+	core.PuregoSafeRegister(&xMessageQueryFlags, libs, "soup_message_query_flags")
+	core.PuregoSafeRegister(&xMessageRemoveFlags, libs, "soup_message_remove_flags")
+	core.PuregoSafeRegister(&xMessageSetFirstParty, libs, "soup_message_set_first_party")
+	core.PuregoSafeRegister(&xMessageSetFlags, libs, "soup_message_set_flags")
+	core.PuregoSafeRegister(&xMessageSetForceHttp1, libs, "soup_message_set_force_http1")
+	core.PuregoSafeRegister(&xMessageSetIsOptionsPing, libs, "soup_message_set_is_options_ping")
+	core.PuregoSafeRegister(&xMessageSetIsTopLevelNavigation, libs, "soup_message_set_is_top_level_navigation")
+	core.PuregoSafeRegister(&xMessageSetMethod, libs, "soup_message_set_method")
+	core.PuregoSafeRegister(&xMessageSetPriority, libs, "soup_message_set_priority")
+	core.PuregoSafeRegister(&xMessageSetRequestBody, libs, "soup_message_set_request_body")
+	core.PuregoSafeRegister(&xMessageSetRequestBodyFromBytes, libs, "soup_message_set_request_body_from_bytes")
+	core.PuregoSafeRegister(&xMessageSetSiteForCookies, libs, "soup_message_set_site_for_cookies")
+	core.PuregoSafeRegister(&xMessageSetTlsClientCertificate, libs, "soup_message_set_tls_client_certificate")
+	core.PuregoSafeRegister(&xMessageSetUri, libs, "soup_message_set_uri")
+	core.PuregoSafeRegister(&xMessageTlsClientCertificatePasswordRequestComplete, libs, "soup_message_tls_client_certificate_password_request_complete")
+
+}
diff --git a/v4/soup/soup-multipart-input-stream.go b/v4/soup/soup-multipart-input-stream.go
new file mode 100644
index 0000000000000000000000000000000000000000..c2b790816542c3fba69692827c08656e5c04ed59
--- /dev/null
+++ b/v4/soup/soup-multipart-input-stream.go
@@ -0,0 +1,260 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type MultipartInputStreamClass struct {
+	_ structs.HostLayout
+
+	ParentClass gio.FilterInputStreamClass
+}
+
+func (x *MultipartInputStreamClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Handles streams of multipart messages.
+//
+// This adds support for the multipart responses. For handling the
+// multiple parts the user needs to wrap the [class@Gio.InputStream] obtained by
+// sending the request with a [class@MultipartInputStream] and use
+// [method@MultipartInputStream.next_part] before reading. Responses
+// which are not wrapped will be treated like non-multipart responses.
+//
+// Note that although #SoupMultipartInputStream is a [class@Gio.InputStream],
+// you should not read directly from it, and the results are undefined
+// if you do.
+type MultipartInputStream struct {
+	gio.FilterInputStream
+}
+
+var xMultipartInputStreamGLibType func() types.GType
+
+func MultipartInputStreamGLibType() types.GType {
+	return xMultipartInputStreamGLibType()
+}
+
+func MultipartInputStreamNewFromInternalPtr(ptr uintptr) *MultipartInputStream {
+	cls := &MultipartInputStream{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewMultipartInputStream func(uintptr, uintptr) uintptr
+
+// Creates a new #SoupMultipartInputStream that wraps the
+// [class@Gio.InputStream] obtained by sending the [class@Message].
+//
+// Reads should not be done directly through this object, use the input streams
+// returned by [method@MultipartInputStream.next_part] or its async
+// counterpart instead.
+func NewMultipartInputStream(MsgVar *Message, BaseStreamVar *gio.InputStream) *MultipartInputStream {
+	var cls *MultipartInputStream
+
+	cret := xNewMultipartInputStream(MsgVar.GoPointer(), BaseStreamVar.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &MultipartInputStream{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xMultipartInputStreamGetHeaders func(uintptr) *MessageHeaders
+
+// Obtains the headers for the part currently being processed.
+//
+// Note that the [struct@MessageHeaders] that are returned are owned by the
+// #SoupMultipartInputStream and will be replaced when a call is made to
+// [method@MultipartInputStream.next_part] or its async counterpart, so if
+// keeping the headers is required, a copy must be made.
+//
+// Note that if a part had no headers at all an empty [struct@MessageHeaders]
+// will be returned.
+func (x *MultipartInputStream) GetHeaders() *MessageHeaders {
+
+	cret := xMultipartInputStreamGetHeaders(x.GoPointer())
+	return cret
+}
+
+var xMultipartInputStreamNextPart func(uintptr, uintptr, **glib.Error) uintptr
+
+// Obtains an input stream for the next part.
+//
+// When dealing with a multipart response the input stream needs to be wrapped
+// in a #SoupMultipartInputStream and this function or its async counterpart
+// need to be called to obtain the first part for reading.
+//
+// After calling this function,
+// [method@MultipartInputStream.get_headers] can be used to obtain the
+// headers for the first part. A read of 0 bytes indicates the end of
+// the part; a new call to this function should be done at that point,
+// to obtain the next part.
+//
+// @error will only be set if an error happens during a read, %NULL
+// is a valid return value otherwise.
+func (x *MultipartInputStream) NextPart(CancellableVar *gio.Cancellable) (*gio.InputStream, error) {
+	var cls *gio.InputStream
+	var cerr *glib.Error
+
+	cret := xMultipartInputStreamNextPart(x.GoPointer(), CancellableVar.GoPointer(), &cerr)
+
+	if cret == 0 {
+		return nil, cerr
+	}
+	cls = &gio.InputStream{}
+	cls.Ptr = cret
+	if cerr == nil {
+		return cls, nil
+	}
+	return cls, cerr
+
+}
+
+var xMultipartInputStreamNextPartAsync func(uintptr, int, uintptr, uintptr, uintptr)
+
+// Obtains a [class@Gio.InputStream] for the next request.
+//
+// See [method@MultipartInputStream.next_part] for details on the workflow.
+func (x *MultipartInputStream) NextPartAsync(IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, DataVar uintptr) {
+
+	xMultipartInputStreamNextPartAsync(x.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), DataVar)
+
+}
+
+var xMultipartInputStreamNextPartFinish func(uintptr, uintptr, **glib.Error) uintptr
+
+// Finishes an asynchronous request for the next part.
+func (x *MultipartInputStream) NextPartFinish(ResultVar gio.AsyncResult) (*gio.InputStream, error) {
+	var cls *gio.InputStream
+	var cerr *glib.Error
+
+	cret := xMultipartInputStreamNextPartFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+
+	if cret == 0 {
+		return nil, cerr
+	}
+	cls = &gio.InputStream{}
+	cls.Ptr = cret
+	if cerr == nil {
+		return cls, nil
+	}
+	return cls, cerr
+
+}
+
+func (c *MultipartInputStream) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *MultipartInputStream) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Checks if @stream is actually pollable. Some classes may implement
+// #GPollableInputStream but have only certain instances of that class
+// be pollable. If this method returns %FALSE, then the behavior of
+// other #GPollableInputStream methods is undefined.
+//
+// For any given stream, the value returned by this method is constant;
+// a stream cannot switch from pollable to non-pollable or vice versa.
+func (x *MultipartInputStream) CanPoll() bool {
+
+	cret := gio.XGPollableInputStreamCanPoll(x.GoPointer())
+	return cret
+}
+
+// Creates a #GSource that triggers when @stream can be read, or
+// @cancellable is triggered or an error occurs. The callback on the
+// source is of the #GPollableSourceFunc type.
+//
+// As with g_pollable_input_stream_is_readable(), it is possible that
+// the stream may not actually be readable even after the source
+// triggers, so you should use g_pollable_input_stream_read_nonblocking()
+// rather than g_input_stream_read() from the callback.
+//
+// The behaviour of this method is undefined if
+// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
+func (x *MultipartInputStream) CreateSource(CancellableVar *gio.Cancellable) *glib.Source {
+
+	cret := gio.XGPollableInputStreamCreateSource(x.GoPointer(), CancellableVar.GoPointer())
+	return cret
+}
+
+// Checks if @stream can be read.
+//
+// Note that some stream types may not be able to implement this 100%
+// reliably, and it is possible that a call to g_input_stream_read()
+// after this returns %TRUE would still block. To guarantee
+// non-blocking behavior, you should always use
+// g_pollable_input_stream_read_nonblocking(), which will return a
+// %G_IO_ERROR_WOULD_BLOCK error rather than blocking.
+//
+// The behaviour of this method is undefined if
+// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
+func (x *MultipartInputStream) IsReadable() bool {
+
+	cret := gio.XGPollableInputStreamIsReadable(x.GoPointer())
+	return cret
+}
+
+// Attempts to read up to @count bytes from @stream into @buffer, as
+// with g_input_stream_read(). If @stream is not currently readable,
+// this will immediately return %G_IO_ERROR_WOULD_BLOCK, and you can
+// use g_pollable_input_stream_create_source() to create a #GSource
+// that will be triggered when @stream is readable.
+//
+// Note that since this method never blocks, you cannot actually
+// use @cancellable to cancel it. However, it will return an error
+// if @cancellable has already been cancelled when you call, which
+// may happen if you call this method after a source triggers due
+// to having been cancelled.
+//
+// The behaviour of this method is undefined if
+// g_pollable_input_stream_can_poll() returns %FALSE for @stream.
+func (x *MultipartInputStream) ReadNonblocking(BufferVar *[]byte, CountVar uint, CancellableVar *gio.Cancellable) (int, error) {
+	var cerr *glib.Error
+
+	cret := gio.XGPollableInputStreamReadNonblocking(x.GoPointer(), BufferVar, CountVar, CancellableVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xMultipartInputStreamGLibType, libs, "soup_multipart_input_stream_get_type")
+
+	core.PuregoSafeRegister(&xNewMultipartInputStream, libs, "soup_multipart_input_stream_new")
+
+	core.PuregoSafeRegister(&xMultipartInputStreamGetHeaders, libs, "soup_multipart_input_stream_get_headers")
+	core.PuregoSafeRegister(&xMultipartInputStreamNextPart, libs, "soup_multipart_input_stream_next_part")
+	core.PuregoSafeRegister(&xMultipartInputStreamNextPartAsync, libs, "soup_multipart_input_stream_next_part_async")
+	core.PuregoSafeRegister(&xMultipartInputStreamNextPartFinish, libs, "soup_multipart_input_stream_next_part_finish")
+
+}
diff --git a/v4/soup/soup-multipart.go b/v4/soup/soup-multipart.go
new file mode 100644
index 0000000000000000000000000000000000000000..0691b1adc31a55dd71fc99455dba02f7457b70bb
--- /dev/null
+++ b/v4/soup/soup-multipart.go
@@ -0,0 +1,159 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Represents a multipart HTTP message body, parsed according to the
+// syntax of RFC 2046.
+//
+// Of particular interest to HTTP are `multipart/byte-ranges` and
+// `multipart/form-data`,
+//
+// Although the headers of a #SoupMultipart body part will contain the
+// full headers from that body part, libsoup does not interpret them
+// according to MIME rules. For example, each body part is assumed to
+// have "binary" Content-Transfer-Encoding, even if its headers
+// explicitly state otherwise. In other words, don't try to use
+// #SoupMultipart for handling real MIME multiparts.
+type Multipart struct {
+	_ structs.HostLayout
+}
+
+var xMultipartGLibType func() types.GType
+
+func MultipartGLibType() types.GType {
+	return xMultipartGLibType()
+}
+
+func (x *Multipart) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewMultipart func(string) *Multipart
+
+// Creates a new empty #SoupMultipart with a randomly-generated
+// boundary string.
+//
+// Note that @mime_type must be the full MIME type, including "multipart/".
+//
+// See also: [ctor@Message.new_from_multipart].
+func NewMultipart(MimeTypeVar string) *Multipart {
+
+	cret := xNewMultipart(MimeTypeVar)
+	return cret
+}
+
+var xNewMultipartFromMessage func(*MessageHeaders, *glib.Bytes) *Multipart
+
+// Parses @headers and @body to form a new #SoupMultipart
+func NewMultipartFromMessage(HeadersVar *MessageHeaders, BodyVar *glib.Bytes) *Multipart {
+
+	cret := xNewMultipartFromMessage(HeadersVar, BodyVar)
+	return cret
+}
+
+var xMultipartAppendFormFile func(uintptr, string, string, string, *glib.Bytes)
+
+// Adds a new MIME part containing @body to @multipart
+//
+// Uses "Content-Disposition: form-data", as per the HTML forms specification.
+func (x *Multipart) AppendFormFile(ControlNameVar string, FilenameVar string, ContentTypeVar string, BodyVar *glib.Bytes) {
+
+	xMultipartAppendFormFile(x.GoPointer(), ControlNameVar, FilenameVar, ContentTypeVar, BodyVar)
+
+}
+
+var xMultipartAppendFormString func(uintptr, string, string)
+
+// Adds a new MIME part containing @data to @multipart.
+//
+// Uses "Content-Disposition: form-data", as per the HTML forms specification.
+func (x *Multipart) AppendFormString(ControlNameVar string, DataVar string) {
+
+	xMultipartAppendFormString(x.GoPointer(), ControlNameVar, DataVar)
+
+}
+
+var xMultipartAppendPart func(uintptr, *MessageHeaders, *glib.Bytes)
+
+// Adds a new MIME part to @multipart with the given headers and body.
+//
+// (The multipart will make its own copies of @headers and @body, so
+// you should free your copies if you are not using them for anything
+// else.)
+func (x *Multipart) AppendPart(HeadersVar *MessageHeaders, BodyVar *glib.Bytes) {
+
+	xMultipartAppendPart(x.GoPointer(), HeadersVar, BodyVar)
+
+}
+
+var xMultipartFree func(uintptr)
+
+// Frees @multipart.
+func (x *Multipart) Free() {
+
+	xMultipartFree(x.GoPointer())
+
+}
+
+var xMultipartGetLength func(uintptr) int
+
+// Gets the number of body parts in @multipart.
+func (x *Multipart) GetLength() int {
+
+	cret := xMultipartGetLength(x.GoPointer())
+	return cret
+}
+
+var xMultipartGetPart func(uintptr, int, **MessageHeaders, **glib.Bytes) bool
+
+// Gets the indicated body part from @multipart.
+func (x *Multipart) GetPart(PartVar int, HeadersVar **MessageHeaders, BodyVar **glib.Bytes) bool {
+
+	cret := xMultipartGetPart(x.GoPointer(), PartVar, HeadersVar, BodyVar)
+	return cret
+}
+
+var xMultipartToMessage func(uintptr, *MessageHeaders, **glib.Bytes)
+
+// Serializes @multipart to @dest_headers and @dest_body.
+func (x *Multipart) ToMessage(DestHeadersVar *MessageHeaders, DestBodyVar **glib.Bytes) {
+
+	xMultipartToMessage(x.GoPointer(), DestHeadersVar, DestBodyVar)
+
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xMultipartGLibType, libs, "soup_multipart_get_type")
+
+	core.PuregoSafeRegister(&xNewMultipart, libs, "soup_multipart_new")
+	core.PuregoSafeRegister(&xNewMultipartFromMessage, libs, "soup_multipart_new_from_message")
+
+	core.PuregoSafeRegister(&xMultipartAppendFormFile, libs, "soup_multipart_append_form_file")
+	core.PuregoSafeRegister(&xMultipartAppendFormString, libs, "soup_multipart_append_form_string")
+	core.PuregoSafeRegister(&xMultipartAppendPart, libs, "soup_multipart_append_part")
+	core.PuregoSafeRegister(&xMultipartFree, libs, "soup_multipart_free")
+	core.PuregoSafeRegister(&xMultipartGetLength, libs, "soup_multipart_get_length")
+	core.PuregoSafeRegister(&xMultipartGetPart, libs, "soup_multipart_get_part")
+	core.PuregoSafeRegister(&xMultipartToMessage, libs, "soup_multipart_to_message")
+
+}
diff --git a/v4/soup/soup-server-message.go b/v4/soup/soup-server-message.go
new file mode 100644
index 0000000000000000000000000000000000000000..8519d2b67cddac27679d81547e6fb796fee50c98
--- /dev/null
+++ b/v4/soup/soup-server-message.go
@@ -0,0 +1,648 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type ServerMessageClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *ServerMessageClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// An HTTP server request and response pair.
+//
+// A SoupServerMessage represents an HTTP message that is being sent or
+// received on a [class@Server].
+//
+// [class@Server] will create `SoupServerMessage`s automatically for
+// incoming requests, which your application will receive via handlers.
+//
+// Note that libsoup's terminology here does not quite match the HTTP
+// specification: in RFC 2616, an "HTTP-message" is *either* a Request, *or* a
+// Response. In libsoup, a #SoupServerMessage combines both the request and the
+// response.
+type ServerMessage struct {
+	gobject.Object
+}
+
+var xServerMessageGLibType func() types.GType
+
+func ServerMessageGLibType() types.GType {
+	return xServerMessageGLibType()
+}
+
+func ServerMessageNewFromInternalPtr(ptr uintptr) *ServerMessage {
+	cls := &ServerMessage{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xServerMessageGetHttpVersion func(uintptr) HTTPVersion
+
+// Get the HTTP version of @msg.
+func (x *ServerMessage) GetHttpVersion() HTTPVersion {
+
+	cret := xServerMessageGetHttpVersion(x.GoPointer())
+	return cret
+}
+
+var xServerMessageGetLocalAddress func(uintptr) uintptr
+
+// Retrieves the [class@Gio.SocketAddress] associated with the local end
+// of a connection.
+func (x *ServerMessage) GetLocalAddress() *gio.SocketAddress {
+	var cls *gio.SocketAddress
+
+	cret := xServerMessageGetLocalAddress(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.SocketAddress{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xServerMessageGetMethod func(uintptr) string
+
+// Get the HTTP method of @msg.
+func (x *ServerMessage) GetMethod() string {
+
+	cret := xServerMessageGetMethod(x.GoPointer())
+	return cret
+}
+
+var xServerMessageGetReasonPhrase func(uintptr) string
+
+// Get the HTTP reason phrase of @msg.
+func (x *ServerMessage) GetReasonPhrase() string {
+
+	cret := xServerMessageGetReasonPhrase(x.GoPointer())
+	return cret
+}
+
+var xServerMessageGetRemoteAddress func(uintptr) uintptr
+
+// Retrieves the [class@Gio.SocketAddress] associated with the remote end
+// of a connection.
+func (x *ServerMessage) GetRemoteAddress() *gio.SocketAddress {
+	var cls *gio.SocketAddress
+
+	cret := xServerMessageGetRemoteAddress(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.SocketAddress{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xServerMessageGetRemoteHost func(uintptr) string
+
+// Retrieves the IP address associated with the remote end of a
+// connection.
+func (x *ServerMessage) GetRemoteHost() string {
+
+	cret := xServerMessageGetRemoteHost(x.GoPointer())
+	return cret
+}
+
+var xServerMessageGetRequestBody func(uintptr) *MessageBody
+
+// Get the request body of @msg.
+func (x *ServerMessage) GetRequestBody() *MessageBody {
+
+	cret := xServerMessageGetRequestBody(x.GoPointer())
+	return cret
+}
+
+var xServerMessageGetRequestHeaders func(uintptr) *MessageHeaders
+
+// Get the request headers of @msg.
+func (x *ServerMessage) GetRequestHeaders() *MessageHeaders {
+
+	cret := xServerMessageGetRequestHeaders(x.GoPointer())
+	return cret
+}
+
+var xServerMessageGetResponseBody func(uintptr) *MessageBody
+
+// Get the response body of @msg.
+func (x *ServerMessage) GetResponseBody() *MessageBody {
+
+	cret := xServerMessageGetResponseBody(x.GoPointer())
+	return cret
+}
+
+var xServerMessageGetResponseHeaders func(uintptr) *MessageHeaders
+
+// Get the response headers of @msg.
+func (x *ServerMessage) GetResponseHeaders() *MessageHeaders {
+
+	cret := xServerMessageGetResponseHeaders(x.GoPointer())
+	return cret
+}
+
+var xServerMessageGetSocket func(uintptr) uintptr
+
+// Retrieves the [class@Gio.Socket] that @msg is associated with.
+//
+// If you are using this method to observe when multiple requests are
+// made on the same persistent HTTP connection (eg, as the ntlm-test
+// test program does), you will need to pay attention to socket
+// destruction as well (eg, by using weak references), so that you do
+// not get fooled when the allocator reuses the memory address of a
+// previously-destroyed socket to represent a new socket.
+func (x *ServerMessage) GetSocket() *gio.Socket {
+	var cls *gio.Socket
+
+	cret := xServerMessageGetSocket(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.Socket{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xServerMessageGetStatus func(uintptr) uint
+
+// Get the HTTP status code of @msg.
+func (x *ServerMessage) GetStatus() uint {
+
+	cret := xServerMessageGetStatus(x.GoPointer())
+	return cret
+}
+
+var xServerMessageGetTlsPeerCertificate func(uintptr) uintptr
+
+// Gets the peer's #GTlsCertificate associated with @msg's connection.
+// Note that this is not set yet during the emission of
+// SoupServerMessage::accept-certificate signal.
+func (x *ServerMessage) GetTlsPeerCertificate() *gio.TlsCertificate {
+	var cls *gio.TlsCertificate
+
+	cret := xServerMessageGetTlsPeerCertificate(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.TlsCertificate{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xServerMessageGetTlsPeerCertificateErrors func(uintptr) gio.TlsCertificateFlags
+
+// Gets the errors associated with validating @msg's TLS peer certificate.
+// Note that this is not set yet during the emission of
+// SoupServerMessage::accept-certificate signal.
+func (x *ServerMessage) GetTlsPeerCertificateErrors() gio.TlsCertificateFlags {
+
+	cret := xServerMessageGetTlsPeerCertificateErrors(x.GoPointer())
+	return cret
+}
+
+var xServerMessageGetUri func(uintptr) *glib.Uri
+
+// Get @msg's URI.
+func (x *ServerMessage) GetUri() *glib.Uri {
+
+	cret := xServerMessageGetUri(x.GoPointer())
+	return cret
+}
+
+var xServerMessageIsOptionsPing func(uintptr) bool
+
+// Gets if @msg represents an OPTIONS message with the path `*`.
+func (x *ServerMessage) IsOptionsPing() bool {
+
+	cret := xServerMessageIsOptionsPing(x.GoPointer())
+	return cret
+}
+
+var xServerMessagePause func(uintptr)
+
+// Pauses I/O on @msg.
+//
+// This can be used when you need to return from the server handler without
+// having the full response ready yet. Use [method@ServerMessage.unpause] to
+// resume I/O.
+func (x *ServerMessage) Pause() {
+
+	xServerMessagePause(x.GoPointer())
+
+}
+
+var xServerMessageSetHttpVersion func(uintptr, HTTPVersion)
+
+// Set the HTTP version of @msg.
+func (x *ServerMessage) SetHttpVersion(VersionVar HTTPVersion) {
+
+	xServerMessageSetHttpVersion(x.GoPointer(), VersionVar)
+
+}
+
+var xServerMessageSetRedirect func(uintptr, uint, string)
+
+// Sets @msg's status_code to @status_code and adds a Location header
+// pointing to @redirect_uri. Use this from a [class@Server] when you
+// want to redirect the client to another URI.
+//
+// @redirect_uri can be a relative URI, in which case it is
+// interpreted relative to @msg's current URI. In particular, if
+// @redirect_uri is just a path, it will replace the path
+// *and query* of @msg's URI.
+func (x *ServerMessage) SetRedirect(StatusCodeVar uint, RedirectUriVar string) {
+
+	xServerMessageSetRedirect(x.GoPointer(), StatusCodeVar, RedirectUriVar)
+
+}
+
+var xServerMessageSetResponse func(uintptr, string, MemoryUse, string, uint)
+
+// Convenience function to set the response body of a #SoupServerMessage. If
+// @content_type is %NULL, the response body must be empty as well.
+func (x *ServerMessage) SetResponse(ContentTypeVar string, RespUseVar MemoryUse, RespBodyVar string, RespLengthVar uint) {
+
+	xServerMessageSetResponse(x.GoPointer(), ContentTypeVar, RespUseVar, RespBodyVar, RespLengthVar)
+
+}
+
+var xServerMessageSetStatus func(uintptr, uint, string)
+
+// Sets @msg's status code to @status_code.
+//
+// If @status_code is a known value and @reason_phrase is %NULL, the
+// reason_phrase will be set automatically.
+func (x *ServerMessage) SetStatus(StatusCodeVar uint, ReasonPhraseVar string) {
+
+	xServerMessageSetStatus(x.GoPointer(), StatusCodeVar, ReasonPhraseVar)
+
+}
+
+var xServerMessageStealConnection func(uintptr) uintptr
+
+// "Steals" the HTTP connection associated with @msg from its #SoupServer. This
+// happens immediately, regardless of the current state of the connection; if
+// the response to @msg has not yet finished being sent, then it will be
+// discarded; you can steal the connection from a
+// [signal@ServerMessage::wrote-informational] or
+// [signal@ServerMessage::wrote-body] signal handler if you need to wait for
+// part or all of the response to be sent.
+//
+// Note that when calling this function from C, @msg will most
+// likely be freed as a side effect.
+func (x *ServerMessage) StealConnection() *gio.IOStream {
+	var cls *gio.IOStream
+
+	cret := xServerMessageStealConnection(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &gio.IOStream{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xServerMessageUnpause func(uintptr)
+
+// Resumes I/O on @msg.
+//
+// Use this to resume after calling [method@ServerMessage.pause], or after
+// adding a new chunk to a chunked response. I/O won't actually resume until you
+// return to the main loop.
+func (x *ServerMessage) Unpause() {
+
+	xServerMessageUnpause(x.GoPointer())
+
+}
+
+func (c *ServerMessage) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *ServerMessage) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Emitted during the @msg's connection TLS handshake
+// after client TLS certificate has been received.
+// You can return %TRUE to accept @tls_certificate despite
+// @tls_errors.
+func (x *ServerMessage) ConnectAcceptCertificate(cb *func(ServerMessage, uintptr, gio.TlsCertificateFlags) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "accept-certificate", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, TlsPeerCertificateVarp uintptr, TlsPeerErrorsVarp gio.TlsCertificateFlags) bool {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, TlsPeerCertificateVarp, TlsPeerErrorsVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "accept-certificate", cbRefPtr)
+}
+
+// Emitted when the @msg's socket is connected and the TLS handshake completed.
+func (x *ServerMessage) ConnectConnected(cb *func(ServerMessage)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "connected", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "connected", cbRefPtr)
+}
+
+// Emitted when the @msg's socket is disconnected.
+func (x *ServerMessage) ConnectDisconnected(cb *func(ServerMessage)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "disconnected", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "disconnected", cbRefPtr)
+}
+
+// Emitted when all HTTP processing is finished for a message.
+// (After [signal@ServerMessage::wrote-body]).
+func (x *ServerMessage) ConnectFinished(cb *func(ServerMessage)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+}
+
+// Emitted after receiving the complete request body.
+func (x *ServerMessage) ConnectGotBody(cb *func(ServerMessage)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "got-body", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "got-body", cbRefPtr)
+}
+
+// Emitted after receiving a chunk of a message body.
+//
+// Note that "chunk" in this context means any subpiece of the body, not
+// necessarily the specific HTTP 1.1 chunks sent by the other side.
+func (x *ServerMessage) ConnectGotChunk(cb *func(ServerMessage, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "got-chunk", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ChunkVarp uintptr) {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ChunkVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "got-chunk", cbRefPtr)
+}
+
+// Emitted after receiving the Request-Line and request headers.
+func (x *ServerMessage) ConnectGotHeaders(cb *func(ServerMessage)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "got-headers", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "got-headers", cbRefPtr)
+}
+
+// Emitted immediately after writing the complete response body for a
+// message.
+func (x *ServerMessage) ConnectWroteBody(cb *func(ServerMessage)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "wrote-body", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "wrote-body", cbRefPtr)
+}
+
+// Emitted immediately after writing a portion of the message
+// body to the network.
+func (x *ServerMessage) ConnectWroteBodyData(cb *func(ServerMessage, uint)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "wrote-body-data", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ChunkSizeVarp uint) {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ChunkSizeVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "wrote-body-data", cbRefPtr)
+}
+
+// Emitted immediately after writing a body chunk for a message.
+//
+// Note that this signal is not parallel to
+// [signal@ServerMessage::got-chunk]; it is emitted only when a complete
+// chunk (added with [method@MessageBody.append] or
+// [method@MessageBody.append_bytes] has been written. To get
+// more useful continuous progress information, use
+// [signal@ServerMessage::wrote-body-data].
+func (x *ServerMessage) ConnectWroteChunk(cb *func(ServerMessage)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "wrote-chunk", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "wrote-chunk", cbRefPtr)
+}
+
+// Emitted immediately after writing the response headers for a
+// message.
+func (x *ServerMessage) ConnectWroteHeaders(cb *func(ServerMessage)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "wrote-headers", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "wrote-headers", cbRefPtr)
+}
+
+// Emitted immediately after writing a 1xx (Informational) response.
+func (x *ServerMessage) ConnectWroteInformational(cb *func(ServerMessage)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "wrote-informational", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := ServerMessage{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "wrote-informational", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xServerMessageGLibType, libs, "soup_server_message_get_type")
+
+	core.PuregoSafeRegister(&xServerMessageGetHttpVersion, libs, "soup_server_message_get_http_version")
+	core.PuregoSafeRegister(&xServerMessageGetLocalAddress, libs, "soup_server_message_get_local_address")
+	core.PuregoSafeRegister(&xServerMessageGetMethod, libs, "soup_server_message_get_method")
+	core.PuregoSafeRegister(&xServerMessageGetReasonPhrase, libs, "soup_server_message_get_reason_phrase")
+	core.PuregoSafeRegister(&xServerMessageGetRemoteAddress, libs, "soup_server_message_get_remote_address")
+	core.PuregoSafeRegister(&xServerMessageGetRemoteHost, libs, "soup_server_message_get_remote_host")
+	core.PuregoSafeRegister(&xServerMessageGetRequestBody, libs, "soup_server_message_get_request_body")
+	core.PuregoSafeRegister(&xServerMessageGetRequestHeaders, libs, "soup_server_message_get_request_headers")
+	core.PuregoSafeRegister(&xServerMessageGetResponseBody, libs, "soup_server_message_get_response_body")
+	core.PuregoSafeRegister(&xServerMessageGetResponseHeaders, libs, "soup_server_message_get_response_headers")
+	core.PuregoSafeRegister(&xServerMessageGetSocket, libs, "soup_server_message_get_socket")
+	core.PuregoSafeRegister(&xServerMessageGetStatus, libs, "soup_server_message_get_status")
+	core.PuregoSafeRegister(&xServerMessageGetTlsPeerCertificate, libs, "soup_server_message_get_tls_peer_certificate")
+	core.PuregoSafeRegister(&xServerMessageGetTlsPeerCertificateErrors, libs, "soup_server_message_get_tls_peer_certificate_errors")
+	core.PuregoSafeRegister(&xServerMessageGetUri, libs, "soup_server_message_get_uri")
+	core.PuregoSafeRegister(&xServerMessageIsOptionsPing, libs, "soup_server_message_is_options_ping")
+	core.PuregoSafeRegister(&xServerMessagePause, libs, "soup_server_message_pause")
+	core.PuregoSafeRegister(&xServerMessageSetHttpVersion, libs, "soup_server_message_set_http_version")
+	core.PuregoSafeRegister(&xServerMessageSetRedirect, libs, "soup_server_message_set_redirect")
+	core.PuregoSafeRegister(&xServerMessageSetResponse, libs, "soup_server_message_set_response")
+	core.PuregoSafeRegister(&xServerMessageSetStatus, libs, "soup_server_message_set_status")
+	core.PuregoSafeRegister(&xServerMessageStealConnection, libs, "soup_server_message_steal_connection")
+	core.PuregoSafeRegister(&xServerMessageUnpause, libs, "soup_server_message_unpause")
+
+}
diff --git a/v4/soup/soup-server.go b/v4/soup/soup-server.go
new file mode 100644
index 0000000000000000000000000000000000000000..0db41e789ef6c5f50d67d0235e7b13d25d537f17
--- /dev/null
+++ b/v4/soup/soup-server.go
@@ -0,0 +1,996 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// A callback used to handle requests to a [class@Server].
+//
+// @path and @query contain the likewise-named components of the
+// Request-URI, subject to certain assumptions. By default,
+// [class@Server] decodes all percent-encoding in the URI path, such that
+// `"/foo%2Fbar"` is treated the same as `"/foo/bar"`. If your
+// server is serving resources in some non-POSIX-filesystem namespace,
+// you may want to distinguish those as two distinct paths. In that
+// case, you can set the [property@Server:raw-paths] property when creating
+// the [class@Server], and it will leave those characters undecoded.
+//
+// @query contains the query component of the Request-URI parsed according to
+// the rules for HTML form handling. Although this is the only commonly-used
+// query string format in HTTP, there is nothing that actually requires that
+// HTTP URIs use that format; if your server needs to use some other format, you
+// can just ignore @query, and call [method@Message.get_uri] and parse the URI's
+// query field yourself.
+//
+// See [method@Server.add_handler] and [method@Server.add_early_handler]
+// for details of what handlers can/should do.
+type ServerCallback func(uintptr, uintptr, string, *glib.HashTable, uintptr)
+
+// A callback used to handle WebSocket requests to a #SoupServer.
+//
+// The callback will be invoked after sending the handshake response back to the
+// client (and is only invoked if the handshake was successful).
+//
+// @path contains the path of the Request-URI, subject to the same
+// rules as [callback@ServerCallback] `(qv)`.
+type ServerWebsocketCallback func(uintptr, uintptr, string, uintptr, uintptr)
+
+type ServerClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+
+	xRequestStarted uintptr
+
+	xRequestRead uintptr
+
+	xRequestFinished uintptr
+
+	xRequestAborted uintptr
+
+	Padding [6]uintptr
+}
+
+func (x *ServerClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideRequestStarted sets the "request_started" callback function.
+func (x *ServerClass) OverrideRequestStarted(cb func(*Server, *ServerMessage)) {
+	if cb == nil {
+		x.xRequestStarted = 0
+	} else {
+		x.xRequestStarted = purego.NewCallback(func(ServerVarp uintptr, MsgVarp uintptr) {
+			cb(ServerNewFromInternalPtr(ServerVarp), ServerMessageNewFromInternalPtr(MsgVarp))
+		})
+	}
+}
+
+// GetRequestStarted gets the "request_started" callback function.
+func (x *ServerClass) GetRequestStarted() func(*Server, *ServerMessage) {
+	if x.xRequestStarted == 0 {
+		return nil
+	}
+	var rawCallback func(ServerVarp uintptr, MsgVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xRequestStarted)
+	return func(ServerVar *Server, MsgVar *ServerMessage) {
+		rawCallback(ServerVar.GoPointer(), MsgVar.GoPointer())
+	}
+}
+
+// OverrideRequestRead sets the "request_read" callback function.
+func (x *ServerClass) OverrideRequestRead(cb func(*Server, *ServerMessage)) {
+	if cb == nil {
+		x.xRequestRead = 0
+	} else {
+		x.xRequestRead = purego.NewCallback(func(ServerVarp uintptr, MsgVarp uintptr) {
+			cb(ServerNewFromInternalPtr(ServerVarp), ServerMessageNewFromInternalPtr(MsgVarp))
+		})
+	}
+}
+
+// GetRequestRead gets the "request_read" callback function.
+func (x *ServerClass) GetRequestRead() func(*Server, *ServerMessage) {
+	if x.xRequestRead == 0 {
+		return nil
+	}
+	var rawCallback func(ServerVarp uintptr, MsgVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xRequestRead)
+	return func(ServerVar *Server, MsgVar *ServerMessage) {
+		rawCallback(ServerVar.GoPointer(), MsgVar.GoPointer())
+	}
+}
+
+// OverrideRequestFinished sets the "request_finished" callback function.
+func (x *ServerClass) OverrideRequestFinished(cb func(*Server, *ServerMessage)) {
+	if cb == nil {
+		x.xRequestFinished = 0
+	} else {
+		x.xRequestFinished = purego.NewCallback(func(ServerVarp uintptr, MsgVarp uintptr) {
+			cb(ServerNewFromInternalPtr(ServerVarp), ServerMessageNewFromInternalPtr(MsgVarp))
+		})
+	}
+}
+
+// GetRequestFinished gets the "request_finished" callback function.
+func (x *ServerClass) GetRequestFinished() func(*Server, *ServerMessage) {
+	if x.xRequestFinished == 0 {
+		return nil
+	}
+	var rawCallback func(ServerVarp uintptr, MsgVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xRequestFinished)
+	return func(ServerVar *Server, MsgVar *ServerMessage) {
+		rawCallback(ServerVar.GoPointer(), MsgVar.GoPointer())
+	}
+}
+
+// OverrideRequestAborted sets the "request_aborted" callback function.
+func (x *ServerClass) OverrideRequestAborted(cb func(*Server, *ServerMessage)) {
+	if cb == nil {
+		x.xRequestAborted = 0
+	} else {
+		x.xRequestAborted = purego.NewCallback(func(ServerVarp uintptr, MsgVarp uintptr) {
+			cb(ServerNewFromInternalPtr(ServerVarp), ServerMessageNewFromInternalPtr(MsgVarp))
+		})
+	}
+}
+
+// GetRequestAborted gets the "request_aborted" callback function.
+func (x *ServerClass) GetRequestAborted() func(*Server, *ServerMessage) {
+	if x.xRequestAborted == 0 {
+		return nil
+	}
+	var rawCallback func(ServerVarp uintptr, MsgVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xRequestAborted)
+	return func(ServerVar *Server, MsgVar *ServerMessage) {
+		rawCallback(ServerVar.GoPointer(), MsgVar.GoPointer())
+	}
+}
+
+// Options to pass to [method@Server.listen], etc.
+//
+// %SOUP_SERVER_LISTEN_IPV4_ONLY and %SOUP_SERVER_LISTEN_IPV6_ONLY
+// only make sense with [method@Server.listen_all] and
+// [method@Server.listen_local], not plain [method@Server.listen] (which
+// simply listens on whatever kind of socket you give it). And you
+// cannot specify both of them in a single call.
+type ServerListenOptions int
+
+var xServerListenOptionsGLibType func() types.GType
+
+func ServerListenOptionsGLibType() types.GType {
+	return xServerListenOptionsGLibType()
+}
+
+const (
+
+	// Listen for https connections rather
+	//   than plain http.
+	ServerListenHttpsValue ServerListenOptions = 1
+	// Only listen on IPv4 interfaces.
+	ServerListenIpv4OnlyValue ServerListenOptions = 2
+	// Only listen on IPv6 interfaces.
+	ServerListenIpv6OnlyValue ServerListenOptions = 4
+)
+
+// #SoupServer provides a basic implementation of an HTTP server. The
+// recommended usage of this server is for internal use, tasks like
+// a mock server for tests, a private service for IPC, etc. It is not
+// recommended to be exposed to untrusted clients as it may be vulnerable
+// to denial of service attacks or other exploits.
+//
+// To begin, create a server using [ctor@Server.new]. Add at least one
+// handler by calling [method@Server.add_handler] or
+// [method@Server.add_early_handler]; the handler will be called to
+// process any requests underneath the path you pass. (If you want all
+// requests to go to the same handler, just pass "/" (or %NULL) for
+// the path.)
+//
+// When a new connection is accepted (or a new request is started on
+// an existing persistent connection), the #SoupServer will emit
+// [signal@Server::request-started] and then begin processing the request
+// as described below, but note that once the message is assigned a
+// status-code, then callbacks after that point will be
+// skipped. Note also that it is not defined when the callbacks happen
+// relative to various [class@ServerMessage] signals.
+//
+// Once the headers have been read, #SoupServer will check if there is
+// a [class@AuthDomain] `(qv)` covering the Request-URI; if so, and if the
+// message does not contain suitable authorization, then the
+// [class@AuthDomain] will set a status of %SOUP_STATUS_UNAUTHORIZED on
+// the message.
+//
+// After checking for authorization, #SoupServer will look for "early"
+// handlers (added with [method@Server.add_early_handler]) matching the
+// Request-URI. If one is found, it will be run; in particular, this
+// can be used to connect to signals to do a streaming read of the
+// request body.
+//
+// (At this point, if the request headers contain `Expect:
+// 100-continue`, and a status code has been set, then
+// #SoupServer will skip the remaining steps and return the response.
+// If the request headers contain `Expect:
+// 100-continue` and no status code has been set,
+// #SoupServer will return a %SOUP_STATUS_CONTINUE status before
+// continuing.)
+//
+// The server will then read in the response body (if present). At
+// this point, if there are no handlers at all defined for the
+// Request-URI, then the server will return %SOUP_STATUS_NOT_FOUND to
+// the client.
+//
+// Otherwise (assuming no previous step assigned a status to the
+// message) any "normal" handlers (added with
+// [method@Server.add_handler]) for the message's Request-URI will be
+// run.
+//
+// Then, if the path has a WebSocket handler registered (and has
+// not yet been assigned a status), #SoupServer will attempt to
+// validate the WebSocket handshake, filling in the response and
+// setting a status of %SOUP_STATUS_SWITCHING_PROTOCOLS or
+// %SOUP_STATUS_BAD_REQUEST accordingly.
+//
+// If the message still has no status code at this point (and has not
+// been paused with [method@ServerMessage.pause]), then it will be
+// given a status of %SOUP_STATUS_INTERNAL_SERVER_ERROR (because at
+// least one handler ran, but returned without assigning a status).
+//
+// Finally, the server will emit [signal@Server::request-finished] (or
+// [signal@Server::request-aborted] if an I/O error occurred before
+// handling was completed).
+//
+// If you want to handle the special "*" URI (eg, "OPTIONS *"), you
+// must explicitly register a handler for "*"; the default handler
+// will not be used for that case.
+//
+// If you want to process https connections in addition to (or instead
+// of) http connections, you can set the [property@Server:tls-certificate]
+// property.
+//
+// Once the server is set up, make one or more calls to
+// [method@Server.listen], [method@Server.listen_local], or
+// [method@Server.listen_all] to tell it where to listen for
+// connections. (All ports on a #SoupServer use the same handlers; if
+// you need to handle some ports differently, such as returning
+// different data for http and https, you'll need to create multiple
+// `SoupServer`s, or else check the passed-in URI in the handler
+// function.).
+//
+// #SoupServer will begin processing connections as soon as you return
+// to (or start) the main loop for the current thread-default
+// [struct@GLib.MainContext].
+type Server struct {
+	gobject.Object
+}
+
+var xServerGLibType func() types.GType
+
+func ServerGLibType() types.GType {
+	return xServerGLibType()
+}
+
+func ServerNewFromInternalPtr(ptr uintptr) *Server {
+	cls := &Server{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewServer func(string, ...interface{}) uintptr
+
+// Creates a new #SoupServer.
+//
+// This is exactly equivalent to calling [ctor@GObject.Object.new] and
+// specifying %SOUP_TYPE_SERVER as the type.
+func NewServer(Optname1Var string, varArgs ...interface{}) *Server {
+	var cls *Server
+
+	cret := xNewServer(Optname1Var, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Server{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xServerAcceptIostream func(uintptr, uintptr, uintptr, uintptr, **glib.Error) bool
+
+// Adds a new client stream to the @server.
+func (x *Server) AcceptIostream(StreamVar *gio.IOStream, LocalAddrVar *gio.SocketAddress, RemoteAddrVar *gio.SocketAddress) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xServerAcceptIostream(x.GoPointer(), StreamVar.GoPointer(), LocalAddrVar.GoPointer(), RemoteAddrVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xServerAddAuthDomain func(uintptr, uintptr)
+
+// Adds an authentication domain to @server.
+//
+// Each auth domain will have the chance to require authentication for each
+// request that comes in; normally auth domains will require authentication for
+// requests on certain paths that they have been set up to watch, or that meet
+// other criteria set by the caller. If an auth domain determines that a request
+// requires authentication (and the request doesn't contain authentication),
+// @server will automatically reject the request with an appropriate status (401
+// Unauthorized or 407 Proxy Authentication Required). If the request used the
+// SoupServer:100-continue Expectation, @server will reject it before the
+// request body is sent.
+func (x *Server) AddAuthDomain(AuthDomainVar *AuthDomain) {
+
+	xServerAddAuthDomain(x.GoPointer(), AuthDomainVar.GoPointer())
+
+}
+
+var xServerAddEarlyHandler func(uintptr, string, uintptr, uintptr, uintptr)
+
+// Adds an "early" handler to @server for requests prefixed by @path.
+//
+// Note that "normal" and "early" handlers are matched up together, so if you
+// add a normal handler for "/foo" and an early handler for "/foo/bar", then a
+// request to "/foo/bar" (or any path below it) will run only the early handler.
+// (But if you add both handlers at the same path, then both will get run.)
+//
+// For requests under @path (that have not already been assigned a
+// status code by a [class@AuthDomain] or a signal handler), @callback
+// will be invoked after receiving the request headers, but before
+// receiving the request body; the message's method and
+// request-headers properties will be set.
+//
+// Early handlers are generally used for processing requests with request bodies
+// in a streaming fashion. If you determine that the request will contain a
+// message body, normally you would call [method@MessageBody.set_accumulate] on
+// the message's request-body to turn off request-body accumulation, and connect
+// to the message's [signal@ServerMessage::got-chunk] signal to process each
+// chunk as it comes in.
+//
+// To complete the message processing after the full message body has
+// been read, you can either also connect to [signal@ServerMessage::got-body],
+// or else you can register a non-early handler for @path as well. As
+// long as you have not set the status-code by the time
+// [signal@ServerMessage::got-body] is emitted, the non-early handler will be
+// run as well.
+func (x *Server) AddEarlyHandler(PathVar string, CallbackVar *ServerCallback, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {
+
+	xServerAddEarlyHandler(x.GoPointer(), PathVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallback(DestroyVar))
+
+}
+
+var xServerAddHandler func(uintptr, string, uintptr, uintptr, uintptr)
+
+// Adds a handler to @server for requests prefixed by @path.
+//
+// If @path is %NULL or "/", then this will be the default handler for all
+// requests that don't have a more specific handler. (Note though that if you
+// want to handle requests to the special "*" URI, you must explicitly register
+// a handler for "*"; the default handler will not be used for that case.)
+//
+// For requests under @path (that have not already been assigned a
+// status code by a [class@AuthDomain], an early server handler, or a
+// signal handler), @callback will be invoked after receiving the
+// request body; the [class@ServerMessage]'s method, request-headers,
+// and request-body properties will be set.
+//
+// After determining what to do with the request, the callback must at a minimum
+// call [method@ServerMessage.set_status] on the message to set the response
+// status code. Additionally, it may set response headers and/or fill in the
+// response body.
+//
+// If the callback cannot fully fill in the response before returning
+// (eg, if it needs to wait for information from a database, or
+// another network server), it should call [method@ServerMessage.pause]
+// to tell @server to not send the response right away. When the
+// response is ready, call [method@ServerMessage.unpause] to cause it
+// to be sent.
+//
+// To send the response body a bit at a time using "chunked" encoding, first
+// call [method@MessageHeaders.set_encoding] to set %SOUP_ENCODING_CHUNKED on
+// the response-headers. Then call [method@MessageBody.append] (or
+// [method@MessageBody.append_bytes])) to append each chunk as it becomes ready,
+// and [method@ServerMessage.unpause] to make sure it's running. (The server
+// will automatically pause the message if it is using chunked encoding but no
+// more chunks are available.) When you are done, call
+// [method@MessageBody.complete] to indicate that no more chunks are coming.
+func (x *Server) AddHandler(PathVar string, CallbackVar *ServerCallback, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {
+
+	xServerAddHandler(x.GoPointer(), PathVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallback(DestroyVar))
+
+}
+
+var xServerAddWebsocketExtension func(uintptr, types.GType)
+
+// Add support for a WebSocket extension of the given @extension_type.
+//
+// When a WebSocket client requests an extension of @extension_type,
+// a new [class@WebsocketExtension] of type @extension_type will be created
+// to handle the request.
+//
+// Note that [class@WebsocketExtensionDeflate] is supported by default, use
+// [method@Server.remove_websocket_extension] if you want to disable it.
+func (x *Server) AddWebsocketExtension(ExtensionTypeVar types.GType) {
+
+	xServerAddWebsocketExtension(x.GoPointer(), ExtensionTypeVar)
+
+}
+
+var xServerAddWebsocketHandler func(uintptr, string, string, []string, uintptr, uintptr, uintptr)
+
+// Adds a WebSocket handler to @server for requests prefixed by @path.
+//
+// If @path is %NULL or "/", then this will be the default handler for all
+// requests that don't have a more specific handler.
+//
+// When a path has a WebSocket handler registered, @server will check
+// incoming requests for WebSocket handshakes after all other handlers
+// have run (unless some earlier handler has already set a status code
+// on the message), and update the request's status, response headers,
+// and response body accordingly.
+//
+// If @origin is non-%NULL, then only requests containing a matching
+// "Origin" header will be accepted. If @protocols is non-%NULL, then
+// only requests containing a compatible "Sec-WebSocket-Protocols"
+// header will be accepted. More complicated requirements can be
+// handled by adding a normal handler to @path, and having it perform
+// whatever checks are needed and
+// setting a failure status code if the handshake should be rejected.
+func (x *Server) AddWebsocketHandler(PathVar string, OriginVar string, ProtocolsVar []string, CallbackVar *ServerWebsocketCallback, UserDataVar uintptr, DestroyVar *glib.DestroyNotify) {
+
+	xServerAddWebsocketHandler(x.GoPointer(), PathVar, OriginVar, ProtocolsVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallback(DestroyVar))
+
+}
+
+var xServerDisconnect func(uintptr)
+
+// Closes and frees @server's listening sockets.
+//
+// Note that if there are currently requests in progress on @server, that they
+// will continue to be processed if @server's [struct@GLib.MainContext] is still
+// running.
+//
+// You can call [method@Server.listen], etc, after calling this function
+// if you want to start listening again.
+func (x *Server) Disconnect() {
+
+	xServerDisconnect(x.GoPointer())
+
+}
+
+var xServerGetListeners func(uintptr) *glib.SList
+
+// Gets @server's list of listening sockets.
+//
+// You should treat these sockets as read-only; writing to or
+// modifiying any of these sockets may cause @server to malfunction.
+func (x *Server) GetListeners() *glib.SList {
+
+	cret := xServerGetListeners(x.GoPointer())
+	return cret
+}
+
+var xServerGetTlsAuthMode func(uintptr) gio.TlsAuthenticationMode
+
+// Gets the @server SSL/TLS client authentication mode.
+func (x *Server) GetTlsAuthMode() gio.TlsAuthenticationMode {
+
+	cret := xServerGetTlsAuthMode(x.GoPointer())
+	return cret
+}
+
+var xServerGetTlsCertificate func(uintptr) uintptr
+
+// Gets the @server SSL/TLS certificate.
+func (x *Server) GetTlsCertificate() *gio.TlsCertificate {
+	var cls *gio.TlsCertificate
+
+	cret := xServerGetTlsCertificate(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.TlsCertificate{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xServerGetTlsDatabase func(uintptr) uintptr
+
+// Gets the @server SSL/TLS database.
+func (x *Server) GetTlsDatabase() *gio.TlsDatabase {
+	var cls *gio.TlsDatabase
+
+	cret := xServerGetTlsDatabase(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.TlsDatabase{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xServerGetUris func(uintptr) *glib.SList
+
+// Gets a list of URIs corresponding to the interfaces @server is
+// listening on.
+//
+// These will contain IP addresses, not hostnames, and will also indicate
+// whether the given listener is http or https.
+//
+// Note that if you used [method@Server.listen_all] the returned URIs will use
+// the addresses `0.0.0.0` and `::`, rather than actually returning separate
+// URIs for each interface on the system.
+func (x *Server) GetUris() *glib.SList {
+
+	cret := xServerGetUris(x.GoPointer())
+	return cret
+}
+
+var xServerIsHttps func(uintptr) bool
+
+// Checks whether @server is capable of https.
+//
+// In order for a server to run https, you must call
+// [method@Server.set_tls_certificate], or set the
+// [property@Server:tls-certificate] property, to provide it with a
+// certificate to use.
+//
+// If you are using the deprecated single-listener APIs, then a return value of
+// %TRUE indicates that the #SoupServer serves https exclusively. If you are
+// using [method@Server.listen], etc, then a %TRUE return value merely indicates
+// that the server is *able* to do https, regardless of whether it actually
+// currently is or not. Use [method@Server.get_uris] to see if it currently has
+// any https listeners.
+func (x *Server) IsHttps() bool {
+
+	cret := xServerIsHttps(x.GoPointer())
+	return cret
+}
+
+var xServerListen func(uintptr, uintptr, ServerListenOptions, **glib.Error) bool
+
+// Attempts to set up @server to listen for connections on @address.
+//
+// If @options includes %SOUP_SERVER_LISTEN_HTTPS, and @server has
+// been configured for TLS, then @server will listen for https
+// connections on this port. Otherwise it will listen for plain http.
+//
+// You may call this method (along with the other "listen" methods)
+// any number of times on a server, if you want to listen on multiple
+// ports, or set up both http and https service.
+//
+// After calling this method, @server will begin accepting and processing
+// connections as soon as the appropriate [struct@GLib.MainContext] is run.
+//
+// Note that this API does not make use of dual IPv4/IPv6 sockets; if
+// @address is an IPv6 address, it will only accept IPv6 connections.
+// You must configure IPv4 listening separately.
+func (x *Server) Listen(AddressVar *gio.SocketAddress, OptionsVar ServerListenOptions) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xServerListen(x.GoPointer(), AddressVar.GoPointer(), OptionsVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xServerListenAll func(uintptr, uint, ServerListenOptions, **glib.Error) bool
+
+// Attempts to set up @server to listen for connections on all interfaces
+// on the system.
+//
+// That is, it listens on the addresses `0.0.0.0` and/or `::`, depending on
+// whether @options includes %SOUP_SERVER_LISTEN_IPV4_ONLY,
+// %SOUP_SERVER_LISTEN_IPV6_ONLY, or neither.) If @port is specified, @server
+// will listen on that port. If it is 0, @server will find an unused port to
+// listen on. (In that case, you can use [method@Server.get_uris] to find out
+// what port it ended up choosing.
+//
+// See [method@Server.listen] for more details.
+func (x *Server) ListenAll(PortVar uint, OptionsVar ServerListenOptions) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xServerListenAll(x.GoPointer(), PortVar, OptionsVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xServerListenLocal func(uintptr, uint, ServerListenOptions, **glib.Error) bool
+
+// Attempts to set up @server to listen for connections on "localhost".
+//
+// That is, `127.0.0.1` and/or `::1`, depending on whether @options includes
+// %SOUP_SERVER_LISTEN_IPV4_ONLY, %SOUP_SERVER_LISTEN_IPV6_ONLY, or neither). If
+// @port is specified, @server will listen on that port. If it is 0, @server
+// will find an unused port to listen on. (In that case, you can use
+// [method@Server.get_uris] to find out what port it ended up choosing.
+//
+// See [method@Server.listen] for more details.
+func (x *Server) ListenLocal(PortVar uint, OptionsVar ServerListenOptions) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xServerListenLocal(x.GoPointer(), PortVar, OptionsVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xServerListenSocket func(uintptr, uintptr, ServerListenOptions, **glib.Error) bool
+
+// Attempts to set up @server to listen for connections on @socket.
+//
+// See [method@Server.listen] for more details.
+func (x *Server) ListenSocket(SocketVar *gio.Socket, OptionsVar ServerListenOptions) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xServerListenSocket(x.GoPointer(), SocketVar.GoPointer(), OptionsVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xServerPauseMessage func(uintptr, uintptr)
+
+// Pauses I/O on @msg.
+//
+// This can be used when you need to return from the server handler without
+// having the full response ready yet. Use [method@Server.unpause_message] to
+// resume I/O.
+//
+// This must only be called on a [class@ServerMessage] which was created by the
+// #SoupServer and are currently doing I/O, such as those passed into a
+// [callback@ServerCallback] or emitted in a [signal@Server::request-read]
+// signal.
+func (x *Server) PauseMessage(MsgVar *ServerMessage) {
+
+	xServerPauseMessage(x.GoPointer(), MsgVar.GoPointer())
+
+}
+
+var xServerRemoveAuthDomain func(uintptr, uintptr)
+
+// Removes @auth_domain from @server.
+func (x *Server) RemoveAuthDomain(AuthDomainVar *AuthDomain) {
+
+	xServerRemoveAuthDomain(x.GoPointer(), AuthDomainVar.GoPointer())
+
+}
+
+var xServerRemoveHandler func(uintptr, string)
+
+// Removes all handlers (early and normal) registered at @path.
+func (x *Server) RemoveHandler(PathVar string) {
+
+	xServerRemoveHandler(x.GoPointer(), PathVar)
+
+}
+
+var xServerRemoveWebsocketExtension func(uintptr, types.GType)
+
+// Removes support for WebSocket extension of type @extension_type (or any subclass of
+// @extension_type) from @server.
+func (x *Server) RemoveWebsocketExtension(ExtensionTypeVar types.GType) {
+
+	xServerRemoveWebsocketExtension(x.GoPointer(), ExtensionTypeVar)
+
+}
+
+var xServerSetTlsAuthMode func(uintptr, gio.TlsAuthenticationMode)
+
+// Sets @server's #GTlsAuthenticationMode to use for SSL/TLS client authentication.
+func (x *Server) SetTlsAuthMode(ModeVar gio.TlsAuthenticationMode) {
+
+	xServerSetTlsAuthMode(x.GoPointer(), ModeVar)
+
+}
+
+var xServerSetTlsCertificate func(uintptr, uintptr)
+
+// Sets @server up to do https, using the given SSL/TLS @certificate.
+func (x *Server) SetTlsCertificate(CertificateVar *gio.TlsCertificate) {
+
+	xServerSetTlsCertificate(x.GoPointer(), CertificateVar.GoPointer())
+
+}
+
+var xServerSetTlsDatabase func(uintptr, uintptr)
+
+// Sets @server's #GTlsDatabase to use for validating SSL/TLS client certificates.
+func (x *Server) SetTlsDatabase(TlsDatabaseVar *gio.TlsDatabase) {
+
+	xServerSetTlsDatabase(x.GoPointer(), TlsDatabaseVar.GoPointer())
+
+}
+
+var xServerUnpauseMessage func(uintptr, uintptr)
+
+// Resumes I/O on @msg.
+//
+// Use this to resume after calling [method@Server.pause_message], or after
+// adding a new chunk to a chunked response.
+//
+// I/O won't actually resume until you return to the main loop.
+//
+// This must only be called on a [class@ServerMessage] which was created by the
+// #SoupServer and are currently doing I/O, such as those passed into a
+// [callback@ServerCallback] or emitted in a [signal@Server::request-read]
+// signal.
+func (x *Server) UnpauseMessage(MsgVar *ServerMessage) {
+
+	xServerUnpauseMessage(x.GoPointer(), MsgVar.GoPointer())
+
+}
+
+func (c *Server) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Server) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyRawPaths sets the "raw-paths" property.
+// If %TRUE, percent-encoding in the Request-URI path will not be
+// automatically decoded.
+func (x *Server) SetPropertyRawPaths(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("raw-paths", &v)
+}
+
+// GetPropertyRawPaths gets the "raw-paths" property.
+// If %TRUE, percent-encoding in the Request-URI path will not be
+// automatically decoded.
+func (x *Server) GetPropertyRawPaths() bool {
+	var v gobject.Value
+	x.GetProperty("raw-paths", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyServerHeader sets the "server-header" property.
+// Server header.
+//
+// If non-%NULL, the value to use for the "Server" header on
+// [class@ServerMessage]s processed by this server.
+//
+// The Server header is the server equivalent of the
+// User-Agent header, and provides information about the
+// server and its components. It contains a list of one or
+// more product tokens, separated by whitespace, with the most
+// significant product token coming first. The tokens must be
+// brief, ASCII, and mostly alphanumeric (although "-", "_",
+// and "." are also allowed), and may optionally include a "/"
+// followed by a version string. You may also put comments,
+// enclosed in parentheses, between or after the tokens.
+//
+// Some HTTP server implementations intentionally do not use
+// version numbers in their Server header, so that
+// installations running older versions of the server don't
+// end up advertising their vulnerability to specific security
+// holes.
+//
+// As with [property@Session:user_agent], if you set a
+// [property@Server:server-header] property that has trailing
+// whitespace, #SoupServer will append its own product token (eg,
+// `libsoup/2.3.2`) to the end of the header for you.
+func (x *Server) SetPropertyServerHeader(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("server-header", &v)
+}
+
+// GetPropertyServerHeader gets the "server-header" property.
+// Server header.
+//
+// If non-%NULL, the value to use for the "Server" header on
+// [class@ServerMessage]s processed by this server.
+//
+// The Server header is the server equivalent of the
+// User-Agent header, and provides information about the
+// server and its components. It contains a list of one or
+// more product tokens, separated by whitespace, with the most
+// significant product token coming first. The tokens must be
+// brief, ASCII, and mostly alphanumeric (although "-", "_",
+// and "." are also allowed), and may optionally include a "/"
+// followed by a version string. You may also put comments,
+// enclosed in parentheses, between or after the tokens.
+//
+// Some HTTP server implementations intentionally do not use
+// version numbers in their Server header, so that
+// installations running older versions of the server don't
+// end up advertising their vulnerability to specific security
+// holes.
+//
+// As with [property@Session:user_agent], if you set a
+// [property@Server:server-header] property that has trailing
+// whitespace, #SoupServer will append its own product token (eg,
+// `libsoup/2.3.2`) to the end of the header for you.
+func (x *Server) GetPropertyServerHeader() string {
+	var v gobject.Value
+	x.GetProperty("server-header", &v)
+	return v.GetString()
+}
+
+// Emitted when processing has failed for a message.
+//
+// This could mean either that it could not be read (if
+// [signal@Server::request-read] has not been emitted for it yet), or that
+// the response could not be written back (if [signal@Server::request-read]
+// has been emitted but [signal@Server::request-finished] has not been).
+//
+// @message is in an undefined state when this signal is
+// emitted; the signal exists primarily to allow the server to
+// free any state that it may have allocated in
+// [signal@Server::request-started].
+func (x *Server) ConnectRequestAborted(cb *func(Server, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "request-aborted", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MessageVarp uintptr) {
+		fa := Server{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, MessageVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "request-aborted", cbRefPtr)
+}
+
+// Emitted when the server has finished writing a response to
+// a request.
+func (x *Server) ConnectRequestFinished(cb *func(Server, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "request-finished", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MessageVarp uintptr) {
+		fa := Server{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, MessageVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "request-finished", cbRefPtr)
+}
+
+// Emitted when the server has successfully read a request.
+//
+// @message will have all of its request-side information
+// filled in, and if the message was authenticated, @client
+// will have information about that. This signal is emitted
+// before any (non-early) handlers are called for the message,
+// and if it sets the message's #status_code, then normal
+// handler processing will be skipped.
+func (x *Server) ConnectRequestRead(cb *func(Server, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "request-read", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MessageVarp uintptr) {
+		fa := Server{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, MessageVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "request-read", cbRefPtr)
+}
+
+// Emitted when the server has started reading a new request.
+//
+// @message will be completely blank; not even the
+// Request-Line will have been read yet. About the only thing
+// you can usefully do with it is connect to its signals.
+//
+// If the request is read successfully, this will eventually
+// be followed by a [signal@Server::request_read signal]. If a
+// response is then sent, the request processing will end with
+// a [signal@Server::request-finished] signal. If a network error
+// occurs, the processing will instead end with
+// [signal@Server::request-aborted].
+func (x *Server) ConnectRequestStarted(cb *func(Server, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "request-started", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MessageVarp uintptr) {
+		fa := Server{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, MessageVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "request-started", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xServerListenOptionsGLibType, libs, "soup_server_listen_options_get_type")
+
+	core.PuregoSafeRegister(&xServerGLibType, libs, "soup_server_get_type")
+
+	core.PuregoSafeRegister(&xNewServer, libs, "soup_server_new")
+
+	core.PuregoSafeRegister(&xServerAcceptIostream, libs, "soup_server_accept_iostream")
+	core.PuregoSafeRegister(&xServerAddAuthDomain, libs, "soup_server_add_auth_domain")
+	core.PuregoSafeRegister(&xServerAddEarlyHandler, libs, "soup_server_add_early_handler")
+	core.PuregoSafeRegister(&xServerAddHandler, libs, "soup_server_add_handler")
+	core.PuregoSafeRegister(&xServerAddWebsocketExtension, libs, "soup_server_add_websocket_extension")
+	core.PuregoSafeRegister(&xServerAddWebsocketHandler, libs, "soup_server_add_websocket_handler")
+	core.PuregoSafeRegister(&xServerDisconnect, libs, "soup_server_disconnect")
+	core.PuregoSafeRegister(&xServerGetListeners, libs, "soup_server_get_listeners")
+	core.PuregoSafeRegister(&xServerGetTlsAuthMode, libs, "soup_server_get_tls_auth_mode")
+	core.PuregoSafeRegister(&xServerGetTlsCertificate, libs, "soup_server_get_tls_certificate")
+	core.PuregoSafeRegister(&xServerGetTlsDatabase, libs, "soup_server_get_tls_database")
+	core.PuregoSafeRegister(&xServerGetUris, libs, "soup_server_get_uris")
+	core.PuregoSafeRegister(&xServerIsHttps, libs, "soup_server_is_https")
+	core.PuregoSafeRegister(&xServerListen, libs, "soup_server_listen")
+	core.PuregoSafeRegister(&xServerListenAll, libs, "soup_server_listen_all")
+	core.PuregoSafeRegister(&xServerListenLocal, libs, "soup_server_listen_local")
+	core.PuregoSafeRegister(&xServerListenSocket, libs, "soup_server_listen_socket")
+	core.PuregoSafeRegister(&xServerPauseMessage, libs, "soup_server_pause_message")
+	core.PuregoSafeRegister(&xServerRemoveAuthDomain, libs, "soup_server_remove_auth_domain")
+	core.PuregoSafeRegister(&xServerRemoveHandler, libs, "soup_server_remove_handler")
+	core.PuregoSafeRegister(&xServerRemoveWebsocketExtension, libs, "soup_server_remove_websocket_extension")
+	core.PuregoSafeRegister(&xServerSetTlsAuthMode, libs, "soup_server_set_tls_auth_mode")
+	core.PuregoSafeRegister(&xServerSetTlsCertificate, libs, "soup_server_set_tls_certificate")
+	core.PuregoSafeRegister(&xServerSetTlsDatabase, libs, "soup_server_set_tls_database")
+	core.PuregoSafeRegister(&xServerUnpauseMessage, libs, "soup_server_unpause_message")
+
+}
diff --git a/v4/soup/soup-session-feature.go b/v4/soup/soup-session-feature.go
new file mode 100644
index 0000000000000000000000000000000000000000..74c9250fcaa4864026665d4d9606d07260345353
--- /dev/null
+++ b/v4/soup/soup-session-feature.go
@@ -0,0 +1,53 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// The interface implemented by [iface@SessionFeature]s.
+type SessionFeatureInterface struct {
+	_ structs.HostLayout
+}
+
+func (x *SessionFeatureInterface) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Interface for miscellaneous [class@Session] features.
+//
+// #SoupSessionFeature is the interface used by classes that extend
+// the functionality of a [class@Session]. Some features like HTTP
+// authentication handling are implemented internally via
+// `SoupSessionFeature`s. Other features can be added to the session
+// by the application. (Eg, [class@Logger], [class@CookieJar].)
+//
+// See [method@Session.add_feature], etc, to add a feature to a session.
+type SessionFeature interface {
+	GoPointer() uintptr
+	SetGoPointer(uintptr)
+}
+
+var xSessionFeatureGLibType func() types.GType
+
+func SessionFeatureGLibType() types.GType {
+	return xSessionFeatureGLibType()
+}
+
+type SessionFeatureBase struct {
+	Ptr uintptr
+}
+
+func (x *SessionFeatureBase) GoPointer() uintptr {
+	if x == nil {
+		return 0
+	}
+	return x.Ptr
+}
+
+func (x *SessionFeatureBase) SetGoPointer(ptr uintptr) {
+	x.Ptr = ptr
+}
diff --git a/v4/soup/soup-session.go b/v4/soup/soup-session.go
new file mode 100644
index 0000000000000000000000000000000000000000..c51ce93ef16712111743fd8b3f6e207f760ce585
--- /dev/null
+++ b/v4/soup/soup-session.go
@@ -0,0 +1,1414 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type SessionClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+
+	xRequestQueued uintptr
+
+	xRequestUnqueued uintptr
+
+	xSoupReserved1 uintptr
+
+	xSoupReserved2 uintptr
+
+	xSoupReserved3 uintptr
+
+	xSoupReserved4 uintptr
+
+	xSoupReserved5 uintptr
+
+	xSoupReserved6 uintptr
+
+	xSoupReserved7 uintptr
+
+	xSoupReserved8 uintptr
+}
+
+func (x *SessionClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideRequestQueued sets the "request_queued" callback function.
+func (x *SessionClass) OverrideRequestQueued(cb func(*Session, *Message)) {
+	if cb == nil {
+		x.xRequestQueued = 0
+	} else {
+		x.xRequestQueued = purego.NewCallback(func(SessionVarp uintptr, MsgVarp uintptr) {
+			cb(SessionNewFromInternalPtr(SessionVarp), MessageNewFromInternalPtr(MsgVarp))
+		})
+	}
+}
+
+// GetRequestQueued gets the "request_queued" callback function.
+func (x *SessionClass) GetRequestQueued() func(*Session, *Message) {
+	if x.xRequestQueued == 0 {
+		return nil
+	}
+	var rawCallback func(SessionVarp uintptr, MsgVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xRequestQueued)
+	return func(SessionVar *Session, MsgVar *Message) {
+		rawCallback(SessionVar.GoPointer(), MsgVar.GoPointer())
+	}
+}
+
+// OverrideRequestUnqueued sets the "request_unqueued" callback function.
+func (x *SessionClass) OverrideRequestUnqueued(cb func(*Session, *Message)) {
+	if cb == nil {
+		x.xRequestUnqueued = 0
+	} else {
+		x.xRequestUnqueued = purego.NewCallback(func(SessionVarp uintptr, MsgVarp uintptr) {
+			cb(SessionNewFromInternalPtr(SessionVarp), MessageNewFromInternalPtr(MsgVarp))
+		})
+	}
+}
+
+// GetRequestUnqueued gets the "request_unqueued" callback function.
+func (x *SessionClass) GetRequestUnqueued() func(*Session, *Message) {
+	if x.xRequestUnqueued == 0 {
+		return nil
+	}
+	var rawCallback func(SessionVarp uintptr, MsgVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xRequestUnqueued)
+	return func(SessionVar *Session, MsgVar *Message) {
+		rawCallback(SessionVar.GoPointer(), MsgVar.GoPointer())
+	}
+}
+
+// OverrideSoupReserved1 sets the "_soup_reserved1" callback function.
+func (x *SessionClass) OverrideSoupReserved1(cb func()) {
+	if cb == nil {
+		x.xSoupReserved1 = 0
+	} else {
+		x.xSoupReserved1 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetSoupReserved1 gets the "_soup_reserved1" callback function.
+func (x *SessionClass) GetSoupReserved1() func() {
+	if x.xSoupReserved1 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xSoupReserved1)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideSoupReserved2 sets the "_soup_reserved2" callback function.
+func (x *SessionClass) OverrideSoupReserved2(cb func()) {
+	if cb == nil {
+		x.xSoupReserved2 = 0
+	} else {
+		x.xSoupReserved2 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetSoupReserved2 gets the "_soup_reserved2" callback function.
+func (x *SessionClass) GetSoupReserved2() func() {
+	if x.xSoupReserved2 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xSoupReserved2)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideSoupReserved3 sets the "_soup_reserved3" callback function.
+func (x *SessionClass) OverrideSoupReserved3(cb func()) {
+	if cb == nil {
+		x.xSoupReserved3 = 0
+	} else {
+		x.xSoupReserved3 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetSoupReserved3 gets the "_soup_reserved3" callback function.
+func (x *SessionClass) GetSoupReserved3() func() {
+	if x.xSoupReserved3 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xSoupReserved3)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideSoupReserved4 sets the "_soup_reserved4" callback function.
+func (x *SessionClass) OverrideSoupReserved4(cb func()) {
+	if cb == nil {
+		x.xSoupReserved4 = 0
+	} else {
+		x.xSoupReserved4 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetSoupReserved4 gets the "_soup_reserved4" callback function.
+func (x *SessionClass) GetSoupReserved4() func() {
+	if x.xSoupReserved4 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xSoupReserved4)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideSoupReserved5 sets the "_soup_reserved5" callback function.
+func (x *SessionClass) OverrideSoupReserved5(cb func()) {
+	if cb == nil {
+		x.xSoupReserved5 = 0
+	} else {
+		x.xSoupReserved5 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetSoupReserved5 gets the "_soup_reserved5" callback function.
+func (x *SessionClass) GetSoupReserved5() func() {
+	if x.xSoupReserved5 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xSoupReserved5)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideSoupReserved6 sets the "_soup_reserved6" callback function.
+func (x *SessionClass) OverrideSoupReserved6(cb func()) {
+	if cb == nil {
+		x.xSoupReserved6 = 0
+	} else {
+		x.xSoupReserved6 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetSoupReserved6 gets the "_soup_reserved6" callback function.
+func (x *SessionClass) GetSoupReserved6() func() {
+	if x.xSoupReserved6 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xSoupReserved6)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideSoupReserved7 sets the "_soup_reserved7" callback function.
+func (x *SessionClass) OverrideSoupReserved7(cb func()) {
+	if cb == nil {
+		x.xSoupReserved7 = 0
+	} else {
+		x.xSoupReserved7 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetSoupReserved7 gets the "_soup_reserved7" callback function.
+func (x *SessionClass) GetSoupReserved7() func() {
+	if x.xSoupReserved7 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xSoupReserved7)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideSoupReserved8 sets the "_soup_reserved8" callback function.
+func (x *SessionClass) OverrideSoupReserved8(cb func()) {
+	if cb == nil {
+		x.xSoupReserved8 = 0
+	} else {
+		x.xSoupReserved8 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetSoupReserved8 gets the "_soup_reserved8" callback function.
+func (x *SessionClass) GetSoupReserved8() func() {
+	if x.xSoupReserved8 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xSoupReserved8)
+	return func() {
+		rawCallback()
+	}
+}
+
+// A #SoupSession error.
+type SessionError int
+
+var xSessionErrorGLibType func() types.GType
+
+func SessionErrorGLibType() types.GType {
+	return xSessionErrorGLibType()
+}
+
+const (
+
+	// the server's response could not
+	//   be parsed
+	SessionErrorParsingValue SessionError = 0
+	// the server's response was in an
+	//   unsupported format
+	SessionErrorEncodingValue SessionError = 1
+	// the message has been redirected
+	//   too many times
+	SessionErrorTooManyRedirectsValue SessionError = 2
+	// the message has been restarted
+	//   too many times
+	SessionErrorTooManyRestartsValue SessionError = 3
+	// failed to redirect message because
+	//   Location header was missing or empty in response
+	SessionErrorRedirectNoLocationValue SessionError = 4
+	// failed to redirect message because
+	//   Location header contains an invalid URI
+	SessionErrorRedirectBadUriValue SessionError = 5
+	// the message is already in the
+	//   session queue. Messages can only be reused after unqueued.
+	SessionErrorMessageAlreadyInQueueValue SessionError = 6
+)
+
+var xSessionErrorQuark func() glib.Quark
+
+// Registers error quark for SoupSession if needed.
+func SessionErrorQuark() glib.Quark {
+
+	cret := xSessionErrorQuark()
+	return cret
+}
+
+// Soup session state object.
+//
+// #SoupSession is the object that controls client-side HTTP. A
+// #SoupSession encapsulates all of the state that libsoup is keeping
+// on behalf of your program; cached HTTP connections, authentication
+// information, etc. It also keeps track of various global options
+// and features that you are using.
+//
+// Most applications will only need a single #SoupSession; the primary
+// reason you might need multiple sessions is if you need to have
+// multiple independent authentication contexts. (Eg, you are
+// connecting to a server and authenticating as two different users at
+// different times; the easiest way to ensure that each [class@Message]
+// is sent with the authentication information you intended is to use
+// one session for the first user, and a second session for the other
+// user.)
+//
+// Additional #SoupSession functionality is provided by
+// [iface@SessionFeature] objects, which can be added to a session with
+// [method@Session.add_feature] or [method@Session.add_feature_by_type]
+// For example, [class@Logger] provides support for
+// logging HTTP traffic, [class@ContentDecoder] provides support for
+// compressed response handling, and [class@ContentSniffer] provides
+// support for HTML5-style response body content sniffing.
+// Additionally, subtypes of [class@Auth] can be added
+// as features, to add support for additional authentication types.
+//
+// All `SoupSession`s are created with a [class@AuthManager], and support
+// for %SOUP_TYPE_AUTH_BASIC and %SOUP_TYPE_AUTH_DIGEST. Additionally,
+// sessions using the plain #SoupSession class (rather than one of its deprecated
+// subtypes) have a [class@ContentDecoder] by default.
+//
+// Note that all async methods will invoke their callbacks on the thread-default
+// context at the time of the function call.
+type Session struct {
+	gobject.Object
+}
+
+var xSessionGLibType func() types.GType
+
+func SessionGLibType() types.GType {
+	return xSessionGLibType()
+}
+
+func SessionNewFromInternalPtr(ptr uintptr) *Session {
+	cls := &Session{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewSession func() uintptr
+
+// Creates a #SoupSession with the default options.
+func NewSession() *Session {
+	var cls *Session
+
+	cret := xNewSession()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Session{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewSessionWithOptions func(string, ...interface{}) uintptr
+
+// Creates a #SoupSession with the specified options.
+func NewSessionWithOptions(Optname1Var string, varArgs ...interface{}) *Session {
+	var cls *Session
+
+	cret := xNewSessionWithOptions(Optname1Var, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Session{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xSessionAbort func(uintptr)
+
+// Cancels all pending requests in @session and closes all idle
+// persistent connections.
+func (x *Session) Abort() {
+
+	xSessionAbort(x.GoPointer())
+
+}
+
+var xSessionAddFeature func(uintptr, uintptr)
+
+// Adds @feature's functionality to @session. You cannot add multiple
+// features of the same [alias@GObject.Type] to a session.
+//
+// See the main #SoupSession documentation for information on what
+// features are present in sessions by default.
+func (x *Session) AddFeature(FeatureVar SessionFeature) {
+
+	xSessionAddFeature(x.GoPointer(), FeatureVar.GoPointer())
+
+}
+
+var xSessionAddFeatureByType func(uintptr, types.GType)
+
+// If @feature_type is the type of a class that implements
+// [iface@SessionFeature], this creates a new feature of that type and
+// adds it to @session as with [method@Session.add_feature]. You can use
+// this when you don't need to customize the new feature in any way.
+// Adding multiple features of the same @feature_type is not allowed.
+//
+// If @feature_type is not a [iface@SessionFeature] type, this gives each
+// existing feature on @session the chance to accept @feature_type as
+// a "subfeature". This can be used to add new [class@Auth] types, for instance.
+//
+// See the main #SoupSession documentation for information on what
+// features are present in sessions by default.
+func (x *Session) AddFeatureByType(FeatureTypeVar types.GType) {
+
+	xSessionAddFeatureByType(x.GoPointer(), FeatureTypeVar)
+
+}
+
+var xSessionGetAcceptLanguage func(uintptr) string
+
+// Get the value used by @session for the "Accept-Language" header on new
+// requests.
+func (x *Session) GetAcceptLanguage() string {
+
+	cret := xSessionGetAcceptLanguage(x.GoPointer())
+	return cret
+}
+
+var xSessionGetAcceptLanguageAuto func(uintptr) bool
+
+// Gets whether @session automatically sets the "Accept-Language" header on new
+// requests.
+func (x *Session) GetAcceptLanguageAuto() bool {
+
+	cret := xSessionGetAcceptLanguageAuto(x.GoPointer())
+	return cret
+}
+
+var xSessionGetAsyncResultMessage func(uintptr, uintptr) uintptr
+
+// Gets the [class@Message] of the @result asynchronous operation This is useful
+// to get the [class@Message] of an asynchronous operation started by @session
+// from its [callback@Gio.AsyncReadyCallback].
+func (x *Session) GetAsyncResultMessage(ResultVar gio.AsyncResult) *Message {
+	var cls *Message
+
+	cret := xSessionGetAsyncResultMessage(x.GoPointer(), ResultVar.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &Message{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xSessionGetFeature func(uintptr, types.GType) uintptr
+
+// Gets the feature in @session of type @feature_type.
+func (x *Session) GetFeature(FeatureTypeVar types.GType) *SessionFeatureBase {
+	var cls *SessionFeatureBase
+
+	cret := xSessionGetFeature(x.GoPointer(), FeatureTypeVar)
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &SessionFeatureBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xSessionGetFeatureForMessage func(uintptr, types.GType, uintptr) uintptr
+
+// Gets the feature in @session of type @feature_type, provided
+// that it is not disabled for @msg.
+func (x *Session) GetFeatureForMessage(FeatureTypeVar types.GType, MsgVar *Message) *SessionFeatureBase {
+	var cls *SessionFeatureBase
+
+	cret := xSessionGetFeatureForMessage(x.GoPointer(), FeatureTypeVar, MsgVar.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &SessionFeatureBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xSessionGetIdleTimeout func(uintptr) uint
+
+// Get the timeout in seconds for idle connection lifetime currently used by
+// @session.
+func (x *Session) GetIdleTimeout() uint {
+
+	cret := xSessionGetIdleTimeout(x.GoPointer())
+	return cret
+}
+
+var xSessionGetLocalAddress func(uintptr) uintptr
+
+// Get the [class@Gio.InetSocketAddress] to use for the client side of
+// connections in @session.
+func (x *Session) GetLocalAddress() *gio.InetSocketAddress {
+	var cls *gio.InetSocketAddress
+
+	cret := xSessionGetLocalAddress(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.InetSocketAddress{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xSessionGetMaxConns func(uintptr) uint
+
+// Get the maximum number of connections that @session can open at once.
+func (x *Session) GetMaxConns() uint {
+
+	cret := xSessionGetMaxConns(x.GoPointer())
+	return cret
+}
+
+var xSessionGetMaxConnsPerHost func(uintptr) uint
+
+// Get the maximum number of connections that @session can open at once to a
+// given host.
+func (x *Session) GetMaxConnsPerHost() uint {
+
+	cret := xSessionGetMaxConnsPerHost(x.GoPointer())
+	return cret
+}
+
+var xSessionGetProxyResolver func(uintptr) uintptr
+
+// Get the [iface@Gio.ProxyResolver] currently used by @session.
+func (x *Session) GetProxyResolver() *gio.ProxyResolverBase {
+	var cls *gio.ProxyResolverBase
+
+	cret := xSessionGetProxyResolver(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.ProxyResolverBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xSessionGetRemoteConnectable func(uintptr) uintptr
+
+// Gets the remote connectable if one set.
+func (x *Session) GetRemoteConnectable() *gio.SocketConnectableBase {
+	var cls *gio.SocketConnectableBase
+
+	cret := xSessionGetRemoteConnectable(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.SocketConnectableBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xSessionGetTimeout func(uintptr) uint
+
+// Get the timeout in seconds for socket I/O operations currently used by
+// @session.
+func (x *Session) GetTimeout() uint {
+
+	cret := xSessionGetTimeout(x.GoPointer())
+	return cret
+}
+
+var xSessionGetTlsDatabase func(uintptr) uintptr
+
+// Get the [class@Gio.TlsDatabase] currently used by @session.
+func (x *Session) GetTlsDatabase() *gio.TlsDatabase {
+	var cls *gio.TlsDatabase
+
+	cret := xSessionGetTlsDatabase(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.TlsDatabase{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xSessionGetTlsInteraction func(uintptr) uintptr
+
+// Get the [class@Gio.TlsInteraction] currently used by @session.
+func (x *Session) GetTlsInteraction() *gio.TlsInteraction {
+	var cls *gio.TlsInteraction
+
+	cret := xSessionGetTlsInteraction(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.TlsInteraction{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xSessionGetUserAgent func(uintptr) string
+
+// Get the value used by @session for the "User-Agent" header on new requests.
+func (x *Session) GetUserAgent() string {
+
+	cret := xSessionGetUserAgent(x.GoPointer())
+	return cret
+}
+
+var xSessionHasFeature func(uintptr, types.GType) bool
+
+// Tests if @session has at a feature of type @feature_type (which can
+// be the type of either a [iface@SessionFeature], or else a subtype of
+// some class managed by another feature, such as [class@Auth]).
+func (x *Session) HasFeature(FeatureTypeVar types.GType) bool {
+
+	cret := xSessionHasFeature(x.GoPointer(), FeatureTypeVar)
+	return cret
+}
+
+var xSessionPreconnectAsync func(uintptr, uintptr, int, uintptr, uintptr, uintptr)
+
+// Start a preconnection to @msg.
+//
+// Once the connection is done, it will remain in idle state so that it can be
+// reused by future requests. If there's already an idle connection for the
+// given @msg host, the operation finishes successfully without creating a new
+// connection. If a new request for the given @msg host is made while the
+// preconnect is still ongoing, the request will take the ownership of the
+// connection and the preconnect operation will finish successfully (if there's
+// a connection error it will be handled by the request).
+//
+// The operation finishes when the connection is done or an error occurred.
+func (x *Session) PreconnectAsync(MsgVar *Message, IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xSessionPreconnectAsync(x.GoPointer(), MsgVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xSessionPreconnectFinish func(uintptr, uintptr, **glib.Error) bool
+
+// Complete a preconnect async operation started with [method@Session.preconnect_async].
+func (x *Session) PreconnectFinish(ResultVar gio.AsyncResult) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xSessionPreconnectFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xSessionRemoveFeature func(uintptr, uintptr)
+
+// Removes @feature's functionality from @session.
+func (x *Session) RemoveFeature(FeatureVar SessionFeature) {
+
+	xSessionRemoveFeature(x.GoPointer(), FeatureVar.GoPointer())
+
+}
+
+var xSessionRemoveFeatureByType func(uintptr, types.GType)
+
+// Removes all features of type @feature_type (or any subclass of
+// @feature_type) from @session.
+func (x *Session) RemoveFeatureByType(FeatureTypeVar types.GType) {
+
+	xSessionRemoveFeatureByType(x.GoPointer(), FeatureTypeVar)
+
+}
+
+var xSessionSend func(uintptr, uintptr, uintptr, **glib.Error) uintptr
+
+// Synchronously sends @msg and waits for the beginning of a response.
+//
+// On success, a [class@Gio.InputStream] will be returned which you can use to
+// read the response body. ("Success" here means only that an HTTP
+// response was received and understood; it does not necessarily mean
+// that a 2xx class status code was received.)
+//
+// If non-%NULL, @cancellable can be used to cancel the request;
+// [method@Session.send] will return a %G_IO_ERROR_CANCELLED error. Note that
+// with requests that have side effects (eg, `POST`, `PUT`, `DELETE`) it is
+// possible that you might cancel the request after the server acts on it, but
+// before it returns a response, leaving the remote resource in an unknown
+// state.
+//
+// If @msg is requeued due to a redirect or authentication, the
+// initial (`3xx/401/407`) response body will be suppressed, and
+// [method@Session.send] will only return once a final response has been
+// received.
+//
+// Possible error domains include [error@SessionError], [error@Gio.IOErrorEnum],
+// and [error@Gio.TlsError] which you may want to specifically handle.
+func (x *Session) Send(MsgVar *Message, CancellableVar *gio.Cancellable) (*gio.InputStream, error) {
+	var cls *gio.InputStream
+	var cerr *glib.Error
+
+	cret := xSessionSend(x.GoPointer(), MsgVar.GoPointer(), CancellableVar.GoPointer(), &cerr)
+
+	if cret == 0 {
+		return nil, cerr
+	}
+	cls = &gio.InputStream{}
+	cls.Ptr = cret
+	if cerr == nil {
+		return cls, nil
+	}
+	return cls, cerr
+
+}
+
+var xSessionSendAndRead func(uintptr, uintptr, uintptr, **glib.Error) *glib.Bytes
+
+// Synchronously sends @msg and reads the response body.
+//
+// On success, a [struct@GLib.Bytes] will be returned with the response body.
+// This function should only be used when the resource to be retrieved
+// is not too long and can be stored in memory.
+//
+// See [method@Session.send] for more details on the general semantics.
+func (x *Session) SendAndRead(MsgVar *Message, CancellableVar *gio.Cancellable) (*glib.Bytes, error) {
+	var cerr *glib.Error
+
+	cret := xSessionSendAndRead(x.GoPointer(), MsgVar.GoPointer(), CancellableVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xSessionSendAndReadAsync func(uintptr, uintptr, int, uintptr, uintptr, uintptr)
+
+// Asynchronously sends @msg and reads the response body.
+//
+// When @callback is called, then either @msg has been sent, and its response
+// body read, or else an error has occurred. This function should only be used
+// when the resource to be retrieved is not too long and can be stored in
+// memory. Call [method@Session.send_and_read_finish] to get a
+// [struct@GLib.Bytes] with the response body.
+//
+// See [method@Session.send] for more details on the general semantics.
+func (x *Session) SendAndReadAsync(MsgVar *Message, IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xSessionSendAndReadAsync(x.GoPointer(), MsgVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xSessionSendAndReadFinish func(uintptr, uintptr, **glib.Error) *glib.Bytes
+
+// Gets the response to a [method@Session.send_and_read_async].
+//
+// If successful, returns a [struct@GLib.Bytes] with the response body.
+func (x *Session) SendAndReadFinish(ResultVar gio.AsyncResult) (*glib.Bytes, error) {
+	var cerr *glib.Error
+
+	cret := xSessionSendAndReadFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xSessionSendAndSplice func(uintptr, uintptr, uintptr, gio.OutputStreamSpliceFlags, uintptr, **glib.Error) int
+
+// Synchronously sends @msg and splices the response body stream into @out_stream.
+//
+// See [method@Session.send] for more details on the general semantics.
+func (x *Session) SendAndSplice(MsgVar *Message, OutStreamVar *gio.OutputStream, FlagsVar gio.OutputStreamSpliceFlags, CancellableVar *gio.Cancellable) (int, error) {
+	var cerr *glib.Error
+
+	cret := xSessionSendAndSplice(x.GoPointer(), MsgVar.GoPointer(), OutStreamVar.GoPointer(), FlagsVar, CancellableVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xSessionSendAndSpliceAsync func(uintptr, uintptr, uintptr, gio.OutputStreamSpliceFlags, int, uintptr, uintptr, uintptr)
+
+// Asynchronously sends @msg and splices the response body stream into @out_stream.
+// When @callback is called, then either @msg has been sent and its response body
+// spliced, or else an error has occurred.
+//
+// See [method@Session.send] for more details on the general semantics.
+func (x *Session) SendAndSpliceAsync(MsgVar *Message, OutStreamVar *gio.OutputStream, FlagsVar gio.OutputStreamSpliceFlags, IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xSessionSendAndSpliceAsync(x.GoPointer(), MsgVar.GoPointer(), OutStreamVar.GoPointer(), FlagsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xSessionSendAndSpliceFinish func(uintptr, uintptr, **glib.Error) int
+
+// Gets the response to a [method@Session.send_and_splice_async].
+func (x *Session) SendAndSpliceFinish(ResultVar gio.AsyncResult) (int, error) {
+	var cerr *glib.Error
+
+	cret := xSessionSendAndSpliceFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xSessionSendAsync func(uintptr, uintptr, int, uintptr, uintptr, uintptr)
+
+// Asynchronously sends @msg and waits for the beginning of a response.
+//
+// When @callback is called, then either @msg has been sent, and its response
+// headers received, or else an error has occurred. Call
+// [method@Session.send_finish] to get a [class@Gio.InputStream] for reading the
+// response body.
+//
+// See [method@Session.send] for more details on the general semantics.
+func (x *Session) SendAsync(MsgVar *Message, IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xSessionSendAsync(x.GoPointer(), MsgVar.GoPointer(), IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xSessionSendFinish func(uintptr, uintptr, **glib.Error) uintptr
+
+// Gets the response to a [method@Session.send_async] call.
+//
+// If successful returns a [class@Gio.InputStream] that can be used to read the
+// response body.
+func (x *Session) SendFinish(ResultVar gio.AsyncResult) (*gio.InputStream, error) {
+	var cls *gio.InputStream
+	var cerr *glib.Error
+
+	cret := xSessionSendFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+
+	if cret == 0 {
+		return nil, cerr
+	}
+	cls = &gio.InputStream{}
+	cls.Ptr = cret
+	if cerr == nil {
+		return cls, nil
+	}
+	return cls, cerr
+
+}
+
+var xSessionSetAcceptLanguage func(uintptr, string)
+
+// Set the value to use for the "Accept-Language" header on [class@Message]s
+// sent from @session.
+//
+// If @accept_language is %NULL then no "Accept-Language" will be included in
+// requests. See [property@Session:accept-language] for more information.
+func (x *Session) SetAcceptLanguage(AcceptLanguageVar string) {
+
+	xSessionSetAcceptLanguage(x.GoPointer(), AcceptLanguageVar)
+
+}
+
+var xSessionSetAcceptLanguageAuto func(uintptr, bool)
+
+// Set whether @session will automatically set the "Accept-Language" header on
+// requests using a value generated from system languages based on
+// [func@GLib.get_language_names].
+//
+// See [property@Session:accept-language-auto] for more information.
+func (x *Session) SetAcceptLanguageAuto(AcceptLanguageAutoVar bool) {
+
+	xSessionSetAcceptLanguageAuto(x.GoPointer(), AcceptLanguageAutoVar)
+
+}
+
+var xSessionSetIdleTimeout func(uintptr, uint)
+
+// Set a timeout in seconds for idle connection lifetime to be used by @session
+// on new connections.
+//
+// See [property@Session:idle-timeout] for more information.
+func (x *Session) SetIdleTimeout(TimeoutVar uint) {
+
+	xSessionSetIdleTimeout(x.GoPointer(), TimeoutVar)
+
+}
+
+var xSessionSetProxyResolver func(uintptr, uintptr)
+
+// Set a [iface@Gio.ProxyResolver] to be used by @session on new connections.
+//
+// If @proxy_resolver is %NULL then no proxies will be used. See
+// [property@Session:proxy-resolver] for more information.
+func (x *Session) SetProxyResolver(ProxyResolverVar gio.ProxyResolver) {
+
+	xSessionSetProxyResolver(x.GoPointer(), ProxyResolverVar.GoPointer())
+
+}
+
+var xSessionSetTimeout func(uintptr, uint)
+
+// Set a timeout in seconds for socket I/O operations to be used by @session
+// on new connections.
+//
+// See [property@Session:timeout] for more information.
+func (x *Session) SetTimeout(TimeoutVar uint) {
+
+	xSessionSetTimeout(x.GoPointer(), TimeoutVar)
+
+}
+
+var xSessionSetTlsDatabase func(uintptr, uintptr)
+
+// Set a [class@Gio.TlsDatabase] to be used by @session on new connections.
+//
+// If @tls_database is %NULL then certificate validation will always fail. See
+// [property@Session:tls-database] for more information.
+func (x *Session) SetTlsDatabase(TlsDatabaseVar *gio.TlsDatabase) {
+
+	xSessionSetTlsDatabase(x.GoPointer(), TlsDatabaseVar.GoPointer())
+
+}
+
+var xSessionSetTlsInteraction func(uintptr, uintptr)
+
+// Set a [class@Gio.TlsInteraction] to be used by @session on new connections.
+//
+// If @tls_interaction is %NULL then client certificate validation will always
+// fail.
+//
+// See [property@Session:tls-interaction] for more information.
+func (x *Session) SetTlsInteraction(TlsInteractionVar *gio.TlsInteraction) {
+
+	xSessionSetTlsInteraction(x.GoPointer(), TlsInteractionVar.GoPointer())
+
+}
+
+var xSessionSetUserAgent func(uintptr, string)
+
+// Set the value to use for the "User-Agent" header on [class@Message]s sent
+// from @session.
+//
+// If @user_agent has trailing whitespace, @session will append its own product
+// token (eg, `libsoup/3.0.0`) to the end of the header for you. If @user_agent
+// is %NULL then no "User-Agent" will be included in requests. See
+// [property@Session:user-agent] for more information.
+func (x *Session) SetUserAgent(UserAgentVar string) {
+
+	xSessionSetUserAgent(x.GoPointer(), UserAgentVar)
+
+}
+
+var xSessionWebsocketConnectAsync func(uintptr, uintptr, string, []string, int, uintptr, uintptr, uintptr)
+
+// Asynchronously creates a [class@WebsocketConnection] to communicate with a
+// remote server.
+//
+// All necessary WebSocket-related headers will be added to @msg, and
+// it will then be sent and asynchronously processed normally
+// (including handling of redirection and HTTP authentication).
+//
+// If the server returns "101 Switching Protocols", then @msg's status
+// code and response headers will be updated, and then the WebSocket
+// handshake will be completed. On success,
+// [method@Session.websocket_connect_finish] will return a new
+// [class@WebsocketConnection]. On failure it will return a #GError.
+//
+// If the server returns a status other than "101 Switching Protocols", then
+// @msg will contain the complete response headers and body from the server's
+// response, and [method@Session.websocket_connect_finish] will return
+// %SOUP_WEBSOCKET_ERROR_NOT_WEBSOCKET.
+func (x *Session) WebsocketConnectAsync(MsgVar *Message, OriginVar string, ProtocolsVar []string, IoPriorityVar int, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xSessionWebsocketConnectAsync(x.GoPointer(), MsgVar.GoPointer(), OriginVar, ProtocolsVar, IoPriorityVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xSessionWebsocketConnectFinish func(uintptr, uintptr, **glib.Error) uintptr
+
+// Gets the [class@WebsocketConnection] response to a
+// [method@Session.websocket_connect_async] call.
+//
+// If successful, returns a [class@WebsocketConnection] that can be used to
+// communicate with the server.
+func (x *Session) WebsocketConnectFinish(ResultVar gio.AsyncResult) (*WebsocketConnection, error) {
+	var cls *WebsocketConnection
+	var cerr *glib.Error
+
+	cret := xSessionWebsocketConnectFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+
+	if cret == 0 {
+		return nil, cerr
+	}
+	cls = &WebsocketConnection{}
+	cls.Ptr = cret
+	if cerr == nil {
+		return cls, nil
+	}
+	return cls, cerr
+
+}
+
+func (c *Session) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Session) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyAcceptLanguage sets the "accept-language" property.
+// If non-%NULL, the value to use for the "Accept-Language" header
+// on [class@Message]s sent from this session.
+//
+// Setting this will disable [property@Session:accept-language-auto].
+func (x *Session) SetPropertyAcceptLanguage(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("accept-language", &v)
+}
+
+// GetPropertyAcceptLanguage gets the "accept-language" property.
+// If non-%NULL, the value to use for the "Accept-Language" header
+// on [class@Message]s sent from this session.
+//
+// Setting this will disable [property@Session:accept-language-auto].
+func (x *Session) GetPropertyAcceptLanguage() string {
+	var v gobject.Value
+	x.GetProperty("accept-language", &v)
+	return v.GetString()
+}
+
+// SetPropertyAcceptLanguageAuto sets the "accept-language-auto" property.
+// If %TRUE, #SoupSession will automatically set the string
+// for the "Accept-Language" header on every [class@Message]
+// sent, based on the return value of [func@GLib.get_language_names].
+//
+// Setting this will override any previous value of
+// [property@Session:accept-language].
+func (x *Session) SetPropertyAcceptLanguageAuto(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("accept-language-auto", &v)
+}
+
+// GetPropertyAcceptLanguageAuto gets the "accept-language-auto" property.
+// If %TRUE, #SoupSession will automatically set the string
+// for the "Accept-Language" header on every [class@Message]
+// sent, based on the return value of [func@GLib.get_language_names].
+//
+// Setting this will override any previous value of
+// [property@Session:accept-language].
+func (x *Session) GetPropertyAcceptLanguageAuto() bool {
+	var v gobject.Value
+	x.GetProperty("accept-language-auto", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyIdleTimeout sets the "idle-timeout" property.
+// Connection lifetime (in seconds) when idle. Any connection
+// left idle longer than this will be closed.
+//
+// Although you can change this property at any time, it will
+// only affect newly-created connections, not currently-open
+// ones. You can call [method@Session.abort] after setting this
+// if you want to ensure that all future connections will have
+// this timeout value.
+func (x *Session) SetPropertyIdleTimeout(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("idle-timeout", &v)
+}
+
+// GetPropertyIdleTimeout gets the "idle-timeout" property.
+// Connection lifetime (in seconds) when idle. Any connection
+// left idle longer than this will be closed.
+//
+// Although you can change this property at any time, it will
+// only affect newly-created connections, not currently-open
+// ones. You can call [method@Session.abort] after setting this
+// if you want to ensure that all future connections will have
+// this timeout value.
+func (x *Session) GetPropertyIdleTimeout() uint {
+	var v gobject.Value
+	x.GetProperty("idle-timeout", &v)
+	return v.GetUint()
+}
+
+// SetPropertyMaxConns sets the "max-conns" property.
+// The maximum number of connections that the session can open at once.
+func (x *Session) SetPropertyMaxConns(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-conns", &v)
+}
+
+// GetPropertyMaxConns gets the "max-conns" property.
+// The maximum number of connections that the session can open at once.
+func (x *Session) GetPropertyMaxConns() int {
+	var v gobject.Value
+	x.GetProperty("max-conns", &v)
+	return v.GetInt()
+}
+
+// SetPropertyMaxConnsPerHost sets the "max-conns-per-host" property.
+// The maximum number of connections that the session can open at once
+// to a given host.
+func (x *Session) SetPropertyMaxConnsPerHost(value int) {
+	var v gobject.Value
+	v.Init(gobject.TypeIntVal)
+	v.SetInt(value)
+	x.SetProperty("max-conns-per-host", &v)
+}
+
+// GetPropertyMaxConnsPerHost gets the "max-conns-per-host" property.
+// The maximum number of connections that the session can open at once
+// to a given host.
+func (x *Session) GetPropertyMaxConnsPerHost() int {
+	var v gobject.Value
+	x.GetProperty("max-conns-per-host", &v)
+	return v.GetInt()
+}
+
+// SetPropertyTimeout sets the "timeout" property.
+// The timeout (in seconds) for socket I/O operations
+// (including connecting to a server, and waiting for a reply
+// to an HTTP request).
+//
+// Although you can change this property at any time, it will
+// only affect newly-created connections, not currently-open
+// ones. You can call [method@Session.abort] after setting this
+// if you want to ensure that all future connections will have
+// this timeout value.
+//
+// Not to be confused with [property@Session:idle-timeout] (which is
+// the length of time that idle persistent connections will be
+// kept open).
+func (x *Session) SetPropertyTimeout(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("timeout", &v)
+}
+
+// GetPropertyTimeout gets the "timeout" property.
+// The timeout (in seconds) for socket I/O operations
+// (including connecting to a server, and waiting for a reply
+// to an HTTP request).
+//
+// Although you can change this property at any time, it will
+// only affect newly-created connections, not currently-open
+// ones. You can call [method@Session.abort] after setting this
+// if you want to ensure that all future connections will have
+// this timeout value.
+//
+// Not to be confused with [property@Session:idle-timeout] (which is
+// the length of time that idle persistent connections will be
+// kept open).
+func (x *Session) GetPropertyTimeout() uint {
+	var v gobject.Value
+	x.GetProperty("timeout", &v)
+	return v.GetUint()
+}
+
+// SetPropertyUserAgent sets the "user-agent" property.
+// User-Agent string.
+//
+// If non-%NULL, the value to use for the "User-Agent" header
+// on [class@Message]s sent from this session.
+//
+// RFC 2616 says: "The User-Agent request-header field
+// contains information about the user agent originating the
+// request. This is for statistical purposes, the tracing of
+// protocol violations, and automated recognition of user
+// agents for the sake of tailoring responses to avoid
+// particular user agent limitations. User agents SHOULD
+// include this field with requests."
+//
+// The User-Agent header contains a list of one or more
+// product tokens, separated by whitespace, with the most
+// significant product token coming first. The tokens must be
+// brief, ASCII, and mostly alphanumeric (although "-", "_",
+// and "." are also allowed), and may optionally include a "/"
+// followed by a version string. You may also put comments,
+// enclosed in parentheses, between or after the tokens.
+//
+// If you set a [property@Session:user-agent] property that has trailing
+// whitespace, #SoupSession will append its own product token
+// (eg, `libsoup/2.3.2`) to the end of the
+// header for you.
+func (x *Session) SetPropertyUserAgent(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("user-agent", &v)
+}
+
+// GetPropertyUserAgent gets the "user-agent" property.
+// User-Agent string.
+//
+// If non-%NULL, the value to use for the "User-Agent" header
+// on [class@Message]s sent from this session.
+//
+// RFC 2616 says: "The User-Agent request-header field
+// contains information about the user agent originating the
+// request. This is for statistical purposes, the tracing of
+// protocol violations, and automated recognition of user
+// agents for the sake of tailoring responses to avoid
+// particular user agent limitations. User agents SHOULD
+// include this field with requests."
+//
+// The User-Agent header contains a list of one or more
+// product tokens, separated by whitespace, with the most
+// significant product token coming first. The tokens must be
+// brief, ASCII, and mostly alphanumeric (although "-", "_",
+// and "." are also allowed), and may optionally include a "/"
+// followed by a version string. You may also put comments,
+// enclosed in parentheses, between or after the tokens.
+//
+// If you set a [property@Session:user-agent] property that has trailing
+// whitespace, #SoupSession will append its own product token
+// (eg, `libsoup/2.3.2`) to the end of the
+// header for you.
+func (x *Session) GetPropertyUserAgent() string {
+	var v gobject.Value
+	x.GetProperty("user-agent", &v)
+	return v.GetString()
+}
+
+// Emitted when a request is queued on @session.
+//
+// When sending a request, first [signal@Session::request-queued]
+// is emitted, indicating that the session has become aware of
+// the request.
+//
+// After a connection is available to send the request various
+// [class@Message] signals are emitted as the message is
+// processed. If the message is requeued, it will emit
+// [signal@Message::restarted], which will then be followed by other
+// [class@Message] signals when the message is re-sent.
+//
+// Eventually, the message will emit [signal@Message::finished].
+// Normally, this signals the completion of message
+// processing. However, it is possible that the application
+// will requeue the message from the "finished" handler.
+// In that case the process will loop back.
+//
+// Eventually, a message will reach "finished" and not be
+// requeued. At that point, the session will emit
+// [signal@Session::request-unqueued] to indicate that it is done
+// with the message.
+//
+// To sum up: [signal@Session::request-queued] and
+// [signal@Session::request-unqueued] are guaranteed to be emitted
+// exactly once, but [signal@Message::finished] (and all of the other
+// [class@Message] signals) may be invoked multiple times for a given
+// message.
+func (x *Session) ConnectRequestQueued(cb *func(Session, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "request-queued", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MsgVarp uintptr) {
+		fa := Session{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, MsgVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "request-queued", cbRefPtr)
+}
+
+// Emitted when a request is removed from @session's queue,
+// indicating that @session is done with it.
+//
+// See [signal@Session::request-queued] for a detailed description of
+// the message lifecycle within a session.
+func (x *Session) ConnectRequestUnqueued(cb *func(Session, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "request-unqueued", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MsgVarp uintptr) {
+		fa := Session{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, MsgVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "request-unqueued", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xSessionErrorGLibType, libs, "soup_session_error_get_type")
+
+	core.PuregoSafeRegister(&xSessionErrorQuark, libs, "soup_session_error_quark")
+
+	core.PuregoSafeRegister(&xSessionGLibType, libs, "soup_session_get_type")
+
+	core.PuregoSafeRegister(&xNewSession, libs, "soup_session_new")
+	core.PuregoSafeRegister(&xNewSessionWithOptions, libs, "soup_session_new_with_options")
+
+	core.PuregoSafeRegister(&xSessionAbort, libs, "soup_session_abort")
+	core.PuregoSafeRegister(&xSessionAddFeature, libs, "soup_session_add_feature")
+	core.PuregoSafeRegister(&xSessionAddFeatureByType, libs, "soup_session_add_feature_by_type")
+	core.PuregoSafeRegister(&xSessionGetAcceptLanguage, libs, "soup_session_get_accept_language")
+	core.PuregoSafeRegister(&xSessionGetAcceptLanguageAuto, libs, "soup_session_get_accept_language_auto")
+	core.PuregoSafeRegister(&xSessionGetAsyncResultMessage, libs, "soup_session_get_async_result_message")
+	core.PuregoSafeRegister(&xSessionGetFeature, libs, "soup_session_get_feature")
+	core.PuregoSafeRegister(&xSessionGetFeatureForMessage, libs, "soup_session_get_feature_for_message")
+	core.PuregoSafeRegister(&xSessionGetIdleTimeout, libs, "soup_session_get_idle_timeout")
+	core.PuregoSafeRegister(&xSessionGetLocalAddress, libs, "soup_session_get_local_address")
+	core.PuregoSafeRegister(&xSessionGetMaxConns, libs, "soup_session_get_max_conns")
+	core.PuregoSafeRegister(&xSessionGetMaxConnsPerHost, libs, "soup_session_get_max_conns_per_host")
+	core.PuregoSafeRegister(&xSessionGetProxyResolver, libs, "soup_session_get_proxy_resolver")
+	core.PuregoSafeRegister(&xSessionGetRemoteConnectable, libs, "soup_session_get_remote_connectable")
+	core.PuregoSafeRegister(&xSessionGetTimeout, libs, "soup_session_get_timeout")
+	core.PuregoSafeRegister(&xSessionGetTlsDatabase, libs, "soup_session_get_tls_database")
+	core.PuregoSafeRegister(&xSessionGetTlsInteraction, libs, "soup_session_get_tls_interaction")
+	core.PuregoSafeRegister(&xSessionGetUserAgent, libs, "soup_session_get_user_agent")
+	core.PuregoSafeRegister(&xSessionHasFeature, libs, "soup_session_has_feature")
+	core.PuregoSafeRegister(&xSessionPreconnectAsync, libs, "soup_session_preconnect_async")
+	core.PuregoSafeRegister(&xSessionPreconnectFinish, libs, "soup_session_preconnect_finish")
+	core.PuregoSafeRegister(&xSessionRemoveFeature, libs, "soup_session_remove_feature")
+	core.PuregoSafeRegister(&xSessionRemoveFeatureByType, libs, "soup_session_remove_feature_by_type")
+	core.PuregoSafeRegister(&xSessionSend, libs, "soup_session_send")
+	core.PuregoSafeRegister(&xSessionSendAndRead, libs, "soup_session_send_and_read")
+	core.PuregoSafeRegister(&xSessionSendAndReadAsync, libs, "soup_session_send_and_read_async")
+	core.PuregoSafeRegister(&xSessionSendAndReadFinish, libs, "soup_session_send_and_read_finish")
+	core.PuregoSafeRegister(&xSessionSendAndSplice, libs, "soup_session_send_and_splice")
+	core.PuregoSafeRegister(&xSessionSendAndSpliceAsync, libs, "soup_session_send_and_splice_async")
+	core.PuregoSafeRegister(&xSessionSendAndSpliceFinish, libs, "soup_session_send_and_splice_finish")
+	core.PuregoSafeRegister(&xSessionSendAsync, libs, "soup_session_send_async")
+	core.PuregoSafeRegister(&xSessionSendFinish, libs, "soup_session_send_finish")
+	core.PuregoSafeRegister(&xSessionSetAcceptLanguage, libs, "soup_session_set_accept_language")
+	core.PuregoSafeRegister(&xSessionSetAcceptLanguageAuto, libs, "soup_session_set_accept_language_auto")
+	core.PuregoSafeRegister(&xSessionSetIdleTimeout, libs, "soup_session_set_idle_timeout")
+	core.PuregoSafeRegister(&xSessionSetProxyResolver, libs, "soup_session_set_proxy_resolver")
+	core.PuregoSafeRegister(&xSessionSetTimeout, libs, "soup_session_set_timeout")
+	core.PuregoSafeRegister(&xSessionSetTlsDatabase, libs, "soup_session_set_tls_database")
+	core.PuregoSafeRegister(&xSessionSetTlsInteraction, libs, "soup_session_set_tls_interaction")
+	core.PuregoSafeRegister(&xSessionSetUserAgent, libs, "soup_session_set_user_agent")
+	core.PuregoSafeRegister(&xSessionWebsocketConnectAsync, libs, "soup_session_websocket_connect_async")
+	core.PuregoSafeRegister(&xSessionWebsocketConnectFinish, libs, "soup_session_websocket_connect_finish")
+
+}
diff --git a/v4/soup/soup-status.go b/v4/soup/soup-status.go
new file mode 100644
index 0000000000000000000000000000000000000000..168d9b2cff2468d02f26f64d80d5d236030be23e
--- /dev/null
+++ b/v4/soup/soup-status.go
@@ -0,0 +1,206 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Indicates the HTTP protocol version being used.
+type HTTPVersion int
+
+var xHTTPVersionGLibType func() types.GType
+
+func HTTPVersionGLibType() types.GType {
+	return xHTTPVersionGLibType()
+}
+
+const (
+
+	// HTTP 1.0 (RFC 1945)
+	Http10Value HTTPVersion = 0
+	// HTTP 1.1 (RFC 2616)
+	Http11Value HTTPVersion = 1
+	// HTTP 2.0 (RFC 7540)
+	Http20Value HTTPVersion = 2
+)
+
+// These represent the known HTTP status code values, plus various
+// network and internal errors.
+//
+// Note that no libsoup functions take or return this type directly;
+// any function that works with status codes will accept unrecognized
+// status codes as well.
+type Status int
+
+var xStatusGLibType func() types.GType
+
+func StatusGLibType() types.GType {
+	return xStatusGLibType()
+}
+
+const (
+
+	// No status available. (Eg, the message has not
+	// been sent yet)
+	StatusNoneValue Status = 0
+	// 100 Continue (HTTP)
+	StatusContinueValue Status = 100
+	// 101 Switching Protocols (HTTP)
+	StatusSwitchingProtocolsValue Status = 101
+	// 102 Processing (WebDAV)
+	StatusProcessingValue Status = 102
+	// 200 Success (HTTP). Also used by many lower-level
+	// soup routines to indicate success.
+	StatusOkValue Status = 200
+	// 201 Created (HTTP)
+	StatusCreatedValue Status = 201
+	// 202 Accepted (HTTP)
+	StatusAcceptedValue Status = 202
+	// 203 Non-Authoritative Information
+	// (HTTP)
+	StatusNonAuthoritativeValue Status = 203
+	// 204 No Content (HTTP)
+	StatusNoContentValue Status = 204
+	// 205 Reset Content (HTTP)
+	StatusResetContentValue Status = 205
+	// 206 Partial Content (HTTP)
+	StatusPartialContentValue Status = 206
+	// 207 Multi-Status (WebDAV)
+	StatusMultiStatusValue Status = 207
+	// 300 Multiple Choices (HTTP)
+	StatusMultipleChoicesValue Status = 300
+	// 301 Moved Permanently (HTTP)
+	StatusMovedPermanentlyValue Status = 301
+	// 302 Found (HTTP)
+	StatusFoundValue Status = 302
+	// 302 Moved Temporarily (old name,
+	// RFC 2068)
+	StatusMovedTemporarilyValue Status = 302
+	// 303 See Other (HTTP)
+	StatusSeeOtherValue Status = 303
+	// 304 Not Modified (HTTP)
+	StatusNotModifiedValue Status = 304
+	// 305 Use Proxy (HTTP)
+	StatusUseProxyValue Status = 305
+	// 306 [Unused] (HTTP)
+	StatusNotAppearingInThisProtocolValue Status = 306
+	// 307 Temporary Redirect (HTTP)
+	StatusTemporaryRedirectValue Status = 307
+	// 308 Permanent Redirect (HTTP)
+	StatusPermanentRedirectValue Status = 308
+	// 400 Bad Request (HTTP)
+	StatusBadRequestValue Status = 400
+	// 401 Unauthorized (HTTP)
+	StatusUnauthorizedValue Status = 401
+	// 402 Payment Required (HTTP)
+	StatusPaymentRequiredValue Status = 402
+	// 403 Forbidden (HTTP)
+	StatusForbiddenValue Status = 403
+	// 404 Not Found (HTTP)
+	StatusNotFoundValue Status = 404
+	// 405 Method Not Allowed (HTTP)
+	StatusMethodNotAllowedValue Status = 405
+	// 406 Not Acceptable (HTTP)
+	StatusNotAcceptableValue Status = 406
+	// 407 Proxy Authentication
+	// Required (HTTP)
+	StatusProxyAuthenticationRequiredValue Status = 407
+	// shorter alias for
+	// %SOUP_STATUS_PROXY_AUTHENTICATION_REQUIRED
+	StatusProxyUnauthorizedValue Status = 407
+	// 408 Request Timeout (HTTP)
+	StatusRequestTimeoutValue Status = 408
+	// 409 Conflict (HTTP)
+	StatusConflictValue Status = 409
+	// 410 Gone (HTTP)
+	StatusGoneValue Status = 410
+	// 411 Length Required (HTTP)
+	StatusLengthRequiredValue Status = 411
+	// 412 Precondition Failed (HTTP)
+	StatusPreconditionFailedValue Status = 412
+	// 413 Request Entity Too Large
+	// (HTTP)
+	StatusRequestEntityTooLargeValue Status = 413
+	// 414 Request-URI Too Long (HTTP)
+	StatusRequestUriTooLongValue Status = 414
+	// 415 Unsupported Media Type
+	// (HTTP)
+	StatusUnsupportedMediaTypeValue Status = 415
+	// 416 Requested Range
+	// Not Satisfiable (HTTP)
+	StatusRequestedRangeNotSatisfiableValue Status = 416
+	// shorter alias for
+	// %SOUP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE
+	StatusInvalidRangeValue Status = 416
+	// 417 Expectation Failed (HTTP)
+	StatusExpectationFailedValue Status = 417
+	// 421 Misdirected Request
+	StatusMisdirectedRequestValue Status = 421
+	// 422 Unprocessable Entity
+	// (WebDAV)
+	StatusUnprocessableEntityValue Status = 422
+	// 423 Locked (WebDAV)
+	StatusLockedValue Status = 423
+	// 424 Failed Dependency (WebDAV)
+	StatusFailedDependencyValue Status = 424
+	// 500 Internal Server Error
+	// (HTTP)
+	StatusInternalServerErrorValue Status = 500
+	// 501 Not Implemented (HTTP)
+	StatusNotImplementedValue Status = 501
+	// 502 Bad Gateway (HTTP)
+	StatusBadGatewayValue Status = 502
+	// 503 Service Unavailable (HTTP)
+	StatusServiceUnavailableValue Status = 503
+	// 504 Gateway Timeout (HTTP)
+	StatusGatewayTimeoutValue Status = 504
+	// 505 HTTP Version Not
+	// Supported (HTTP)
+	StatusHttpVersionNotSupportedValue Status = 505
+	// 507 Insufficient Storage
+	// (WebDAV)
+	StatusInsufficientStorageValue Status = 507
+	// 510 Not Extended (RFC 2774)
+	StatusNotExtendedValue Status = 510
+)
+
+var xStatusGetPhrase func(uint) string
+
+// Looks up the stock HTTP description of @status_code.
+//
+// *There is no reason for you to ever use this
+// function.* If you wanted the textual description for the
+// [property@Message:status-code] of a given [class@Message], you should just
+// look at the message's [property@Message:reason-phrase]. However, you
+// should only do that for use in debugging messages; HTTP reason
+// phrases are not localized, and are not generally very descriptive
+// anyway, and so they should never be presented to the user directly.
+// Instead, you should create you own error messages based on the
+// status code, and on what you were trying to do.
+func StatusGetPhrase(StatusCodeVar uint) string {
+
+	cret := xStatusGetPhrase(StatusCodeVar)
+	return cret
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xHTTPVersionGLibType, libs, "soup_http_version_get_type")
+
+	core.PuregoSafeRegister(&xStatusGLibType, libs, "soup_status_get_type")
+
+	core.PuregoSafeRegister(&xStatusGetPhrase, libs, "soup_status_get_phrase")
+
+}
diff --git a/v4/soup/soup-tld.go b/v4/soup/soup-tld.go
new file mode 100644
index 0000000000000000000000000000000000000000..dde9ad013ba0b8ad3025ac15ae7174d74ffb3ae7
--- /dev/null
+++ b/v4/soup/soup-tld.go
@@ -0,0 +1,109 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Error codes for %SOUP_TLD_ERROR.
+type TLDError int
+
+var xTLDErrorGLibType func() types.GType
+
+func TLDErrorGLibType() types.GType {
+	return xTLDErrorGLibType()
+}
+
+const (
+
+	// A hostname was syntactically
+	//   invalid.
+	TldErrorInvalidHostnameValue TLDError = 0
+	// The passed-in "hostname" was
+	//   actually an IP address (and thus has no base domain or
+	//   public suffix).
+	TldErrorIsIpAddressValue TLDError = 1
+	// The passed-in hostname
+	//   did not have enough components. Eg, calling
+	//   [func@tld_get_base_domain] on &lt;literal&gt;"co.uk"&lt;/literal&gt;.
+	TldErrorNotEnoughDomainsValue TLDError = 2
+	// The passed-in hostname has
+	//   no recognized public suffix.
+	TldErrorNoBaseDomainValue TLDError = 3
+	// The Public Suffix List was not
+	//   available.
+	TldErrorNoPslDataValue TLDError = 4
+)
+
+var xTldDomainIsPublicSuffix func(string) bool
+
+// Looks whether the @domain passed as argument is a public domain
+// suffix (.org, .com, .co.uk, etc) or not.
+//
+// Prior to libsoup 2.46, this function required that @domain be in
+// UTF-8 if it was an IDN. From 2.46 on, the name can be in either
+// UTF-8 or ASCII format.
+func TldDomainIsPublicSuffix(DomainVar string) bool {
+
+	cret := xTldDomainIsPublicSuffix(DomainVar)
+	return cret
+}
+
+var xTldErrorQuark func() glib.Quark
+
+// Registers error quark for soup_tld_get_base_domain() if needed.
+func TldErrorQuark() glib.Quark {
+
+	cret := xTldErrorQuark()
+	return cret
+}
+
+var xTldGetBaseDomain func(string, **glib.Error) string
+
+// Finds the base domain for a given @hostname
+//
+// The base domain is composed by the top level domain (such as .org, .com,
+// .co.uk, etc) plus the second level domain, for example for
+// myhost.mydomain.com it will return mydomain.com.
+//
+// Note that %NULL will be returned for private URLs (those not ending
+// with any well known TLD) because choosing a base domain for them
+// would be totally arbitrary.
+//
+// Prior to libsoup 2.46, this function required that @hostname be in
+// UTF-8 if it was an IDN. From 2.46 on, the name can be in either
+// UTF-8 or ASCII format (and the return value will be in the same
+// format).
+func TldGetBaseDomain(HostnameVar string) (string, error) {
+	var cerr *glib.Error
+
+	cret := xTldGetBaseDomain(HostnameVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xTLDErrorGLibType, libs, "soup_tld_error_get_type")
+
+	core.PuregoSafeRegister(&xTldDomainIsPublicSuffix, libs, "soup_tld_domain_is_public_suffix")
+	core.PuregoSafeRegister(&xTldErrorQuark, libs, "soup_tld_error_quark")
+	core.PuregoSafeRegister(&xTldGetBaseDomain, libs, "soup_tld_get_base_domain")
+
+}
diff --git a/v4/soup/soup-types.go b/v4/soup/soup-types.go
new file mode 100644
index 0000000000000000000000000000000000000000..42121f53d8520c1ad089d135ca8b3ebbf31372a5
--- /dev/null
+++ b/v4/soup/soup-types.go
@@ -0,0 +1,830 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Implements HTTP cookies, as described by
+// [RFC 6265](http://tools.ietf.org/html/rfc6265.txt).
+//
+// To have a [class@Session] handle cookies for your appliction
+// automatically, use a [class@CookieJar].
+//
+// @name and @value will be set for all cookies. If the cookie is
+// generated from a string that appears to have no name, then @name
+// will be the empty string.
+//
+// @domain and @path give the host or domain, and path within that
+// host/domain, to restrict this cookie to. If @domain starts with
+// ".", that indicates a domain (which matches the string after the
+// ".", or any hostname that has @domain as a suffix). Otherwise, it
+// is a hostname and must match exactly.
+//
+// @expires will be non-%NULL if the cookie uses either the original
+// "expires" attribute, or the newer "max-age" attribute. If @expires
+// is %NULL, it indicates that neither "expires" nor "max-age" was
+// specified, and the cookie expires at the end of the session.
+//
+// If @http_only is set, the cookie should not be exposed to untrusted
+// code (eg, javascript), so as to minimize the danger posed by
+// cross-site scripting attacks.
+type Cookie struct {
+	_ structs.HostLayout
+}
+
+var xCookieGLibType func() types.GType
+
+func CookieGLibType() types.GType {
+	return xCookieGLibType()
+}
+
+func (x *Cookie) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewCookie func(string, string, string, string, int) *Cookie
+
+// Creates a new #SoupCookie with the given attributes.
+//
+// Use [method@Cookie.set_secure] and [method@Cookie.set_http_only] if you
+// need to set those attributes on the returned cookie.
+//
+// If @domain starts with ".", that indicates a domain (which matches
+// the string after the ".", or any hostname that has @domain as a
+// suffix). Otherwise, it is a hostname and must match exactly.
+//
+// @max_age is used to set the "expires" attribute on the cookie; pass
+// -1 to not include the attribute (indicating that the cookie expires
+// with the current session), 0 for an already-expired cookie, or a
+// lifetime in seconds. You can use the constants
+// %SOUP_COOKIE_MAX_AGE_ONE_HOUR, %SOUP_COOKIE_MAX_AGE_ONE_DAY,
+// %SOUP_COOKIE_MAX_AGE_ONE_WEEK and %SOUP_COOKIE_MAX_AGE_ONE_YEAR (or
+// multiples thereof) to calculate this value. (If you really care
+// about setting the exact time that the cookie will expire, use
+// [method@Cookie.set_expires].)
+//
+// As of version 3.4.0 the default value of a cookie's same-site-policy
+// is %SOUP_SAME_SITE_POLICY_LAX.
+func NewCookie(NameVar string, ValueVar string, DomainVar string, PathVar string, MaxAgeVar int) *Cookie {
+
+	cret := xNewCookie(NameVar, ValueVar, DomainVar, PathVar, MaxAgeVar)
+	return cret
+}
+
+var xCookieAppliesToUri func(uintptr, *glib.Uri) bool
+
+// Tests if @cookie should be sent to @uri.
+//
+// (At the moment, this does not check that @cookie's domain matches
+// @uri, because it assumes that the caller has already done that.
+// But don't rely on that; it may change in the future.)
+func (x *Cookie) AppliesToUri(UriVar *glib.Uri) bool {
+
+	cret := xCookieAppliesToUri(x.GoPointer(), UriVar)
+	return cret
+}
+
+var xCookieCopy func(uintptr) *Cookie
+
+// Copies @cookie.
+func (x *Cookie) Copy() *Cookie {
+
+	cret := xCookieCopy(x.GoPointer())
+	return cret
+}
+
+var xCookieDomainMatches func(uintptr, string) bool
+
+// Checks if the @cookie's domain and @host match.
+//
+// The domains match if @cookie should be sent when making a request to @host,
+// or that @cookie should be accepted when receiving a response from @host.
+func (x *Cookie) DomainMatches(HostVar string) bool {
+
+	cret := xCookieDomainMatches(x.GoPointer(), HostVar)
+	return cret
+}
+
+var xCookieEqual func(uintptr, *Cookie) bool
+
+// Tests if @cookie1 and @cookie2 are equal.
+//
+// Note that currently, this does not check that the cookie domains
+// match. This may change in the future.
+func (x *Cookie) Equal(Cookie2Var *Cookie) bool {
+
+	cret := xCookieEqual(x.GoPointer(), Cookie2Var)
+	return cret
+}
+
+var xCookieFree func(uintptr)
+
+// Frees @cookie.
+func (x *Cookie) Free() {
+
+	xCookieFree(x.GoPointer())
+
+}
+
+var xCookieGetDomain func(uintptr) string
+
+// Gets @cookie's domain.
+func (x *Cookie) GetDomain() string {
+
+	cret := xCookieGetDomain(x.GoPointer())
+	return cret
+}
+
+var xCookieGetExpires func(uintptr) *glib.DateTime
+
+// Gets @cookie's expiration time.
+func (x *Cookie) GetExpires() *glib.DateTime {
+
+	cret := xCookieGetExpires(x.GoPointer())
+	return cret
+}
+
+var xCookieGetHttpOnly func(uintptr) bool
+
+// Gets @cookie's HttpOnly attribute.
+func (x *Cookie) GetHttpOnly() bool {
+
+	cret := xCookieGetHttpOnly(x.GoPointer())
+	return cret
+}
+
+var xCookieGetName func(uintptr) string
+
+// Gets @cookie's name.
+func (x *Cookie) GetName() string {
+
+	cret := xCookieGetName(x.GoPointer())
+	return cret
+}
+
+var xCookieGetPath func(uintptr) string
+
+// Gets @cookie's path.
+func (x *Cookie) GetPath() string {
+
+	cret := xCookieGetPath(x.GoPointer())
+	return cret
+}
+
+var xCookieGetSameSitePolicy func(uintptr) SameSitePolicy
+
+// Returns the same-site policy for this cookie.
+func (x *Cookie) GetSameSitePolicy() SameSitePolicy {
+
+	cret := xCookieGetSameSitePolicy(x.GoPointer())
+	return cret
+}
+
+var xCookieGetSecure func(uintptr) bool
+
+// Gets @cookie's secure attribute.
+func (x *Cookie) GetSecure() bool {
+
+	cret := xCookieGetSecure(x.GoPointer())
+	return cret
+}
+
+var xCookieGetValue func(uintptr) string
+
+// Gets @cookie's value.
+func (x *Cookie) GetValue() string {
+
+	cret := xCookieGetValue(x.GoPointer())
+	return cret
+}
+
+var xCookieSetDomain func(uintptr, string)
+
+// Sets @cookie's domain to @domain.
+func (x *Cookie) SetDomain(DomainVar string) {
+
+	xCookieSetDomain(x.GoPointer(), DomainVar)
+
+}
+
+var xCookieSetExpires func(uintptr, *glib.DateTime)
+
+// Sets @cookie's expiration time to @expires.
+//
+// If @expires is %NULL, @cookie will be a session cookie and will expire at the
+// end of the client's session.
+//
+// (This sets the same property as [method@Cookie.set_max_age].)
+func (x *Cookie) SetExpires(ExpiresVar *glib.DateTime) {
+
+	xCookieSetExpires(x.GoPointer(), ExpiresVar)
+
+}
+
+var xCookieSetHttpOnly func(uintptr, bool)
+
+// Sets @cookie's HttpOnly attribute to @http_only.
+//
+// If %TRUE, @cookie will be marked as "http only", meaning it should not be
+// exposed to web page scripts or other untrusted code.
+func (x *Cookie) SetHttpOnly(HttpOnlyVar bool) {
+
+	xCookieSetHttpOnly(x.GoPointer(), HttpOnlyVar)
+
+}
+
+var xCookieSetMaxAge func(uintptr, int)
+
+// Sets @cookie's max age to @max_age.
+//
+// If @max_age is -1, the cookie is a session cookie, and will expire at the end
+// of the client's session. Otherwise, it is the number of seconds until the
+// cookie expires. You can use the constants %SOUP_COOKIE_MAX_AGE_ONE_HOUR,
+// %SOUP_COOKIE_MAX_AGE_ONE_DAY, %SOUP_COOKIE_MAX_AGE_ONE_WEEK and
+// %SOUP_COOKIE_MAX_AGE_ONE_YEAR (or multiples thereof) to calculate this value.
+// (A value of 0 indicates that the cookie should be considered
+// already-expired.)
+//
+// This sets the same property as [method@Cookie.set_expires].
+func (x *Cookie) SetMaxAge(MaxAgeVar int) {
+
+	xCookieSetMaxAge(x.GoPointer(), MaxAgeVar)
+
+}
+
+var xCookieSetName func(uintptr, string)
+
+// Sets @cookie's name to @name.
+func (x *Cookie) SetName(NameVar string) {
+
+	xCookieSetName(x.GoPointer(), NameVar)
+
+}
+
+var xCookieSetPath func(uintptr, string)
+
+// Sets @cookie's path to @path.
+func (x *Cookie) SetPath(PathVar string) {
+
+	xCookieSetPath(x.GoPointer(), PathVar)
+
+}
+
+var xCookieSetSameSitePolicy func(uintptr, SameSitePolicy)
+
+// When used in conjunction with
+// [method@CookieJar.get_cookie_list_with_same_site_info] this sets the policy
+// of when this cookie should be exposed.
+func (x *Cookie) SetSameSitePolicy(PolicyVar SameSitePolicy) {
+
+	xCookieSetSameSitePolicy(x.GoPointer(), PolicyVar)
+
+}
+
+var xCookieSetSecure func(uintptr, bool)
+
+// Sets @cookie's secure attribute to @secure.
+//
+// If %TRUE, @cookie will only be transmitted from the client to the server over
+// secure (https) connections.
+func (x *Cookie) SetSecure(SecureVar bool) {
+
+	xCookieSetSecure(x.GoPointer(), SecureVar)
+
+}
+
+var xCookieSetValue func(uintptr, string)
+
+// Sets @cookie's value to @value.
+func (x *Cookie) SetValue(ValueVar string) {
+
+	xCookieSetValue(x.GoPointer(), ValueVar)
+
+}
+
+var xCookieToCookieHeader func(uintptr) string
+
+// Serializes @cookie in the format used by the Cookie header (ie, for
+// returning a cookie from a [class@Session] to a server).
+func (x *Cookie) ToCookieHeader() string {
+
+	cret := xCookieToCookieHeader(x.GoPointer())
+	return cret
+}
+
+var xCookieToSetCookieHeader func(uintptr) string
+
+// Serializes @cookie in the format used by the Set-Cookie header.
+//
+// i.e. for sending a cookie from a [class@Server] to a client.
+func (x *Cookie) ToSetCookieHeader() string {
+
+	cret := xCookieToSetCookieHeader(x.GoPointer())
+	return cret
+}
+
+// #SoupHSTSPolicy implements HTTP policies, as described by
+// [RFC 6797](http://tools.ietf.org/html/rfc6797).
+//
+// @domain represents the host that this policy applies to. The domain
+// must be IDNA-canonicalized. [ctor@HSTSPolicy.new] and related methods
+// will do this for you.
+//
+// @max_age contains the 'max-age' value from the Strict Transport
+// Security header and indicates the time to live of this policy,
+// in seconds.
+//
+// @expires will be non-%NULL if the policy has been set by the host and
+// hence has an expiry time. If @expires is %NULL, it indicates that the
+// policy is a permanent session policy set by the user agent.
+//
+// If @include_subdomains is %TRUE, the Strict Transport Security policy
+// must also be enforced on subdomains of @domain.
+type HSTSPolicy struct {
+	_ structs.HostLayout
+}
+
+var xHSTSPolicyGLibType func() types.GType
+
+func HSTSPolicyGLibType() types.GType {
+	return xHSTSPolicyGLibType()
+}
+
+func (x *HSTSPolicy) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewHSTSPolicy func(string, uint32, bool) *HSTSPolicy
+
+// Creates a new #SoupHSTSPolicy with the given attributes.
+//
+// @domain is a domain on which the strict transport security policy
+// represented by this object must be enforced.
+//
+// @max_age is used to set the "expires" attribute on the policy; pass
+// %SOUP_HSTS_POLICY_MAX_AGE_PAST for an already-expired policy, or a
+// lifetime in seconds.
+//
+// If @include_subdomains is %TRUE, the strict transport security policy
+// must also be enforced on all subdomains of @domain.
+func NewHSTSPolicy(DomainVar string, MaxAgeVar uint32, IncludeSubdomainsVar bool) *HSTSPolicy {
+
+	cret := xNewHSTSPolicy(DomainVar, MaxAgeVar, IncludeSubdomainsVar)
+	return cret
+}
+
+var xNewHSTSPolicyFromResponse func(uintptr) *HSTSPolicy
+
+// Parses @msg's first "Strict-Transport-Security" response header and
+// returns a #SoupHSTSPolicy.
+func NewHSTSPolicyFromResponse(MsgVar *Message) *HSTSPolicy {
+
+	cret := xNewHSTSPolicyFromResponse(MsgVar.GoPointer())
+	return cret
+}
+
+var xNewHSTSPolicyFull func(string, uint32, *glib.DateTime, bool) *HSTSPolicy
+
+// Full version of [ctor@HSTSPolicy.new], to use with an existing
+// expiration date.
+//
+// See [ctor@HSTSPolicy.new] for details.
+func NewHSTSPolicyFull(DomainVar string, MaxAgeVar uint32, ExpiresVar *glib.DateTime, IncludeSubdomainsVar bool) *HSTSPolicy {
+
+	cret := xNewHSTSPolicyFull(DomainVar, MaxAgeVar, ExpiresVar, IncludeSubdomainsVar)
+	return cret
+}
+
+var xNewHSTSPolicySessionPolicy func(string, bool) *HSTSPolicy
+
+// Creates a new session #SoupHSTSPolicy with the given attributes.
+//
+// A session policy is a policy that is valid during the lifetime of
+// the [class@HSTSEnforcer] it is added to. Contrary to regular policies,
+// it has no expiration date and is not stored in persistent
+// enforcers. These policies are useful for user-agent to load their
+// own or user-defined rules.
+//
+// @domain is a domain on which the strict transport security policy
+// represented by this object must be enforced.
+//
+// If @include_subdomains is %TRUE, the strict transport security policy
+// must also be enforced on all subdomains of @domain.
+func NewHSTSPolicySessionPolicy(DomainVar string, IncludeSubdomainsVar bool) *HSTSPolicy {
+
+	cret := xNewHSTSPolicySessionPolicy(DomainVar, IncludeSubdomainsVar)
+	return cret
+}
+
+var xHSTSPolicyCopy func(uintptr) *HSTSPolicy
+
+// Copies @policy.
+func (x *HSTSPolicy) Copy() *HSTSPolicy {
+
+	cret := xHSTSPolicyCopy(x.GoPointer())
+	return cret
+}
+
+var xHSTSPolicyEqual func(uintptr, *HSTSPolicy) bool
+
+// Tests if @policy1 and @policy2 are equal.
+func (x *HSTSPolicy) Equal(Policy2Var *HSTSPolicy) bool {
+
+	cret := xHSTSPolicyEqual(x.GoPointer(), Policy2Var)
+	return cret
+}
+
+var xHSTSPolicyFree func(uintptr)
+
+// Frees @policy.
+func (x *HSTSPolicy) Free() {
+
+	xHSTSPolicyFree(x.GoPointer())
+
+}
+
+var xHSTSPolicyGetDomain func(uintptr) string
+
+// Gets @policy's domain.
+func (x *HSTSPolicy) GetDomain() string {
+
+	cret := xHSTSPolicyGetDomain(x.GoPointer())
+	return cret
+}
+
+var xHSTSPolicyGetExpires func(uintptr) *glib.DateTime
+
+// Returns the expiration date for @policy.
+func (x *HSTSPolicy) GetExpires() *glib.DateTime {
+
+	cret := xHSTSPolicyGetExpires(x.GoPointer())
+	return cret
+}
+
+var xHSTSPolicyGetMaxAge func(uintptr) uint32
+
+// Returns the max age for @policy.
+func (x *HSTSPolicy) GetMaxAge() uint32 {
+
+	cret := xHSTSPolicyGetMaxAge(x.GoPointer())
+	return cret
+}
+
+var xHSTSPolicyIncludesSubdomains func(uintptr) bool
+
+// Gets whether @policy include its subdomains.
+func (x *HSTSPolicy) IncludesSubdomains() bool {
+
+	cret := xHSTSPolicyIncludesSubdomains(x.GoPointer())
+	return cret
+}
+
+var xHSTSPolicyIsExpired func(uintptr) bool
+
+// Gets whether @policy is expired.
+//
+// Permanent policies never expire.
+func (x *HSTSPolicy) IsExpired() bool {
+
+	cret := xHSTSPolicyIsExpired(x.GoPointer())
+	return cret
+}
+
+var xHSTSPolicyIsSessionPolicy func(uintptr) bool
+
+// Gets whether @policy is a non-permanent, non-expirable session policy.
+//
+// See [ctor@HSTSPolicy.new_session_policy] for details.
+func (x *HSTSPolicy) IsSessionPolicy() bool {
+
+	cret := xHSTSPolicyIsSessionPolicy(x.GoPointer())
+	return cret
+}
+
+// Contains metrics collected while loading a [class@Message] either from the
+// network or the disk cache.
+//
+// Metrics are not collected by default for a [class@Message], you need to add the
+// flag %SOUP_MESSAGE_COLLECT_METRICS to enable the feature.
+//
+// Temporal metrics are expressed as a monotonic time and always start with a
+// fetch start event and finish with response end. All other events are optional.
+// An event can be 0 because it hasn't happened yet, because it's optional or
+// because the load failed before the event reached.
+//
+// Size metrics are expressed in bytes and are updated while the [class@Message] is
+// being loaded. You can connect to different [class@Message] signals to get the
+// final result of every value.
+type MessageMetrics struct {
+	_ structs.HostLayout
+}
+
+var xMessageMetricsGLibType func() types.GType
+
+func MessageMetricsGLibType() types.GType {
+	return xMessageMetricsGLibType()
+}
+
+func (x *MessageMetrics) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xMessageMetricsCopy func(uintptr) *MessageMetrics
+
+// Copies @metrics.
+func (x *MessageMetrics) Copy() *MessageMetrics {
+
+	cret := xMessageMetricsCopy(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsFree func(uintptr)
+
+// Frees @metrics.
+func (x *MessageMetrics) Free() {
+
+	xMessageMetricsFree(x.GoPointer())
+
+}
+
+var xMessageMetricsGetConnectEnd func(uintptr) uint64
+
+// Get the time immediately after the [class@Message] completed the
+// connection to the server. This includes the time for the proxy
+// negotiation and TLS handshake.
+//
+// It will be 0 if no network connection was required to fetch the resource (a
+// persistent connection was used or resource was loaded from the local disk
+// cache).
+func (x *MessageMetrics) GetConnectEnd() uint64 {
+
+	cret := xMessageMetricsGetConnectEnd(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetConnectStart func(uintptr) uint64
+
+// Get the time immediately before the [class@Message] started to
+// establish the connection to the server.
+//
+// It will be 0 if no network connection was required to fetch the resource (a
+// persistent connection was used or resource was loaded from the local disk
+// cache).
+func (x *MessageMetrics) GetConnectStart() uint64 {
+
+	cret := xMessageMetricsGetConnectStart(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetDnsEnd func(uintptr) uint64
+
+// Get the time immediately after the [class@Message] completed the
+// domain lookup name for the resource.
+//
+// It will be 0 if no domain lookup was required to fetch the resource (a
+// persistent connection was used or resource was loaded from the local disk
+// cache).
+func (x *MessageMetrics) GetDnsEnd() uint64 {
+
+	cret := xMessageMetricsGetDnsEnd(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetDnsStart func(uintptr) uint64
+
+// Get the time immediately before the [class@Message] started the
+// domain lookup name for the resource.
+//
+// It will be 0 if no domain lookup was required to fetch the resource (a
+// persistent connection was used or resource was loaded from the local disk
+// cache).
+func (x *MessageMetrics) GetDnsStart() uint64 {
+
+	cret := xMessageMetricsGetDnsStart(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetFetchStart func(uintptr) uint64
+
+// Get the time immediately before the [class@Message] started to
+// fetch a resource either from a remote server or local disk cache.
+func (x *MessageMetrics) GetFetchStart() uint64 {
+
+	cret := xMessageMetricsGetFetchStart(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetRequestBodyBytesSent func(uintptr) uint64
+
+// Get the number of bytes sent to the network for the request body.
+//
+// This is the size of the body sent, after encodings are applied, so it might
+// be greater than the value returned by
+// [method@MessageMetrics.get_request_body_size]. This value is available right
+// before [signal@Message::wrote-body] signal is emitted, but you might get an
+// intermediate value if called before.
+func (x *MessageMetrics) GetRequestBodyBytesSent() uint64 {
+
+	cret := xMessageMetricsGetRequestBodyBytesSent(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetRequestBodySize func(uintptr) uint64
+
+// Get the request body size in bytes. This is the size of the original body
+// given to the request before any encoding is applied.
+//
+// This value is available right before [signal@Message::wrote-body] signal is
+// emitted, but you might get an intermediate value if called before.
+func (x *MessageMetrics) GetRequestBodySize() uint64 {
+
+	cret := xMessageMetricsGetRequestBodySize(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetRequestHeaderBytesSent func(uintptr) uint64
+
+// Get the number of bytes sent to the network for the request headers.
+//
+// This value is available right before [signal@Message::wrote-headers] signal
+// is emitted, but you might get an intermediate value if called before.
+func (x *MessageMetrics) GetRequestHeaderBytesSent() uint64 {
+
+	cret := xMessageMetricsGetRequestHeaderBytesSent(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetRequestStart func(uintptr) uint64
+
+// Get the time immediately before the [class@Message] started the
+// request of the resource from the server or the local disk cache.
+func (x *MessageMetrics) GetRequestStart() uint64 {
+
+	cret := xMessageMetricsGetRequestStart(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetResponseBodyBytesReceived func(uintptr) uint64
+
+// Get the number of bytes received from the network for the response body.
+//
+// This value is available right before [signal@Message::got-body] signal is
+// emitted, but you might get an intermediate value if called before. For
+// resources loaded from the disk cache this value is always 0.
+func (x *MessageMetrics) GetResponseBodyBytesReceived() uint64 {
+
+	cret := xMessageMetricsGetResponseBodyBytesReceived(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetResponseBodySize func(uintptr) uint64
+
+// Get the response body size in bytes.
+//
+// This is the size of the body as given to the user after all encodings are
+// applied, so it might be greater than the value returned by
+// [method@MessageMetrics.get_response_body_bytes_received]. This value is
+// available right before [signal@Message::got-body] signal is emitted, but you
+// might get an intermediate value if called before.
+func (x *MessageMetrics) GetResponseBodySize() uint64 {
+
+	cret := xMessageMetricsGetResponseBodySize(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetResponseEnd func(uintptr) uint64
+
+// Get the time immediately after the [class@Message] received the last
+// bytes of the response from the server or the local disk cache.
+//
+// In case of load failure, this returns the time immediately before the
+// fetch is aborted.
+func (x *MessageMetrics) GetResponseEnd() uint64 {
+
+	cret := xMessageMetricsGetResponseEnd(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetResponseHeaderBytesReceived func(uintptr) uint64
+
+// Get the number of bytes received from the network for the response headers.
+//
+// This value is available right before [signal@Message::got-headers] signal
+// is emitted, but you might get an intermediate value if called before.
+// For resources loaded from the disk cache this value is always 0.
+func (x *MessageMetrics) GetResponseHeaderBytesReceived() uint64 {
+
+	cret := xMessageMetricsGetResponseHeaderBytesReceived(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetResponseStart func(uintptr) uint64
+
+// Get the time immediately after the [class@Message] received the first
+// bytes of the response from the server or the local disk cache.
+func (x *MessageMetrics) GetResponseStart() uint64 {
+
+	cret := xMessageMetricsGetResponseStart(x.GoPointer())
+	return cret
+}
+
+var xMessageMetricsGetTlsStart func(uintptr) uint64
+
+// Get the time immediately before the [class@Message] started the
+// TLS handshake.
+//
+// It will be 0 if no TLS handshake was required to fetch the resource
+// (connection was not secure, a persistent connection was used or resource was
+// loaded from the local disk cache).
+func (x *MessageMetrics) GetTlsStart() uint64 {
+
+	cret := xMessageMetricsGetTlsStart(x.GoPointer())
+	return cret
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xCookieGLibType, libs, "soup_cookie_get_type")
+
+	core.PuregoSafeRegister(&xNewCookie, libs, "soup_cookie_new")
+
+	core.PuregoSafeRegister(&xCookieAppliesToUri, libs, "soup_cookie_applies_to_uri")
+	core.PuregoSafeRegister(&xCookieCopy, libs, "soup_cookie_copy")
+	core.PuregoSafeRegister(&xCookieDomainMatches, libs, "soup_cookie_domain_matches")
+	core.PuregoSafeRegister(&xCookieEqual, libs, "soup_cookie_equal")
+	core.PuregoSafeRegister(&xCookieFree, libs, "soup_cookie_free")
+	core.PuregoSafeRegister(&xCookieGetDomain, libs, "soup_cookie_get_domain")
+	core.PuregoSafeRegister(&xCookieGetExpires, libs, "soup_cookie_get_expires")
+	core.PuregoSafeRegister(&xCookieGetHttpOnly, libs, "soup_cookie_get_http_only")
+	core.PuregoSafeRegister(&xCookieGetName, libs, "soup_cookie_get_name")
+	core.PuregoSafeRegister(&xCookieGetPath, libs, "soup_cookie_get_path")
+	core.PuregoSafeRegister(&xCookieGetSameSitePolicy, libs, "soup_cookie_get_same_site_policy")
+	core.PuregoSafeRegister(&xCookieGetSecure, libs, "soup_cookie_get_secure")
+	core.PuregoSafeRegister(&xCookieGetValue, libs, "soup_cookie_get_value")
+	core.PuregoSafeRegister(&xCookieSetDomain, libs, "soup_cookie_set_domain")
+	core.PuregoSafeRegister(&xCookieSetExpires, libs, "soup_cookie_set_expires")
+	core.PuregoSafeRegister(&xCookieSetHttpOnly, libs, "soup_cookie_set_http_only")
+	core.PuregoSafeRegister(&xCookieSetMaxAge, libs, "soup_cookie_set_max_age")
+	core.PuregoSafeRegister(&xCookieSetName, libs, "soup_cookie_set_name")
+	core.PuregoSafeRegister(&xCookieSetPath, libs, "soup_cookie_set_path")
+	core.PuregoSafeRegister(&xCookieSetSameSitePolicy, libs, "soup_cookie_set_same_site_policy")
+	core.PuregoSafeRegister(&xCookieSetSecure, libs, "soup_cookie_set_secure")
+	core.PuregoSafeRegister(&xCookieSetValue, libs, "soup_cookie_set_value")
+	core.PuregoSafeRegister(&xCookieToCookieHeader, libs, "soup_cookie_to_cookie_header")
+	core.PuregoSafeRegister(&xCookieToSetCookieHeader, libs, "soup_cookie_to_set_cookie_header")
+
+	core.PuregoSafeRegister(&xHSTSPolicyGLibType, libs, "soup_hsts_policy_get_type")
+
+	core.PuregoSafeRegister(&xNewHSTSPolicy, libs, "soup_hsts_policy_new")
+	core.PuregoSafeRegister(&xNewHSTSPolicyFromResponse, libs, "soup_hsts_policy_new_from_response")
+	core.PuregoSafeRegister(&xNewHSTSPolicyFull, libs, "soup_hsts_policy_new_full")
+	core.PuregoSafeRegister(&xNewHSTSPolicySessionPolicy, libs, "soup_hsts_policy_new_session_policy")
+
+	core.PuregoSafeRegister(&xHSTSPolicyCopy, libs, "soup_hsts_policy_copy")
+	core.PuregoSafeRegister(&xHSTSPolicyEqual, libs, "soup_hsts_policy_equal")
+	core.PuregoSafeRegister(&xHSTSPolicyFree, libs, "soup_hsts_policy_free")
+	core.PuregoSafeRegister(&xHSTSPolicyGetDomain, libs, "soup_hsts_policy_get_domain")
+	core.PuregoSafeRegister(&xHSTSPolicyGetExpires, libs, "soup_hsts_policy_get_expires")
+	core.PuregoSafeRegister(&xHSTSPolicyGetMaxAge, libs, "soup_hsts_policy_get_max_age")
+	core.PuregoSafeRegister(&xHSTSPolicyIncludesSubdomains, libs, "soup_hsts_policy_includes_subdomains")
+	core.PuregoSafeRegister(&xHSTSPolicyIsExpired, libs, "soup_hsts_policy_is_expired")
+	core.PuregoSafeRegister(&xHSTSPolicyIsSessionPolicy, libs, "soup_hsts_policy_is_session_policy")
+
+	core.PuregoSafeRegister(&xMessageMetricsGLibType, libs, "soup_message_metrics_get_type")
+
+	core.PuregoSafeRegister(&xMessageMetricsCopy, libs, "soup_message_metrics_copy")
+	core.PuregoSafeRegister(&xMessageMetricsFree, libs, "soup_message_metrics_free")
+	core.PuregoSafeRegister(&xMessageMetricsGetConnectEnd, libs, "soup_message_metrics_get_connect_end")
+	core.PuregoSafeRegister(&xMessageMetricsGetConnectStart, libs, "soup_message_metrics_get_connect_start")
+	core.PuregoSafeRegister(&xMessageMetricsGetDnsEnd, libs, "soup_message_metrics_get_dns_end")
+	core.PuregoSafeRegister(&xMessageMetricsGetDnsStart, libs, "soup_message_metrics_get_dns_start")
+	core.PuregoSafeRegister(&xMessageMetricsGetFetchStart, libs, "soup_message_metrics_get_fetch_start")
+	core.PuregoSafeRegister(&xMessageMetricsGetRequestBodyBytesSent, libs, "soup_message_metrics_get_request_body_bytes_sent")
+	core.PuregoSafeRegister(&xMessageMetricsGetRequestBodySize, libs, "soup_message_metrics_get_request_body_size")
+	core.PuregoSafeRegister(&xMessageMetricsGetRequestHeaderBytesSent, libs, "soup_message_metrics_get_request_header_bytes_sent")
+	core.PuregoSafeRegister(&xMessageMetricsGetRequestStart, libs, "soup_message_metrics_get_request_start")
+	core.PuregoSafeRegister(&xMessageMetricsGetResponseBodyBytesReceived, libs, "soup_message_metrics_get_response_body_bytes_received")
+	core.PuregoSafeRegister(&xMessageMetricsGetResponseBodySize, libs, "soup_message_metrics_get_response_body_size")
+	core.PuregoSafeRegister(&xMessageMetricsGetResponseEnd, libs, "soup_message_metrics_get_response_end")
+	core.PuregoSafeRegister(&xMessageMetricsGetResponseHeaderBytesReceived, libs, "soup_message_metrics_get_response_header_bytes_received")
+	core.PuregoSafeRegister(&xMessageMetricsGetResponseStart, libs, "soup_message_metrics_get_response_start")
+	core.PuregoSafeRegister(&xMessageMetricsGetTlsStart, libs, "soup_message_metrics_get_tls_start")
+
+}
diff --git a/v4/soup/soup-uri-utils.go b/v4/soup/soup-uri-utils.go
new file mode 100644
index 0000000000000000000000000000000000000000..fb14f3b6439bc111fa39bd14bf2a74b2c77fad58
--- /dev/null
+++ b/v4/soup/soup-uri-utils.go
@@ -0,0 +1,100 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+const (
+	// The set of #GUriFlags libsoup expects all #GUri to use.
+	HTTP_URI_FLAGS int = 482
+)
+
+// Enum values passed to [func@uri_copy] to indicate the components of
+// the URI that should be updated with the given values.
+type URIComponent int
+
+var xURIComponentGLibType func() types.GType
+
+func URIComponentGLibType() types.GType {
+	return xURIComponentGLibType()
+}
+
+const (
+
+	// no component
+	UriNoneValue URIComponent = 0
+	// the URI scheme component
+	UriSchemeValue URIComponent = 1
+	// the URI user component
+	UriUserValue URIComponent = 2
+	// the URI password component
+	UriPasswordValue URIComponent = 3
+	// the URI authentication parameters component
+	UriAuthParamsValue URIComponent = 4
+	// the URI host component
+	UriHostValue URIComponent = 5
+	// the URI port component
+	UriPortValue URIComponent = 6
+	// the URI path component
+	UriPathValue URIComponent = 7
+	// the URI query component
+	UriQueryValue URIComponent = 8
+	// the URI fragment component
+	UriFragmentValue URIComponent = 9
+)
+
+var xUriCopy func(*glib.Uri, URIComponent, ...interface{}) *glib.Uri
+
+// As of 3.4.0 this will detect the default ports of HTTP(s) and WS(S)
+// URIs when copying and set it to the default port of the new scheme.
+// So for example copying `http://localhost:80` while changing the scheme to https
+// will result in `https://localhost:443`.
+//
+// Return a copy of @uri with the given components updated.
+func UriCopy(UriVar *glib.Uri, FirstComponentVar URIComponent, varArgs ...interface{}) *glib.Uri {
+
+	cret := xUriCopy(UriVar, FirstComponentVar, varArgs...)
+	return cret
+}
+
+var xUriDecodeDataUri func(string, *string) *glib.Bytes
+
+// Decodes the given data URI and returns its contents and @content_type.
+func UriDecodeDataUri(UriVar string, ContentTypeVar *string) *glib.Bytes {
+
+	cret := xUriDecodeDataUri(UriVar, ContentTypeVar)
+	return cret
+}
+
+var xUriEqual func(*glib.Uri, *glib.Uri) bool
+
+// Tests whether or not @uri1 and @uri2 are equal in all parts.
+func UriEqual(Uri1Var *glib.Uri, Uri2Var *glib.Uri) bool {
+
+	cret := xUriEqual(Uri1Var, Uri2Var)
+	return cret
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xURIComponentGLibType, libs, "soup_uri_component_get_type")
+
+	core.PuregoSafeRegister(&xUriCopy, libs, "soup_uri_copy")
+	core.PuregoSafeRegister(&xUriDecodeDataUri, libs, "soup_uri_decode_data_uri")
+	core.PuregoSafeRegister(&xUriEqual, libs, "soup_uri_equal")
+
+}
diff --git a/v4/soup/soup-version.go b/v4/soup/soup-version.go
new file mode 100644
index 0000000000000000000000000000000000000000..52a50bfe1a1421a8872219e6f96a70660474a3c4
--- /dev/null
+++ b/v4/soup/soup-version.go
@@ -0,0 +1,116 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+)
+
+const (
+	// Like [func@get_major_version], but from the headers used at application
+	// compile time, rather than from the library linked against at application run
+	// time.
+	MAJOR_VERSION int = 3
+	// Like [func@get_micro_version], but from the headers used at
+	// application compile time, rather than from the library linked
+	// against at application run time.
+	MICRO_VERSION int = 5
+	// Like [func@get_minor_version], but from the headers used at
+	// application compile time, rather than from the library linked
+	// against at application run time.
+	MINOR_VERSION int = 6
+	// A macro that should be defined by the user prior to including
+	// `libsoup.h`.
+	//
+	// The definition should be one of the predefined libsoup
+	// version macros: %SOUP_VERSION_2_24, %SOUP_VERSION_2_26, ...
+	//
+	// This macro defines the earliest version of libsoup that the package
+	// is required to be able to compile against.
+	//
+	// If the compiler is configured to warn about the use of deprecated
+	// functions, then using functions that were deprecated in version
+	// %SOUP_VERSION_MIN_REQUIRED or earlier will cause warnings (but
+	// using functions deprecated in later releases will not).
+	VERSION_MIN_REQUIRED int = 2
+)
+
+var xCheckVersion func(uint, uint, uint) bool
+
+// Like [func@CHECK_VERSION], but the check for soup_check_version is
+// at runtime instead of compile time.
+//
+// This is useful for compiling against older versions of libsoup, but using
+// features from newer versions.
+func CheckVersion(MajorVar uint, MinorVar uint, MicroVar uint) bool {
+
+	cret := xCheckVersion(MajorVar, MinorVar, MicroVar)
+	return cret
+}
+
+var xGetMajorVersion func() uint
+
+// Returns the major version number of the libsoup library.
+//
+// e.g. in libsoup version 2.42.0 this is 2.
+//
+// This function is in the library, so it represents the libsoup library
+// your code is running against. Contrast with the #SOUP_MAJOR_VERSION
+// macro, which represents the major version of the libsoup headers you
+// have included when compiling your code.
+func GetMajorVersion() uint {
+
+	cret := xGetMajorVersion()
+	return cret
+}
+
+var xGetMicroVersion func() uint
+
+// Returns the micro version number of the libsoup library.
+//
+// e.g. in libsoup version 2.42.0 this is 0.
+//
+// This function is in the library, so it represents the libsoup library
+// your code is running against. Contrast with the #SOUP_MICRO_VERSION
+// macro, which represents the micro version of the libsoup headers you
+// have included when compiling your code.
+func GetMicroVersion() uint {
+
+	cret := xGetMicroVersion()
+	return cret
+}
+
+var xGetMinorVersion func() uint
+
+// Returns the minor version number of the libsoup library.
+//
+// e.g. in libsoup version 2.42.0 this is 42.
+//
+// This function is in the library, so it represents the libsoup library
+// your code is running against. Contrast with the #SOUP_MINOR_VERSION
+// macro, which represents the minor version of the libsoup headers you
+// have included when compiling your code.
+func GetMinorVersion() uint {
+
+	cret := xGetMinorVersion()
+	return cret
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xCheckVersion, libs, "soup_check_version")
+	core.PuregoSafeRegister(&xGetMajorVersion, libs, "soup_get_major_version")
+	core.PuregoSafeRegister(&xGetMicroVersion, libs, "soup_get_micro_version")
+	core.PuregoSafeRegister(&xGetMinorVersion, libs, "soup_get_minor_version")
+
+}
diff --git a/v4/soup/soup-websocket-connection.go b/v4/soup/soup-websocket-connection.go
new file mode 100644
index 0000000000000000000000000000000000000000..69713507aabe6ede47b36c52009413048f1f787f
--- /dev/null
+++ b/v4/soup/soup-websocket-connection.go
@@ -0,0 +1,618 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// The abstract base class for [class@WebsocketConnection].
+type WebsocketConnectionClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *WebsocketConnectionClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// The WebSocket Protocol
+//
+// Provides support for the [WebSocket](http://tools.ietf.org/html/rfc6455)
+// protocol.
+//
+// To connect to a WebSocket server, create a [class@Session] and call
+// [method@Session.websocket_connect_async]. To accept WebSocket
+// connections, create a [class@Server] and add a handler to it with
+// [method@Server.add_websocket_handler].
+//
+// (Lower-level support is available via
+// [func@websocket_client_prepare_handshake] and
+// [func@websocket_client_verify_handshake], for handling the client side of the
+// WebSocket handshake, and [func@websocket_server_process_handshake] for
+// handling the server side.)
+//
+// #SoupWebsocketConnection handles the details of WebSocket communication. You
+// can use [method@WebsocketConnection.send_text] and
+// [method@WebsocketConnection.send_binary] to send data, and the
+// [signal@WebsocketConnection::message] signal to receive data.
+// (#SoupWebsocketConnection currently only supports asynchronous I/O.)
+type WebsocketConnection struct {
+	gobject.Object
+}
+
+var xWebsocketConnectionGLibType func() types.GType
+
+func WebsocketConnectionGLibType() types.GType {
+	return xWebsocketConnectionGLibType()
+}
+
+func WebsocketConnectionNewFromInternalPtr(ptr uintptr) *WebsocketConnection {
+	cls := &WebsocketConnection{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewWebsocketConnection func(uintptr, *glib.Uri, WebsocketConnectionType, string, string, *glib.List) uintptr
+
+// Creates a #SoupWebsocketConnection on @stream with the given active @extensions.
+//
+// This should be called after completing the handshake to begin using the WebSocket
+// protocol.
+func NewWebsocketConnection(StreamVar *gio.IOStream, UriVar *glib.Uri, TypeVar WebsocketConnectionType, OriginVar string, ProtocolVar string, ExtensionsVar *glib.List) *WebsocketConnection {
+	var cls *WebsocketConnection
+
+	cret := xNewWebsocketConnection(StreamVar.GoPointer(), UriVar, TypeVar, OriginVar, ProtocolVar, ExtensionsVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &WebsocketConnection{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebsocketConnectionClose func(uintptr, uint16, string)
+
+// Close the connection in an orderly fashion.
+//
+// Note that until the [signal@WebsocketConnection::closed] signal fires, the connection
+// is not yet completely closed. The close message is not even sent until the
+// main loop runs.
+//
+// The @code and @data are sent to the peer along with the close request.
+// If @code is %SOUP_WEBSOCKET_CLOSE_NO_STATUS a close message with no body
+// (without code and data) is sent.
+// Note that the @data must be UTF-8 valid.
+func (x *WebsocketConnection) Close(CodeVar uint16, DataVar string) {
+
+	xWebsocketConnectionClose(x.GoPointer(), CodeVar, DataVar)
+
+}
+
+var xWebsocketConnectionGetCloseCode func(uintptr) uint16
+
+// Get the close code received from the WebSocket peer.
+//
+// This only becomes valid once the WebSocket is in the
+// %SOUP_WEBSOCKET_STATE_CLOSED state. The value will often be in the
+// [enum@WebsocketCloseCode] enumeration, but may also be an application
+// defined close code.
+func (x *WebsocketConnection) GetCloseCode() uint16 {
+
+	cret := xWebsocketConnectionGetCloseCode(x.GoPointer())
+	return cret
+}
+
+var xWebsocketConnectionGetCloseData func(uintptr) string
+
+// Get the close data received from the WebSocket peer.
+//
+// This only becomes valid once the WebSocket is in the
+// %SOUP_WEBSOCKET_STATE_CLOSED state. The data may be freed once
+// the main loop is run, so copy it if you need to keep it around.
+func (x *WebsocketConnection) GetCloseData() string {
+
+	cret := xWebsocketConnectionGetCloseData(x.GoPointer())
+	return cret
+}
+
+var xWebsocketConnectionGetConnectionType func(uintptr) WebsocketConnectionType
+
+// Get the connection type (client/server) of the connection.
+func (x *WebsocketConnection) GetConnectionType() WebsocketConnectionType {
+
+	cret := xWebsocketConnectionGetConnectionType(x.GoPointer())
+	return cret
+}
+
+var xWebsocketConnectionGetExtensions func(uintptr) *glib.List
+
+// Get the extensions chosen via negotiation with the peer.
+func (x *WebsocketConnection) GetExtensions() *glib.List {
+
+	cret := xWebsocketConnectionGetExtensions(x.GoPointer())
+	return cret
+}
+
+var xWebsocketConnectionGetIoStream func(uintptr) uintptr
+
+// Get the I/O stream the WebSocket is communicating over.
+func (x *WebsocketConnection) GetIoStream() *gio.IOStream {
+	var cls *gio.IOStream
+
+	cret := xWebsocketConnectionGetIoStream(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.IOStream{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebsocketConnectionGetKeepaliveInterval func(uintptr) uint
+
+// Gets the keepalive interval in seconds or 0 if disabled.
+func (x *WebsocketConnection) GetKeepaliveInterval() uint {
+
+	cret := xWebsocketConnectionGetKeepaliveInterval(x.GoPointer())
+	return cret
+}
+
+var xWebsocketConnectionGetKeepalivePongTimeout func(uintptr) uint
+
+// Gets the keepalive pong timeout in seconds or 0 if disabled.
+func (x *WebsocketConnection) GetKeepalivePongTimeout() uint {
+
+	cret := xWebsocketConnectionGetKeepalivePongTimeout(x.GoPointer())
+	return cret
+}
+
+var xWebsocketConnectionGetMaxIncomingPayloadSize func(uintptr) uint64
+
+// Gets the maximum payload size allowed for incoming packets.
+func (x *WebsocketConnection) GetMaxIncomingPayloadSize() uint64 {
+
+	cret := xWebsocketConnectionGetMaxIncomingPayloadSize(x.GoPointer())
+	return cret
+}
+
+var xWebsocketConnectionGetOrigin func(uintptr) string
+
+// Get the origin of the WebSocket.
+func (x *WebsocketConnection) GetOrigin() string {
+
+	cret := xWebsocketConnectionGetOrigin(x.GoPointer())
+	return cret
+}
+
+var xWebsocketConnectionGetProtocol func(uintptr) string
+
+// Get the protocol chosen via negotiation with the peer.
+func (x *WebsocketConnection) GetProtocol() string {
+
+	cret := xWebsocketConnectionGetProtocol(x.GoPointer())
+	return cret
+}
+
+var xWebsocketConnectionGetState func(uintptr) WebsocketState
+
+// Get the current state of the WebSocket.
+func (x *WebsocketConnection) GetState() WebsocketState {
+
+	cret := xWebsocketConnectionGetState(x.GoPointer())
+	return cret
+}
+
+var xWebsocketConnectionGetUri func(uintptr) *glib.Uri
+
+// Get the URI of the WebSocket.
+//
+// For servers this represents the address of the WebSocket, and
+// for clients it is the address connected to.
+func (x *WebsocketConnection) GetUri() *glib.Uri {
+
+	cret := xWebsocketConnectionGetUri(x.GoPointer())
+	return cret
+}
+
+var xWebsocketConnectionSendBinary func(uintptr, []byte, uint)
+
+// Send a binary message to the peer.
+//
+// If @length is 0, @data may be %NULL.
+//
+// The message is queued to be sent and will be sent when the main loop
+// is run.
+func (x *WebsocketConnection) SendBinary(DataVar []byte, LengthVar uint) {
+
+	xWebsocketConnectionSendBinary(x.GoPointer(), DataVar, LengthVar)
+
+}
+
+var xWebsocketConnectionSendMessage func(uintptr, WebsocketDataType, *glib.Bytes)
+
+// Send a message of the given @type to the peer. Note that this method,
+// allows to send text messages containing %NULL characters.
+//
+// The message is queued to be sent and will be sent when the main loop
+// is run.
+func (x *WebsocketConnection) SendMessage(TypeVar WebsocketDataType, MessageVar *glib.Bytes) {
+
+	xWebsocketConnectionSendMessage(x.GoPointer(), TypeVar, MessageVar)
+
+}
+
+var xWebsocketConnectionSendText func(uintptr, string)
+
+// Send a %NULL-terminated text (UTF-8) message to the peer.
+//
+// If you need to send text messages containing %NULL characters use
+// [method@WebsocketConnection.send_message] instead.
+//
+// The message is queued to be sent and will be sent when the main loop
+// is run.
+func (x *WebsocketConnection) SendText(TextVar string) {
+
+	xWebsocketConnectionSendText(x.GoPointer(), TextVar)
+
+}
+
+var xWebsocketConnectionSetKeepaliveInterval func(uintptr, uint)
+
+// Sets the interval in seconds on when to send a ping message which will serve
+// as a keepalive message.
+//
+// If set to 0 the keepalive message is disabled.
+func (x *WebsocketConnection) SetKeepaliveInterval(IntervalVar uint) {
+
+	xWebsocketConnectionSetKeepaliveInterval(x.GoPointer(), IntervalVar)
+
+}
+
+var xWebsocketConnectionSetKeepalivePongTimeout func(uintptr, uint)
+
+// Set the timeout in seconds for when the absence of a pong from a keepalive
+// ping is assumed to be caused by a faulty connection.
+//
+// If set to 0 then the absence of pongs from keepalive pings is ignored.
+func (x *WebsocketConnection) SetKeepalivePongTimeout(PongTimeoutVar uint) {
+
+	xWebsocketConnectionSetKeepalivePongTimeout(x.GoPointer(), PongTimeoutVar)
+
+}
+
+var xWebsocketConnectionSetMaxIncomingPayloadSize func(uintptr, uint64)
+
+// Sets the maximum payload size allowed for incoming packets.
+//
+// It does not limit the outgoing packet size.
+func (x *WebsocketConnection) SetMaxIncomingPayloadSize(MaxIncomingPayloadSizeVar uint64) {
+
+	xWebsocketConnectionSetMaxIncomingPayloadSize(x.GoPointer(), MaxIncomingPayloadSizeVar)
+
+}
+
+func (c *WebsocketConnection) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebsocketConnection) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyExtensions sets the "extensions" property.
+// List of [class@WebsocketExtension] objects that are active in the connection.
+func (x *WebsocketConnection) SetPropertyExtensions(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("extensions", &v)
+}
+
+// GetPropertyExtensions gets the "extensions" property.
+// List of [class@WebsocketExtension] objects that are active in the connection.
+func (x *WebsocketConnection) GetPropertyExtensions() uintptr {
+	var v gobject.Value
+	x.GetProperty("extensions", &v)
+	return v.GetPointer()
+}
+
+// SetPropertyKeepaliveInterval sets the "keepalive-interval" property.
+// Interval in seconds on when to send a ping message which will
+// serve as a keepalive message.
+//
+// If set to 0 the keepalive message is disabled.
+func (x *WebsocketConnection) SetPropertyKeepaliveInterval(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("keepalive-interval", &v)
+}
+
+// GetPropertyKeepaliveInterval gets the "keepalive-interval" property.
+// Interval in seconds on when to send a ping message which will
+// serve as a keepalive message.
+//
+// If set to 0 the keepalive message is disabled.
+func (x *WebsocketConnection) GetPropertyKeepaliveInterval() uint {
+	var v gobject.Value
+	x.GetProperty("keepalive-interval", &v)
+	return v.GetUint()
+}
+
+// SetPropertyKeepalivePongTimeout sets the "keepalive-pong-timeout" property.
+// Timeout in seconds for when the absence of a pong from a keepalive
+// ping is assumed to be caused by a faulty connection. The WebSocket
+// will be transitioned to a closed state when this happens.
+//
+// If set to 0 then the absence of pongs from keepalive pings is
+// ignored.
+func (x *WebsocketConnection) SetPropertyKeepalivePongTimeout(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("keepalive-pong-timeout", &v)
+}
+
+// GetPropertyKeepalivePongTimeout gets the "keepalive-pong-timeout" property.
+// Timeout in seconds for when the absence of a pong from a keepalive
+// ping is assumed to be caused by a faulty connection. The WebSocket
+// will be transitioned to a closed state when this happens.
+//
+// If set to 0 then the absence of pongs from keepalive pings is
+// ignored.
+func (x *WebsocketConnection) GetPropertyKeepalivePongTimeout() uint {
+	var v gobject.Value
+	x.GetProperty("keepalive-pong-timeout", &v)
+	return v.GetUint()
+}
+
+// SetPropertyMaxIncomingPayloadSize sets the "max-incoming-payload-size" property.
+// The maximum payload size for incoming packets.
+//
+// The protocol expects or 0 to not limit it.
+func (x *WebsocketConnection) SetPropertyMaxIncomingPayloadSize(value uint64) {
+	var v gobject.Value
+	v.Init(gobject.TypeUint64Val)
+	v.SetUint64(value)
+	x.SetProperty("max-incoming-payload-size", &v)
+}
+
+// GetPropertyMaxIncomingPayloadSize gets the "max-incoming-payload-size" property.
+// The maximum payload size for incoming packets.
+//
+// The protocol expects or 0 to not limit it.
+func (x *WebsocketConnection) GetPropertyMaxIncomingPayloadSize() uint64 {
+	var v gobject.Value
+	x.GetProperty("max-incoming-payload-size", &v)
+	return v.GetUint64()
+}
+
+// SetPropertyOrigin sets the "origin" property.
+// The client's Origin.
+func (x *WebsocketConnection) SetPropertyOrigin(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("origin", &v)
+}
+
+// GetPropertyOrigin gets the "origin" property.
+// The client's Origin.
+func (x *WebsocketConnection) GetPropertyOrigin() string {
+	var v gobject.Value
+	x.GetProperty("origin", &v)
+	return v.GetString()
+}
+
+// SetPropertyProtocol sets the "protocol" property.
+// The chosen protocol, or %NULL if a protocol was not agreed
+// upon.
+func (x *WebsocketConnection) SetPropertyProtocol(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("protocol", &v)
+}
+
+// GetPropertyProtocol gets the "protocol" property.
+// The chosen protocol, or %NULL if a protocol was not agreed
+// upon.
+func (x *WebsocketConnection) GetPropertyProtocol() string {
+	var v gobject.Value
+	x.GetProperty("protocol", &v)
+	return v.GetString()
+}
+
+// SetPropertyUri sets the "uri" property.
+// The URI of the WebSocket.
+//
+// For servers this represents the address of the WebSocket,
+// and for clients it is the address connected to.
+func (x *WebsocketConnection) SetPropertyUri(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("uri", &v)
+}
+
+// GetPropertyUri gets the "uri" property.
+// The URI of the WebSocket.
+//
+// For servers this represents the address of the WebSocket,
+// and for clients it is the address connected to.
+func (x *WebsocketConnection) GetPropertyUri() uintptr {
+	var v gobject.Value
+	x.GetProperty("uri", &v)
+	return v.GetPointer()
+}
+
+// Emitted when the connection has completely closed.
+//
+// This happens either due to an orderly close from the peer, one
+// initiated via [method@WebsocketConnection.close] or a fatal error
+// condition that caused a close.
+//
+// This signal will be emitted once.
+func (x *WebsocketConnection) ConnectClosed(cb *func(WebsocketConnection)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := WebsocketConnection{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
+}
+
+// This signal will be emitted during an orderly close.
+func (x *WebsocketConnection) ConnectClosing(cb *func(WebsocketConnection)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "closing", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := WebsocketConnection{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "closing", cbRefPtr)
+}
+
+// Emitted when an error occurred on the WebSocket.
+//
+// This may be fired multiple times. Fatal errors will be followed by
+// the [signal@WebsocketConnection::closed] signal being emitted.
+func (x *WebsocketConnection) ConnectError(cb *func(WebsocketConnection, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "error", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ErrorVarp uintptr) {
+		fa := WebsocketConnection{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ErrorVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "error", cbRefPtr)
+}
+
+// Emitted when we receive a message from the peer.
+//
+// As a convenience, the @message data will always be
+// %NULL-terminated, but the NUL byte will not be included in
+// the length count.
+func (x *WebsocketConnection) ConnectMessage(cb *func(WebsocketConnection, int, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "message", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, TypeVarp int, MessageVarp uintptr) {
+		fa := WebsocketConnection{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, TypeVarp, MessageVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "message", cbRefPtr)
+}
+
+// Emitted when we receive a Pong frame (solicited or
+// unsolicited) from the peer.
+//
+// As a convenience, the @message data will always be
+// %NULL-terminated, but the NUL byte will not be included in
+// the length count.
+func (x *WebsocketConnection) ConnectPong(cb *func(WebsocketConnection, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "pong", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MessageVarp uintptr) {
+		fa := WebsocketConnection{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, MessageVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "pong", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xWebsocketConnectionGLibType, libs, "soup_websocket_connection_get_type")
+
+	core.PuregoSafeRegister(&xNewWebsocketConnection, libs, "soup_websocket_connection_new")
+
+	core.PuregoSafeRegister(&xWebsocketConnectionClose, libs, "soup_websocket_connection_close")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetCloseCode, libs, "soup_websocket_connection_get_close_code")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetCloseData, libs, "soup_websocket_connection_get_close_data")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetConnectionType, libs, "soup_websocket_connection_get_connection_type")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetExtensions, libs, "soup_websocket_connection_get_extensions")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetIoStream, libs, "soup_websocket_connection_get_io_stream")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetKeepaliveInterval, libs, "soup_websocket_connection_get_keepalive_interval")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetKeepalivePongTimeout, libs, "soup_websocket_connection_get_keepalive_pong_timeout")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetMaxIncomingPayloadSize, libs, "soup_websocket_connection_get_max_incoming_payload_size")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetOrigin, libs, "soup_websocket_connection_get_origin")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetProtocol, libs, "soup_websocket_connection_get_protocol")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetState, libs, "soup_websocket_connection_get_state")
+	core.PuregoSafeRegister(&xWebsocketConnectionGetUri, libs, "soup_websocket_connection_get_uri")
+	core.PuregoSafeRegister(&xWebsocketConnectionSendBinary, libs, "soup_websocket_connection_send_binary")
+	core.PuregoSafeRegister(&xWebsocketConnectionSendMessage, libs, "soup_websocket_connection_send_message")
+	core.PuregoSafeRegister(&xWebsocketConnectionSendText, libs, "soup_websocket_connection_send_text")
+	core.PuregoSafeRegister(&xWebsocketConnectionSetKeepaliveInterval, libs, "soup_websocket_connection_set_keepalive_interval")
+	core.PuregoSafeRegister(&xWebsocketConnectionSetKeepalivePongTimeout, libs, "soup_websocket_connection_set_keepalive_pong_timeout")
+	core.PuregoSafeRegister(&xWebsocketConnectionSetMaxIncomingPayloadSize, libs, "soup_websocket_connection_set_max_incoming_payload_size")
+
+}
diff --git a/v4/soup/soup-websocket-extension-deflate.go b/v4/soup/soup-websocket-extension-deflate.go
new file mode 100644
index 0000000000000000000000000000000000000000..23e08abff08000fe9cae164015feaf23fb77e78a
--- /dev/null
+++ b/v4/soup/soup-websocket-extension-deflate.go
@@ -0,0 +1,51 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type WebsocketExtensionDeflateClass struct {
+	_ structs.HostLayout
+
+	ParentClass WebsocketExtensionClass
+}
+
+func (x *WebsocketExtensionDeflateClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A SoupWebsocketExtensionDeflate is a [class@WebsocketExtension]
+// implementing permessage-deflate (RFC 7692).
+//
+// This extension is used by default in a [class@Session] when [class@WebsocketExtensionManager]
+// feature is present, and always used by [class@Server].
+type WebsocketExtensionDeflate struct {
+	WebsocketExtension
+}
+
+var xWebsocketExtensionDeflateGLibType func() types.GType
+
+func WebsocketExtensionDeflateGLibType() types.GType {
+	return xWebsocketExtensionDeflateGLibType()
+}
+
+func WebsocketExtensionDeflateNewFromInternalPtr(ptr uintptr) *WebsocketExtensionDeflate {
+	cls := &WebsocketExtensionDeflate{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *WebsocketExtensionDeflate) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebsocketExtensionDeflate) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
diff --git a/v4/soup/soup-websocket-extension-manager.go b/v4/soup/soup-websocket-extension-manager.go
new file mode 100644
index 0000000000000000000000000000000000000000..bd43b585488934d10773b27ccef2ed8d8dd50004
--- /dev/null
+++ b/v4/soup/soup-websocket-extension-manager.go
@@ -0,0 +1,55 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type WebsocketExtensionManagerClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *WebsocketExtensionManagerClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// SoupWebsocketExtensionManager is the [iface@SessionFeature] that handles WebSockets
+// extensions for a [class@Session].
+//
+// A #SoupWebsocketExtensionManager is added to the session by default, and normally
+// you don't need to worry about it at all. However, if you want to
+// disable WebSocket extensions, you can remove the feature from the
+// session with [method@Session.remove_feature_by_type] or disable it on
+// individual requests with [method@Message.disable_feature].
+type WebsocketExtensionManager struct {
+	gobject.Object
+}
+
+var xWebsocketExtensionManagerGLibType func() types.GType
+
+func WebsocketExtensionManagerGLibType() types.GType {
+	return xWebsocketExtensionManagerGLibType()
+}
+
+func WebsocketExtensionManagerNewFromInternalPtr(ptr uintptr) *WebsocketExtensionManager {
+	cls := &WebsocketExtensionManager{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *WebsocketExtensionManager) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebsocketExtensionManager) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
diff --git a/v4/soup/soup-websocket-extension.go b/v4/soup/soup-websocket-extension.go
new file mode 100644
index 0000000000000000000000000000000000000000..69841efe6f162929828f9fa639c204077d0a2ac3
--- /dev/null
+++ b/v4/soup/soup-websocket-extension.go
@@ -0,0 +1,309 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// The class structure for the #SoupWebsocketExtension.
+type WebsocketExtensionClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+
+	Name uintptr
+
+	xConfigure uintptr
+
+	xGetRequestParams uintptr
+
+	xGetResponseParams uintptr
+
+	xProcessOutgoingMessage uintptr
+
+	xProcessIncomingMessage uintptr
+
+	Padding [6]uintptr
+}
+
+func (x *WebsocketExtensionClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideConfigure sets the "configure" callback function.
+// called to configure the extension with the given parameters
+func (x *WebsocketExtensionClass) OverrideConfigure(cb func(*WebsocketExtension, WebsocketConnectionType, *glib.HashTable) bool) {
+	if cb == nil {
+		x.xConfigure = 0
+	} else {
+		x.xConfigure = purego.NewCallback(func(ExtensionVarp uintptr, ConnectionTypeVarp WebsocketConnectionType, ParamsVarp *glib.HashTable) bool {
+			return cb(WebsocketExtensionNewFromInternalPtr(ExtensionVarp), ConnectionTypeVarp, ParamsVarp)
+		})
+	}
+}
+
+// GetConfigure gets the "configure" callback function.
+// called to configure the extension with the given parameters
+func (x *WebsocketExtensionClass) GetConfigure() func(*WebsocketExtension, WebsocketConnectionType, *glib.HashTable) bool {
+	if x.xConfigure == 0 {
+		return nil
+	}
+	var rawCallback func(ExtensionVarp uintptr, ConnectionTypeVarp WebsocketConnectionType, ParamsVarp *glib.HashTable) bool
+	purego.RegisterFunc(&rawCallback, x.xConfigure)
+	return func(ExtensionVar *WebsocketExtension, ConnectionTypeVar WebsocketConnectionType, ParamsVar *glib.HashTable) bool {
+		return rawCallback(ExtensionVar.GoPointer(), ConnectionTypeVar, ParamsVar)
+	}
+}
+
+// OverrideGetRequestParams sets the "get_request_params" callback function.
+// called by the client to build the request header.
+//
+//	It should include the parameters string starting with ';'
+func (x *WebsocketExtensionClass) OverrideGetRequestParams(cb func(*WebsocketExtension) string) {
+	if cb == nil {
+		x.xGetRequestParams = 0
+	} else {
+		x.xGetRequestParams = purego.NewCallback(func(ExtensionVarp uintptr) string {
+			return cb(WebsocketExtensionNewFromInternalPtr(ExtensionVarp))
+		})
+	}
+}
+
+// GetGetRequestParams gets the "get_request_params" callback function.
+// called by the client to build the request header.
+//
+//	It should include the parameters string starting with ';'
+func (x *WebsocketExtensionClass) GetGetRequestParams() func(*WebsocketExtension) string {
+	if x.xGetRequestParams == 0 {
+		return nil
+	}
+	var rawCallback func(ExtensionVarp uintptr) string
+	purego.RegisterFunc(&rawCallback, x.xGetRequestParams)
+	return func(ExtensionVar *WebsocketExtension) string {
+		return rawCallback(ExtensionVar.GoPointer())
+	}
+}
+
+// OverrideGetResponseParams sets the "get_response_params" callback function.
+// called by the server to build the response header.
+//
+//	It should include the parameters string starting with ';'
+func (x *WebsocketExtensionClass) OverrideGetResponseParams(cb func(*WebsocketExtension) string) {
+	if cb == nil {
+		x.xGetResponseParams = 0
+	} else {
+		x.xGetResponseParams = purego.NewCallback(func(ExtensionVarp uintptr) string {
+			return cb(WebsocketExtensionNewFromInternalPtr(ExtensionVarp))
+		})
+	}
+}
+
+// GetGetResponseParams gets the "get_response_params" callback function.
+// called by the server to build the response header.
+//
+//	It should include the parameters string starting with ';'
+func (x *WebsocketExtensionClass) GetGetResponseParams() func(*WebsocketExtension) string {
+	if x.xGetResponseParams == 0 {
+		return nil
+	}
+	var rawCallback func(ExtensionVarp uintptr) string
+	purego.RegisterFunc(&rawCallback, x.xGetResponseParams)
+	return func(ExtensionVar *WebsocketExtension) string {
+		return rawCallback(ExtensionVar.GoPointer())
+	}
+}
+
+// OverrideProcessOutgoingMessage sets the "process_outgoing_message" callback function.
+// called to process the payload data of a message
+//
+//	before it's sent. Reserved bits of the header should be changed.
+func (x *WebsocketExtensionClass) OverrideProcessOutgoingMessage(cb func(*WebsocketExtension, byte, *glib.Bytes) *glib.Bytes) {
+	if cb == nil {
+		x.xProcessOutgoingMessage = 0
+	} else {
+		x.xProcessOutgoingMessage = purego.NewCallback(func(ExtensionVarp uintptr, HeaderVarp byte, PayloadVarp *glib.Bytes) *glib.Bytes {
+			return cb(WebsocketExtensionNewFromInternalPtr(ExtensionVarp), HeaderVarp, PayloadVarp)
+		})
+	}
+}
+
+// GetProcessOutgoingMessage gets the "process_outgoing_message" callback function.
+// called to process the payload data of a message
+//
+//	before it's sent. Reserved bits of the header should be changed.
+func (x *WebsocketExtensionClass) GetProcessOutgoingMessage() func(*WebsocketExtension, byte, *glib.Bytes) *glib.Bytes {
+	if x.xProcessOutgoingMessage == 0 {
+		return nil
+	}
+	var rawCallback func(ExtensionVarp uintptr, HeaderVarp byte, PayloadVarp *glib.Bytes) *glib.Bytes
+	purego.RegisterFunc(&rawCallback, x.xProcessOutgoingMessage)
+	return func(ExtensionVar *WebsocketExtension, HeaderVar byte, PayloadVar *glib.Bytes) *glib.Bytes {
+		return rawCallback(ExtensionVar.GoPointer(), HeaderVar, PayloadVar)
+	}
+}
+
+// OverrideProcessIncomingMessage sets the "process_incoming_message" callback function.
+// called to process the payload data of a message
+//
+//	after it's received. Reserved bits of the header should be cleared.
+func (x *WebsocketExtensionClass) OverrideProcessIncomingMessage(cb func(*WebsocketExtension, byte, *glib.Bytes) *glib.Bytes) {
+	if cb == nil {
+		x.xProcessIncomingMessage = 0
+	} else {
+		x.xProcessIncomingMessage = purego.NewCallback(func(ExtensionVarp uintptr, HeaderVarp byte, PayloadVarp *glib.Bytes) *glib.Bytes {
+			return cb(WebsocketExtensionNewFromInternalPtr(ExtensionVarp), HeaderVarp, PayloadVarp)
+		})
+	}
+}
+
+// GetProcessIncomingMessage gets the "process_incoming_message" callback function.
+// called to process the payload data of a message
+//
+//	after it's received. Reserved bits of the header should be cleared.
+func (x *WebsocketExtensionClass) GetProcessIncomingMessage() func(*WebsocketExtension, byte, *glib.Bytes) *glib.Bytes {
+	if x.xProcessIncomingMessage == 0 {
+		return nil
+	}
+	var rawCallback func(ExtensionVarp uintptr, HeaderVarp byte, PayloadVarp *glib.Bytes) *glib.Bytes
+	purego.RegisterFunc(&rawCallback, x.xProcessIncomingMessage)
+	return func(ExtensionVar *WebsocketExtension, HeaderVar byte, PayloadVar *glib.Bytes) *glib.Bytes {
+		return rawCallback(ExtensionVar.GoPointer(), HeaderVar, PayloadVar)
+	}
+}
+
+// A WebSocket extension
+//
+// #SoupWebsocketExtension is the base class for WebSocket extension objects.
+type WebsocketExtension struct {
+	gobject.Object
+}
+
+var xWebsocketExtensionGLibType func() types.GType
+
+func WebsocketExtensionGLibType() types.GType {
+	return xWebsocketExtensionGLibType()
+}
+
+func WebsocketExtensionNewFromInternalPtr(ptr uintptr) *WebsocketExtension {
+	cls := &WebsocketExtension{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xWebsocketExtensionConfigure func(uintptr, WebsocketConnectionType, *glib.HashTable, **glib.Error) bool
+
+// Configures @extension with the given @params.
+func (x *WebsocketExtension) Configure(ConnectionTypeVar WebsocketConnectionType, ParamsVar *glib.HashTable) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xWebsocketExtensionConfigure(x.GoPointer(), ConnectionTypeVar, ParamsVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebsocketExtensionGetRequestParams func(uintptr) string
+
+// Get the parameters strings to be included in the request header.
+//
+// If the extension doesn't include any parameter in the request, this function
+// returns %NULL.
+func (x *WebsocketExtension) GetRequestParams() string {
+
+	cret := xWebsocketExtensionGetRequestParams(x.GoPointer())
+	return cret
+}
+
+var xWebsocketExtensionGetResponseParams func(uintptr) string
+
+// Get the parameters strings to be included in the response header.
+//
+// If the extension doesn't include any parameter in the response, this function
+// returns %NULL.
+func (x *WebsocketExtension) GetResponseParams() string {
+
+	cret := xWebsocketExtensionGetResponseParams(x.GoPointer())
+	return cret
+}
+
+var xWebsocketExtensionProcessIncomingMessage func(uintptr, byte, *glib.Bytes, **glib.Error) *glib.Bytes
+
+// Process a message after it's received.
+//
+// If the payload isn't changed the given @payload is just returned, otherwise
+// [method@GLib.Bytes.unref] is called on the given @payload and a new
+// [struct@GLib.Bytes] is returned with the new data.
+//
+// Extensions using reserved bits of the header will reset them in @header.
+func (x *WebsocketExtension) ProcessIncomingMessage(HeaderVar byte, PayloadVar *glib.Bytes) (*glib.Bytes, error) {
+	var cerr *glib.Error
+
+	cret := xWebsocketExtensionProcessIncomingMessage(x.GoPointer(), HeaderVar, PayloadVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebsocketExtensionProcessOutgoingMessage func(uintptr, byte, *glib.Bytes, **glib.Error) *glib.Bytes
+
+// Process a message before it's sent.
+//
+// If the payload isn't changed the given @payload is just returned, otherwise
+// [method@Glib.Bytes.unref] is called on the given @payload and a new
+// [struct@GLib.Bytes] is returned with the new data.
+//
+// Extensions using reserved bits of the header will change them in @header.
+func (x *WebsocketExtension) ProcessOutgoingMessage(HeaderVar byte, PayloadVar *glib.Bytes) (*glib.Bytes, error) {
+	var cerr *glib.Error
+
+	cret := xWebsocketExtensionProcessOutgoingMessage(x.GoPointer(), HeaderVar, PayloadVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+func (c *WebsocketExtension) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebsocketExtension) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xWebsocketExtensionGLibType, libs, "soup_websocket_extension_get_type")
+
+	core.PuregoSafeRegister(&xWebsocketExtensionConfigure, libs, "soup_websocket_extension_configure")
+	core.PuregoSafeRegister(&xWebsocketExtensionGetRequestParams, libs, "soup_websocket_extension_get_request_params")
+	core.PuregoSafeRegister(&xWebsocketExtensionGetResponseParams, libs, "soup_websocket_extension_get_response_params")
+	core.PuregoSafeRegister(&xWebsocketExtensionProcessIncomingMessage, libs, "soup_websocket_extension_process_incoming_message")
+	core.PuregoSafeRegister(&xWebsocketExtensionProcessOutgoingMessage, libs, "soup_websocket_extension_process_outgoing_message")
+
+}
diff --git a/v4/soup/soup-websocket.go b/v4/soup/soup-websocket.go
new file mode 100644
index 0000000000000000000000000000000000000000..8216f11d18759c14d3ca27deeb55f13e85d8360c
--- /dev/null
+++ b/v4/soup/soup-websocket.go
@@ -0,0 +1,274 @@
+// Package soup was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package soup
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Pre-defined close codes that can be passed to
+// [method@WebsocketConnection.close] or received from
+// [method@WebsocketConnection.get_close_code].
+//
+// However, other codes are also allowed.
+type WebsocketCloseCode int
+
+var xWebsocketCloseCodeGLibType func() types.GType
+
+func WebsocketCloseCodeGLibType() types.GType {
+	return xWebsocketCloseCodeGLibType()
+}
+
+const (
+
+	// a normal, non-error close
+	WebsocketCloseNormalValue WebsocketCloseCode = 1000
+	// the client/server is going away
+	WebsocketCloseGoingAwayValue WebsocketCloseCode = 1001
+	// a protocol error occurred
+	WebsocketCloseProtocolErrorValue WebsocketCloseCode = 1002
+	// the endpoint received data
+	//   of a type that it does not support.
+	WebsocketCloseUnsupportedDataValue WebsocketCloseCode = 1003
+	// reserved value indicating that
+	//   no close code was present; must not be sent.
+	WebsocketCloseNoStatusValue WebsocketCloseCode = 1005
+	// reserved value indicating that
+	//   the connection was closed abnormally; must not be sent.
+	WebsocketCloseAbnormalValue WebsocketCloseCode = 1006
+	// the endpoint received data that
+	//   was invalid (eg, non-UTF-8 data in a text message).
+	WebsocketCloseBadDataValue WebsocketCloseCode = 1007
+	// generic error code
+	//   indicating some sort of policy violation.
+	WebsocketClosePolicyViolationValue WebsocketCloseCode = 1008
+	// the endpoint received a message
+	//   that is too big to process.
+	WebsocketCloseTooBigValue WebsocketCloseCode = 1009
+	// the client is closing the
+	//   connection because the server failed to negotiate a required
+	//   extension.
+	WebsocketCloseNoExtensionValue WebsocketCloseCode = 1010
+	// the server is closing the
+	//   connection because it was unable to fulfill the request.
+	WebsocketCloseServerErrorValue WebsocketCloseCode = 1011
+	// reserved value indicating that
+	//   the TLS handshake failed; must not be sent.
+	WebsocketCloseTlsHandshakeValue WebsocketCloseCode = 1015
+)
+
+// The type of a [class@WebsocketConnection].
+type WebsocketConnectionType int
+
+var xWebsocketConnectionTypeGLibType func() types.GType
+
+func WebsocketConnectionTypeGLibType() types.GType {
+	return xWebsocketConnectionTypeGLibType()
+}
+
+const (
+
+	// unknown/invalid connection
+	WebsocketConnectionUnknownValue WebsocketConnectionType = 0
+	// a client-side connection
+	WebsocketConnectionClientValue WebsocketConnectionType = 1
+	// a server-side connection
+	WebsocketConnectionServerValue WebsocketConnectionType = 2
+)
+
+// The type of data contained in a [signal@WebsocketConnection::message] signal.
+type WebsocketDataType int
+
+var xWebsocketDataTypeGLibType func() types.GType
+
+func WebsocketDataTypeGLibType() types.GType {
+	return xWebsocketDataTypeGLibType()
+}
+
+const (
+
+	// UTF-8 text
+	WebsocketDataTextValue WebsocketDataType = 1
+	// binary data
+	WebsocketDataBinaryValue WebsocketDataType = 2
+)
+
+// WebSocket-related errors.
+type WebsocketError int
+
+var xWebsocketErrorGLibType func() types.GType
+
+func WebsocketErrorGLibType() types.GType {
+	return xWebsocketErrorGLibType()
+}
+
+const (
+
+	// a generic error
+	WebsocketErrorFailedValue WebsocketError = 0
+	// attempted to handshake with a
+	//   server that does not appear to understand WebSockets.
+	WebsocketErrorNotWebsocketValue WebsocketError = 1
+	// the WebSocket handshake failed
+	//   because some detail was invalid (eg, incorrect accept key).
+	WebsocketErrorBadHandshakeValue WebsocketError = 2
+	// the WebSocket handshake failed
+	//   because the "Origin" header was not an allowed value.
+	WebsocketErrorBadOriginValue WebsocketError = 3
+)
+
+// The state of the WebSocket connection.
+type WebsocketState int
+
+var xWebsocketStateGLibType func() types.GType
+
+func WebsocketStateGLibType() types.GType {
+	return xWebsocketStateGLibType()
+}
+
+const (
+
+	// the connection is ready to send messages
+	WebsocketStateOpenValue WebsocketState = 1
+	// the connection is in the process of
+	//   closing down; messages may be received, but not sent
+	WebsocketStateClosingValue WebsocketState = 2
+	// the connection is completely closed down
+	WebsocketStateClosedValue WebsocketState = 3
+)
+
+var xWebsocketClientPrepareHandshake func(uintptr, string, []string, []gobject.TypeClass)
+
+// Adds the necessary headers to @msg to request a WebSocket
+// handshake including supported WebSocket extensions.
+//
+// The message body and non-WebSocket-related headers are
+// not modified.
+//
+// This is a low-level function; if you use
+// [method@Session.websocket_connect_async] to create a WebSocket connection, it
+// will call this for you.
+func WebsocketClientPrepareHandshake(MsgVar *Message, OriginVar string, ProtocolsVar []string, SupportedExtensionsVar []gobject.TypeClass) {
+
+	xWebsocketClientPrepareHandshake(MsgVar.GoPointer(), OriginVar, ProtocolsVar, SupportedExtensionsVar)
+
+}
+
+var xWebsocketClientVerifyHandshake func(uintptr, []gobject.TypeClass, **glib.List, **glib.Error) bool
+
+// Looks at the response status code and headers in @msg and
+// determines if they contain a valid WebSocket handshake response
+// (given the handshake request in @msg's request headers).
+//
+// If @supported_extensions is non-%NULL, extensions included in the
+// response "Sec-WebSocket-Extensions" are verified too. Accepted
+// extensions are returned in @accepted_extensions parameter if non-%NULL.
+//
+// This is a low-level function; if you use
+// [method@Session.websocket_connect_async] to create a WebSocket
+// connection, it will call this for you.
+func WebsocketClientVerifyHandshake(MsgVar *Message, SupportedExtensionsVar []gobject.TypeClass, AcceptedExtensionsVar **glib.List) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xWebsocketClientVerifyHandshake(MsgVar.GoPointer(), SupportedExtensionsVar, AcceptedExtensionsVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebsocketErrorQuark func() glib.Quark
+
+// Registers error quark for SoupWebsocket if needed.
+func WebsocketErrorQuark() glib.Quark {
+
+	cret := xWebsocketErrorQuark()
+	return cret
+}
+
+var xWebsocketServerCheckHandshake func(uintptr, string, []string, []gobject.TypeClass, **glib.Error) bool
+
+// Examines the method and request headers in @msg and determines
+// whether @msg contains a valid handshake request.
+//
+// If @origin is non-%NULL, then only requests containing a matching
+// "Origin" header will be accepted. If @protocols is non-%NULL, then
+// only requests containing a compatible "Sec-WebSocket-Protocols"
+// header will be accepted. If @supported_extensions is non-%NULL, then
+// only requests containing valid supported extensions in
+// "Sec-WebSocket-Extensions" header will be accepted.
+//
+// Normally [func@websocket_server_process_handshake]
+// will take care of this for you, and if you use
+// [method@Server.add_websocket_handler] to handle accepting WebSocket
+// connections, it will call that for you. However, this function may
+// be useful if you need to perform more complicated validation; eg,
+// accepting multiple different Origins, or handling different protocols
+// depending on the path.
+func WebsocketServerCheckHandshake(MsgVar *ServerMessage, OriginVar string, ProtocolsVar []string, SupportedExtensionsVar []gobject.TypeClass) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xWebsocketServerCheckHandshake(MsgVar.GoPointer(), OriginVar, ProtocolsVar, SupportedExtensionsVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebsocketServerProcessHandshake func(uintptr, string, []string, []gobject.TypeClass, **glib.List) bool
+
+// Examines the method and request headers in @msg and (assuming @msg
+// contains a valid handshake request), fills in the handshake
+// response.
+//
+// If @expected_origin is non-%NULL, then only requests containing a matching
+// "Origin" header will be accepted. If @protocols is non-%NULL, then
+// only requests containing a compatible "Sec-WebSocket-Protocols"
+// header will be accepted. If @supported_extensions is non-%NULL, then
+// only requests containing valid supported extensions in
+// "Sec-WebSocket-Extensions" header will be accepted. The accepted extensions
+// will be returned in @accepted_extensions parameter if non-%NULL.
+//
+// This is a low-level function; if you use
+// [method@Server.add_websocket_handler] to handle accepting WebSocket
+// connections, it will call this for you.
+func WebsocketServerProcessHandshake(MsgVar *ServerMessage, ExpectedOriginVar string, ProtocolsVar []string, SupportedExtensionsVar []gobject.TypeClass, AcceptedExtensionsVar **glib.List) bool {
+
+	cret := xWebsocketServerProcessHandshake(MsgVar.GoPointer(), ExpectedOriginVar, ProtocolsVar, SupportedExtensionsVar, AcceptedExtensionsVar)
+	return cret
+}
+
+func init() {
+	core.SetPackageName("SOUP", "libsoup-3.0")
+	core.SetSharedLibraries("SOUP", []string{"libsoup-3.0.so.0"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("SOUP") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xWebsocketCloseCodeGLibType, libs, "soup_websocket_close_code_get_type")
+
+	core.PuregoSafeRegister(&xWebsocketConnectionTypeGLibType, libs, "soup_websocket_connection_type_get_type")
+
+	core.PuregoSafeRegister(&xWebsocketDataTypeGLibType, libs, "soup_websocket_data_type_get_type")
+
+	core.PuregoSafeRegister(&xWebsocketErrorGLibType, libs, "soup_websocket_error_get_type")
+
+	core.PuregoSafeRegister(&xWebsocketStateGLibType, libs, "soup_websocket_state_get_type")
+
+	core.PuregoSafeRegister(&xWebsocketClientPrepareHandshake, libs, "soup_websocket_client_prepare_handshake")
+	core.PuregoSafeRegister(&xWebsocketClientVerifyHandshake, libs, "soup_websocket_client_verify_handshake")
+	core.PuregoSafeRegister(&xWebsocketErrorQuark, libs, "soup_websocket_error_quark")
+	core.PuregoSafeRegister(&xWebsocketServerCheckHandshake, libs, "soup_websocket_server_check_handshake")
+	core.PuregoSafeRegister(&xWebsocketServerProcessHandshake, libs, "soup_websocket_server_process_handshake")
+
+}
diff --git a/v4/webkit/WebKitApplicationInfo.go b/v4/webkit/WebKitApplicationInfo.go
new file mode 100644
index 0000000000000000000000000000000000000000..ef9eac0ff9882e233935f76d8d7c9f5c1ad6640b
--- /dev/null
+++ b/v4/webkit/WebKitApplicationInfo.go
@@ -0,0 +1,133 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Information about an application running in automation mode.
+type ApplicationInfo struct {
+	_ structs.HostLayout
+}
+
+var xApplicationInfoGLibType func() types.GType
+
+func ApplicationInfoGLibType() types.GType {
+	return xApplicationInfoGLibType()
+}
+
+func (x *ApplicationInfo) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewApplicationInfo func() *ApplicationInfo
+
+// Creates a new #WebKitApplicationInfo
+func NewApplicationInfo() *ApplicationInfo {
+
+	cret := xNewApplicationInfo()
+	return cret
+}
+
+var xApplicationInfoGetName func(uintptr) string
+
+// Get the name of the application.
+//
+// If webkit_application_info_set_name() hasn't been
+// called with a valid name, this returns g_get_prgname().
+func (x *ApplicationInfo) GetName() string {
+
+	cret := xApplicationInfoGetName(x.GoPointer())
+	return cret
+}
+
+var xApplicationInfoGetVersion func(uintptr, *uint64, *uint64, *uint64)
+
+// Get the application version previously set with webkit_application_info_set_version().
+func (x *ApplicationInfo) GetVersion(MajorVar *uint64, MinorVar *uint64, MicroVar *uint64) {
+
+	xApplicationInfoGetVersion(x.GoPointer(), MajorVar, MinorVar, MicroVar)
+
+}
+
+var xApplicationInfoRef func(uintptr) *ApplicationInfo
+
+// Atomically increments the reference count of @info by one.
+//
+// This
+// function is MT-safe and may be called from any thread.
+func (x *ApplicationInfo) Ref() *ApplicationInfo {
+
+	cret := xApplicationInfoRef(x.GoPointer())
+	return cret
+}
+
+var xApplicationInfoSetName func(uintptr, string)
+
+// Set the name of the application.
+//
+// If not provided, or %NULL is passed,
+// g_get_prgname() will be used.
+func (x *ApplicationInfo) SetName(NameVar string) {
+
+	xApplicationInfoSetName(x.GoPointer(), NameVar)
+
+}
+
+var xApplicationInfoSetVersion func(uintptr, uint64, uint64, uint64)
+
+// Set the application version.
+//
+// If the application doesn't use the format
+// major.minor.micro you can pass 0 as the micro to use major.minor, or pass
+// 0 as both micro and minor to use only major number. Any other format must
+// be converted to major.minor.micro so that it can be used in version comparisons.
+func (x *ApplicationInfo) SetVersion(MajorVar uint64, MinorVar uint64, MicroVar uint64) {
+
+	xApplicationInfoSetVersion(x.GoPointer(), MajorVar, MinorVar, MicroVar)
+
+}
+
+var xApplicationInfoUnref func(uintptr)
+
+// Atomically decrements the reference count of @info by one.
+//
+// If the
+// reference count drops to 0, all memory allocated by the #WebKitApplicationInfo is
+// released. This function is MT-safe and may be called from any
+// thread.
+func (x *ApplicationInfo) Unref() {
+
+	xApplicationInfoUnref(x.GoPointer())
+
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xApplicationInfoGLibType, libs, "webkit_application_info_get_type")
+
+	core.PuregoSafeRegister(&xNewApplicationInfo, libs, "webkit_application_info_new")
+
+	core.PuregoSafeRegister(&xApplicationInfoGetName, libs, "webkit_application_info_get_name")
+	core.PuregoSafeRegister(&xApplicationInfoGetVersion, libs, "webkit_application_info_get_version")
+	core.PuregoSafeRegister(&xApplicationInfoRef, libs, "webkit_application_info_ref")
+	core.PuregoSafeRegister(&xApplicationInfoSetName, libs, "webkit_application_info_set_name")
+	core.PuregoSafeRegister(&xApplicationInfoSetVersion, libs, "webkit_application_info_set_version")
+	core.PuregoSafeRegister(&xApplicationInfoUnref, libs, "webkit_application_info_unref")
+
+}
diff --git a/v4/webkit/WebKitAuthenticationRequest.go b/v4/webkit/WebKitAuthenticationRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..75f19b0c564b8dd69ccd3e62dbc6f9e49520d8d6
--- /dev/null
+++ b/v4/webkit/WebKitAuthenticationRequest.go
@@ -0,0 +1,336 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type AuthenticationRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *AuthenticationRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values representing the authentication scheme.
+type AuthenticationScheme int
+
+var xAuthenticationSchemeGLibType func() types.GType
+
+func AuthenticationSchemeGLibType() types.GType {
+	return xAuthenticationSchemeGLibType()
+}
+
+const (
+
+	// The default authentication scheme of WebKit.
+	AuthenticationSchemeDefaultValue AuthenticationScheme = 1
+	// Basic authentication scheme as defined in RFC 2617.
+	AuthenticationSchemeHttpBasicValue AuthenticationScheme = 2
+	// Digest authentication scheme as defined in RFC 2617.
+	AuthenticationSchemeHttpDigestValue AuthenticationScheme = 3
+	// HTML Form authentication.
+	AuthenticationSchemeHtmlFormValue AuthenticationScheme = 4
+	// NTLM Microsoft proprietary authentication scheme.
+	AuthenticationSchemeNtlmValue AuthenticationScheme = 5
+	// Negotiate (or SPNEGO) authentication scheme as defined in RFC 4559.
+	AuthenticationSchemeNegotiateValue AuthenticationScheme = 6
+	// Client Certificate Authentication (see RFC 2246).
+	AuthenticationSchemeClientCertificateRequestedValue AuthenticationScheme = 7
+	// Server Trust Authentication.
+	AuthenticationSchemeServerTrustEvaluationRequestedValue AuthenticationScheme = 8
+	// Client certificate PIN required for use. Since: 2.34
+	AuthenticationSchemeClientCertificatePinRequestedValue AuthenticationScheme = 9
+	// Authentication scheme unknown.
+	AuthenticationSchemeUnknownValue AuthenticationScheme = 100
+)
+
+// Represents an authentication request.
+//
+// Whenever a client attempts to load a page protected by HTTP
+// authentication, credentials will need to be provided to authorize access.
+// To allow the client to decide how it wishes to handle authentication,
+// WebKit will fire a #WebKitWebView::authenticate signal with a
+// WebKitAuthenticationRequest object to provide client side
+// authentication support. Credentials are exposed through the
+// #WebKitCredential object.
+//
+// In case the client application does not wish
+// to handle this signal WebKit will provide a default handler. To handle
+// authentication asynchronously, simply increase the reference count of the
+// WebKitAuthenticationRequest object.
+type AuthenticationRequest struct {
+	gobject.Object
+}
+
+var xAuthenticationRequestGLibType func() types.GType
+
+func AuthenticationRequestGLibType() types.GType {
+	return xAuthenticationRequestGLibType()
+}
+
+func AuthenticationRequestNewFromInternalPtr(ptr uintptr) *AuthenticationRequest {
+	cls := &AuthenticationRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xAuthenticationRequestAuthenticate func(uintptr, *Credential)
+
+// Authenticate the #WebKitAuthenticationRequest.
+//
+// Authenticate the #WebKitAuthenticationRequest using the #WebKitCredential
+// supplied. To continue without credentials, pass %NULL as @credential.
+func (x *AuthenticationRequest) Authenticate(CredentialVar *Credential) {
+
+	xAuthenticationRequestAuthenticate(x.GoPointer(), CredentialVar)
+
+}
+
+var xAuthenticationRequestCanSaveCredentials func(uintptr) bool
+
+// Determine whether this #WebKitAuthenticationRequest should allow the storage of credentials.
+//
+// Determine whether the authentication method associated with this
+// #WebKitAuthenticationRequest should allow the storage of credentials.
+// This will return %FALSE if WebKit doesn't support credential storing,
+// if private browsing is enabled, or if persistent credential storage has been
+// disabled in #WebKitWebsiteDataManager, unless credentials saving has been
+// explicitly enabled with webkit_authentication_request_set_can_save_credentials().
+func (x *AuthenticationRequest) CanSaveCredentials() bool {
+
+	cret := xAuthenticationRequestCanSaveCredentials(x.GoPointer())
+	return cret
+}
+
+var xAuthenticationRequestCancel func(uintptr)
+
+// Cancel the authentication challenge.
+//
+// This will also cancel the page loading and result in a
+// #WebKitWebView::load-failed signal with a #WebKitNetworkError of type %WEBKIT_NETWORK_ERROR_CANCELLED being emitted.
+func (x *AuthenticationRequest) Cancel() {
+
+	xAuthenticationRequestCancel(x.GoPointer())
+
+}
+
+var xAuthenticationRequestGetCertificatePinFlags func(uintptr) gio.TlsPasswordFlags
+
+// Get the #GTlsPasswordFlags of the %WEBKIT_AUTHENTICATION_SCHEME_CLIENT_CERTIFICATE_PIN_REQUESTED authentication challenge.
+func (x *AuthenticationRequest) GetCertificatePinFlags() gio.TlsPasswordFlags {
+
+	cret := xAuthenticationRequestGetCertificatePinFlags(x.GoPointer())
+	return cret
+}
+
+var xAuthenticationRequestGetHost func(uintptr) string
+
+// Get the host that this authentication challenge is applicable to.
+func (x *AuthenticationRequest) GetHost() string {
+
+	cret := xAuthenticationRequestGetHost(x.GoPointer())
+	return cret
+}
+
+var xAuthenticationRequestGetPort func(uintptr) uint
+
+// Get the port that this authentication challenge is applicable to.
+func (x *AuthenticationRequest) GetPort() uint {
+
+	cret := xAuthenticationRequestGetPort(x.GoPointer())
+	return cret
+}
+
+var xAuthenticationRequestGetProposedCredential func(uintptr) *Credential
+
+// Get the #WebKitCredential of the proposed authentication challenge.
+//
+// Get the #WebKitCredential of the proposed authentication challenge that was
+// stored from a previous session. The client can use this directly for
+// authentication or construct their own #WebKitCredential.
+func (x *AuthenticationRequest) GetProposedCredential() *Credential {
+
+	cret := xAuthenticationRequestGetProposedCredential(x.GoPointer())
+	return cret
+}
+
+var xAuthenticationRequestGetRealm func(uintptr) string
+
+// Get the realm that this authentication challenge is applicable to.
+func (x *AuthenticationRequest) GetRealm() string {
+
+	cret := xAuthenticationRequestGetRealm(x.GoPointer())
+	return cret
+}
+
+var xAuthenticationRequestGetScheme func(uintptr) AuthenticationScheme
+
+// Get the authentication scheme of the authentication challenge.
+func (x *AuthenticationRequest) GetScheme() AuthenticationScheme {
+
+	cret := xAuthenticationRequestGetScheme(x.GoPointer())
+	return cret
+}
+
+var xAuthenticationRequestGetSecurityOrigin func(uintptr) *SecurityOrigin
+
+// Get the #WebKitSecurityOrigin that this authentication challenge is applicable to.
+func (x *AuthenticationRequest) GetSecurityOrigin() *SecurityOrigin {
+
+	cret := xAuthenticationRequestGetSecurityOrigin(x.GoPointer())
+	return cret
+}
+
+var xAuthenticationRequestIsForProxy func(uintptr) bool
+
+// Determine whether the authentication challenge is associated with a proxy server.
+//
+// Determine whether the authentication challenge is associated with a proxy server rather than an "origin" server.
+func (x *AuthenticationRequest) IsForProxy() bool {
+
+	cret := xAuthenticationRequestIsForProxy(x.GoPointer())
+	return cret
+}
+
+var xAuthenticationRequestIsRetry func(uintptr) bool
+
+// Determine whether this this is a first attempt or a retry for this authentication challenge.
+func (x *AuthenticationRequest) IsRetry() bool {
+
+	cret := xAuthenticationRequestIsRetry(x.GoPointer())
+	return cret
+}
+
+var xAuthenticationRequestSetCanSaveCredentials func(uintptr, bool)
+
+// Set whether the authentication method associated with @request
+// should allow the storage of credentials.
+//
+// Set whether the authentication method associated with @request
+// should allow the storage of credentials.
+// This should be used by applications handling their own credentials
+// storage to indicate that it should be supported even when internal
+// credential storage is disabled or unsupported.
+// Note that storing of credentials will not be allowed on ephemeral
+// sessions in any case.
+func (x *AuthenticationRequest) SetCanSaveCredentials(EnabledVar bool) {
+
+	xAuthenticationRequestSetCanSaveCredentials(x.GoPointer(), EnabledVar)
+
+}
+
+var xAuthenticationRequestSetProposedCredential func(uintptr, *Credential)
+
+// Set the #WebKitCredential of the proposed authentication challenge.
+//
+// Set the #WebKitCredential of the proposed authentication challenge that was
+// stored from a previous session. This should only be used by applications handling
+// their own credential storage. (When using the default WebKit credential storage,
+// webkit_authentication_request_get_proposed_credential() already contains previously-stored
+// credentials.)
+// Passing a %NULL @credential will clear the proposed credential.
+func (x *AuthenticationRequest) SetProposedCredential(CredentialVar *Credential) {
+
+	xAuthenticationRequestSetProposedCredential(x.GoPointer(), CredentialVar)
+
+}
+
+func (c *AuthenticationRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *AuthenticationRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// This signal is emitted when the user authentication request succeeded.
+// Applications handling their own credential storage should connect to
+// this signal to save the credentials.
+func (x *AuthenticationRequest) ConnectAuthenticated(cb *func(AuthenticationRequest, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "authenticated", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, CredentialVarp uintptr) {
+		fa := AuthenticationRequest{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, CredentialVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "authenticated", cbRefPtr)
+}
+
+// This signal is emitted when the user authentication request is
+// cancelled. It allows the application to dismiss its authentication
+// dialog in case of page load failure for example.
+func (x *AuthenticationRequest) ConnectCancelled(cb *func(AuthenticationRequest)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "cancelled", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := AuthenticationRequest{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "cancelled", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xAuthenticationSchemeGLibType, libs, "webkit_authentication_scheme_get_type")
+
+	core.PuregoSafeRegister(&xAuthenticationRequestGLibType, libs, "webkit_authentication_request_get_type")
+
+	core.PuregoSafeRegister(&xAuthenticationRequestAuthenticate, libs, "webkit_authentication_request_authenticate")
+	core.PuregoSafeRegister(&xAuthenticationRequestCanSaveCredentials, libs, "webkit_authentication_request_can_save_credentials")
+	core.PuregoSafeRegister(&xAuthenticationRequestCancel, libs, "webkit_authentication_request_cancel")
+	core.PuregoSafeRegister(&xAuthenticationRequestGetCertificatePinFlags, libs, "webkit_authentication_request_get_certificate_pin_flags")
+	core.PuregoSafeRegister(&xAuthenticationRequestGetHost, libs, "webkit_authentication_request_get_host")
+	core.PuregoSafeRegister(&xAuthenticationRequestGetPort, libs, "webkit_authentication_request_get_port")
+	core.PuregoSafeRegister(&xAuthenticationRequestGetProposedCredential, libs, "webkit_authentication_request_get_proposed_credential")
+	core.PuregoSafeRegister(&xAuthenticationRequestGetRealm, libs, "webkit_authentication_request_get_realm")
+	core.PuregoSafeRegister(&xAuthenticationRequestGetScheme, libs, "webkit_authentication_request_get_scheme")
+	core.PuregoSafeRegister(&xAuthenticationRequestGetSecurityOrigin, libs, "webkit_authentication_request_get_security_origin")
+	core.PuregoSafeRegister(&xAuthenticationRequestIsForProxy, libs, "webkit_authentication_request_is_for_proxy")
+	core.PuregoSafeRegister(&xAuthenticationRequestIsRetry, libs, "webkit_authentication_request_is_retry")
+	core.PuregoSafeRegister(&xAuthenticationRequestSetCanSaveCredentials, libs, "webkit_authentication_request_set_can_save_credentials")
+	core.PuregoSafeRegister(&xAuthenticationRequestSetProposedCredential, libs, "webkit_authentication_request_set_proposed_credential")
+
+}
diff --git a/v4/webkit/WebKitAutomationSession.go b/v4/webkit/WebKitAutomationSession.go
new file mode 100644
index 0000000000000000000000000000000000000000..dd592ecae829169a9525d12e87e19b4ac94b7836
--- /dev/null
+++ b/v4/webkit/WebKitAutomationSession.go
@@ -0,0 +1,203 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type AutomationSessionClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *AutomationSessionClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values used for determining the automation browsing context presentation.
+type AutomationBrowsingContextPresentation int
+
+var xAutomationBrowsingContextPresentationGLibType func() types.GType
+
+func AutomationBrowsingContextPresentationGLibType() types.GType {
+	return xAutomationBrowsingContextPresentationGLibType()
+}
+
+const (
+
+	// a window
+	AutomationBrowsingContextPresentationWindowValue AutomationBrowsingContextPresentation = 0
+	// a tab
+	AutomationBrowsingContextPresentationTabValue AutomationBrowsingContextPresentation = 1
+)
+
+// Automation Session.
+//
+// WebKitAutomationSession represents an automation session of a WebKitWebContext.
+// When a new session is requested, a WebKitAutomationSession is created and the signal
+// WebKitWebContext::automation-started is emitted with the WebKitAutomationSession as
+// argument. Then, the automation client can request the session to create a new
+// #WebKitWebView to interact with it. When this happens the signal #WebKitAutomationSession::create-web-view
+// is emitted.
+type AutomationSession struct {
+	gobject.Object
+}
+
+var xAutomationSessionGLibType func() types.GType
+
+func AutomationSessionGLibType() types.GType {
+	return xAutomationSessionGLibType()
+}
+
+func AutomationSessionNewFromInternalPtr(ptr uintptr) *AutomationSession {
+	cls := &AutomationSession{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xAutomationSessionGetApplicationInfo func(uintptr) *ApplicationInfo
+
+// Get the the previously set #WebKitAutomationSession.
+//
+// Get the #WebKitAutomationSession previously set with webkit_automation_session_set_application_info().
+func (x *AutomationSession) GetApplicationInfo() *ApplicationInfo {
+
+	cret := xAutomationSessionGetApplicationInfo(x.GoPointer())
+	return cret
+}
+
+var xAutomationSessionGetId func(uintptr) string
+
+// Get the unique identifier of a #WebKitAutomationSession
+func (x *AutomationSession) GetId() string {
+
+	cret := xAutomationSessionGetId(x.GoPointer())
+	return cret
+}
+
+var xAutomationSessionSetApplicationInfo func(uintptr, *ApplicationInfo)
+
+// Set the application information to @session.
+//
+// This information will be used by the driver service
+// to match the requested capabilities with the actual application information. If this information
+// is not provided to the session when a new automation session is requested, the creation might fail
+// if the client requested a specific browser name or version. This will not have any effect when called
+// after the automation session has been fully created, so this must be called in the callback of
+// #WebKitWebContext::automation-started signal.
+func (x *AutomationSession) SetApplicationInfo(InfoVar *ApplicationInfo) {
+
+	xAutomationSessionSetApplicationInfo(x.GoPointer(), InfoVar)
+
+}
+
+func (c *AutomationSession) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *AutomationSession) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyId sets the "id" property.
+// The session unique identifier.
+func (x *AutomationSession) SetPropertyId(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("id", &v)
+}
+
+// GetPropertyId gets the "id" property.
+// The session unique identifier.
+func (x *AutomationSession) GetPropertyId() string {
+	var v gobject.Value
+	x.GetProperty("id", &v)
+	return v.GetString()
+}
+
+// This signal is emitted when the automation client requests a new
+// browsing context to interact with it. The callback handler should
+// return a #WebKitWebView created with #WebKitWebView:is-controlled-by-automation
+// construct property enabled and #WebKitWebView:automation-presentation-type construct
+// property set if needed.
+//
+// If the signal is emitted with "tab" detail, the returned #WebKitWebView should be
+// a new web view added to a new tab of the current browsing context window.
+// If the signal is emitted with "window" detail, the returned #WebKitWebView should be
+// a new web view added to a new window.
+// When creating a new web view and there's an active browsing context, the new window
+// or tab shouldn't be focused.
+func (x *AutomationSession) ConnectCreateWebView(cb *func(AutomationSession) WebView) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "create-web-view", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) uintptr {
+		fa := AutomationSession{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		CreateWebViewCls := cbFn(fa)
+		return CreateWebViewCls.Ptr
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "create-web-view", cbRefPtr)
+}
+
+// This signal is emitted when the given automation session is about to finish.
+// It allows clients to perform any cleanup tasks before the session is destroyed.
+func (x *AutomationSession) ConnectWillClose(cb *func(AutomationSession)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "will-close", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := AutomationSession{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "will-close", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xAutomationBrowsingContextPresentationGLibType, libs, "webkit_automation_browsing_context_presentation_get_type")
+
+	core.PuregoSafeRegister(&xAutomationSessionGLibType, libs, "webkit_automation_session_get_type")
+
+	core.PuregoSafeRegister(&xAutomationSessionGetApplicationInfo, libs, "webkit_automation_session_get_application_info")
+	core.PuregoSafeRegister(&xAutomationSessionGetId, libs, "webkit_automation_session_get_id")
+	core.PuregoSafeRegister(&xAutomationSessionSetApplicationInfo, libs, "webkit_automation_session_set_application_info")
+
+}
diff --git a/v4/webkit/WebKitBackForwardList.go b/v4/webkit/WebKitBackForwardList.go
new file mode 100644
index 0000000000000000000000000000000000000000..0cc9e2f6c08630146cd157a70f37fbb0e97f4c5d
--- /dev/null
+++ b/v4/webkit/WebKitBackForwardList.go
@@ -0,0 +1,228 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type BackForwardListClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *BackForwardListClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// List of visited pages.
+//
+// WebKitBackForwardList maintains a list of visited pages used to
+// navigate to recent pages. Items are inserted in the list in the
+// order they are visited.
+//
+// WebKitBackForwardList also maintains the notion of the current item
+// (which is always at index 0), the preceding item (which is at index -1),
+// and the following item (which is at index 1).
+// Methods webkit_web_view_go_back() and webkit_web_view_go_forward() move
+// the current item backward or forward by one. Method
+// webkit_web_view_go_to_back_forward_list_item() sets the current item to the
+// specified item. All other methods returning #WebKitBackForwardListItem&lt;!-- --&gt;s
+// do not change the value of the current item, they just return the requested
+// item or items.
+type BackForwardList struct {
+	gobject.Object
+}
+
+var xBackForwardListGLibType func() types.GType
+
+func BackForwardListGLibType() types.GType {
+	return xBackForwardListGLibType()
+}
+
+func BackForwardListNewFromInternalPtr(ptr uintptr) *BackForwardList {
+	cls := &BackForwardList{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xBackForwardListGetBackItem func(uintptr) uintptr
+
+// Returns the item that precedes the current item.
+func (x *BackForwardList) GetBackItem() *BackForwardListItem {
+	var cls *BackForwardListItem
+
+	cret := xBackForwardListGetBackItem(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &BackForwardListItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xBackForwardListGetBackList func(uintptr) *glib.List
+
+// Obtain the list of items preceding the current one.
+func (x *BackForwardList) GetBackList() *glib.List {
+
+	cret := xBackForwardListGetBackList(x.GoPointer())
+	return cret
+}
+
+var xBackForwardListGetBackListWithLimit func(uintptr, uint) *glib.List
+
+// Obtain a list up to some number of items preceding the current one.
+func (x *BackForwardList) GetBackListWithLimit(LimitVar uint) *glib.List {
+
+	cret := xBackForwardListGetBackListWithLimit(x.GoPointer(), LimitVar)
+	return cret
+}
+
+var xBackForwardListGetCurrentItem func(uintptr) uintptr
+
+// Returns the current item in @back_forward_list.
+func (x *BackForwardList) GetCurrentItem() *BackForwardListItem {
+	var cls *BackForwardListItem
+
+	cret := xBackForwardListGetCurrentItem(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &BackForwardListItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xBackForwardListGetForwardItem func(uintptr) uintptr
+
+// Returns the item that follows the current item.
+func (x *BackForwardList) GetForwardItem() *BackForwardListItem {
+	var cls *BackForwardListItem
+
+	cret := xBackForwardListGetForwardItem(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &BackForwardListItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xBackForwardListGetForwardList func(uintptr) *glib.List
+
+// Obtain the list of items following the current one.
+func (x *BackForwardList) GetForwardList() *glib.List {
+
+	cret := xBackForwardListGetForwardList(x.GoPointer())
+	return cret
+}
+
+var xBackForwardListGetForwardListWithLimit func(uintptr, uint) *glib.List
+
+// Obtain a list up to some number of items following the current one.
+func (x *BackForwardList) GetForwardListWithLimit(LimitVar uint) *glib.List {
+
+	cret := xBackForwardListGetForwardListWithLimit(x.GoPointer(), LimitVar)
+	return cret
+}
+
+var xBackForwardListGetLength func(uintptr) uint
+
+// Obtain the amount of items in the list.
+func (x *BackForwardList) GetLength() uint {
+
+	cret := xBackForwardListGetLength(x.GoPointer())
+	return cret
+}
+
+var xBackForwardListGetNthItem func(uintptr, int) uintptr
+
+// Returns the item at a given index relative to the current item.
+func (x *BackForwardList) GetNthItem(IndexVar int) *BackForwardListItem {
+	var cls *BackForwardListItem
+
+	cret := xBackForwardListGetNthItem(x.GoPointer(), IndexVar)
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &BackForwardListItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+func (c *BackForwardList) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *BackForwardList) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// This signal is emitted when @back_forward_list changes. This happens
+// when the current item is updated, a new item is added or one or more
+// items are removed. Note that both @item_added and @items_removed can
+// %NULL when only the current item is updated. Items are only removed
+// when the list is cleared or the maximum items limit is reached.
+func (x *BackForwardList) ConnectChanged(cb *func(BackForwardList, uintptr, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ItemAddedVarp uintptr, ItemsRemovedVarp uintptr) {
+		fa := BackForwardList{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ItemAddedVarp, ItemsRemovedVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xBackForwardListGLibType, libs, "webkit_back_forward_list_get_type")
+
+	core.PuregoSafeRegister(&xBackForwardListGetBackItem, libs, "webkit_back_forward_list_get_back_item")
+	core.PuregoSafeRegister(&xBackForwardListGetBackList, libs, "webkit_back_forward_list_get_back_list")
+	core.PuregoSafeRegister(&xBackForwardListGetBackListWithLimit, libs, "webkit_back_forward_list_get_back_list_with_limit")
+	core.PuregoSafeRegister(&xBackForwardListGetCurrentItem, libs, "webkit_back_forward_list_get_current_item")
+	core.PuregoSafeRegister(&xBackForwardListGetForwardItem, libs, "webkit_back_forward_list_get_forward_item")
+	core.PuregoSafeRegister(&xBackForwardListGetForwardList, libs, "webkit_back_forward_list_get_forward_list")
+	core.PuregoSafeRegister(&xBackForwardListGetForwardListWithLimit, libs, "webkit_back_forward_list_get_forward_list_with_limit")
+	core.PuregoSafeRegister(&xBackForwardListGetLength, libs, "webkit_back_forward_list_get_length")
+	core.PuregoSafeRegister(&xBackForwardListGetNthItem, libs, "webkit_back_forward_list_get_nth_item")
+
+}
diff --git a/v4/webkit/WebKitBackForwardListItem.go b/v4/webkit/WebKitBackForwardListItem.go
new file mode 100644
index 0000000000000000000000000000000000000000..9ed254b89b80b1343813dea1c2c2932132d8caad
--- /dev/null
+++ b/v4/webkit/WebKitBackForwardListItem.go
@@ -0,0 +1,106 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type BackForwardListItemClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.InitiallyUnownedClass
+}
+
+func (x *BackForwardListItemClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// One item of the #WebKitBackForwardList.
+//
+// A history item is part of the #WebKitBackForwardList and consists
+// out of a title and a URI.
+type BackForwardListItem struct {
+	gobject.InitiallyUnowned
+}
+
+var xBackForwardListItemGLibType func() types.GType
+
+func BackForwardListItemGLibType() types.GType {
+	return xBackForwardListItemGLibType()
+}
+
+func BackForwardListItemNewFromInternalPtr(ptr uintptr) *BackForwardListItem {
+	cls := &BackForwardListItem{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xBackForwardListItemGetOriginalUri func(uintptr) string
+
+// Obtain the original URI of the item.
+//
+// See also webkit_back_forward_list_item_get_uri().
+func (x *BackForwardListItem) GetOriginalUri() string {
+
+	cret := xBackForwardListItemGetOriginalUri(x.GoPointer())
+	return cret
+}
+
+var xBackForwardListItemGetTitle func(uintptr) string
+
+// Obtain the title of the item.
+func (x *BackForwardListItem) GetTitle() string {
+
+	cret := xBackForwardListItemGetTitle(x.GoPointer())
+	return cret
+}
+
+var xBackForwardListItemGetUri func(uintptr) string
+
+// Obtain the URI of the item.
+//
+// This URI may differ from the original URI if the page was,
+// for example, redirected to a new location.
+// See also webkit_back_forward_list_item_get_original_uri().
+func (x *BackForwardListItem) GetUri() string {
+
+	cret := xBackForwardListItemGetUri(x.GoPointer())
+	return cret
+}
+
+func (c *BackForwardListItem) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *BackForwardListItem) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xBackForwardListItemGLibType, libs, "webkit_back_forward_list_item_get_type")
+
+	core.PuregoSafeRegister(&xBackForwardListItemGetOriginalUri, libs, "webkit_back_forward_list_item_get_original_uri")
+	core.PuregoSafeRegister(&xBackForwardListItemGetTitle, libs, "webkit_back_forward_list_item_get_title")
+	core.PuregoSafeRegister(&xBackForwardListItemGetUri, libs, "webkit_back_forward_list_item_get_uri")
+
+}
diff --git a/v4/webkit/WebKitClipboardPermissionRequest.go b/v4/webkit/WebKitClipboardPermissionRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..f1cf3a6358c5e878893337f14a6030560a355d44
--- /dev/null
+++ b/v4/webkit/WebKitClipboardPermissionRequest.go
@@ -0,0 +1,69 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type ClipboardPermissionRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *ClipboardPermissionRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A permission request for reading clipboard contents.
+//
+// WebKitClipboardPermissionRequest represents a request for
+// permission to decide whether WebKit can access the clipboard to read
+// its contents through the Async Clipboard API.
+//
+// When a WebKitClipboardPermissionRequest is not handled by the user,
+// it is denied by default.
+type ClipboardPermissionRequest struct {
+	gobject.Object
+}
+
+var xClipboardPermissionRequestGLibType func() types.GType
+
+func ClipboardPermissionRequestGLibType() types.GType {
+	return xClipboardPermissionRequestGLibType()
+}
+
+func ClipboardPermissionRequestNewFromInternalPtr(ptr uintptr) *ClipboardPermissionRequest {
+	cls := &ClipboardPermissionRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *ClipboardPermissionRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *ClipboardPermissionRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Allow the action which triggered this request.
+func (x *ClipboardPermissionRequest) Allow() {
+
+	XWebkitPermissionRequestAllow(x.GoPointer())
+
+}
+
+// Deny the action which triggered this request.
+func (x *ClipboardPermissionRequest) Deny() {
+
+	XWebkitPermissionRequestDeny(x.GoPointer())
+
+}
diff --git a/v4/webkit/WebKitColorChooserRequest.go b/v4/webkit/WebKitColorChooserRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..066f0954fa9eff0c255eadfd506809851a41104f
--- /dev/null
+++ b/v4/webkit/WebKitColorChooserRequest.go
@@ -0,0 +1,184 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gdk"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type ColorChooserRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *ColorChooserRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A request to open a color chooser.
+//
+// Whenever the user interacts with an &lt;input type='color' /&gt;
+// HTML element, WebKit will need to show a dialog to choose a color. For that
+// to happen in a general way, instead of just opening a #GtkColorChooser
+// (which might be not desirable in some cases, which could prefer to use their
+// own color chooser dialog), WebKit will fire the
+// #WebKitWebView::run-color-chooser signal with a #WebKitColorChooserRequest
+// object, which will allow the client application to specify the color to be
+// selected, to inspect the details of the request (e.g. to get initial color)
+// and to cancel the request, in case nothing was selected.
+//
+// In case the client application does not wish to handle this signal,
+// WebKit will provide a default handler which will asynchronously run
+// a regular #GtkColorChooserDialog for the user to interact with.
+type ColorChooserRequest struct {
+	gobject.Object
+}
+
+var xColorChooserRequestGLibType func() types.GType
+
+func ColorChooserRequestGLibType() types.GType {
+	return xColorChooserRequestGLibType()
+}
+
+func ColorChooserRequestNewFromInternalPtr(ptr uintptr) *ColorChooserRequest {
+	cls := &ColorChooserRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xColorChooserRequestCancel func(uintptr)
+
+// Cancels @request and the input element changes to use the initial color.
+//
+// Cancels @request and the input element changes to use the initial color
+// it has before the request started.
+// The signal #WebKitColorChooserRequest::finished
+// is emitted to notify that the request has finished.
+func (x *ColorChooserRequest) Cancel() {
+
+	xColorChooserRequestCancel(x.GoPointer())
+
+}
+
+var xColorChooserRequestFinish func(uintptr)
+
+// Finishes @request and the input element keeps the current value of
+// #WebKitColorChooserRequest:rgba.
+//
+// Finishes @request and the input element keeps the current value of
+// #WebKitColorChooserRequest:rgba.
+// The signal #WebKitColorChooserRequest::finished
+// is emitted to notify that the request has finished.
+func (x *ColorChooserRequest) Finish() {
+
+	xColorChooserRequestFinish(x.GoPointer())
+
+}
+
+var xColorChooserRequestGetElementRectangle func(uintptr, *gdk.Rectangle)
+
+// Gets the bounding box of the color input element.
+func (x *ColorChooserRequest) GetElementRectangle(RectVar *gdk.Rectangle) {
+
+	xColorChooserRequestGetElementRectangle(x.GoPointer(), RectVar)
+
+}
+
+var xColorChooserRequestGetRgba func(uintptr, *gdk.RGBA)
+
+// Gets the current #GdkRGBA color of @request
+func (x *ColorChooserRequest) GetRgba(RgbaVar *gdk.RGBA) {
+
+	xColorChooserRequestGetRgba(x.GoPointer(), RgbaVar)
+
+}
+
+var xColorChooserRequestSetRgba func(uintptr, *gdk.RGBA)
+
+// Sets the current #GdkRGBA color of @request
+func (x *ColorChooserRequest) SetRgba(RgbaVar *gdk.RGBA) {
+
+	xColorChooserRequestSetRgba(x.GoPointer(), RgbaVar)
+
+}
+
+func (c *ColorChooserRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *ColorChooserRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyRgba sets the "rgba" property.
+// The #GdkRGBA color of the request
+func (x *ColorChooserRequest) SetPropertyRgba(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("rgba", &v)
+}
+
+// GetPropertyRgba gets the "rgba" property.
+// The #GdkRGBA color of the request
+func (x *ColorChooserRequest) GetPropertyRgba() uintptr {
+	var v gobject.Value
+	x.GetProperty("rgba", &v)
+	return v.GetPointer()
+}
+
+// Emitted when the @request finishes. This signal can be emitted because the
+// user completed the @request calling webkit_color_chooser_request_finish(),
+// or cancelled it with webkit_color_chooser_request_cancel() or because the
+// color input element is removed from the DOM.
+func (x *ColorChooserRequest) ConnectFinished(cb *func(ColorChooserRequest)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := ColorChooserRequest{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xColorChooserRequestGLibType, libs, "webkit_color_chooser_request_get_type")
+
+	core.PuregoSafeRegister(&xColorChooserRequestCancel, libs, "webkit_color_chooser_request_cancel")
+	core.PuregoSafeRegister(&xColorChooserRequestFinish, libs, "webkit_color_chooser_request_finish")
+	core.PuregoSafeRegister(&xColorChooserRequestGetElementRectangle, libs, "webkit_color_chooser_request_get_element_rectangle")
+	core.PuregoSafeRegister(&xColorChooserRequestGetRgba, libs, "webkit_color_chooser_request_get_rgba")
+	core.PuregoSafeRegister(&xColorChooserRequestSetRgba, libs, "webkit_color_chooser_request_set_rgba")
+
+}
diff --git a/v4/webkit/WebKitContextMenu.go b/v4/webkit/WebKitContextMenu.go
new file mode 100644
index 0000000000000000000000000000000000000000..acea4f67814b70d99797b515e791d03b0dc3533b
--- /dev/null
+++ b/v4/webkit/WebKitContextMenu.go
@@ -0,0 +1,333 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gdk"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type ContextMenuClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *ContextMenuClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Represents the context menu in a #WebKitWebView.
+//
+// #WebKitContextMenu represents a context menu containing
+// #WebKitContextMenuItem&lt;!-- --&gt;s in a #WebKitWebView.
+//
+// When a #WebKitWebView is about to display the context menu, it
+// emits the #WebKitWebView::context-menu signal, which has the
+// #WebKitContextMenu as an argument. You can modify it, adding new
+// submenus that you can create with webkit_context_menu_new(), adding
+// new #WebKitContextMenuItem&lt;!-- --&gt;s with
+// webkit_context_menu_prepend(), webkit_context_menu_append() or
+// webkit_context_menu_insert(), maybe after having removed the
+// existing ones with webkit_context_menu_remove_all().
+type ContextMenu struct {
+	gobject.Object
+}
+
+var xContextMenuGLibType func() types.GType
+
+func ContextMenuGLibType() types.GType {
+	return xContextMenuGLibType()
+}
+
+func ContextMenuNewFromInternalPtr(ptr uintptr) *ContextMenu {
+	cls := &ContextMenu{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewContextMenu func() uintptr
+
+// Creates a new #WebKitContextMenu object.
+//
+// Creates a new #WebKitContextMenu object to be used as a submenu of an existing
+// #WebKitContextMenu. The context menu of a #WebKitWebView is created by the view
+// and passed as an argument of #WebKitWebView::context-menu signal.
+// To add items to the menu use webkit_context_menu_prepend(),
+// webkit_context_menu_append() or webkit_context_menu_insert().
+// See also webkit_context_menu_new_with_items() to create a #WebKitContextMenu with
+// a list of initial items.
+func NewContextMenu() *ContextMenu {
+	var cls *ContextMenu
+
+	cret := xNewContextMenu()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &ContextMenu{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewContextMenuWithItems func(*glib.List) uintptr
+
+// Creates a new #WebKitContextMenu object with the given items.
+//
+// Creates a new #WebKitContextMenu object to be used as a submenu of an existing
+// #WebKitContextMenu with the given initial items.
+// See also webkit_context_menu_new()
+func NewContextMenuWithItems(ItemsVar *glib.List) *ContextMenu {
+	var cls *ContextMenu
+
+	cret := xNewContextMenuWithItems(ItemsVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &ContextMenu{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextMenuAppend func(uintptr, uintptr)
+
+// Adds @item at the end of the @menu.
+func (x *ContextMenu) Append(ItemVar *ContextMenuItem) {
+
+	xContextMenuAppend(x.GoPointer(), ItemVar.GoPointer())
+
+}
+
+var xContextMenuFirst func(uintptr) uintptr
+
+// Gets the first item in the @menu.
+func (x *ContextMenu) First() *ContextMenuItem {
+	var cls *ContextMenuItem
+
+	cret := xContextMenuFirst(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &ContextMenuItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextMenuGetEvent func(uintptr) uintptr
+
+// Gets the #GdkEvent that triggered the context menu. This function only returns a valid
+// #GdkEvent when called for a #WebKitContextMenu passed to #WebKitWebView::context-menu
+// signal; in all other cases, %NULL is returned.
+//
+// The returned #GdkEvent is expected to be one of the following types:
+// &lt;itemizedlist&gt;
+// &lt;listitem&gt;&lt;para&gt;
+// a #GdkEventButton of type %GDK_BUTTON_PRESS when the context menu was triggered with mouse.
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+// a #GdkEventKey of type %GDK_KEY_PRESS if the keyboard was used to show the menu.
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+// a generic #GdkEvent of type %GDK_NOTHING when the #GtkWidget::popup-menu signal was used to show the context menu.
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;/itemizedlist&gt;
+func (x *ContextMenu) GetEvent() *gdk.Event {
+	var cls *gdk.Event
+
+	cret := xContextMenuGetEvent(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gdk.Event{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextMenuGetItemAtPosition func(uintptr, uint) uintptr
+
+// Gets the item at the given position in the @menu.
+func (x *ContextMenu) GetItemAtPosition(PositionVar uint) *ContextMenuItem {
+	var cls *ContextMenuItem
+
+	cret := xContextMenuGetItemAtPosition(x.GoPointer(), PositionVar)
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &ContextMenuItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextMenuGetItems func(uintptr) *glib.List
+
+// Returns the item list of @menu.
+func (x *ContextMenu) GetItems() *glib.List {
+
+	cret := xContextMenuGetItems(x.GoPointer())
+	return cret
+}
+
+var xContextMenuGetNItems func(uintptr) uint
+
+// Gets the length of the @menu.
+func (x *ContextMenu) GetNItems() uint {
+
+	cret := xContextMenuGetNItems(x.GoPointer())
+	return cret
+}
+
+var xContextMenuGetUserData func(uintptr) *glib.Variant
+
+// Gets the user data of @menu.
+//
+// This function can be used from the UI Process to get user data previously set
+// from the Web Process with webkit_context_menu_set_user_data().
+func (x *ContextMenu) GetUserData() *glib.Variant {
+
+	cret := xContextMenuGetUserData(x.GoPointer())
+	return cret
+}
+
+var xContextMenuInsert func(uintptr, uintptr, int)
+
+// Inserts @item into the @menu at the given position.
+//
+// If @position is negative, or is larger than the number of items
+// in the #WebKitContextMenu, the item is added on to the end of
+// the @menu. The first position is 0.
+func (x *ContextMenu) Insert(ItemVar *ContextMenuItem, PositionVar int) {
+
+	xContextMenuInsert(x.GoPointer(), ItemVar.GoPointer(), PositionVar)
+
+}
+
+var xContextMenuLast func(uintptr) uintptr
+
+// Gets the last item in the @menu.
+func (x *ContextMenu) Last() *ContextMenuItem {
+	var cls *ContextMenuItem
+
+	cret := xContextMenuLast(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &ContextMenuItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextMenuMoveItem func(uintptr, uintptr, int)
+
+// Moves @item to the given position in the @menu.
+//
+// If @position is negative, or is larger than the number of items
+// in the #WebKitContextMenu, the item is added on to the end of
+// the @menu.
+// The first position is 0.
+func (x *ContextMenu) MoveItem(ItemVar *ContextMenuItem, PositionVar int) {
+
+	xContextMenuMoveItem(x.GoPointer(), ItemVar.GoPointer(), PositionVar)
+
+}
+
+var xContextMenuPrepend func(uintptr, uintptr)
+
+// Adds @item at the beginning of the @menu.
+func (x *ContextMenu) Prepend(ItemVar *ContextMenuItem) {
+
+	xContextMenuPrepend(x.GoPointer(), ItemVar.GoPointer())
+
+}
+
+var xContextMenuRemove func(uintptr, uintptr)
+
+// Removes @item from the @menu.
+//
+// See also webkit_context_menu_remove_all() to remove all items.
+func (x *ContextMenu) Remove(ItemVar *ContextMenuItem) {
+
+	xContextMenuRemove(x.GoPointer(), ItemVar.GoPointer())
+
+}
+
+var xContextMenuRemoveAll func(uintptr)
+
+// Removes all items of the @menu.
+func (x *ContextMenu) RemoveAll() {
+
+	xContextMenuRemoveAll(x.GoPointer())
+
+}
+
+var xContextMenuSetUserData func(uintptr, *glib.Variant)
+
+// Sets user data to @menu.
+//
+// This function can be used from a Web Process extension to set user data
+// that can be retrieved from the UI Process using webkit_context_menu_get_user_data().
+// If the @user_data #GVariant is floating, it is consumed.
+func (x *ContextMenu) SetUserData(UserDataVar *glib.Variant) {
+
+	xContextMenuSetUserData(x.GoPointer(), UserDataVar)
+
+}
+
+func (c *ContextMenu) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *ContextMenu) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xContextMenuGLibType, libs, "webkit_context_menu_get_type")
+
+	core.PuregoSafeRegister(&xNewContextMenu, libs, "webkit_context_menu_new")
+	core.PuregoSafeRegister(&xNewContextMenuWithItems, libs, "webkit_context_menu_new_with_items")
+
+	core.PuregoSafeRegister(&xContextMenuAppend, libs, "webkit_context_menu_append")
+	core.PuregoSafeRegister(&xContextMenuFirst, libs, "webkit_context_menu_first")
+	core.PuregoSafeRegister(&xContextMenuGetEvent, libs, "webkit_context_menu_get_event")
+	core.PuregoSafeRegister(&xContextMenuGetItemAtPosition, libs, "webkit_context_menu_get_item_at_position")
+	core.PuregoSafeRegister(&xContextMenuGetItems, libs, "webkit_context_menu_get_items")
+	core.PuregoSafeRegister(&xContextMenuGetNItems, libs, "webkit_context_menu_get_n_items")
+	core.PuregoSafeRegister(&xContextMenuGetUserData, libs, "webkit_context_menu_get_user_data")
+	core.PuregoSafeRegister(&xContextMenuInsert, libs, "webkit_context_menu_insert")
+	core.PuregoSafeRegister(&xContextMenuLast, libs, "webkit_context_menu_last")
+	core.PuregoSafeRegister(&xContextMenuMoveItem, libs, "webkit_context_menu_move_item")
+	core.PuregoSafeRegister(&xContextMenuPrepend, libs, "webkit_context_menu_prepend")
+	core.PuregoSafeRegister(&xContextMenuRemove, libs, "webkit_context_menu_remove")
+	core.PuregoSafeRegister(&xContextMenuRemoveAll, libs, "webkit_context_menu_remove_all")
+	core.PuregoSafeRegister(&xContextMenuSetUserData, libs, "webkit_context_menu_set_user_data")
+
+}
diff --git a/v4/webkit/WebKitContextMenuActions.go b/v4/webkit/WebKitContextMenuActions.go
new file mode 100644
index 0000000000000000000000000000000000000000..bd15108f3cf527bd9dd87f7c60ca1d321b508739
--- /dev/null
+++ b/v4/webkit/WebKitContextMenuActions.go
@@ -0,0 +1,112 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import "github.com/jwijenbergh/puregotk/v4/gobject/types"
+
+// Enum values used to denote the stock actions for
+// #WebKitContextMenuItem&lt;!-- --&gt;s
+type ContextMenuAction int
+
+var xContextMenuActionGLibType func() types.GType
+
+func ContextMenuActionGLibType() types.GType {
+	return xContextMenuActionGLibType()
+}
+
+const (
+
+	// No action, used by separator menu items.
+	ContextMenuActionNoActionValue ContextMenuAction = 0
+	// Open current link.
+	ContextMenuActionOpenLinkValue ContextMenuAction = 1
+	// Open current link in a new window.
+	ContextMenuActionOpenLinkInNewWindowValue ContextMenuAction = 2
+	// Download link destination.
+	ContextMenuActionDownloadLinkToDiskValue ContextMenuAction = 3
+	// Copy link location to the clipboard.
+	ContextMenuActionCopyLinkToClipboardValue ContextMenuAction = 4
+	// Open current image in a new window.
+	ContextMenuActionOpenImageInNewWindowValue ContextMenuAction = 5
+	// Download current image.
+	ContextMenuActionDownloadImageToDiskValue ContextMenuAction = 6
+	// Copy current image to the clipboard.
+	ContextMenuActionCopyImageToClipboardValue ContextMenuAction = 7
+	// Copy current image location to the clipboard.
+	ContextMenuActionCopyImageUrlToClipboardValue ContextMenuAction = 8
+	// Open current frame in a new window.
+	ContextMenuActionOpenFrameInNewWindowValue ContextMenuAction = 9
+	// Load the previous history item.
+	ContextMenuActionGoBackValue ContextMenuAction = 10
+	// Load the next history item.
+	ContextMenuActionGoForwardValue ContextMenuAction = 11
+	// Stop any ongoing loading operation.
+	ContextMenuActionStopValue ContextMenuAction = 12
+	// Reload the contents of current view.
+	ContextMenuActionReloadValue ContextMenuAction = 13
+	// Copy current selection the clipboard.
+	ContextMenuActionCopyValue ContextMenuAction = 14
+	// Cut current selection to the clipboard.
+	ContextMenuActionCutValue ContextMenuAction = 15
+	// Paste clipboard contents.
+	ContextMenuActionPasteValue ContextMenuAction = 16
+	// Delete current selection.
+	ContextMenuActionDeleteValue ContextMenuAction = 17
+	// Select all text.
+	ContextMenuActionSelectAllValue ContextMenuAction = 18
+	// Input methods menu.
+	ContextMenuActionInputMethodsValue ContextMenuAction = 19
+	// Unicode menu.
+	ContextMenuActionUnicodeValue ContextMenuAction = 20
+	// A proposed replacement for a misspelled word.
+	ContextMenuActionSpellingGuessValue ContextMenuAction = 21
+	// An indicator that spellchecking found no proposed replacements.
+	ContextMenuActionNoGuessesFoundValue ContextMenuAction = 22
+	// Causes the spellchecker to ignore the word for this session.
+	ContextMenuActionIgnoreSpellingValue ContextMenuAction = 23
+	// Causes the spellchecker to add the word to the dictionary.
+	ContextMenuActionLearnSpellingValue ContextMenuAction = 24
+	// Ignore grammar.
+	ContextMenuActionIgnoreGrammarValue ContextMenuAction = 25
+	// Font options menu.
+	ContextMenuActionFontMenuValue ContextMenuAction = 26
+	// Bold.
+	ContextMenuActionBoldValue ContextMenuAction = 27
+	// Italic.
+	ContextMenuActionItalicValue ContextMenuAction = 28
+	// Underline.
+	ContextMenuActionUnderlineValue ContextMenuAction = 29
+	// Outline.
+	ContextMenuActionOutlineValue ContextMenuAction = 30
+	// Open current element in the inspector.
+	ContextMenuActionInspectElementValue ContextMenuAction = 31
+	// Open current video element in a new window.
+	ContextMenuActionOpenVideoInNewWindowValue ContextMenuAction = 32
+	// Open current audio element in a new window.
+	ContextMenuActionOpenAudioInNewWindowValue ContextMenuAction = 33
+	// Copy video link location in to the clipboard.
+	ContextMenuActionCopyVideoLinkToClipboardValue ContextMenuAction = 34
+	// Copy audio link location in to the clipboard.
+	ContextMenuActionCopyAudioLinkToClipboardValue ContextMenuAction = 35
+	// Enable or disable media controls.
+	ContextMenuActionToggleMediaControlsValue ContextMenuAction = 36
+	// Enable or disable media loop.
+	ContextMenuActionToggleMediaLoopValue ContextMenuAction = 37
+	// Show current video element in fullscreen mode.
+	ContextMenuActionEnterVideoFullscreenValue ContextMenuAction = 38
+	// Play current media element.
+	ContextMenuActionMediaPlayValue ContextMenuAction = 39
+	// Pause current media element.
+	ContextMenuActionMediaPauseValue ContextMenuAction = 40
+	// Mute current media element.
+	ContextMenuActionMediaMuteValue ContextMenuAction = 41
+	// Download video to disk. Since 2.2
+	ContextMenuActionDownloadVideoToDiskValue ContextMenuAction = 42
+	// Download audio to disk. Since 2.2
+	ContextMenuActionDownloadAudioToDiskValue ContextMenuAction = 43
+	// Insert an emoji. Since 2.26
+	ContextMenuActionInsertEmojiValue ContextMenuAction = 44
+	// Paste clipboard contents as plain text. Since 2.30
+	ContextMenuActionPasteAsPlainTextValue ContextMenuAction = 45
+	// Custom action defined by applications.
+	ContextMenuActionCustomValue ContextMenuAction = 10000
+)
diff --git a/v4/webkit/WebKitContextMenuItem.go b/v4/webkit/WebKitContextMenuItem.go
new file mode 100644
index 0000000000000000000000000000000000000000..3ff2718f8796e161c351230bd9637ae9b981c16e
--- /dev/null
+++ b/v4/webkit/WebKitContextMenuItem.go
@@ -0,0 +1,255 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type ContextMenuItemClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.InitiallyUnownedClass
+}
+
+func (x *ContextMenuItemClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// One item of a #WebKitContextMenu.
+//
+// The #WebKitContextMenu is composed of #WebKitContextMenuItem&lt;!--
+// --&gt;s. These items can be created from a #GtkAction, from a
+// #WebKitContextMenuAction or from a #WebKitContextMenuAction and a
+// label. These #WebKitContextMenuAction&lt;!-- --&gt;s denote stock actions
+// for the items. You can also create separators and submenus.
+type ContextMenuItem struct {
+	gobject.InitiallyUnowned
+}
+
+var xContextMenuItemGLibType func() types.GType
+
+func ContextMenuItemGLibType() types.GType {
+	return xContextMenuItemGLibType()
+}
+
+func ContextMenuItemNewFromInternalPtr(ptr uintptr) *ContextMenuItem {
+	cls := &ContextMenuItem{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewContextMenuItemFromGaction func(uintptr, string, *glib.Variant) uintptr
+
+// Creates a new #WebKitContextMenuItem for the given @action and @label.
+//
+// On activation
+// @target will be passed as parameter to the callback.
+func NewContextMenuItemFromGaction(ActionVar gio.Action, LabelVar string, TargetVar *glib.Variant) *ContextMenuItem {
+	var cls *ContextMenuItem
+
+	cret := xNewContextMenuItemFromGaction(ActionVar.GoPointer(), LabelVar, TargetVar)
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &ContextMenuItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewContextMenuItemFromStockAction func(ContextMenuAction) uintptr
+
+// Creates a new #WebKitContextMenuItem for the given stock action.
+//
+// Stock actions are handled automatically by WebKit so that, for example,
+// when a menu item created with a %WEBKIT_CONTEXT_MENU_ACTION_STOP is
+// activated the action associated will be handled by WebKit and the current
+// load operation will be stopped. You can get the #GAction of a
+// #WebKitContextMenuItem created with a #WebKitContextMenuAction with
+// webkit_context_menu_item_get_gaction() and connect to the #GSimpleAction::activate signal
+// to be notified when the item is activated, but you can't prevent the associated
+// action from being performed.
+func NewContextMenuItemFromStockAction(ActionVar ContextMenuAction) *ContextMenuItem {
+	var cls *ContextMenuItem
+
+	cret := xNewContextMenuItemFromStockAction(ActionVar)
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &ContextMenuItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewContextMenuItemFromStockActionWithLabel func(ContextMenuAction, string) uintptr
+
+// Creates a new #WebKitContextMenuItem for the given stock action using the given @label.
+//
+// Stock actions have a predefined label, this method can be used to create a
+// #WebKitContextMenuItem for a #WebKitContextMenuAction but using a custom label.
+func NewContextMenuItemFromStockActionWithLabel(ActionVar ContextMenuAction, LabelVar string) *ContextMenuItem {
+	var cls *ContextMenuItem
+
+	cret := xNewContextMenuItemFromStockActionWithLabel(ActionVar, LabelVar)
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &ContextMenuItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewContextMenuItemSeparator func() uintptr
+
+// Creates a new #WebKitContextMenuItem representing a separator.
+func NewContextMenuItemSeparator() *ContextMenuItem {
+	var cls *ContextMenuItem
+
+	cret := xNewContextMenuItemSeparator()
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &ContextMenuItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewContextMenuItemWithSubmenu func(string, uintptr) uintptr
+
+// Creates a new #WebKitContextMenuItem using the given @label with a submenu.
+func NewContextMenuItemWithSubmenu(LabelVar string, SubmenuVar *ContextMenu) *ContextMenuItem {
+	var cls *ContextMenuItem
+
+	cret := xNewContextMenuItemWithSubmenu(LabelVar, SubmenuVar.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &ContextMenuItem{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextMenuItemGetGaction func(uintptr) uintptr
+
+// Gets the action associated to @item as a #GAction.
+func (x *ContextMenuItem) GetGaction() *gio.ActionBase {
+	var cls *gio.ActionBase
+
+	cret := xContextMenuItemGetGaction(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.ActionBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextMenuItemGetStockAction func(uintptr) ContextMenuAction
+
+// Gets the #WebKitContextMenuAction of @item.
+//
+// If the #WebKitContextMenuItem was not
+// created for a stock action %WEBKIT_CONTEXT_MENU_ACTION_CUSTOM will be
+// returned. If the #WebKitContextMenuItem is a separator %WEBKIT_CONTEXT_MENU_ACTION_NO_ACTION
+// will be returned.
+func (x *ContextMenuItem) GetStockAction() ContextMenuAction {
+
+	cret := xContextMenuItemGetStockAction(x.GoPointer())
+	return cret
+}
+
+var xContextMenuItemGetSubmenu func(uintptr) uintptr
+
+// Gets the submenu of @item.
+func (x *ContextMenuItem) GetSubmenu() *ContextMenu {
+	var cls *ContextMenu
+
+	cret := xContextMenuItemGetSubmenu(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &ContextMenu{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xContextMenuItemIsSeparator func(uintptr) bool
+
+// Checks whether @item is a separator.
+func (x *ContextMenuItem) IsSeparator() bool {
+
+	cret := xContextMenuItemIsSeparator(x.GoPointer())
+	return cret
+}
+
+var xContextMenuItemSetSubmenu func(uintptr, uintptr)
+
+// Sets or replaces the @item submenu.
+//
+// If @submenu is %NULL the current
+// submenu of @item is removed.
+func (x *ContextMenuItem) SetSubmenu(SubmenuVar *ContextMenu) {
+
+	xContextMenuItemSetSubmenu(x.GoPointer(), SubmenuVar.GoPointer())
+
+}
+
+func (c *ContextMenuItem) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *ContextMenuItem) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xContextMenuItemGLibType, libs, "webkit_context_menu_item_get_type")
+
+	core.PuregoSafeRegister(&xNewContextMenuItemFromGaction, libs, "webkit_context_menu_item_new_from_gaction")
+	core.PuregoSafeRegister(&xNewContextMenuItemFromStockAction, libs, "webkit_context_menu_item_new_from_stock_action")
+	core.PuregoSafeRegister(&xNewContextMenuItemFromStockActionWithLabel, libs, "webkit_context_menu_item_new_from_stock_action_with_label")
+	core.PuregoSafeRegister(&xNewContextMenuItemSeparator, libs, "webkit_context_menu_item_new_separator")
+	core.PuregoSafeRegister(&xNewContextMenuItemWithSubmenu, libs, "webkit_context_menu_item_new_with_submenu")
+
+	core.PuregoSafeRegister(&xContextMenuItemGetGaction, libs, "webkit_context_menu_item_get_gaction")
+	core.PuregoSafeRegister(&xContextMenuItemGetStockAction, libs, "webkit_context_menu_item_get_stock_action")
+	core.PuregoSafeRegister(&xContextMenuItemGetSubmenu, libs, "webkit_context_menu_item_get_submenu")
+	core.PuregoSafeRegister(&xContextMenuItemIsSeparator, libs, "webkit_context_menu_item_is_separator")
+	core.PuregoSafeRegister(&xContextMenuItemSetSubmenu, libs, "webkit_context_menu_item_set_submenu")
+
+}
diff --git a/v4/webkit/WebKitCookieManager.go b/v4/webkit/WebKitCookieManager.go
new file mode 100644
index 0000000000000000000000000000000000000000..206a1322c1c601b54cb1b70d905ae397e6fc8ae4
--- /dev/null
+++ b/v4/webkit/WebKitCookieManager.go
@@ -0,0 +1,354 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/soup"
+)
+
+type CookieManagerClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *CookieManagerClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values used to denote the cookie acceptance policies.
+type CookieAcceptPolicy int
+
+var xCookieAcceptPolicyGLibType func() types.GType
+
+func CookieAcceptPolicyGLibType() types.GType {
+	return xCookieAcceptPolicyGLibType()
+}
+
+const (
+
+	// Accept all cookies unconditionally.
+	CookiePolicyAcceptAlwaysValue CookieAcceptPolicy = 0
+	// Reject all cookies unconditionally.
+	CookiePolicyAcceptNeverValue CookieAcceptPolicy = 1
+	// Accept only cookies set by the main document loaded.
+	CookiePolicyAcceptNoThirdPartyValue CookieAcceptPolicy = 2
+)
+
+// Enum values used to denote the cookie persistent storage types.
+type CookiePersistentStorage int
+
+var xCookiePersistentStorageGLibType func() types.GType
+
+func CookiePersistentStorageGLibType() types.GType {
+	return xCookiePersistentStorageGLibType()
+}
+
+const (
+
+	// Cookies are stored in a text
+	//  file in the Mozilla "cookies.txt" format.
+	CookiePersistentStorageTextValue CookiePersistentStorage = 0
+	// Cookies are stored in a SQLite
+	//  file in the current Mozilla format.
+	CookiePersistentStorageSqliteValue CookiePersistentStorage = 1
+)
+
+// Defines how to handle cookies in a #WebKitWebContext.
+//
+// The WebKitCookieManager defines how to set up and handle cookies.
+// You can get it from a #WebKitWebsiteDataManager with
+// webkit_website_data_manager_get_cookie_manager(), and use it to set where to
+// store cookies with webkit_cookie_manager_set_persistent_storage(),
+// or to set the acceptance policy, with webkit_cookie_manager_get_accept_policy().
+type CookieManager struct {
+	gobject.Object
+}
+
+var xCookieManagerGLibType func() types.GType
+
+func CookieManagerGLibType() types.GType {
+	return xCookieManagerGLibType()
+}
+
+func CookieManagerNewFromInternalPtr(ptr uintptr) *CookieManager {
+	cls := &CookieManager{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xCookieManagerAddCookie func(uintptr, *soup.Cookie, uintptr, uintptr, uintptr)
+
+// Asynchronously add a #SoupCookie to the underlying storage.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_cookie_manager_add_cookie_finish() to get the result of the operation.
+func (x *CookieManager) AddCookie(CookieVar *soup.Cookie, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xCookieManagerAddCookie(x.GoPointer(), CookieVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xCookieManagerAddCookieFinish func(uintptr, uintptr, **glib.Error) bool
+
+// Finish an asynchronous operation started with webkit_cookie_manager_add_cookie().
+func (x *CookieManager) AddCookieFinish(ResultVar gio.AsyncResult) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xCookieManagerAddCookieFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xCookieManagerDeleteCookie func(uintptr, *soup.Cookie, uintptr, uintptr, uintptr)
+
+// Asynchronously delete a #SoupCookie from the current session.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_cookie_manager_delete_cookie_finish() to get the result of the operation.
+func (x *CookieManager) DeleteCookie(CookieVar *soup.Cookie, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xCookieManagerDeleteCookie(x.GoPointer(), CookieVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xCookieManagerDeleteCookieFinish func(uintptr, uintptr, **glib.Error) bool
+
+// Finish an asynchronous operation started with webkit_cookie_manager_delete_cookie().
+func (x *CookieManager) DeleteCookieFinish(ResultVar gio.AsyncResult) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xCookieManagerDeleteCookieFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xCookieManagerGetAcceptPolicy func(uintptr, uintptr, uintptr, uintptr)
+
+// Asynchronously get the cookie acceptance policy of @cookie_manager.
+//
+// Note that when policy was set to %WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY and
+// ITP is enabled, this will return %WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS.
+// See also webkit_website_data_manager_set_itp_enabled().
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_cookie_manager_get_accept_policy_finish() to get the result of the operation.
+func (x *CookieManager) GetAcceptPolicy(CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xCookieManagerGetAcceptPolicy(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xCookieManagerGetAcceptPolicyFinish func(uintptr, uintptr, **glib.Error) CookieAcceptPolicy
+
+// Finish an asynchronous operation started with webkit_cookie_manager_get_accept_policy().
+func (x *CookieManager) GetAcceptPolicyFinish(ResultVar gio.AsyncResult) (CookieAcceptPolicy, error) {
+	var cerr *glib.Error
+
+	cret := xCookieManagerGetAcceptPolicyFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xCookieManagerGetAllCookies func(uintptr, uintptr, uintptr, uintptr)
+
+// Asynchronously get a list of #SoupCookie from @cookie_manager.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_cookie_manager_get_all_cookies_finish() to get the result of the operation.
+func (x *CookieManager) GetAllCookies(CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xCookieManagerGetAllCookies(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xCookieManagerGetAllCookiesFinish func(uintptr, uintptr, **glib.Error) *glib.List
+
+// Finish an asynchronous operation started with webkit_cookie_manager_get_all_cookies().
+//
+// The return value is a #GList of #SoupCookie instances which should be released
+// with g_list_free_full() and soup_cookie_free().
+func (x *CookieManager) GetAllCookiesFinish(ResultVar gio.AsyncResult) (*glib.List, error) {
+	var cerr *glib.Error
+
+	cret := xCookieManagerGetAllCookiesFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xCookieManagerGetCookies func(uintptr, string, uintptr, uintptr, uintptr)
+
+// Asynchronously get a list of #SoupCookie from @cookie_manager.
+//
+// Asynchronously get a list of #SoupCookie from @cookie_manager associated with @uri, which
+// must be either an HTTP or an HTTPS URL.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_cookie_manager_get_cookies_finish() to get the result of the operation.
+func (x *CookieManager) GetCookies(UriVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xCookieManagerGetCookies(x.GoPointer(), UriVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xCookieManagerGetCookiesFinish func(uintptr, uintptr, **glib.Error) *glib.List
+
+// Finish an asynchronous operation started with webkit_cookie_manager_get_cookies().
+//
+// The return value is a #GList of #SoupCookie instances which should be released
+// with g_list_free_full() and soup_cookie_free().
+func (x *CookieManager) GetCookiesFinish(ResultVar gio.AsyncResult) (*glib.List, error) {
+	var cerr *glib.Error
+
+	cret := xCookieManagerGetCookiesFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xCookieManagerReplaceCookies func(uintptr, *glib.List, uintptr, uintptr, uintptr)
+
+// Asynchronously replace all cookies in @cookie_manager with the given list of @cookies.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_cookie_manager_replace_cookies_finish() to get the result of the operation.
+func (x *CookieManager) ReplaceCookies(CookiesVar *glib.List, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xCookieManagerReplaceCookies(x.GoPointer(), CookiesVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xCookieManagerReplaceCookiesFinish func(uintptr, uintptr, **glib.Error) bool
+
+// Finish an asynchronous operation started with webkit_cookie_manager_replace_cookies().
+func (x *CookieManager) ReplaceCookiesFinish(ResultVar gio.AsyncResult) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xCookieManagerReplaceCookiesFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xCookieManagerSetAcceptPolicy func(uintptr, CookieAcceptPolicy)
+
+// Set the cookie acceptance policy of @cookie_manager as @policy.
+//
+// Note that ITP has its own way to handle third-party cookies, so when it's enabled,
+// and @policy is set to %WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY, %WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS
+// will be used instead. Once disabled, the policy will be set back to %WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY.
+// See also webkit_website_data_manager_set_itp_enabled().
+func (x *CookieManager) SetAcceptPolicy(PolicyVar CookieAcceptPolicy) {
+
+	xCookieManagerSetAcceptPolicy(x.GoPointer(), PolicyVar)
+
+}
+
+var xCookieManagerSetPersistentStorage func(uintptr, string, CookiePersistentStorage)
+
+// Set non-session cookies.
+//
+// Set the @filename where non-session cookies are stored persistently using
+// @storage as the format to read/write the cookies.
+// Cookies are initially read from @filename to create an initial set of cookies.
+// Then, non-session cookies will be written to @filename when the WebKitCookieManager::changed
+// signal is emitted.
+// By default, @cookie_manager doesn't store the cookies persistently, so you need to call this
+// method to keep cookies saved across sessions.
+//
+// This method should never be called on a #WebKitCookieManager associated to an ephemeral #WebKitWebsiteDataManager.
+func (x *CookieManager) SetPersistentStorage(FilenameVar string, StorageVar CookiePersistentStorage) {
+
+	xCookieManagerSetPersistentStorage(x.GoPointer(), FilenameVar, StorageVar)
+
+}
+
+func (c *CookieManager) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *CookieManager) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// This signal is emitted when cookies are added, removed or modified.
+func (x *CookieManager) ConnectChanged(cb *func(CookieManager)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := CookieManager{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xCookieAcceptPolicyGLibType, libs, "webkit_cookie_accept_policy_get_type")
+
+	core.PuregoSafeRegister(&xCookiePersistentStorageGLibType, libs, "webkit_cookie_persistent_storage_get_type")
+
+	core.PuregoSafeRegister(&xCookieManagerGLibType, libs, "webkit_cookie_manager_get_type")
+
+	core.PuregoSafeRegister(&xCookieManagerAddCookie, libs, "webkit_cookie_manager_add_cookie")
+	core.PuregoSafeRegister(&xCookieManagerAddCookieFinish, libs, "webkit_cookie_manager_add_cookie_finish")
+	core.PuregoSafeRegister(&xCookieManagerDeleteCookie, libs, "webkit_cookie_manager_delete_cookie")
+	core.PuregoSafeRegister(&xCookieManagerDeleteCookieFinish, libs, "webkit_cookie_manager_delete_cookie_finish")
+	core.PuregoSafeRegister(&xCookieManagerGetAcceptPolicy, libs, "webkit_cookie_manager_get_accept_policy")
+	core.PuregoSafeRegister(&xCookieManagerGetAcceptPolicyFinish, libs, "webkit_cookie_manager_get_accept_policy_finish")
+	core.PuregoSafeRegister(&xCookieManagerGetAllCookies, libs, "webkit_cookie_manager_get_all_cookies")
+	core.PuregoSafeRegister(&xCookieManagerGetAllCookiesFinish, libs, "webkit_cookie_manager_get_all_cookies_finish")
+	core.PuregoSafeRegister(&xCookieManagerGetCookies, libs, "webkit_cookie_manager_get_cookies")
+	core.PuregoSafeRegister(&xCookieManagerGetCookiesFinish, libs, "webkit_cookie_manager_get_cookies_finish")
+	core.PuregoSafeRegister(&xCookieManagerReplaceCookies, libs, "webkit_cookie_manager_replace_cookies")
+	core.PuregoSafeRegister(&xCookieManagerReplaceCookiesFinish, libs, "webkit_cookie_manager_replace_cookies_finish")
+	core.PuregoSafeRegister(&xCookieManagerSetAcceptPolicy, libs, "webkit_cookie_manager_set_accept_policy")
+	core.PuregoSafeRegister(&xCookieManagerSetPersistentStorage, libs, "webkit_cookie_manager_set_persistent_storage")
+
+}
diff --git a/v4/webkit/WebKitCredential.go b/v4/webkit/WebKitCredential.go
new file mode 100644
index 0000000000000000000000000000000000000000..24aed6bfe66068c8b166b8a8e118869001e3ee23
--- /dev/null
+++ b/v4/webkit/WebKitCredential.go
@@ -0,0 +1,179 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Groups information used for user authentication.
+type Credential struct {
+	_ structs.HostLayout
+}
+
+var xCredentialGLibType func() types.GType
+
+func CredentialGLibType() types.GType {
+	return xCredentialGLibType()
+}
+
+func (x *Credential) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewCredential func(string, string, CredentialPersistence) *Credential
+
+// Create a new credential from the provided username, password and persistence mode.
+func NewCredential(UsernameVar string, PasswordVar string, PersistenceVar CredentialPersistence) *Credential {
+
+	cret := xNewCredential(UsernameVar, PasswordVar, PersistenceVar)
+	return cret
+}
+
+var xNewCredentialForCertificate func(uintptr, CredentialPersistence) *Credential
+
+// Create a new credential from the @certificate and persistence mode.
+//
+// Note that %WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT is not supported for certificate credentials.
+func NewCredentialForCertificate(CertificateVar *gio.TlsCertificate, PersistenceVar CredentialPersistence) *Credential {
+
+	cret := xNewCredentialForCertificate(CertificateVar.GoPointer(), PersistenceVar)
+	return cret
+}
+
+var xNewCredentialForCertificatePin func(string, CredentialPersistence) *Credential
+
+// Create a new credential from the provided PIN and persistence mode.
+//
+// Note that %WEBKIT_CREDENTIAL_PERSISTENCE_PERMANENT is not supported for certificate pin credentials.
+func NewCredentialForCertificatePin(PinVar string, PersistenceVar CredentialPersistence) *Credential {
+
+	cret := xNewCredentialForCertificatePin(PinVar, PersistenceVar)
+	return cret
+}
+
+var xCredentialCopy func(uintptr) *Credential
+
+// Make a copy of the #WebKitCredential.
+func (x *Credential) Copy() *Credential {
+
+	cret := xCredentialCopy(x.GoPointer())
+	return cret
+}
+
+var xCredentialFree func(uintptr)
+
+// Free the #WebKitCredential.
+func (x *Credential) Free() {
+
+	xCredentialFree(x.GoPointer())
+
+}
+
+var xCredentialGetCertificate func(uintptr) uintptr
+
+// Get the certificate currently held by this #WebKitCredential.
+func (x *Credential) GetCertificate() *gio.TlsCertificate {
+	var cls *gio.TlsCertificate
+
+	cret := xCredentialGetCertificate(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.TlsCertificate{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xCredentialGetPassword func(uintptr) string
+
+// Get the password currently held by this #WebKitCredential.
+func (x *Credential) GetPassword() string {
+
+	cret := xCredentialGetPassword(x.GoPointer())
+	return cret
+}
+
+var xCredentialGetPersistence func(uintptr) CredentialPersistence
+
+// Get the persistence mode currently held by this #WebKitCredential.
+func (x *Credential) GetPersistence() CredentialPersistence {
+
+	cret := xCredentialGetPersistence(x.GoPointer())
+	return cret
+}
+
+var xCredentialGetUsername func(uintptr) string
+
+// Get the username currently held by this #WebKitCredential.
+func (x *Credential) GetUsername() string {
+
+	cret := xCredentialGetUsername(x.GoPointer())
+	return cret
+}
+
+var xCredentialHasPassword func(uintptr) bool
+
+// Determine whether this credential has a password stored.
+func (x *Credential) HasPassword() bool {
+
+	cret := xCredentialHasPassword(x.GoPointer())
+	return cret
+}
+
+// Enum values representing the duration for which a credential persists.
+type CredentialPersistence int
+
+var xCredentialPersistenceGLibType func() types.GType
+
+func CredentialPersistenceGLibType() types.GType {
+	return xCredentialPersistenceGLibType()
+}
+
+const (
+
+	// Credential does not persist
+	CredentialPersistenceNoneValue CredentialPersistence = 0
+	// Credential persists for session only
+	CredentialPersistenceForSessionValue CredentialPersistence = 1
+	// Credential persists permanently
+	CredentialPersistencePermanentValue CredentialPersistence = 2
+)
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xCredentialPersistenceGLibType, libs, "webkit_credential_persistence_get_type")
+
+	core.PuregoSafeRegister(&xCredentialGLibType, libs, "webkit_credential_get_type")
+
+	core.PuregoSafeRegister(&xNewCredential, libs, "webkit_credential_new")
+	core.PuregoSafeRegister(&xNewCredentialForCertificate, libs, "webkit_credential_new_for_certificate")
+	core.PuregoSafeRegister(&xNewCredentialForCertificatePin, libs, "webkit_credential_new_for_certificate_pin")
+
+	core.PuregoSafeRegister(&xCredentialCopy, libs, "webkit_credential_copy")
+	core.PuregoSafeRegister(&xCredentialFree, libs, "webkit_credential_free")
+	core.PuregoSafeRegister(&xCredentialGetCertificate, libs, "webkit_credential_get_certificate")
+	core.PuregoSafeRegister(&xCredentialGetPassword, libs, "webkit_credential_get_password")
+	core.PuregoSafeRegister(&xCredentialGetPersistence, libs, "webkit_credential_get_persistence")
+	core.PuregoSafeRegister(&xCredentialGetUsername, libs, "webkit_credential_get_username")
+	core.PuregoSafeRegister(&xCredentialHasPassword, libs, "webkit_credential_has_password")
+
+}
diff --git a/v4/webkit/WebKitDeviceInfoPermissionRequest.go b/v4/webkit/WebKitDeviceInfoPermissionRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..c97b65077f49395c765a1819faaa59637fe46cf9
--- /dev/null
+++ b/v4/webkit/WebKitDeviceInfoPermissionRequest.go
@@ -0,0 +1,70 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type DeviceInfoPermissionRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *DeviceInfoPermissionRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A permission request for enumerating the user's media devices
+//
+// WebKitDeviceInfoPermissionRequest represents a request for
+// permission to whether WebKit should be allowed to access the user's
+// devices information when requested through the MediaDevices.enumerateDevices
+// API.
+//
+// When a WebKitDeviceInfoPermissionRequest is not handled by the user,
+// it is denied by default.
+type DeviceInfoPermissionRequest struct {
+	gobject.Object
+}
+
+var xDeviceInfoPermissionRequestGLibType func() types.GType
+
+func DeviceInfoPermissionRequestGLibType() types.GType {
+	return xDeviceInfoPermissionRequestGLibType()
+}
+
+func DeviceInfoPermissionRequestNewFromInternalPtr(ptr uintptr) *DeviceInfoPermissionRequest {
+	cls := &DeviceInfoPermissionRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *DeviceInfoPermissionRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *DeviceInfoPermissionRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Allow the action which triggered this request.
+func (x *DeviceInfoPermissionRequest) Allow() {
+
+	XWebkitPermissionRequestAllow(x.GoPointer())
+
+}
+
+// Deny the action which triggered this request.
+func (x *DeviceInfoPermissionRequest) Deny() {
+
+	XWebkitPermissionRequestDeny(x.GoPointer())
+
+}
diff --git a/v4/webkit/WebKitDownload.go b/v4/webkit/WebKitDownload.go
new file mode 100644
index 0000000000000000000000000000000000000000..5cebd8ff08693f71bd781cf973d8bdd24f37563d
--- /dev/null
+++ b/v4/webkit/WebKitDownload.go
@@ -0,0 +1,415 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type DownloadClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *DownloadClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Object used to communicate with the application when downloading.
+//
+// #WebKitDownload carries information about a download request and
+// response, including a #WebKitURIRequest and a #WebKitURIResponse
+// objects. The application may use this object to control the
+// download process, or to simply figure out what is to be downloaded,
+// and handle the download process itself.
+type Download struct {
+	gobject.Object
+}
+
+var xDownloadGLibType func() types.GType
+
+func DownloadGLibType() types.GType {
+	return xDownloadGLibType()
+}
+
+func DownloadNewFromInternalPtr(ptr uintptr) *Download {
+	cls := &Download{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xDownloadCancel func(uintptr)
+
+// Cancels the download.
+//
+// When the ongoing download
+// operation is effectively cancelled the signal
+// #WebKitDownload::failed is emitted with
+// %WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER error.
+func (x *Download) Cancel() {
+
+	xDownloadCancel(x.GoPointer())
+
+}
+
+var xDownloadGetAllowOverwrite func(uintptr) bool
+
+// Returns the current value of the #WebKitDownload:allow-overwrite property.
+//
+// Returns the current value of the #WebKitDownload:allow-overwrite property,
+// which determines whether the download will overwrite an existing file on
+// disk, or if it will fail if the destination already exists.
+func (x *Download) GetAllowOverwrite() bool {
+
+	cret := xDownloadGetAllowOverwrite(x.GoPointer())
+	return cret
+}
+
+var xDownloadGetDestination func(uintptr) string
+
+// Obtains the destination to which the downloaded file will be written.
+//
+// You can connect to #WebKitDownload::created-destination to make
+// sure this method returns a valid destination.
+func (x *Download) GetDestination() string {
+
+	cret := xDownloadGetDestination(x.GoPointer())
+	return cret
+}
+
+var xDownloadGetElapsedTime func(uintptr) float64
+
+// Gets the elapsed time in seconds, including any fractional part.
+//
+// If the download finished, had an error or was cancelled this is
+// the time between its start and the event.
+func (x *Download) GetElapsedTime() float64 {
+
+	cret := xDownloadGetElapsedTime(x.GoPointer())
+	return cret
+}
+
+var xDownloadGetEstimatedProgress func(uintptr) float64
+
+// Gets the value of the #WebKitDownload:estimated-progress property.
+// Gets the value of the #WebKitDownload:estimated-progress property.
+// You can monitor the estimated progress of the download operation by
+// connecting to the notify::estimated-progress signal of @download.
+func (x *Download) GetEstimatedProgress() float64 {
+
+	cret := xDownloadGetEstimatedProgress(x.GoPointer())
+	return cret
+}
+
+var xDownloadGetReceivedDataLength func(uintptr) uint64
+
+// Gets the length of the data already downloaded for @download.
+//
+// Gets the length of the data already downloaded for @download
+// in bytes.
+func (x *Download) GetReceivedDataLength() uint64 {
+
+	cret := xDownloadGetReceivedDataLength(x.GoPointer())
+	return cret
+}
+
+var xDownloadGetRequest func(uintptr) uintptr
+
+// Retrieves the #WebKitURIRequest object that backs the download
+// process.
+func (x *Download) GetRequest() *URIRequest {
+	var cls *URIRequest
+
+	cret := xDownloadGetRequest(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &URIRequest{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xDownloadGetResponse func(uintptr) uintptr
+
+// Retrieves the #WebKitURIResponse object that backs the download process.
+//
+// Retrieves the #WebKitURIResponse object that backs the download
+// process. This method returns %NULL if called before the response
+// is received from the server. You can connect to notify::response
+// signal to be notified when the response is received.
+func (x *Download) GetResponse() *URIResponse {
+	var cls *URIResponse
+
+	cret := xDownloadGetResponse(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &URIResponse{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xDownloadGetWebView func(uintptr) uintptr
+
+// Get the #WebKitWebView that initiated the download.
+func (x *Download) GetWebView() *WebView {
+	var cls *WebView
+
+	cret := xDownloadGetWebView(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WebView{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xDownloadSetAllowOverwrite func(uintptr, bool)
+
+// Sets the #WebKitDownload:allow-overwrite property.
+//
+// Sets the #WebKitDownload:allow-overwrite property, which determines whether
+// the download may overwrite an existing file on disk, or if it will fail if
+// the destination already exists.
+func (x *Download) SetAllowOverwrite(AllowedVar bool) {
+
+	xDownloadSetAllowOverwrite(x.GoPointer(), AllowedVar)
+
+}
+
+var xDownloadSetDestination func(uintptr, string)
+
+// Sets the destination to which the downloaded file will be written.
+//
+// This method should be called before the download transfer
+// starts or it will not have any effect on the ongoing download
+// operation. To set the destination using the filename suggested
+// by the server connect to #WebKitDownload::decide-destination
+// signal and call webkit_download_set_destination(). If you want to
+// set a fixed destination that doesn't depend on the suggested
+// filename you can connect to notify::response signal and call
+// webkit_download_set_destination().
+//
+// If #WebKitDownload::decide-destination signal is not handled
+// and destination is not set when the download transfer starts,
+// the file will be saved with the filename suggested by the server in
+// %G_USER_DIRECTORY_DOWNLOAD directory.
+func (x *Download) SetDestination(DestinationVar string) {
+
+	xDownloadSetDestination(x.GoPointer(), DestinationVar)
+
+}
+
+func (c *Download) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Download) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyAllowOverwrite sets the "allow-overwrite" property.
+// Whether or not the download is allowed to overwrite an existing file on
+// disk. If this property is %FALSE and the destination already exists,
+// the download will fail.
+func (x *Download) SetPropertyAllowOverwrite(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-overwrite", &v)
+}
+
+// GetPropertyAllowOverwrite gets the "allow-overwrite" property.
+// Whether or not the download is allowed to overwrite an existing file on
+// disk. If this property is %FALSE and the destination already exists,
+// the download will fail.
+func (x *Download) GetPropertyAllowOverwrite() bool {
+	var v gobject.Value
+	x.GetProperty("allow-overwrite", &v)
+	return v.GetBoolean()
+}
+
+// GetPropertyDestination gets the "destination" property.
+// The local path to where the download will be saved.
+func (x *Download) GetPropertyDestination() string {
+	var v gobject.Value
+	x.GetProperty("destination", &v)
+	return v.GetString()
+}
+
+// GetPropertyEstimatedProgress gets the "estimated-progress" property.
+// An estimate of the percent completion for the download operation.
+// This value will range from 0.0 to 1.0. The value is an estimate
+// based on the total number of bytes expected to be received for
+// a download.
+// If you need a more accurate progress information you can connect to
+// #WebKitDownload::received-data signal to track the progress.
+func (x *Download) GetPropertyEstimatedProgress() float64 {
+	var v gobject.Value
+	x.GetProperty("estimated-progress", &v)
+	return v.GetDouble()
+}
+
+// This signal is emitted after #WebKitDownload::decide-destination and before
+// #WebKitDownload::received-data to notify that destination file has been
+// created successfully at @destination.
+func (x *Download) ConnectCreatedDestination(cb *func(Download, string)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "created-destination", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, DestinationVarp string) {
+		fa := Download{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, DestinationVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "created-destination", cbRefPtr)
+}
+
+// This signal is emitted after response is received to
+// decide a destination for the download using
+// webkit_download_set_destination(). If this signal is not
+// handled, the file will be downloaded to %G_USER_DIRECTORY_DOWNLOAD
+// directory using @suggested_filename.
+//
+// Since 2.40, you may handle this signal asynchronously by
+// returning %TRUE without calling webkit_download_set_destination().
+// This indicates intent to eventually call webkit_download_set_destination().
+// In this case, the download will not proceed until the destination is set
+// or cancelled with webkit_download_cancel().
+func (x *Download) ConnectDecideDestination(cb *func(Download, string) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "decide-destination", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, SuggestedFilenameVarp string) bool {
+		fa := Download{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, SuggestedFilenameVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "decide-destination", cbRefPtr)
+}
+
+// This signal is emitted when an error occurs during the download
+// operation. The given @error, of the domain %WEBKIT_DOWNLOAD_ERROR,
+// contains further details of the failure. If the download is cancelled
+// with webkit_download_cancel(), this signal is emitted with error
+// %WEBKIT_DOWNLOAD_ERROR_CANCELLED_BY_USER. The download operation finishes
+// after an error and #WebKitDownload::finished signal is emitted after this one.
+func (x *Download) ConnectFailed(cb *func(Download, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "failed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ErrorVarp uintptr) {
+		fa := Download{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ErrorVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "failed", cbRefPtr)
+}
+
+// This signal is emitted when download finishes successfully or due to an error.
+// In case of errors #WebKitDownload::failed signal is emitted before this one.
+func (x *Download) ConnectFinished(cb *func(Download)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Download{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+}
+
+// This signal is emitted after response is received,
+// every time new data has been written to the destination. It's
+// useful to know the progress of the download operation.
+func (x *Download) ConnectReceivedData(cb *func(Download, uint64)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "received-data", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, DataLengthVarp uint64) {
+		fa := Download{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, DataLengthVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "received-data", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xDownloadGLibType, libs, "webkit_download_get_type")
+
+	core.PuregoSafeRegister(&xDownloadCancel, libs, "webkit_download_cancel")
+	core.PuregoSafeRegister(&xDownloadGetAllowOverwrite, libs, "webkit_download_get_allow_overwrite")
+	core.PuregoSafeRegister(&xDownloadGetDestination, libs, "webkit_download_get_destination")
+	core.PuregoSafeRegister(&xDownloadGetElapsedTime, libs, "webkit_download_get_elapsed_time")
+	core.PuregoSafeRegister(&xDownloadGetEstimatedProgress, libs, "webkit_download_get_estimated_progress")
+	core.PuregoSafeRegister(&xDownloadGetReceivedDataLength, libs, "webkit_download_get_received_data_length")
+	core.PuregoSafeRegister(&xDownloadGetRequest, libs, "webkit_download_get_request")
+	core.PuregoSafeRegister(&xDownloadGetResponse, libs, "webkit_download_get_response")
+	core.PuregoSafeRegister(&xDownloadGetWebView, libs, "webkit_download_get_web_view")
+	core.PuregoSafeRegister(&xDownloadSetAllowOverwrite, libs, "webkit_download_set_allow_overwrite")
+	core.PuregoSafeRegister(&xDownloadSetDestination, libs, "webkit_download_set_destination")
+
+}
diff --git a/v4/webkit/WebKitEditingCommands.go b/v4/webkit/WebKitEditingCommands.go
new file mode 100644
index 0000000000000000000000000000000000000000..67763f841f9a132ac333f2896df131a706e343bf
--- /dev/null
+++ b/v4/webkit/WebKitEditingCommands.go
@@ -0,0 +1,61 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+const (
+	// The copy clipboard command. Copies the current selection inside
+	// a #WebKitWebView to the clipboard.
+	// You can check whether it's possible to execute the command with
+	// webkit_web_view_can_execute_editing_command(). In general it's
+	// possible to copy to the clipboard when there is an active selection
+	// inside the #WebKitWebView.
+	EDITING_COMMAND_COPY string = "Copy"
+	// The create link command. Creates a link element that is inserted at
+	// the current cursor position. If there's a selection, the selected text
+	// will be used as the link text, otherwise the URL itself will be used.
+	// It receives the link URL as argument. This command should be executed
+	// with webkit_web_view_execute_editing_command_with_argument()
+	EDITING_COMMAND_CREATE_LINK string = "CreateLink"
+	// The cut clipboard command. Copies the current selection inside
+	// a #WebKitWebView to the clipboard and deletes the selected content.
+	// You can check whether it's possible to execute the command with
+	// webkit_web_view_can_execute_editing_command(). In general it's
+	// possible to cut to the clipboard when the #WebKitWebView content is
+	// editable and there is an active selection.
+	EDITING_COMMAND_CUT string = "Cut"
+	// The insert image command. Creates an image element that is inserted at
+	// the current cursor position. It receives an URI as argument,
+	// that is used as the image source. This command should be executed with
+	// webkit_web_view_execute_editing_command_with_argument().
+	EDITING_COMMAND_INSERT_IMAGE string = "InsertImage"
+	// The paste clipboard command. Pastes the contents of the clipboard to
+	// a #WebKitWebView.
+	// You can check whether it's possible to execute the command with
+	// webkit_web_view_can_execute_editing_command(). In general it's possible
+	// to paste from the clipboard when the #WebKitWebView content is editable
+	// and clipboard is not empty.
+	EDITING_COMMAND_PASTE string = "Paste"
+	// The paste as plaintext clipboard command. Pastes the contents of the
+	// clipboard to a #WebKitWebView, with formatting removed.
+	// You can check whether it's possible to execute the command with
+	// webkit_web_view_can_execute_editing_command(). In general it's possible
+	// to paste from the clipboard when the #WebKitWebView content is editable
+	// and clipboard is not empty.
+	EDITING_COMMAND_PASTE_AS_PLAIN_TEXT string = "PasteAsPlainText"
+	// The redo command. Redoes a previously undone editing command in
+	// a #WebKitWebView.
+	// You can check whether it's possible to execute the command with
+	// webkit_web_view_can_execute_editing_command(). It's only possible
+	// to redo a command when it has been previously undone.
+	EDITING_COMMAND_REDO string = "Redo"
+	// The select all command. Selects all the content of the current text field in
+	// a #WebKitWebView.
+	// It is always possible to select all text, no matter whether the
+	// #WebKitWebView content is editable or not. You can still check it
+	// with webkit_web_view_can_execute_editing_command().
+	EDITING_COMMAND_SELECT_ALL string = "SelectAll"
+	// The undo command. Undoes the last editing command in a #WebKitWebView.
+	// You can check whether it's possible to execute the command with
+	// webkit_web_view_can_execute_editing_command(). It's only possible
+	// to undo a command after a previously executed editing operation.
+	EDITING_COMMAND_UNDO string = "Undo"
+)
diff --git a/v4/webkit/WebKitEditorState.go b/v4/webkit/WebKitEditorState.go
new file mode 100644
index 0000000000000000000000000000000000000000..07d4cb2541d8b6ffd5a12d4b094fcd840bd674a7
--- /dev/null
+++ b/v4/webkit/WebKitEditorState.go
@@ -0,0 +1,191 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type EditorStateClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *EditorStateClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values with flags representing typing attributes.
+type EditorTypingAttributes int
+
+var xEditorTypingAttributesGLibType func() types.GType
+
+func EditorTypingAttributesGLibType() types.GType {
+	return xEditorTypingAttributesGLibType()
+}
+
+const (
+
+	// No typing attributes.
+	EditorTypingAttributeNoneValue EditorTypingAttributes = 2
+	// Bold typing attribute.
+	EditorTypingAttributeBoldValue EditorTypingAttributes = 4
+	// Italic typing attribute.
+	EditorTypingAttributeItalicValue EditorTypingAttributes = 8
+	// Underline typing attribute.
+	EditorTypingAttributeUnderlineValue EditorTypingAttributes = 16
+	// Strikethrough typing attribute.
+	EditorTypingAttributeStrikethroughValue EditorTypingAttributes = 32
+)
+
+// Web editor state.
+//
+// WebKitEditorState represents the state of a #WebKitWebView editor.
+// Use webkit_web_view_get_editor_state() to get the WebKitEditorState
+// of a #WebKitWebView.
+type EditorState struct {
+	gobject.Object
+}
+
+var xEditorStateGLibType func() types.GType
+
+func EditorStateGLibType() types.GType {
+	return xEditorStateGLibType()
+}
+
+func EditorStateNewFromInternalPtr(ptr uintptr) *EditorState {
+	cls := &EditorState{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xEditorStateGetTypingAttributes func(uintptr) uint
+
+// Gets the typing attributes at the current cursor position.
+//
+// If there is a selection, this returns the typing attributes
+// of the selected text. Note that in case of a selection,
+// typing attributes are considered active only when they are
+// present throughout the selection.
+func (x *EditorState) GetTypingAttributes() uint {
+
+	cret := xEditorStateGetTypingAttributes(x.GoPointer())
+	return cret
+}
+
+var xEditorStateIsCopyAvailable func(uintptr) bool
+
+// Gets whether a copy command can be issued.
+func (x *EditorState) IsCopyAvailable() bool {
+
+	cret := xEditorStateIsCopyAvailable(x.GoPointer())
+	return cret
+}
+
+var xEditorStateIsCutAvailable func(uintptr) bool
+
+// Gets whether a cut command can be issued.
+func (x *EditorState) IsCutAvailable() bool {
+
+	cret := xEditorStateIsCutAvailable(x.GoPointer())
+	return cret
+}
+
+var xEditorStateIsPasteAvailable func(uintptr) bool
+
+// Gets whether a paste command can be issued.
+func (x *EditorState) IsPasteAvailable() bool {
+
+	cret := xEditorStateIsPasteAvailable(x.GoPointer())
+	return cret
+}
+
+var xEditorStateIsRedoAvailable func(uintptr) bool
+
+// Gets whether a redo command can be issued.
+func (x *EditorState) IsRedoAvailable() bool {
+
+	cret := xEditorStateIsRedoAvailable(x.GoPointer())
+	return cret
+}
+
+var xEditorStateIsUndoAvailable func(uintptr) bool
+
+// Gets whether an undo command can be issued.
+func (x *EditorState) IsUndoAvailable() bool {
+
+	cret := xEditorStateIsUndoAvailable(x.GoPointer())
+	return cret
+}
+
+func (c *EditorState) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *EditorState) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// GetPropertyTypingAttributes gets the "typing-attributes" property.
+// Bitmask of #WebKitEditorTypingAttributes flags.
+// See webkit_editor_state_get_typing_attributes() for more information.
+func (x *EditorState) GetPropertyTypingAttributes() uint {
+	var v gobject.Value
+	x.GetProperty("typing-attributes", &v)
+	return v.GetUint()
+}
+
+// Emitted when the #WebKitEdtorState is changed.
+func (x *EditorState) ConnectChanged(cb *func(EditorState)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := EditorState{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "changed", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xEditorTypingAttributesGLibType, libs, "webkit_editor_typing_attributes_get_type")
+
+	core.PuregoSafeRegister(&xEditorStateGLibType, libs, "webkit_editor_state_get_type")
+
+	core.PuregoSafeRegister(&xEditorStateGetTypingAttributes, libs, "webkit_editor_state_get_typing_attributes")
+	core.PuregoSafeRegister(&xEditorStateIsCopyAvailable, libs, "webkit_editor_state_is_copy_available")
+	core.PuregoSafeRegister(&xEditorStateIsCutAvailable, libs, "webkit_editor_state_is_cut_available")
+	core.PuregoSafeRegister(&xEditorStateIsPasteAvailable, libs, "webkit_editor_state_is_paste_available")
+	core.PuregoSafeRegister(&xEditorStateIsRedoAvailable, libs, "webkit_editor_state_is_redo_available")
+	core.PuregoSafeRegister(&xEditorStateIsUndoAvailable, libs, "webkit_editor_state_is_undo_available")
+
+}
diff --git a/v4/webkit/WebKitError.go b/v4/webkit/WebKitError.go
new file mode 100644
index 0000000000000000000000000000000000000000..4198c528d44367494edffaeb5b7d57a99630ebcf
--- /dev/null
+++ b/v4/webkit/WebKitError.go
@@ -0,0 +1,303 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Enum values used to denote the various download errors.
+type DownloadError int
+
+var xDownloadErrorGLibType func() types.GType
+
+func DownloadErrorGLibType() types.GType {
+	return xDownloadErrorGLibType()
+}
+
+const (
+
+	// Download failure due to network error
+	DownloadErrorNetworkValue DownloadError = 499
+	// Download was cancelled by user
+	DownloadErrorCancelledByUserValue DownloadError = 400
+	// Download failure due to destination error
+	DownloadErrorDestinationValue DownloadError = 401
+)
+
+// Enum values used to denote errors happening when executing JavaScript
+type JavascriptError int
+
+var xJavascriptErrorGLibType func() types.GType
+
+func JavascriptErrorGLibType() types.GType {
+	return xJavascriptErrorGLibType()
+}
+
+const (
+
+	// An exception was raised in JavaScript execution
+	JavascriptErrorScriptFailedValue JavascriptError = 699
+	// An unsupported parameter has been used to call and async function from API. Since 2.40
+	JavascriptErrorInvalidParameterValue JavascriptError = 600
+	// The result of JavaScript execution could not be returned. Since 2.40
+	JavascriptErrorInvalidResultValue JavascriptError = 601
+)
+
+// Enum values used to denote the various media errors.
+type MediaError int
+
+var xMediaErrorGLibType func() types.GType
+
+func MediaErrorGLibType() types.GType {
+	return xMediaErrorGLibType()
+}
+
+const (
+
+	// Preliminary load failure for media content types. A new load will be started to perform the media load. Since: 2.40
+	MediaErrorWillHandleLoadValue MediaError = 204
+)
+
+// Enum values used to denote the various network errors.
+type NetworkError int
+
+var xNetworkErrorGLibType func() types.GType
+
+func NetworkErrorGLibType() types.GType {
+	return xNetworkErrorGLibType()
+}
+
+const (
+
+	// Generic load failure
+	NetworkErrorFailedValue NetworkError = 399
+	// Load failure due to transport error
+	NetworkErrorTransportValue NetworkError = 300
+	// Load failure due to unknown protocol
+	NetworkErrorUnknownProtocolValue NetworkError = 301
+	// Load failure due to cancellation
+	NetworkErrorCancelledValue NetworkError = 302
+	// Load failure due to missing file
+	NetworkErrorFileDoesNotExistValue NetworkError = 303
+)
+
+// Enum values used to denote the various policy errors.
+type PolicyError int
+
+var xPolicyErrorGLibType func() types.GType
+
+func PolicyErrorGLibType() types.GType {
+	return xPolicyErrorGLibType()
+}
+
+const (
+
+	// Generic load failure due to policy error
+	PolicyErrorFailedValue PolicyError = 199
+	// Load failure due to unsupported mime type
+	PolicyErrorCannotShowMimeTypeValue PolicyError = 100
+	// Load failure due to URI that can not be shown
+	PolicyErrorCannotShowUriValue PolicyError = 101
+	// Load failure due to frame load interruption by policy change
+	PolicyErrorFrameLoadInterruptedByPolicyChangeValue PolicyError = 102
+	// Load failure due to port restriction
+	PolicyErrorCannotUseRestrictedPortValue PolicyError = 103
+)
+
+// Enum values used to denote the various print errors.
+type PrintError int
+
+var xPrintErrorGLibType func() types.GType
+
+func PrintErrorGLibType() types.GType {
+	return xPrintErrorGLibType()
+}
+
+const (
+
+	// Unspecified error during a print operation
+	PrintErrorGeneralValue PrintError = 599
+	// Selected printer cannot be found
+	PrintErrorPrinterNotFoundValue PrintError = 500
+	// Invalid page range
+	PrintErrorInvalidPageRangeValue PrintError = 501
+)
+
+// Enum values used to denote errors happening when creating snapshots of #WebKitWebView
+type SnapshotError int
+
+var xSnapshotErrorGLibType func() types.GType
+
+func SnapshotErrorGLibType() types.GType {
+	return xSnapshotErrorGLibType()
+}
+
+const (
+
+	// An error occurred when creating a webpage snapshot.
+	SnapshotErrorFailedToCreateValue SnapshotError = 799
+)
+
+// Errors that can occur while compiling content filters.
+type UserContentFilterError int
+
+var xUserContentFilterErrorGLibType func() types.GType
+
+func UserContentFilterErrorGLibType() types.GType {
+	return xUserContentFilterErrorGLibType()
+}
+
+const (
+
+	// The JSON source for a content filter is invalid.
+	UserContentFilterErrorInvalidSourceValue UserContentFilterError = 0
+	// The requested content filter could not be found.
+	UserContentFilterErrorNotFoundValue UserContentFilterError = 1
+)
+
+// Enum values used to denote errors happening when creating a #WebKitWebExtensionMatchPattern
+type WebExtensionMatchPatternError int
+
+var xWebExtensionMatchPatternErrorGLibType func() types.GType
+
+func WebExtensionMatchPatternErrorGLibType() types.GType {
+	return xWebExtensionMatchPatternErrorGLibType()
+}
+
+const (
+
+	// An unknown error occured.
+	WebExtensionMatchPatternErrorUnknownValue WebExtensionMatchPatternError = 899
+	// The scheme component was invalid.
+	WebExtensionMatchPatternErrorInvalidSchemeValue WebExtensionMatchPatternError = 808
+	// The host component was invalid.
+	WebExtensionMatchPatternErrorInvalidHostValue WebExtensionMatchPatternError = 809
+	// The path component was invalid.
+	WebExtensionMatchPatternErrorInvalidPathValue WebExtensionMatchPatternError = 810
+)
+
+var xDownloadErrorQuark func() glib.Quark
+
+// Gets the quark for the domain of download errors.
+func DownloadErrorQuark() glib.Quark {
+
+	cret := xDownloadErrorQuark()
+	return cret
+}
+
+var xJavascriptErrorQuark func() glib.Quark
+
+// Gets the quark for the domain of JavaScript errors.
+func JavascriptErrorQuark() glib.Quark {
+
+	cret := xJavascriptErrorQuark()
+	return cret
+}
+
+var xMediaErrorQuark func() glib.Quark
+
+// Gets the quark for the domain of media errors.
+func MediaErrorQuark() glib.Quark {
+
+	cret := xMediaErrorQuark()
+	return cret
+}
+
+var xNetworkErrorQuark func() glib.Quark
+
+// Gets the quark for the domain of networking errors.
+func NetworkErrorQuark() glib.Quark {
+
+	cret := xNetworkErrorQuark()
+	return cret
+}
+
+var xPolicyErrorQuark func() glib.Quark
+
+// Gets the quark for the domain of policy errors.
+func PolicyErrorQuark() glib.Quark {
+
+	cret := xPolicyErrorQuark()
+	return cret
+}
+
+var xPrintErrorQuark func() glib.Quark
+
+// Gets the quark for the domain of printing errors.
+func PrintErrorQuark() glib.Quark {
+
+	cret := xPrintErrorQuark()
+	return cret
+}
+
+var xSnapshotErrorQuark func() glib.Quark
+
+// Gets the quark for the domain of page snapshot errors.
+func SnapshotErrorQuark() glib.Quark {
+
+	cret := xSnapshotErrorQuark()
+	return cret
+}
+
+var xUserContentFilterErrorQuark func() glib.Quark
+
+// Gets the quark for the domain of user content filter errors.
+func UserContentFilterErrorQuark() glib.Quark {
+
+	cret := xUserContentFilterErrorQuark()
+	return cret
+}
+
+var xWebExtensionMatchPatternErrorQuark func() glib.Quark
+
+// Gets the quark for the domain of Web Extension Match Pattern errors.
+func WebExtensionMatchPatternErrorQuark() glib.Quark {
+
+	cret := xWebExtensionMatchPatternErrorQuark()
+	return cret
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xDownloadErrorGLibType, libs, "webkit_download_error_get_type")
+
+	core.PuregoSafeRegister(&xJavascriptErrorGLibType, libs, "webkit_javascript_error_get_type")
+
+	core.PuregoSafeRegister(&xMediaErrorGLibType, libs, "webkit_media_error_get_type")
+
+	core.PuregoSafeRegister(&xNetworkErrorGLibType, libs, "webkit_network_error_get_type")
+
+	core.PuregoSafeRegister(&xPolicyErrorGLibType, libs, "webkit_policy_error_get_type")
+
+	core.PuregoSafeRegister(&xPrintErrorGLibType, libs, "webkit_print_error_get_type")
+
+	core.PuregoSafeRegister(&xSnapshotErrorGLibType, libs, "webkit_snapshot_error_get_type")
+
+	core.PuregoSafeRegister(&xUserContentFilterErrorGLibType, libs, "webkit_user_content_filter_error_get_type")
+
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternErrorGLibType, libs, "webkit_web_extension_match_pattern_error_get_type")
+
+	core.PuregoSafeRegister(&xDownloadErrorQuark, libs, "webkit_download_error_quark")
+	core.PuregoSafeRegister(&xJavascriptErrorQuark, libs, "webkit_javascript_error_quark")
+	core.PuregoSafeRegister(&xMediaErrorQuark, libs, "webkit_media_error_quark")
+	core.PuregoSafeRegister(&xNetworkErrorQuark, libs, "webkit_network_error_quark")
+	core.PuregoSafeRegister(&xPolicyErrorQuark, libs, "webkit_policy_error_quark")
+	core.PuregoSafeRegister(&xPrintErrorQuark, libs, "webkit_print_error_quark")
+	core.PuregoSafeRegister(&xSnapshotErrorQuark, libs, "webkit_snapshot_error_quark")
+	core.PuregoSafeRegister(&xUserContentFilterErrorQuark, libs, "webkit_user_content_filter_error_quark")
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternErrorQuark, libs, "webkit_web_extension_match_pattern_error_quark")
+
+}
diff --git a/v4/webkit/WebKitFaviconDatabase.go b/v4/webkit/WebKitFaviconDatabase.go
new file mode 100644
index 0000000000000000000000000000000000000000..f9c57727d87e6cba425417e8c6b73e0b6922078d
--- /dev/null
+++ b/v4/webkit/WebKitFaviconDatabase.go
@@ -0,0 +1,197 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gdk"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type FaviconDatabaseClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *FaviconDatabaseClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values used to denote the various errors related to the #WebKitFaviconDatabase.
+type FaviconDatabaseError int
+
+var xFaviconDatabaseErrorGLibType func() types.GType
+
+func FaviconDatabaseErrorGLibType() types.GType {
+	return xFaviconDatabaseErrorGLibType()
+}
+
+const (
+
+	// The #WebKitFaviconDatabase is closed
+	FaviconDatabaseErrorNotInitializedValue FaviconDatabaseError = 0
+	// There is not an icon available for the requested URL
+	FaviconDatabaseErrorFaviconNotFoundValue FaviconDatabaseError = 1
+	// There might be an icon for the requested URL, but its data is unknown at the moment
+	FaviconDatabaseErrorFaviconUnknownValue FaviconDatabaseError = 2
+)
+
+var xFaviconDatabaseErrorQuark func() glib.Quark
+
+// Gets the quark for the domain of favicon database errors.
+func FaviconDatabaseErrorQuark() glib.Quark {
+
+	cret := xFaviconDatabaseErrorQuark()
+	return cret
+}
+
+// Provides access to the icons associated with web sites.
+//
+// WebKit will automatically look for available icons in &lt;link&gt;
+// elements on opened pages as well as an existing favicon.ico and
+// load the images found into a memory cache if possible. That cache
+// is frozen to an on-disk database for persistence.
+//
+// If #WebKitSettings:enable-private-browsing is %TRUE, new icons
+// won't be added to the on-disk database and no existing icons will
+// be deleted from it. Nevertheless, WebKit will still store them in
+// the in-memory cache during the current execution.
+type FaviconDatabase struct {
+	gobject.Object
+}
+
+var xFaviconDatabaseGLibType func() types.GType
+
+func FaviconDatabaseGLibType() types.GType {
+	return xFaviconDatabaseGLibType()
+}
+
+func FaviconDatabaseNewFromInternalPtr(ptr uintptr) *FaviconDatabase {
+	cls := &FaviconDatabase{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xFaviconDatabaseClear func(uintptr)
+
+// Clears all icons from the database.
+func (x *FaviconDatabase) Clear() {
+
+	xFaviconDatabaseClear(x.GoPointer())
+
+}
+
+var xFaviconDatabaseGetFavicon func(uintptr, string, uintptr, uintptr, uintptr)
+
+// Asynchronously obtains a favicon image.
+//
+// Asynchronously obtains an image of the favicon for the
+// given page URI. It returns the cached icon if it's in the database
+// asynchronously waiting for the icon to be read from the database.
+//
+// This is an asynchronous method. When the operation is finished, callback will
+// be invoked. You can then call webkit_favicon_database_get_favicon_finish()
+// to get the result of the operation.
+func (x *FaviconDatabase) GetFavicon(PageUriVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xFaviconDatabaseGetFavicon(x.GoPointer(), PageUriVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xFaviconDatabaseGetFaviconFinish func(uintptr, uintptr, **glib.Error) uintptr
+
+// Finishes an operation started with webkit_favicon_database_get_favicon().
+func (x *FaviconDatabase) GetFaviconFinish(ResultVar gio.AsyncResult) (*gdk.Texture, error) {
+	var cls *gdk.Texture
+	var cerr *glib.Error
+
+	cret := xFaviconDatabaseGetFaviconFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+
+	if cret == 0 {
+		return nil, cerr
+	}
+	cls = &gdk.Texture{}
+	cls.Ptr = cret
+	if cerr == nil {
+		return cls, nil
+	}
+	return cls, cerr
+
+}
+
+var xFaviconDatabaseGetFaviconUri func(uintptr, string) string
+
+// Obtains the URI of the favicon for the given @page_uri.
+func (x *FaviconDatabase) GetFaviconUri(PageUriVar string) string {
+
+	cret := xFaviconDatabaseGetFaviconUri(x.GoPointer(), PageUriVar)
+	return cret
+}
+
+func (c *FaviconDatabase) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *FaviconDatabase) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// This signal is emitted when the favicon URI of @page_uri has
+// been changed to @favicon_uri in the database. You can connect
+// to this signal and call webkit_favicon_database_get_favicon()
+// to get the favicon. If you are interested in the favicon of a
+// #WebKitWebView it's easier to use the #WebKitWebView:favicon
+// property. See webkit_web_view_get_favicon() for more details.
+func (x *FaviconDatabase) ConnectFaviconChanged(cb *func(FaviconDatabase, string, string)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "favicon-changed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, PageUriVarp string, FaviconUriVarp string) {
+		fa := FaviconDatabase{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, PageUriVarp, FaviconUriVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "favicon-changed", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xFaviconDatabaseErrorGLibType, libs, "webkit_favicon_database_error_get_type")
+
+	core.PuregoSafeRegister(&xFaviconDatabaseErrorQuark, libs, "webkit_favicon_database_error_quark")
+
+	core.PuregoSafeRegister(&xFaviconDatabaseGLibType, libs, "webkit_favicon_database_get_type")
+
+	core.PuregoSafeRegister(&xFaviconDatabaseClear, libs, "webkit_favicon_database_clear")
+	core.PuregoSafeRegister(&xFaviconDatabaseGetFavicon, libs, "webkit_favicon_database_get_favicon")
+	core.PuregoSafeRegister(&xFaviconDatabaseGetFaviconFinish, libs, "webkit_favicon_database_get_favicon_finish")
+	core.PuregoSafeRegister(&xFaviconDatabaseGetFaviconUri, libs, "webkit_favicon_database_get_favicon_uri")
+
+}
diff --git a/v4/webkit/WebKitFeature.go b/v4/webkit/WebKitFeature.go
new file mode 100644
index 0000000000000000000000000000000000000000..23f4e10b66ce9298480ab5b59a3f8aca6349ec52
--- /dev/null
+++ b/v4/webkit/WebKitFeature.go
@@ -0,0 +1,315 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Describes a web engine feature that may be toggled at runtime.
+//
+// The WebKit web engine includes a set of features which may be toggled
+// programmatically, each one represented by a #WebKitFeature that provides
+// information about it:
+//
+//   - A unique identifier: [method@Feature.get_identifier].
+//   - A default value, which indicates whether the option is enabled
+//     automatically: [method@Feature.get_default_value].
+//   - Its status, which determines whether it should be considered
+//     user-settable and its development stage (see [enum@FeatureStatus]
+//     for details): [method@Feature.get_status].
+//   - A category, which may be used to group features together:
+//     [method@Feature.get_category].
+//   - An optional short name which can be presented to an user:
+//     [method@Feature.get_name].
+//   - An optional longer detailed description:
+//     [method@Feature.get_details].
+//
+// The lists of available features can be obtained with
+// [func@Settings.get_all_features], [func@Settings.get_experimental_features],
+// and [func@Settings.get_development_features]). As a rule of thumb,
+// applications which may want to allow users (i.e. web developers) to test
+// WebKit features should use the list of experimental features. Additionally,
+// applications might want to expose development features *when targeting
+// technically inclined users* for early testing of in-development features
+// (i.e. in technology preview or canary builds).
+//
+// Applications **must not** expose the list of all features to end users
+// because they often lack descriptions and control parts of the web engine
+// which are either intended to be used during development of WebKit itself,
+// or in specific scenarios to tweak how WebKit integrates with the
+// application.
+type Feature struct {
+	_ structs.HostLayout
+}
+
+var xFeatureGLibType func() types.GType
+
+func FeatureGLibType() types.GType {
+	return xFeatureGLibType()
+}
+
+func (x *Feature) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xFeatureGetCategory func(uintptr) string
+
+// Gets the category of the feature.
+//
+// Applications which include user interface to toggle features may want
+// to use the category to group related features together.
+func (x *Feature) GetCategory() string {
+
+	cret := xFeatureGetCategory(x.GoPointer())
+	return cret
+}
+
+var xFeatureGetDefaultValue func(uintptr) bool
+
+// Gets whether the feature is enabled by default.
+//
+// The default value may be used by applications which include user interface
+// to toggle features to restore its settings to their defaults. Note that
+// whether a feature is actually enabled must be checked with
+// [method@Settings.get_feature_enabled].
+func (x *Feature) GetDefaultValue() bool {
+
+	cret := xFeatureGetDefaultValue(x.GoPointer())
+	return cret
+}
+
+var xFeatureGetDetails func(uintptr) string
+
+// Gets a description for the @feature.
+//
+// The detailed description should be considered an additional clarification
+// on the purpose of the feature, to be used as complementary aid to be
+// displayed along the feature name returned by [method@Feature.get_name].
+// The returned string is suitable to be displayed to end users, but it
+// should not be relied upon being localized.
+//
+// Note that some *features may not* have a detailed description, and @NULL
+// is returned in this case.
+func (x *Feature) GetDetails() string {
+
+	cret := xFeatureGetDetails(x.GoPointer())
+	return cret
+}
+
+var xFeatureGetIdentifier func(uintptr) string
+
+// Gets a string that uniquely identifies the @feature.
+func (x *Feature) GetIdentifier() string {
+
+	cret := xFeatureGetIdentifier(x.GoPointer())
+	return cret
+}
+
+var xFeatureGetName func(uintptr) string
+
+// Gets a short name for the @feature.
+//
+// The returned string is suitable to be displayed to end users, but it
+// should not be relied upon being localized.
+//
+// Note that some *features may not* have a short name, and @NULL
+// is returned in this case.
+func (x *Feature) GetName() string {
+
+	cret := xFeatureGetName(x.GoPointer())
+	return cret
+}
+
+var xFeatureGetStatus func(uintptr) FeatureStatus
+
+// Gets the status of the feature.
+func (x *Feature) GetStatus() FeatureStatus {
+
+	cret := xFeatureGetStatus(x.GoPointer())
+	return cret
+}
+
+var xFeatureRef func(uintptr) *Feature
+
+// Atomically acquires a reference on the given @feature.
+//
+// This function is MT-safe and may be called from any thread.
+func (x *Feature) Ref() *Feature {
+
+	cret := xFeatureRef(x.GoPointer())
+	return cret
+}
+
+var xFeatureUnref func(uintptr)
+
+// Atomically releases a reference on the given @feature.
+//
+// If the reference was the last, the resources associated to the
+// @feature are freed. This function is MT-safe and may be called from
+// any thread.
+func (x *Feature) Unref() {
+
+	xFeatureUnref(x.GoPointer())
+
+}
+
+// Contains a set of toggle-able web engine features.
+//
+// The list supports passing around a set of [struct@Feature] objects and
+// iterating over them:
+//
+// ```c
+// g_autoptr(WebKitFeatureList) list = webkit_settings_get_experimental_features();
+//
+//	for (gsize i = 0; i &lt; webkit_feature_list_get_length(list): i++) {
+//	    WebKitFeature *feature = webkit_feature_list_get(list, i);
+//	    // Do something with "feature".
+//	}
+//
+// ```
+//
+// Lists of features can be obtained with
+// [func@Settings.get_experimental_features],
+// [func@Settings.get_development_features], and
+// [func@Settings.get_all_features].
+type FeatureList struct {
+	_ structs.HostLayout
+}
+
+var xFeatureListGLibType func() types.GType
+
+func FeatureListGLibType() types.GType {
+	return xFeatureListGLibType()
+}
+
+func (x *FeatureList) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xFeatureListGet func(uintptr, uint) *Feature
+
+// Gets a feature given its index.
+func (x *FeatureList) Get(IndexVar uint) *Feature {
+
+	cret := xFeatureListGet(x.GoPointer(), IndexVar)
+	return cret
+}
+
+var xFeatureListGetLength func(uintptr) uint
+
+// Gets the number of elements in the feature list.
+func (x *FeatureList) GetLength() uint {
+
+	cret := xFeatureListGetLength(x.GoPointer())
+	return cret
+}
+
+var xFeatureListRef func(uintptr) *FeatureList
+
+// Atomically acquires a reference on the given @feature_list.
+//
+// This function is MT-safe and may be called from any thread.
+func (x *FeatureList) Ref() *FeatureList {
+
+	cret := xFeatureListRef(x.GoPointer())
+	return cret
+}
+
+var xFeatureListUnref func(uintptr)
+
+// Atomically releases a reference on the given @feature_list.
+//
+// If the reference was the last, the resources associated to the
+// @feature_list are freed. This function is MT-safe and may be called
+// from any thread.
+func (x *FeatureList) Unref() {
+
+	xFeatureListUnref(x.GoPointer())
+
+}
+
+// Describes the status of a [struct@WebKitFeature].
+//
+// The status for a given feature can be obtained with
+// [id@webkit_feature_get_status].
+type FeatureStatus int
+
+var xFeatureStatusGLibType func() types.GType
+
+func FeatureStatusGLibType() types.GType {
+	return xFeatureStatusGLibType()
+}
+
+const (
+
+	// Feature that adjust behaviour for
+	//   specific application needs. The feature is not part of a Web platform
+	//   feature, not a mature feature intended to be always on.
+	FeatureStatusEmbedderValue FeatureStatus = 0
+	// Feature in development. The feature
+	//   may be unfinished, and there are no guarantees about its safety and
+	//   stability.
+	FeatureStatusUnstableValue FeatureStatus = 1
+	// Feature for debugging the WebKit engine.
+	//   The feature is not generally useful for user or web developers, and
+	//   always disabled by default.
+	FeatureStatusInternalValue FeatureStatus = 2
+	// Feature for web developers. The feature
+	//   is not generally useful for end users, and always disabled by default.
+	FeatureStatusDeveloperValue FeatureStatus = 3
+	// Feature in active development and
+	//   complete enough for testing. The feature may not be yet ready to
+	//   ship and is disabled by default.
+	FeatureStatusTestableValue FeatureStatus = 4
+	// Feature ready to be tested by users.
+	//   The feature is disabled by default, but may be enabled by applications
+	//   automatically e.g. in their technology preview or beta versions.
+	FeatureStatusPreviewValue FeatureStatus = 5
+	// Feature ready for general use. The
+	//   feature is enabled by default, but it may still be toggled to support
+	//   debugging and testing.
+	FeatureStatusStableValue FeatureStatus = 6
+	// Feature in general use. The feature is
+	//   always enabled and in general there should be no user-facing interface
+	//   to toggle it.
+	FeatureStatusMatureValue FeatureStatus = 7
+)
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xFeatureStatusGLibType, libs, "webkit_feature_status_get_type")
+
+	core.PuregoSafeRegister(&xFeatureGLibType, libs, "webkit_feature_get_type")
+
+	core.PuregoSafeRegister(&xFeatureGetCategory, libs, "webkit_feature_get_category")
+	core.PuregoSafeRegister(&xFeatureGetDefaultValue, libs, "webkit_feature_get_default_value")
+	core.PuregoSafeRegister(&xFeatureGetDetails, libs, "webkit_feature_get_details")
+	core.PuregoSafeRegister(&xFeatureGetIdentifier, libs, "webkit_feature_get_identifier")
+	core.PuregoSafeRegister(&xFeatureGetName, libs, "webkit_feature_get_name")
+	core.PuregoSafeRegister(&xFeatureGetStatus, libs, "webkit_feature_get_status")
+	core.PuregoSafeRegister(&xFeatureRef, libs, "webkit_feature_ref")
+	core.PuregoSafeRegister(&xFeatureUnref, libs, "webkit_feature_unref")
+
+	core.PuregoSafeRegister(&xFeatureListGLibType, libs, "webkit_feature_list_get_type")
+
+	core.PuregoSafeRegister(&xFeatureListGet, libs, "webkit_feature_list_get")
+	core.PuregoSafeRegister(&xFeatureListGetLength, libs, "webkit_feature_list_get_length")
+	core.PuregoSafeRegister(&xFeatureListRef, libs, "webkit_feature_list_ref")
+	core.PuregoSafeRegister(&xFeatureListUnref, libs, "webkit_feature_list_unref")
+
+}
diff --git a/v4/webkit/WebKitFileChooserRequest.go b/v4/webkit/WebKitFileChooserRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..f229a39a72edc9f86a6a102bee97a6c8dcdaeb49
--- /dev/null
+++ b/v4/webkit/WebKitFileChooserRequest.go
@@ -0,0 +1,221 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/gtk"
+)
+
+type FileChooserRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *FileChooserRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A request to open a file chooser.
+//
+// Whenever the user interacts with an HTML input element with
+// file type, WebKit will need to show a dialog to choose one or
+// more files to be uploaded to the server along with the rest of the
+// form data. For that to happen in a general way, instead of just
+// opening a #GtkFileChooserDialog (which might be not desirable in
+// some cases, which could prefer to use their own file chooser
+// dialog), WebKit will fire the #WebKitWebView::run-file-chooser
+// signal with a #WebKitFileChooserRequest object, which will allow
+// the client application to specify the files to be selected, to
+// inspect the details of the request (e.g. if multiple selection
+// should be allowed) and to cancel the request, in case nothing was
+// selected.
+//
+// In case the client application does not wish to handle this signal,
+// WebKit will provide a default handler which will asynchronously run
+// a regular #GtkFileChooserDialog for the user to interact with.
+type FileChooserRequest struct {
+	gobject.Object
+}
+
+var xFileChooserRequestGLibType func() types.GType
+
+func FileChooserRequestGLibType() types.GType {
+	return xFileChooserRequestGLibType()
+}
+
+func FileChooserRequestNewFromInternalPtr(ptr uintptr) *FileChooserRequest {
+	cls := &FileChooserRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xFileChooserRequestCancel func(uintptr)
+
+// Ask WebKit to cancel the request.
+//
+// It's important to do this in case
+// no selection has been made in the client, otherwise the request
+// won't be properly completed and the browser will keep the request
+// pending forever, which might cause the browser to hang.
+func (x *FileChooserRequest) Cancel() {
+
+	xFileChooserRequestCancel(x.GoPointer())
+
+}
+
+var xFileChooserRequestGetMimeTypes func(uintptr) []string
+
+// Get the list of MIME types the file chooser dialog should handle.
+//
+// Get the list of MIME types the file chooser dialog should handle,
+// in the format specified in RFC 2046 for "media types". Its contents
+// depend on the value of the 'accept' attribute for HTML input
+// elements. This function should normally be called before presenting
+// the file chooser dialog to the user, to decide whether to allow the
+// user to select multiple files at once or only one.
+func (x *FileChooserRequest) GetMimeTypes() []string {
+
+	cret := xFileChooserRequestGetMimeTypes(x.GoPointer())
+	return cret
+}
+
+var xFileChooserRequestGetMimeTypesFilter func(uintptr) uintptr
+
+// Get the filter currently associated with the request.
+//
+// Get the filter currently associated with the request, ready to be
+// used by #GtkFileChooser. This function should normally be called
+// before presenting the file chooser dialog to the user, to decide
+// whether to apply a filter so the user would not be allowed to
+// select files with other MIME types.
+//
+// See webkit_file_chooser_request_get_mime_types() if you are
+// interested in getting the list of accepted MIME types.
+func (x *FileChooserRequest) GetMimeTypesFilter() *gtk.FileFilter {
+	var cls *gtk.FileFilter
+
+	cret := xFileChooserRequestGetMimeTypesFilter(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gtk.FileFilter{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xFileChooserRequestGetSelectMultiple func(uintptr) bool
+
+// Whether the file chooser should allow selecting multiple files.
+//
+// Determine whether the file chooser associated to this
+// #WebKitFileChooserRequest should allow selecting multiple files,
+// which depends on the HTML input element having a 'multiple'
+// attribute defined.
+func (x *FileChooserRequest) GetSelectMultiple() bool {
+
+	cret := xFileChooserRequestGetSelectMultiple(x.GoPointer())
+	return cret
+}
+
+var xFileChooserRequestGetSelectedFiles func(uintptr) []string
+
+// Get the list of selected files associated to the request.
+//
+// Get the list of selected files currently associated to the
+// request. Initially, the return value of this method contains any
+// files selected in previous file chooser requests for this HTML
+// input element. Once webkit_file_chooser_request_select_files, the
+// value will reflect whatever files are given.
+//
+// This function should normally be called only before presenting the
+// file chooser dialog to the user, to decide whether to perform some
+// extra action, like pre-selecting the files from a previous request.
+func (x *FileChooserRequest) GetSelectedFiles() []string {
+
+	cret := xFileChooserRequestGetSelectedFiles(x.GoPointer())
+	return cret
+}
+
+var xFileChooserRequestSelectFiles func(uintptr, []string)
+
+// Ask WebKit to select local files for upload and complete the
+// request.
+func (x *FileChooserRequest) SelectFiles(FilesVar []string) {
+
+	xFileChooserRequestSelectFiles(x.GoPointer(), FilesVar)
+
+}
+
+func (c *FileChooserRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *FileChooserRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// GetPropertyMimeTypes gets the "mime-types" property.
+// A %NULL-terminated array of strings containing the list of MIME
+// types the file chooser dialog should handle. See
+// webkit_file_chooser_request_get_mime_types() for more details.
+func (x *FileChooserRequest) GetPropertyMimeTypes() []string {
+	var v gobject.Value
+	x.GetProperty("mime-types", &v)
+	return core.GoStringSlice(v.GetBoxed())
+}
+
+// GetPropertySelectMultiple gets the "select-multiple" property.
+// Whether the file chooser should allow selecting multiple
+// files. See
+// webkit_file_chooser_request_get_select_multiple() for
+// more details.
+func (x *FileChooserRequest) GetPropertySelectMultiple() bool {
+	var v gobject.Value
+	x.GetProperty("select-multiple", &v)
+	return v.GetBoolean()
+}
+
+// GetPropertySelectedFiles gets the "selected-files" property.
+// A %NULL-terminated array of strings containing the list of
+// selected files associated to the current request. See
+// webkit_file_chooser_request_get_selected_files() for more details.
+func (x *FileChooserRequest) GetPropertySelectedFiles() []string {
+	var v gobject.Value
+	x.GetProperty("selected-files", &v)
+	return core.GoStringSlice(v.GetBoxed())
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xFileChooserRequestGLibType, libs, "webkit_file_chooser_request_get_type")
+
+	core.PuregoSafeRegister(&xFileChooserRequestCancel, libs, "webkit_file_chooser_request_cancel")
+	core.PuregoSafeRegister(&xFileChooserRequestGetMimeTypes, libs, "webkit_file_chooser_request_get_mime_types")
+	core.PuregoSafeRegister(&xFileChooserRequestGetMimeTypesFilter, libs, "webkit_file_chooser_request_get_mime_types_filter")
+	core.PuregoSafeRegister(&xFileChooserRequestGetSelectMultiple, libs, "webkit_file_chooser_request_get_select_multiple")
+	core.PuregoSafeRegister(&xFileChooserRequestGetSelectedFiles, libs, "webkit_file_chooser_request_get_selected_files")
+	core.PuregoSafeRegister(&xFileChooserRequestSelectFiles, libs, "webkit_file_chooser_request_select_files")
+
+}
diff --git a/v4/webkit/WebKitFindController.go b/v4/webkit/WebKitFindController.go
new file mode 100644
index 0000000000000000000000000000000000000000..282abb0ca96f656bb967304610444936734add71
--- /dev/null
+++ b/v4/webkit/WebKitFindController.go
@@ -0,0 +1,348 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type FindControllerClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *FindControllerClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values used to specify search options.
+type FindOptions int
+
+var xFindOptionsGLibType func() types.GType
+
+func FindOptionsGLibType() types.GType {
+	return xFindOptionsGLibType()
+}
+
+const (
+
+	// no search flags, this means a case
+	//   sensitive, no wrap, forward only search.
+	FindOptionsNoneValue FindOptions = 0
+	// case insensitive search.
+	FindOptionsCaseInsensitiveValue FindOptions = 1
+	// search text only at the
+	//   begining of the words.
+	FindOptionsAtWordStartsValue FindOptions = 2
+	// treat
+	//   capital letters in the middle of words as word start.
+	FindOptionsTreatMedialCapitalAsWordStartValue FindOptions = 4
+	// search backwards.
+	FindOptionsBackwardsValue FindOptions = 8
+	// if not present search will stop
+	//   at the end of the document.
+	FindOptionsWrapAroundValue FindOptions = 16
+)
+
+// Controls text search in a #WebKitWebView.
+//
+// A #WebKitFindController is used to search text in a #WebKitWebView. You
+// can get a #WebKitWebView&lt;!-- --&gt;'s #WebKitFindController with
+// webkit_web_view_get_find_controller(), and later use it to search
+// for text using webkit_find_controller_search(), or get the
+// number of matches using webkit_find_controller_count_matches(). The
+// operations are asynchronous and trigger signals when ready, such as
+// #WebKitFindController::found-text,
+// #WebKitFindController::failed-to-find-text or
+// #WebKitFindController::counted-matches&lt;!-- --&gt;.
+type FindController struct {
+	gobject.Object
+}
+
+var xFindControllerGLibType func() types.GType
+
+func FindControllerGLibType() types.GType {
+	return xFindControllerGLibType()
+}
+
+func FindControllerNewFromInternalPtr(ptr uintptr) *FindController {
+	cls := &FindController{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xFindControllerCountMatches func(uintptr, string, uint32, uint)
+
+// Counts the number of matches for @search_text.
+//
+// Counts the number of matches for @search_text found in the
+// #WebKitWebView with the provided @find_options. The number of
+// matches will be provided by the
+// #WebKitFindController::counted-matches signal.
+func (x *FindController) CountMatches(SearchTextVar string, FindOptionsVar uint32, MaxMatchCountVar uint) {
+
+	xFindControllerCountMatches(x.GoPointer(), SearchTextVar, FindOptionsVar, MaxMatchCountVar)
+
+}
+
+var xFindControllerGetMaxMatchCount func(uintptr) uint
+
+// Gets the maximum number of matches to report.
+//
+// Gets the maximum number of matches to report during a text
+// lookup. This number is passed as the last argument of
+// webkit_find_controller_search() or
+// webkit_find_controller_count_matches().
+func (x *FindController) GetMaxMatchCount() uint {
+
+	cret := xFindControllerGetMaxMatchCount(x.GoPointer())
+	return cret
+}
+
+var xFindControllerGetOptions func(uintptr) uint32
+
+// Gets the #WebKitFindOptions for the current search.
+//
+// Gets a bitmask containing the #WebKitFindOptions associated with
+// the current search.
+func (x *FindController) GetOptions() uint32 {
+
+	cret := xFindControllerGetOptions(x.GoPointer())
+	return cret
+}
+
+var xFindControllerGetSearchText func(uintptr) string
+
+// Gets the text that @find_controller is searching for.
+//
+// Gets the text that @find_controller is currently searching
+// for. This text is passed to either
+// webkit_find_controller_search() or
+// webkit_find_controller_count_matches().
+func (x *FindController) GetSearchText() string {
+
+	cret := xFindControllerGetSearchText(x.GoPointer())
+	return cret
+}
+
+var xFindControllerGetWebView func(uintptr) uintptr
+
+// Gets the #WebKitWebView this find controller is associated to.
+//
+// Do
+// not dereference the returned instance as it belongs to the
+// #WebKitFindController.
+func (x *FindController) GetWebView() *WebView {
+	var cls *WebView
+
+	cret := xFindControllerGetWebView(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WebView{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xFindControllerSearch func(uintptr, string, uint32, uint)
+
+// Looks for @search_text associated with @find_controller.
+//
+// Looks for @search_text in the #WebKitWebView associated with
+// @find_controller since the beginning of the document highlighting
+// up to @max_match_count matches. The outcome of the search will be
+// asynchronously provided by the #WebKitFindController::found-text
+// and #WebKitFindController::failed-to-find-text signals.
+//
+// To look for the next or previous occurrences of the same text
+// with the same find options use webkit_find_controller_search_next()
+// and/or webkit_find_controller_search_previous(). The
+// #WebKitFindController will use the same text and options for the
+// following searches unless they are modified by another call to this
+// method.
+//
+// Note that if the number of matches is higher than @max_match_count
+// then #WebKitFindController::found-text will report %G_MAXUINT matches
+// instead of the actual number.
+//
+// Callers should call webkit_find_controller_search_finish() to
+// finish the current search operation.
+func (x *FindController) Search(SearchTextVar string, FindOptionsVar uint32, MaxMatchCountVar uint) {
+
+	xFindControllerSearch(x.GoPointer(), SearchTextVar, FindOptionsVar, MaxMatchCountVar)
+
+}
+
+var xFindControllerSearchFinish func(uintptr)
+
+// Finishes a find operation.
+//
+// Finishes a find operation started by
+// webkit_find_controller_search(). It will basically unhighlight
+// every text match found.
+//
+// This method will be typically called when the search UI is
+// closed/hidden by the client application.
+func (x *FindController) SearchFinish() {
+
+	xFindControllerSearchFinish(x.GoPointer())
+
+}
+
+var xFindControllerSearchNext func(uintptr)
+
+// Looks for the next occurrence of the search text.
+//
+// Calling this method before webkit_find_controller_search() or
+// webkit_find_controller_count_matches() is a programming error.
+func (x *FindController) SearchNext() {
+
+	xFindControllerSearchNext(x.GoPointer())
+
+}
+
+var xFindControllerSearchPrevious func(uintptr)
+
+// Looks for the previous occurrence of the search text.
+//
+// Calling this method before webkit_find_controller_search() or
+// webkit_find_controller_count_matches() is a programming error.
+func (x *FindController) SearchPrevious() {
+
+	xFindControllerSearchPrevious(x.GoPointer())
+
+}
+
+func (c *FindController) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *FindController) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// GetPropertyMaxMatchCount gets the "max-match-count" property.
+// The maximum number of matches to report for a given search.
+func (x *FindController) GetPropertyMaxMatchCount() uint {
+	var v gobject.Value
+	x.GetProperty("max-match-count", &v)
+	return v.GetUint()
+}
+
+// GetPropertyText gets the "text" property.
+// The current search text for this #WebKitFindController.
+func (x *FindController) GetPropertyText() string {
+	var v gobject.Value
+	x.GetProperty("text", &v)
+	return v.GetString()
+}
+
+// This signal is emitted when the #WebKitFindController has
+// counted the number of matches for a given text after a call
+// to webkit_find_controller_count_matches().
+func (x *FindController) ConnectCountedMatches(cb *func(FindController, uint)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "counted-matches", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MatchCountVarp uint) {
+		fa := FindController{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, MatchCountVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "counted-matches", cbRefPtr)
+}
+
+// This signal is emitted when a search operation does not find
+// any result for the given text. It will be issued if the text
+// is not found asynchronously after a call to
+// webkit_find_controller_search(), webkit_find_controller_search_next()
+// or webkit_find_controller_search_previous().
+func (x *FindController) ConnectFailedToFindText(cb *func(FindController)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "failed-to-find-text", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := FindController{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "failed-to-find-text", cbRefPtr)
+}
+
+// This signal is emitted when a given text is found in the web
+// page text. It will be issued if the text is found
+// asynchronously after a call to webkit_find_controller_search(),
+// webkit_find_controller_search_next() or
+// webkit_find_controller_search_previous().
+func (x *FindController) ConnectFoundText(cb *func(FindController, uint)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "found-text", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MatchCountVarp uint) {
+		fa := FindController{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, MatchCountVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "found-text", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xFindOptionsGLibType, libs, "webkit_find_options_get_type")
+
+	core.PuregoSafeRegister(&xFindControllerGLibType, libs, "webkit_find_controller_get_type")
+
+	core.PuregoSafeRegister(&xFindControllerCountMatches, libs, "webkit_find_controller_count_matches")
+	core.PuregoSafeRegister(&xFindControllerGetMaxMatchCount, libs, "webkit_find_controller_get_max_match_count")
+	core.PuregoSafeRegister(&xFindControllerGetOptions, libs, "webkit_find_controller_get_options")
+	core.PuregoSafeRegister(&xFindControllerGetSearchText, libs, "webkit_find_controller_get_search_text")
+	core.PuregoSafeRegister(&xFindControllerGetWebView, libs, "webkit_find_controller_get_web_view")
+	core.PuregoSafeRegister(&xFindControllerSearch, libs, "webkit_find_controller_search")
+	core.PuregoSafeRegister(&xFindControllerSearchFinish, libs, "webkit_find_controller_search_finish")
+	core.PuregoSafeRegister(&xFindControllerSearchNext, libs, "webkit_find_controller_search_next")
+	core.PuregoSafeRegister(&xFindControllerSearchPrevious, libs, "webkit_find_controller_search_previous")
+
+}
diff --git a/v4/webkit/WebKitFormSubmissionRequest.go b/v4/webkit/WebKitFormSubmissionRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..df9f94fc168f23bd4a6a64b3fde0497d5bcf5326
--- /dev/null
+++ b/v4/webkit/WebKitFormSubmissionRequest.go
@@ -0,0 +1,101 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type FormSubmissionRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *FormSubmissionRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Represents a form submission request.
+//
+// When a form is about to be submitted in a #WebKitWebView, the
+// #WebKitWebView::submit-form signal is emitted. Its request argument
+// contains information about the text fields of the form, that are
+// typically used to store login information, returned as lists by
+// webkit_form_submission_request_list_text_fields(). You can submit the
+// form with webkit_form_submission_request_submit().
+type FormSubmissionRequest struct {
+	gobject.Object
+}
+
+var xFormSubmissionRequestGLibType func() types.GType
+
+func FormSubmissionRequestGLibType() types.GType {
+	return xFormSubmissionRequestGLibType()
+}
+
+func FormSubmissionRequestNewFromInternalPtr(ptr uintptr) *FormSubmissionRequest {
+	cls := &FormSubmissionRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xFormSubmissionRequestListTextFields func(uintptr, *[]string, *[]string) bool
+
+// Get lists of the text fields contained in the form associated to @request.
+//
+// Get lists with the names and values of the text fields contained in
+// the form associated to @request. Note that names and values may be
+// %NULL.
+//
+// If this function returns %FALSE, then both @field_names and
+// @field_values will be empty.
+func (x *FormSubmissionRequest) ListTextFields(FieldNamesVar *[]string, FieldValuesVar *[]string) bool {
+
+	cret := xFormSubmissionRequestListTextFields(x.GoPointer(), FieldNamesVar, FieldValuesVar)
+	return cret
+}
+
+var xFormSubmissionRequestSubmit func(uintptr)
+
+// Continue the form submission.
+func (x *FormSubmissionRequest) Submit() {
+
+	xFormSubmissionRequestSubmit(x.GoPointer())
+
+}
+
+func (c *FormSubmissionRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *FormSubmissionRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xFormSubmissionRequestGLibType, libs, "webkit_form_submission_request_get_type")
+
+	core.PuregoSafeRegister(&xFormSubmissionRequestListTextFields, libs, "webkit_form_submission_request_list_text_fields")
+	core.PuregoSafeRegister(&xFormSubmissionRequestSubmit, libs, "webkit_form_submission_request_submit")
+
+}
diff --git a/v4/webkit/WebKitGeolocationManager.go b/v4/webkit/WebKitGeolocationManager.go
new file mode 100644
index 0000000000000000000000000000000000000000..a589dc6039baa81743b083bcf4559df3f6ab44bc
--- /dev/null
+++ b/v4/webkit/WebKitGeolocationManager.go
@@ -0,0 +1,270 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type GeolocationManagerClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *GeolocationManagerClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// An opaque struct to provide position updates to a #WebKitGeolocationManager.
+//
+// WebKitGeolocationPosition is an opaque struct used to provide position updates to a
+// #WebKitGeolocationManager using webkit_geolocation_manager_update_position().
+type GeolocationPosition struct {
+	_ structs.HostLayout
+}
+
+var xGeolocationPositionGLibType func() types.GType
+
+func GeolocationPositionGLibType() types.GType {
+	return xGeolocationPositionGLibType()
+}
+
+func (x *GeolocationPosition) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewGeolocationPosition func(float64, float64, float64) *GeolocationPosition
+
+// Create a new #WebKitGeolocationPosition.
+func NewGeolocationPosition(LatitudeVar float64, LongitudeVar float64, AccuracyVar float64) *GeolocationPosition {
+
+	cret := xNewGeolocationPosition(LatitudeVar, LongitudeVar, AccuracyVar)
+	return cret
+}
+
+var xGeolocationPositionCopy func(uintptr) *GeolocationPosition
+
+// Make a copy of the #WebKitGeolocationPosition.
+func (x *GeolocationPosition) Copy() *GeolocationPosition {
+
+	cret := xGeolocationPositionCopy(x.GoPointer())
+	return cret
+}
+
+var xGeolocationPositionFree func(uintptr)
+
+// Free the #WebKitGeolocationPosition
+func (x *GeolocationPosition) Free() {
+
+	xGeolocationPositionFree(x.GoPointer())
+
+}
+
+var xGeolocationPositionSetAltitude func(uintptr, float64)
+
+// Set the @position altitude.
+func (x *GeolocationPosition) SetAltitude(AltitudeVar float64) {
+
+	xGeolocationPositionSetAltitude(x.GoPointer(), AltitudeVar)
+
+}
+
+var xGeolocationPositionSetAltitudeAccuracy func(uintptr, float64)
+
+// Set the accuracy of @position altitude.
+func (x *GeolocationPosition) SetAltitudeAccuracy(AltitudeAccuracyVar float64) {
+
+	xGeolocationPositionSetAltitudeAccuracy(x.GoPointer(), AltitudeAccuracyVar)
+
+}
+
+var xGeolocationPositionSetHeading func(uintptr, float64)
+
+// Set the @position heading.
+//
+// Set the @position heading, as a positive angle between the direction of movement and the North
+// direction, in clockwise direction.
+func (x *GeolocationPosition) SetHeading(HeadingVar float64) {
+
+	xGeolocationPositionSetHeading(x.GoPointer(), HeadingVar)
+
+}
+
+var xGeolocationPositionSetSpeed func(uintptr, float64)
+
+// Set the @position speed.
+func (x *GeolocationPosition) SetSpeed(SpeedVar float64) {
+
+	xGeolocationPositionSetSpeed(x.GoPointer(), SpeedVar)
+
+}
+
+var xGeolocationPositionSetTimestamp func(uintptr, uint64)
+
+// Set the @position timestamp.
+//
+// By default it's the time when the @position was created.
+func (x *GeolocationPosition) SetTimestamp(TimestampVar uint64) {
+
+	xGeolocationPositionSetTimestamp(x.GoPointer(), TimestampVar)
+
+}
+
+// Geolocation manager.
+//
+// WebKitGeolocationManager provides API to get the geographical position of the user.
+// Once a #WebKitGeolocationPermissionRequest is allowed, when WebKit needs to know the
+// user location #WebKitGeolocationManager::start signal is emitted. If the signal is handled
+// and returns %TRUE, the application is responsible for providing the position every time it's
+// updated by calling webkit_geolocation_manager_update_position(). The signal #WebKitGeolocationManager::stop
+// will be emitted when location updates are no longer needed.
+type GeolocationManager struct {
+	gobject.Object
+}
+
+var xGeolocationManagerGLibType func() types.GType
+
+func GeolocationManagerGLibType() types.GType {
+	return xGeolocationManagerGLibType()
+}
+
+func GeolocationManagerNewFromInternalPtr(ptr uintptr) *GeolocationManager {
+	cls := &GeolocationManager{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xGeolocationManagerFailed func(uintptr, string)
+
+// Notify @manager that determining the position failed.
+func (x *GeolocationManager) Failed(ErrorMessageVar string) {
+
+	xGeolocationManagerFailed(x.GoPointer(), ErrorMessageVar)
+
+}
+
+var xGeolocationManagerGetEnableHighAccuracy func(uintptr) bool
+
+// Get whether high accuracy is enabled.
+func (x *GeolocationManager) GetEnableHighAccuracy() bool {
+
+	cret := xGeolocationManagerGetEnableHighAccuracy(x.GoPointer())
+	return cret
+}
+
+var xGeolocationManagerUpdatePosition func(uintptr, *GeolocationPosition)
+
+// Notify @manager that position has been updated to @position.
+func (x *GeolocationManager) UpdatePosition(PositionVar *GeolocationPosition) {
+
+	xGeolocationManagerUpdatePosition(x.GoPointer(), PositionVar)
+
+}
+
+func (c *GeolocationManager) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *GeolocationManager) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// GetPropertyEnableHighAccuracy gets the "enable-high-accuracy" property.
+// Whether high accuracy is enabled. This is a read-only property that will be
+// set to %TRUE when a #WebKitGeolocationManager needs to get accurate position updates.
+// You can connect to notify::enable-high-accuracy signal to monitor it.
+func (x *GeolocationManager) GetPropertyEnableHighAccuracy() bool {
+	var v gobject.Value
+	x.GetProperty("enable-high-accuracy", &v)
+	return v.GetBoolean()
+}
+
+// The signal is emitted to notify that @manager needs to start receiving
+// position updates. After this signal is emitted the user should provide
+// the updates using webkit_geolocation_manager_update_position() every time
+// the position changes, or use webkit_geolocation_manager_failed() in case
+// it isn't possible to determine the current position.
+//
+// If the signal is not handled, WebKit will try to determine the position
+// using GeoClue if available.
+func (x *GeolocationManager) ConnectStart(cb *func(GeolocationManager) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "start", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) bool {
+		fa := GeolocationManager{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "start", cbRefPtr)
+}
+
+// The signal is emitted to notify that @manager doesn't need to receive
+// position updates anymore.
+func (x *GeolocationManager) ConnectStop(cb *func(GeolocationManager)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "stop", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := GeolocationManager{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "stop", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xGeolocationPositionGLibType, libs, "webkit_geolocation_position_get_type")
+
+	core.PuregoSafeRegister(&xNewGeolocationPosition, libs, "webkit_geolocation_position_new")
+
+	core.PuregoSafeRegister(&xGeolocationPositionCopy, libs, "webkit_geolocation_position_copy")
+	core.PuregoSafeRegister(&xGeolocationPositionFree, libs, "webkit_geolocation_position_free")
+	core.PuregoSafeRegister(&xGeolocationPositionSetAltitude, libs, "webkit_geolocation_position_set_altitude")
+	core.PuregoSafeRegister(&xGeolocationPositionSetAltitudeAccuracy, libs, "webkit_geolocation_position_set_altitude_accuracy")
+	core.PuregoSafeRegister(&xGeolocationPositionSetHeading, libs, "webkit_geolocation_position_set_heading")
+	core.PuregoSafeRegister(&xGeolocationPositionSetSpeed, libs, "webkit_geolocation_position_set_speed")
+	core.PuregoSafeRegister(&xGeolocationPositionSetTimestamp, libs, "webkit_geolocation_position_set_timestamp")
+
+	core.PuregoSafeRegister(&xGeolocationManagerGLibType, libs, "webkit_geolocation_manager_get_type")
+
+	core.PuregoSafeRegister(&xGeolocationManagerFailed, libs, "webkit_geolocation_manager_failed")
+	core.PuregoSafeRegister(&xGeolocationManagerGetEnableHighAccuracy, libs, "webkit_geolocation_manager_get_enable_high_accuracy")
+	core.PuregoSafeRegister(&xGeolocationManagerUpdatePosition, libs, "webkit_geolocation_manager_update_position")
+
+}
diff --git a/v4/webkit/WebKitGeolocationPermissionRequest.go b/v4/webkit/WebKitGeolocationPermissionRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..c594dad1d284717d2e2c6227fb5365fc8cdf9ea8
--- /dev/null
+++ b/v4/webkit/WebKitGeolocationPermissionRequest.go
@@ -0,0 +1,85 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type GeolocationPermissionRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *GeolocationPermissionRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A permission request for sharing the user's location.
+//
+// WebKitGeolocationPermissionRequest represents a request for
+// permission to decide whether WebKit should provide the user's
+// location to a website when requested through the Geolocation API.
+//
+// When a WebKitGeolocationPermissionRequest is not handled by the user,
+// it is denied by default.
+//
+// When embedding web views in your application, you *must* configure an
+// application identifier to allow web content to use geolocation services.
+// The identifier *must* match the name of the `.desktop` file which describes
+// the application, sans the suffix.
+//
+// If your application uses #GApplication (or any subclass like
+// #GtkApplication), WebKit will automatically use the identifier returned by
+// g_application_get_application_id(). This is the recommended approach for
+// enabling geolocation in applications.
+//
+// If an identifier cannot be obtained through #GApplication, the value
+// returned by g_get_prgname() will be used instead as a fallback. For
+// programs which cannot use #GApplication, calling g_set_prgname() early
+// during initialization is needed when the name of the executable on disk
+// does not match the name of a valid `.desktop` file.
+type GeolocationPermissionRequest struct {
+	gobject.Object
+}
+
+var xGeolocationPermissionRequestGLibType func() types.GType
+
+func GeolocationPermissionRequestGLibType() types.GType {
+	return xGeolocationPermissionRequestGLibType()
+}
+
+func GeolocationPermissionRequestNewFromInternalPtr(ptr uintptr) *GeolocationPermissionRequest {
+	cls := &GeolocationPermissionRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *GeolocationPermissionRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *GeolocationPermissionRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Allow the action which triggered this request.
+func (x *GeolocationPermissionRequest) Allow() {
+
+	XWebkitPermissionRequestAllow(x.GoPointer())
+
+}
+
+// Deny the action which triggered this request.
+func (x *GeolocationPermissionRequest) Deny() {
+
+	XWebkitPermissionRequestDeny(x.GoPointer())
+
+}
diff --git a/v4/webkit/WebKitHitTestResult.go b/v4/webkit/WebKitHitTestResult.go
new file mode 100644
index 0000000000000000000000000000000000000000..ae0e40c6cc324e3db6a435e254510ce121dbc5b9
--- /dev/null
+++ b/v4/webkit/WebKitHitTestResult.go
@@ -0,0 +1,355 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type HitTestResultClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *HitTestResultClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values with flags representing the context of a #WebKitHitTestResult.
+type HitTestResultContext int
+
+var xHitTestResultContextGLibType func() types.GType
+
+func HitTestResultContextGLibType() types.GType {
+	return xHitTestResultContextGLibType()
+}
+
+const (
+
+	// anywhere in the document.
+	HitTestResultContextDocumentValue HitTestResultContext = 2
+	// a hyperlink element.
+	HitTestResultContextLinkValue HitTestResultContext = 4
+	// an image element.
+	HitTestResultContextImageValue HitTestResultContext = 8
+	// a video or audio element.
+	HitTestResultContextMediaValue HitTestResultContext = 16
+	// an editable element
+	HitTestResultContextEditableValue HitTestResultContext = 32
+	// a scrollbar element.
+	HitTestResultContextScrollbarValue HitTestResultContext = 64
+	// a selected element. Since 2.8
+	HitTestResultContextSelectionValue HitTestResultContext = 128
+)
+
+// Result of a Hit Test.
+//
+// A Hit Test is an operation to get context information about a given
+// point in a #WebKitWebView. #WebKitHitTestResult represents the
+// result of a Hit Test. It provides context information about what is
+// at the coordinates of the Hit Test, such as if there's a link,
+// an image or a media.
+//
+// You can get the context of the HitTestResult with
+// webkit_hit_test_result_get_context() that returns a bitmask of
+// #WebKitHitTestResultContext flags. You can also use
+// webkit_hit_test_result_context_is_link(), webkit_hit_test_result_context_is_image() and
+// webkit_hit_test_result_context_is_media() to determine whether there's
+// a link, image or a media element at the coordinates of the Hit Test.
+// Note that it's possible that several #WebKitHitTestResultContext flags
+// are active at the same time, for example if there's a link containing an image.
+//
+// When the mouse is moved over a #WebKitWebView a Hit Test is performed
+// for the mouse coordinates and #WebKitWebView::mouse-target-changed
+// signal is emitted with a #WebKitHitTestResult.
+type HitTestResult struct {
+	gobject.Object
+}
+
+var xHitTestResultGLibType func() types.GType
+
+func HitTestResultGLibType() types.GType {
+	return xHitTestResultGLibType()
+}
+
+func HitTestResultNewFromInternalPtr(ptr uintptr) *HitTestResult {
+	cls := &HitTestResult{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xHitTestResultContextIsEditable func(uintptr) bool
+
+// Gets whether %WEBKIT_HIT_TEST_RESULT_CONTEXT_EDITABLE flag is present in
+// #WebKitHitTestResult:context.
+func (x *HitTestResult) ContextIsEditable() bool {
+
+	cret := xHitTestResultContextIsEditable(x.GoPointer())
+	return cret
+}
+
+var xHitTestResultContextIsImage func(uintptr) bool
+
+// Gets whether %WEBKIT_HIT_TEST_RESULT_CONTEXT_IMAGE flag is present in
+// #WebKitHitTestResult:context.
+func (x *HitTestResult) ContextIsImage() bool {
+
+	cret := xHitTestResultContextIsImage(x.GoPointer())
+	return cret
+}
+
+var xHitTestResultContextIsLink func(uintptr) bool
+
+// Gets whether %WEBKIT_HIT_TEST_RESULT_CONTEXT_LINK flag is present in
+// #WebKitHitTestResult:context.
+func (x *HitTestResult) ContextIsLink() bool {
+
+	cret := xHitTestResultContextIsLink(x.GoPointer())
+	return cret
+}
+
+var xHitTestResultContextIsMedia func(uintptr) bool
+
+// Gets whether %WEBKIT_HIT_TEST_RESULT_CONTEXT_MEDIA flag is present in
+// #WebKitHitTestResult:context.
+func (x *HitTestResult) ContextIsMedia() bool {
+
+	cret := xHitTestResultContextIsMedia(x.GoPointer())
+	return cret
+}
+
+var xHitTestResultContextIsScrollbar func(uintptr) bool
+
+// Gets whether %WEBKIT_HIT_TEST_RESULT_CONTEXT_SCROLLBAR flag is present in
+// #WebKitHitTestResult:context.
+func (x *HitTestResult) ContextIsScrollbar() bool {
+
+	cret := xHitTestResultContextIsScrollbar(x.GoPointer())
+	return cret
+}
+
+var xHitTestResultContextIsSelection func(uintptr) bool
+
+// Gets whether %WEBKIT_HIT_TEST_RESULT_CONTEXT_SELECTION flag is present in
+// #WebKitHitTestResult:context.
+func (x *HitTestResult) ContextIsSelection() bool {
+
+	cret := xHitTestResultContextIsSelection(x.GoPointer())
+	return cret
+}
+
+var xHitTestResultGetContext func(uintptr) uint
+
+// Gets the value of the #WebKitHitTestResult:context property.
+func (x *HitTestResult) GetContext() uint {
+
+	cret := xHitTestResultGetContext(x.GoPointer())
+	return cret
+}
+
+var xHitTestResultGetImageUri func(uintptr) string
+
+// Gets the value of the #WebKitHitTestResult:image-uri property.
+func (x *HitTestResult) GetImageUri() string {
+
+	cret := xHitTestResultGetImageUri(x.GoPointer())
+	return cret
+}
+
+var xHitTestResultGetLinkLabel func(uintptr) string
+
+// Gets the value of the #WebKitHitTestResult:link-label property.
+func (x *HitTestResult) GetLinkLabel() string {
+
+	cret := xHitTestResultGetLinkLabel(x.GoPointer())
+	return cret
+}
+
+var xHitTestResultGetLinkTitle func(uintptr) string
+
+// Gets the value of the #WebKitHitTestResult:link-title property.
+func (x *HitTestResult) GetLinkTitle() string {
+
+	cret := xHitTestResultGetLinkTitle(x.GoPointer())
+	return cret
+}
+
+var xHitTestResultGetLinkUri func(uintptr) string
+
+// Gets the value of the #WebKitHitTestResult:link-uri property.
+func (x *HitTestResult) GetLinkUri() string {
+
+	cret := xHitTestResultGetLinkUri(x.GoPointer())
+	return cret
+}
+
+var xHitTestResultGetMediaUri func(uintptr) string
+
+// Gets the value of the #WebKitHitTestResult:media-uri property.
+func (x *HitTestResult) GetMediaUri() string {
+
+	cret := xHitTestResultGetMediaUri(x.GoPointer())
+	return cret
+}
+
+func (c *HitTestResult) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *HitTestResult) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyContext sets the "context" property.
+// Bitmask of #WebKitHitTestResultContext flags representing
+// the context of the #WebKitHitTestResult.
+func (x *HitTestResult) SetPropertyContext(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("context", &v)
+}
+
+// GetPropertyContext gets the "context" property.
+// Bitmask of #WebKitHitTestResultContext flags representing
+// the context of the #WebKitHitTestResult.
+func (x *HitTestResult) GetPropertyContext() uint {
+	var v gobject.Value
+	x.GetProperty("context", &v)
+	return v.GetUint()
+}
+
+// SetPropertyImageUri sets the "image-uri" property.
+// The URI of the image if flag %WEBKIT_HIT_TEST_RESULT_CONTEXT_IMAGE
+// is present in #WebKitHitTestResult:context
+func (x *HitTestResult) SetPropertyImageUri(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("image-uri", &v)
+}
+
+// GetPropertyImageUri gets the "image-uri" property.
+// The URI of the image if flag %WEBKIT_HIT_TEST_RESULT_CONTEXT_IMAGE
+// is present in #WebKitHitTestResult:context
+func (x *HitTestResult) GetPropertyImageUri() string {
+	var v gobject.Value
+	x.GetProperty("image-uri", &v)
+	return v.GetString()
+}
+
+// SetPropertyLinkLabel sets the "link-label" property.
+// The label of the link if flag %WEBKIT_HIT_TEST_RESULT_CONTEXT_LINK
+// is present in #WebKitHitTestResult:context
+func (x *HitTestResult) SetPropertyLinkLabel(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("link-label", &v)
+}
+
+// GetPropertyLinkLabel gets the "link-label" property.
+// The label of the link if flag %WEBKIT_HIT_TEST_RESULT_CONTEXT_LINK
+// is present in #WebKitHitTestResult:context
+func (x *HitTestResult) GetPropertyLinkLabel() string {
+	var v gobject.Value
+	x.GetProperty("link-label", &v)
+	return v.GetString()
+}
+
+// SetPropertyLinkTitle sets the "link-title" property.
+// The title of the link if flag %WEBKIT_HIT_TEST_RESULT_CONTEXT_LINK
+// is present in #WebKitHitTestResult:context
+func (x *HitTestResult) SetPropertyLinkTitle(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("link-title", &v)
+}
+
+// GetPropertyLinkTitle gets the "link-title" property.
+// The title of the link if flag %WEBKIT_HIT_TEST_RESULT_CONTEXT_LINK
+// is present in #WebKitHitTestResult:context
+func (x *HitTestResult) GetPropertyLinkTitle() string {
+	var v gobject.Value
+	x.GetProperty("link-title", &v)
+	return v.GetString()
+}
+
+// SetPropertyLinkUri sets the "link-uri" property.
+// The URI of the link if flag %WEBKIT_HIT_TEST_RESULT_CONTEXT_LINK
+// is present in #WebKitHitTestResult:context
+func (x *HitTestResult) SetPropertyLinkUri(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("link-uri", &v)
+}
+
+// GetPropertyLinkUri gets the "link-uri" property.
+// The URI of the link if flag %WEBKIT_HIT_TEST_RESULT_CONTEXT_LINK
+// is present in #WebKitHitTestResult:context
+func (x *HitTestResult) GetPropertyLinkUri() string {
+	var v gobject.Value
+	x.GetProperty("link-uri", &v)
+	return v.GetString()
+}
+
+// SetPropertyMediaUri sets the "media-uri" property.
+// The URI of the media if flag %WEBKIT_HIT_TEST_RESULT_CONTEXT_MEDIA
+// is present in #WebKitHitTestResult:context
+func (x *HitTestResult) SetPropertyMediaUri(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("media-uri", &v)
+}
+
+// GetPropertyMediaUri gets the "media-uri" property.
+// The URI of the media if flag %WEBKIT_HIT_TEST_RESULT_CONTEXT_MEDIA
+// is present in #WebKitHitTestResult:context
+func (x *HitTestResult) GetPropertyMediaUri() string {
+	var v gobject.Value
+	x.GetProperty("media-uri", &v)
+	return v.GetString()
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xHitTestResultContextGLibType, libs, "webkit_hit_test_result_context_get_type")
+
+	core.PuregoSafeRegister(&xHitTestResultGLibType, libs, "webkit_hit_test_result_get_type")
+
+	core.PuregoSafeRegister(&xHitTestResultContextIsEditable, libs, "webkit_hit_test_result_context_is_editable")
+	core.PuregoSafeRegister(&xHitTestResultContextIsImage, libs, "webkit_hit_test_result_context_is_image")
+	core.PuregoSafeRegister(&xHitTestResultContextIsLink, libs, "webkit_hit_test_result_context_is_link")
+	core.PuregoSafeRegister(&xHitTestResultContextIsMedia, libs, "webkit_hit_test_result_context_is_media")
+	core.PuregoSafeRegister(&xHitTestResultContextIsScrollbar, libs, "webkit_hit_test_result_context_is_scrollbar")
+	core.PuregoSafeRegister(&xHitTestResultContextIsSelection, libs, "webkit_hit_test_result_context_is_selection")
+	core.PuregoSafeRegister(&xHitTestResultGetContext, libs, "webkit_hit_test_result_get_context")
+	core.PuregoSafeRegister(&xHitTestResultGetImageUri, libs, "webkit_hit_test_result_get_image_uri")
+	core.PuregoSafeRegister(&xHitTestResultGetLinkLabel, libs, "webkit_hit_test_result_get_link_label")
+	core.PuregoSafeRegister(&xHitTestResultGetLinkTitle, libs, "webkit_hit_test_result_get_link_title")
+	core.PuregoSafeRegister(&xHitTestResultGetLinkUri, libs, "webkit_hit_test_result_get_link_uri")
+	core.PuregoSafeRegister(&xHitTestResultGetMediaUri, libs, "webkit_hit_test_result_get_media_uri")
+
+}
diff --git a/v4/webkit/WebKitInputMethodContext.go b/v4/webkit/WebKitInputMethodContext.go
new file mode 100644
index 0000000000000000000000000000000000000000..f2d6cb0b9a7ef05e5d1e37918ef2263104484b37
--- /dev/null
+++ b/v4/webkit/WebKitInputMethodContext.go
@@ -0,0 +1,1238 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gdk"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type InputMethodContextClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+
+	xPreeditStarted uintptr
+
+	xPreeditChanged uintptr
+
+	xPreeditFinished uintptr
+
+	xCommitted uintptr
+
+	xDeleteSurrounding uintptr
+
+	xSetEnablePreedit uintptr
+
+	xGetPreedit uintptr
+
+	xFilterKeyEvent uintptr
+
+	xNotifyFocusIn uintptr
+
+	xNotifyFocusOut uintptr
+
+	xNotifyCursorArea uintptr
+
+	xNotifySurrounding uintptr
+
+	xReset uintptr
+
+	xWebkitReserved0 uintptr
+
+	xWebkitReserved1 uintptr
+
+	xWebkitReserved2 uintptr
+
+	xWebkitReserved3 uintptr
+
+	xWebkitReserved4 uintptr
+
+	xWebkitReserved5 uintptr
+
+	xWebkitReserved6 uintptr
+
+	xWebkitReserved7 uintptr
+
+	xWebkitReserved8 uintptr
+
+	xWebkitReserved9 uintptr
+
+	xWebkitReserved10 uintptr
+
+	xWebkitReserved11 uintptr
+
+	xWebkitReserved12 uintptr
+
+	xWebkitReserved13 uintptr
+
+	xWebkitReserved14 uintptr
+
+	xWebkitReserved15 uintptr
+}
+
+func (x *InputMethodContextClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverridePreeditStarted sets the "preedit_started" callback function.
+func (x *InputMethodContextClass) OverridePreeditStarted(cb func(*InputMethodContext)) {
+	if cb == nil {
+		x.xPreeditStarted = 0
+	} else {
+		x.xPreeditStarted = purego.NewCallback(func(ContextVarp uintptr) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp))
+		})
+	}
+}
+
+// GetPreeditStarted gets the "preedit_started" callback function.
+func (x *InputMethodContextClass) GetPreeditStarted() func(*InputMethodContext) {
+	if x.xPreeditStarted == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xPreeditStarted)
+	return func(ContextVar *InputMethodContext) {
+		rawCallback(ContextVar.GoPointer())
+	}
+}
+
+// OverridePreeditChanged sets the "preedit_changed" callback function.
+func (x *InputMethodContextClass) OverridePreeditChanged(cb func(*InputMethodContext)) {
+	if cb == nil {
+		x.xPreeditChanged = 0
+	} else {
+		x.xPreeditChanged = purego.NewCallback(func(ContextVarp uintptr) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp))
+		})
+	}
+}
+
+// GetPreeditChanged gets the "preedit_changed" callback function.
+func (x *InputMethodContextClass) GetPreeditChanged() func(*InputMethodContext) {
+	if x.xPreeditChanged == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xPreeditChanged)
+	return func(ContextVar *InputMethodContext) {
+		rawCallback(ContextVar.GoPointer())
+	}
+}
+
+// OverridePreeditFinished sets the "preedit_finished" callback function.
+func (x *InputMethodContextClass) OverridePreeditFinished(cb func(*InputMethodContext)) {
+	if cb == nil {
+		x.xPreeditFinished = 0
+	} else {
+		x.xPreeditFinished = purego.NewCallback(func(ContextVarp uintptr) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp))
+		})
+	}
+}
+
+// GetPreeditFinished gets the "preedit_finished" callback function.
+func (x *InputMethodContextClass) GetPreeditFinished() func(*InputMethodContext) {
+	if x.xPreeditFinished == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xPreeditFinished)
+	return func(ContextVar *InputMethodContext) {
+		rawCallback(ContextVar.GoPointer())
+	}
+}
+
+// OverrideCommitted sets the "committed" callback function.
+func (x *InputMethodContextClass) OverrideCommitted(cb func(*InputMethodContext, string)) {
+	if cb == nil {
+		x.xCommitted = 0
+	} else {
+		x.xCommitted = purego.NewCallback(func(ContextVarp uintptr, TextVarp string) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp), TextVarp)
+		})
+	}
+}
+
+// GetCommitted gets the "committed" callback function.
+func (x *InputMethodContextClass) GetCommitted() func(*InputMethodContext, string) {
+	if x.xCommitted == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr, TextVarp string)
+	purego.RegisterFunc(&rawCallback, x.xCommitted)
+	return func(ContextVar *InputMethodContext, TextVar string) {
+		rawCallback(ContextVar.GoPointer(), TextVar)
+	}
+}
+
+// OverrideDeleteSurrounding sets the "delete_surrounding" callback function.
+func (x *InputMethodContextClass) OverrideDeleteSurrounding(cb func(*InputMethodContext, int, uint)) {
+	if cb == nil {
+		x.xDeleteSurrounding = 0
+	} else {
+		x.xDeleteSurrounding = purego.NewCallback(func(ContextVarp uintptr, OffsetVarp int, NCharsVarp uint) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp), OffsetVarp, NCharsVarp)
+		})
+	}
+}
+
+// GetDeleteSurrounding gets the "delete_surrounding" callback function.
+func (x *InputMethodContextClass) GetDeleteSurrounding() func(*InputMethodContext, int, uint) {
+	if x.xDeleteSurrounding == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr, OffsetVarp int, NCharsVarp uint)
+	purego.RegisterFunc(&rawCallback, x.xDeleteSurrounding)
+	return func(ContextVar *InputMethodContext, OffsetVar int, NCharsVar uint) {
+		rawCallback(ContextVar.GoPointer(), OffsetVar, NCharsVar)
+	}
+}
+
+// OverrideSetEnablePreedit sets the "set_enable_preedit" callback function.
+// Called via webkit_input_method_context_set_enable_preedit() to
+//
+//	control the use of the preedit string.
+func (x *InputMethodContextClass) OverrideSetEnablePreedit(cb func(*InputMethodContext, bool)) {
+	if cb == nil {
+		x.xSetEnablePreedit = 0
+	} else {
+		x.xSetEnablePreedit = purego.NewCallback(func(ContextVarp uintptr, EnabledVarp bool) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp), EnabledVarp)
+		})
+	}
+}
+
+// GetSetEnablePreedit gets the "set_enable_preedit" callback function.
+// Called via webkit_input_method_context_set_enable_preedit() to
+//
+//	control the use of the preedit string.
+func (x *InputMethodContextClass) GetSetEnablePreedit() func(*InputMethodContext, bool) {
+	if x.xSetEnablePreedit == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr, EnabledVarp bool)
+	purego.RegisterFunc(&rawCallback, x.xSetEnablePreedit)
+	return func(ContextVar *InputMethodContext, EnabledVar bool) {
+		rawCallback(ContextVar.GoPointer(), EnabledVar)
+	}
+}
+
+// OverrideGetPreedit sets the "get_preedit" callback function.
+// Called via webkit_input_method_context_get_preedit() to
+//
+//	retrieve the text currently being preedited for display at the cursor
+//	position. Any input method which composes complex characters or any
+//	other compositions from multiple sequential key presses should override
+//	this method to provide feedback.
+func (x *InputMethodContextClass) OverrideGetPreedit(cb func(*InputMethodContext, *string, **glib.List, *uint)) {
+	if cb == nil {
+		x.xGetPreedit = 0
+	} else {
+		x.xGetPreedit = purego.NewCallback(func(ContextVarp uintptr, TextVarp *string, UnderlinesVarp **glib.List, CursorOffsetVarp *uint) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp), TextVarp, UnderlinesVarp, CursorOffsetVarp)
+		})
+	}
+}
+
+// GetGetPreedit gets the "get_preedit" callback function.
+// Called via webkit_input_method_context_get_preedit() to
+//
+//	retrieve the text currently being preedited for display at the cursor
+//	position. Any input method which composes complex characters or any
+//	other compositions from multiple sequential key presses should override
+//	this method to provide feedback.
+func (x *InputMethodContextClass) GetGetPreedit() func(*InputMethodContext, *string, **glib.List, *uint) {
+	if x.xGetPreedit == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr, TextVarp *string, UnderlinesVarp **glib.List, CursorOffsetVarp *uint)
+	purego.RegisterFunc(&rawCallback, x.xGetPreedit)
+	return func(ContextVar *InputMethodContext, TextVar *string, UnderlinesVar **glib.List, CursorOffsetVar *uint) {
+		rawCallback(ContextVar.GoPointer(), TextVar, UnderlinesVar, CursorOffsetVar)
+	}
+}
+
+// OverrideFilterKeyEvent sets the "filter_key_event" callback function.
+// Called via webkit_input_method_context_filter_key_event() on every
+//
+//	key press or release event. Every non-trivial input method needs to
+//	override this in order to implement the mapping from key events to text.
+//	A return value of %TRUE indicates to the caller that the event was
+//	consumed by the input method. In that case, the #WebKitInputMethodContext::committed
+//	signal should be emitted upon completion of a key sequence to pass the
+//	resulting text back to the editable element. Alternatively, %FALSE may be
+//	returned to indicate that the event wasnt handled by the input method.
+func (x *InputMethodContextClass) OverrideFilterKeyEvent(cb func(*InputMethodContext, *gdk.Event) bool) {
+	if cb == nil {
+		x.xFilterKeyEvent = 0
+	} else {
+		x.xFilterKeyEvent = purego.NewCallback(func(ContextVarp uintptr, KeyEventVarp uintptr) bool {
+			return cb(InputMethodContextNewFromInternalPtr(ContextVarp), gdk.EventNewFromInternalPtr(KeyEventVarp))
+		})
+	}
+}
+
+// GetFilterKeyEvent gets the "filter_key_event" callback function.
+// Called via webkit_input_method_context_filter_key_event() on every
+//
+//	key press or release event. Every non-trivial input method needs to
+//	override this in order to implement the mapping from key events to text.
+//	A return value of %TRUE indicates to the caller that the event was
+//	consumed by the input method. In that case, the #WebKitInputMethodContext::committed
+//	signal should be emitted upon completion of a key sequence to pass the
+//	resulting text back to the editable element. Alternatively, %FALSE may be
+//	returned to indicate that the event wasnt handled by the input method.
+func (x *InputMethodContextClass) GetFilterKeyEvent() func(*InputMethodContext, *gdk.Event) bool {
+	if x.xFilterKeyEvent == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr, KeyEventVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xFilterKeyEvent)
+	return func(ContextVar *InputMethodContext, KeyEventVar *gdk.Event) bool {
+		return rawCallback(ContextVar.GoPointer(), KeyEventVar.GoPointer())
+	}
+}
+
+// OverrideNotifyFocusIn sets the "notify_focus_in" callback function.
+// Called via webkit_input_method_context_notify_focus_in() when
+//
+//	an editable element of the #WebKitWebView has gained focus.
+func (x *InputMethodContextClass) OverrideNotifyFocusIn(cb func(*InputMethodContext)) {
+	if cb == nil {
+		x.xNotifyFocusIn = 0
+	} else {
+		x.xNotifyFocusIn = purego.NewCallback(func(ContextVarp uintptr) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp))
+		})
+	}
+}
+
+// GetNotifyFocusIn gets the "notify_focus_in" callback function.
+// Called via webkit_input_method_context_notify_focus_in() when
+//
+//	an editable element of the #WebKitWebView has gained focus.
+func (x *InputMethodContextClass) GetNotifyFocusIn() func(*InputMethodContext) {
+	if x.xNotifyFocusIn == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xNotifyFocusIn)
+	return func(ContextVar *InputMethodContext) {
+		rawCallback(ContextVar.GoPointer())
+	}
+}
+
+// OverrideNotifyFocusOut sets the "notify_focus_out" callback function.
+// Called via webkit_input_method_context_notify_focus_out() when
+//
+//	an editable element of the #WebKitWebView has lost focus.
+func (x *InputMethodContextClass) OverrideNotifyFocusOut(cb func(*InputMethodContext)) {
+	if cb == nil {
+		x.xNotifyFocusOut = 0
+	} else {
+		x.xNotifyFocusOut = purego.NewCallback(func(ContextVarp uintptr) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp))
+		})
+	}
+}
+
+// GetNotifyFocusOut gets the "notify_focus_out" callback function.
+// Called via webkit_input_method_context_notify_focus_out() when
+//
+//	an editable element of the #WebKitWebView has lost focus.
+func (x *InputMethodContextClass) GetNotifyFocusOut() func(*InputMethodContext) {
+	if x.xNotifyFocusOut == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xNotifyFocusOut)
+	return func(ContextVar *InputMethodContext) {
+		rawCallback(ContextVar.GoPointer())
+	}
+}
+
+// OverrideNotifyCursorArea sets the "notify_cursor_area" callback function.
+// Called via webkit_input_method_context_notify_cursor_area()
+//
+//	to inform the input method of the current cursor location relative to
+//	the client window.
+func (x *InputMethodContextClass) OverrideNotifyCursorArea(cb func(*InputMethodContext, int, int, int, int)) {
+	if cb == nil {
+		x.xNotifyCursorArea = 0
+	} else {
+		x.xNotifyCursorArea = purego.NewCallback(func(ContextVarp uintptr, XVarp int, YVarp int, WidthVarp int, HeightVarp int) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp), XVarp, YVarp, WidthVarp, HeightVarp)
+		})
+	}
+}
+
+// GetNotifyCursorArea gets the "notify_cursor_area" callback function.
+// Called via webkit_input_method_context_notify_cursor_area()
+//
+//	to inform the input method of the current cursor location relative to
+//	the client window.
+func (x *InputMethodContextClass) GetNotifyCursorArea() func(*InputMethodContext, int, int, int, int) {
+	if x.xNotifyCursorArea == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr, XVarp int, YVarp int, WidthVarp int, HeightVarp int)
+	purego.RegisterFunc(&rawCallback, x.xNotifyCursorArea)
+	return func(ContextVar *InputMethodContext, XVar int, YVar int, WidthVar int, HeightVar int) {
+		rawCallback(ContextVar.GoPointer(), XVar, YVar, WidthVar, HeightVar)
+	}
+}
+
+// OverrideNotifySurrounding sets the "notify_surrounding" callback function.
+// Called via webkit_input_method_context_notify_surrounding() to
+//
+//	update the context surrounding the cursor. The provided text should not include
+//	the preedit string.
+func (x *InputMethodContextClass) OverrideNotifySurrounding(cb func(*InputMethodContext, string, uint, uint, uint)) {
+	if cb == nil {
+		x.xNotifySurrounding = 0
+	} else {
+		x.xNotifySurrounding = purego.NewCallback(func(ContextVarp uintptr, TextVarp string, LengthVarp uint, CursorIndexVarp uint, SelectionIndexVarp uint) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp), TextVarp, LengthVarp, CursorIndexVarp, SelectionIndexVarp)
+		})
+	}
+}
+
+// GetNotifySurrounding gets the "notify_surrounding" callback function.
+// Called via webkit_input_method_context_notify_surrounding() to
+//
+//	update the context surrounding the cursor. The provided text should not include
+//	the preedit string.
+func (x *InputMethodContextClass) GetNotifySurrounding() func(*InputMethodContext, string, uint, uint, uint) {
+	if x.xNotifySurrounding == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr, TextVarp string, LengthVarp uint, CursorIndexVarp uint, SelectionIndexVarp uint)
+	purego.RegisterFunc(&rawCallback, x.xNotifySurrounding)
+	return func(ContextVar *InputMethodContext, TextVar string, LengthVar uint, CursorIndexVar uint, SelectionIndexVar uint) {
+		rawCallback(ContextVar.GoPointer(), TextVar, LengthVar, CursorIndexVar, SelectionIndexVar)
+	}
+}
+
+// OverrideReset sets the "reset" callback function.
+// Called via webkit_input_method_context_reset() to signal a change that
+//
+//	requires a reset. An input method that implements preediting
+//	should override this method to clear the preedit state on reset.
+func (x *InputMethodContextClass) OverrideReset(cb func(*InputMethodContext)) {
+	if cb == nil {
+		x.xReset = 0
+	} else {
+		x.xReset = purego.NewCallback(func(ContextVarp uintptr) {
+			cb(InputMethodContextNewFromInternalPtr(ContextVarp))
+		})
+	}
+}
+
+// GetReset gets the "reset" callback function.
+// Called via webkit_input_method_context_reset() to signal a change that
+//
+//	requires a reset. An input method that implements preediting
+//	should override this method to clear the preedit state on reset.
+func (x *InputMethodContextClass) GetReset() func(*InputMethodContext) {
+	if x.xReset == 0 {
+		return nil
+	}
+	var rawCallback func(ContextVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xReset)
+	return func(ContextVar *InputMethodContext) {
+		rawCallback(ContextVar.GoPointer())
+	}
+}
+
+// OverrideWebkitReserved0 sets the "_webkit_reserved0" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved0(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved0 = 0
+	} else {
+		x.xWebkitReserved0 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved0 gets the "_webkit_reserved0" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved0() func() {
+	if x.xWebkitReserved0 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved0)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved1 sets the "_webkit_reserved1" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved1(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved1 = 0
+	} else {
+		x.xWebkitReserved1 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved1 gets the "_webkit_reserved1" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved1() func() {
+	if x.xWebkitReserved1 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved1)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved2 sets the "_webkit_reserved2" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved2(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved2 = 0
+	} else {
+		x.xWebkitReserved2 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved2 gets the "_webkit_reserved2" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved2() func() {
+	if x.xWebkitReserved2 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved2)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved3 sets the "_webkit_reserved3" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved3(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved3 = 0
+	} else {
+		x.xWebkitReserved3 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved3 gets the "_webkit_reserved3" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved3() func() {
+	if x.xWebkitReserved3 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved3)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved4 sets the "_webkit_reserved4" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved4(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved4 = 0
+	} else {
+		x.xWebkitReserved4 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved4 gets the "_webkit_reserved4" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved4() func() {
+	if x.xWebkitReserved4 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved4)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved5 sets the "_webkit_reserved5" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved5(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved5 = 0
+	} else {
+		x.xWebkitReserved5 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved5 gets the "_webkit_reserved5" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved5() func() {
+	if x.xWebkitReserved5 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved5)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved6 sets the "_webkit_reserved6" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved6(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved6 = 0
+	} else {
+		x.xWebkitReserved6 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved6 gets the "_webkit_reserved6" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved6() func() {
+	if x.xWebkitReserved6 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved6)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved7 sets the "_webkit_reserved7" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved7(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved7 = 0
+	} else {
+		x.xWebkitReserved7 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved7 gets the "_webkit_reserved7" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved7() func() {
+	if x.xWebkitReserved7 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved7)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved8 sets the "_webkit_reserved8" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved8(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved8 = 0
+	} else {
+		x.xWebkitReserved8 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved8 gets the "_webkit_reserved8" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved8() func() {
+	if x.xWebkitReserved8 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved8)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved9 sets the "_webkit_reserved9" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved9(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved9 = 0
+	} else {
+		x.xWebkitReserved9 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved9 gets the "_webkit_reserved9" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved9() func() {
+	if x.xWebkitReserved9 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved9)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved10 sets the "_webkit_reserved10" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved10(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved10 = 0
+	} else {
+		x.xWebkitReserved10 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved10 gets the "_webkit_reserved10" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved10() func() {
+	if x.xWebkitReserved10 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved10)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved11 sets the "_webkit_reserved11" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved11(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved11 = 0
+	} else {
+		x.xWebkitReserved11 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved11 gets the "_webkit_reserved11" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved11() func() {
+	if x.xWebkitReserved11 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved11)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved12 sets the "_webkit_reserved12" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved12(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved12 = 0
+	} else {
+		x.xWebkitReserved12 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved12 gets the "_webkit_reserved12" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved12() func() {
+	if x.xWebkitReserved12 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved12)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved13 sets the "_webkit_reserved13" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved13(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved13 = 0
+	} else {
+		x.xWebkitReserved13 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved13 gets the "_webkit_reserved13" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved13() func() {
+	if x.xWebkitReserved13 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved13)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved14 sets the "_webkit_reserved14" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved14(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved14 = 0
+	} else {
+		x.xWebkitReserved14 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved14 gets the "_webkit_reserved14" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved14() func() {
+	if x.xWebkitReserved14 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved14)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved15 sets the "_webkit_reserved15" callback function.
+func (x *InputMethodContextClass) OverrideWebkitReserved15(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved15 = 0
+	} else {
+		x.xWebkitReserved15 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved15 gets the "_webkit_reserved15" callback function.
+func (x *InputMethodContextClass) GetWebkitReserved15() func() {
+	if x.xWebkitReserved15 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved15)
+	return func() {
+		rawCallback()
+	}
+}
+
+type InputMethodContextPrivate struct {
+	_ structs.HostLayout
+}
+
+func (x *InputMethodContextPrivate) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Range of text in an preedit string to be shown underlined.
+type InputMethodUnderline struct {
+	_ structs.HostLayout
+}
+
+var xInputMethodUnderlineGLibType func() types.GType
+
+func InputMethodUnderlineGLibType() types.GType {
+	return xInputMethodUnderlineGLibType()
+}
+
+func (x *InputMethodUnderline) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewInputMethodUnderline func(uint, uint) *InputMethodUnderline
+
+// Create a new #WebKitInputMethodUnderline for the given range in preedit string
+func NewInputMethodUnderline(StartOffsetVar uint, EndOffsetVar uint) *InputMethodUnderline {
+
+	cret := xNewInputMethodUnderline(StartOffsetVar, EndOffsetVar)
+	return cret
+}
+
+var xInputMethodUnderlineCopy func(uintptr) *InputMethodUnderline
+
+// Make a copy of the #WebKitInputMethodUnderline.
+func (x *InputMethodUnderline) Copy() *InputMethodUnderline {
+
+	cret := xInputMethodUnderlineCopy(x.GoPointer())
+	return cret
+}
+
+var xInputMethodUnderlineFree func(uintptr)
+
+// Free the #WebKitInputMethodUnderline.
+func (x *InputMethodUnderline) Free() {
+
+	xInputMethodUnderlineFree(x.GoPointer())
+
+}
+
+var xInputMethodUnderlineSetColor func(uintptr, *gdk.RGBA)
+
+// Set the color of the underline.
+//
+// If @rgba is %NULL the foreground text color will be used
+// for the underline too.
+func (x *InputMethodUnderline) SetColor(RgbaVar *gdk.RGBA) {
+
+	xInputMethodUnderlineSetColor(x.GoPointer(), RgbaVar)
+
+}
+
+// Enum values used to describe hints that might be taken into account by input methods.
+type InputHints int
+
+var xInputHintsGLibType func() types.GType
+
+func InputHintsGLibType() types.GType {
+	return xInputHintsGLibType()
+}
+
+const (
+
+	// No special behavior suggested
+	InputHintNoneValue InputHints = 0
+	// Suggest spell checking
+	InputHintSpellcheckValue InputHints = 1
+	// Suggest to not autocapitlize
+	InputHintLowercaseValue InputHints = 2
+	// Suggest to capitalize all text
+	InputHintUppercaseCharsValue InputHints = 4
+	// Suggest to capitalize the first character of each word
+	InputHintUppercaseWordsValue InputHints = 8
+	// Suggest to capitalize the first word of each sentence
+	InputHintUppercaseSentencesValue InputHints = 16
+	// Suggest to not show an onscreen keyboard
+	InputHintInhibitOskValue InputHints = 32
+)
+
+// Enum values used to describe the primary purpose of the active editable element.
+type InputPurpose int
+
+var xInputPurposeGLibType func() types.GType
+
+func InputPurposeGLibType() types.GType {
+	return xInputPurposeGLibType()
+}
+
+const (
+
+	// Editable element expects any characters
+	InputPurposeFreeFormValue InputPurpose = 0
+	// Editable element expects digits
+	InputPurposeDigitsValue InputPurpose = 1
+	// Editable element expects a number
+	InputPurposeNumberValue InputPurpose = 2
+	// Editable element expects a telephone
+	InputPurposePhoneValue InputPurpose = 3
+	// Editable element expects a URL
+	InputPurposeUrlValue InputPurpose = 4
+	// Editable element expects an email
+	InputPurposeEmailValue InputPurpose = 5
+	// Editable element expects a password
+	InputPurposePasswordValue InputPurpose = 6
+)
+
+// Base class for input method contexts.
+//
+// WebKitInputMethodContext defines the interface to implement WebKit input methods.
+// The input methods are used by WebKit, when editable content is focused, to map from
+// key events to Unicode character strings.
+//
+// An input method may consume multiple key events in sequence and finally
+// output the composed result. This is called preediting, and an input method
+// may provide feedback about this process by displaying the intermediate
+// composition states as preedit text.
+type InputMethodContext struct {
+	gobject.Object
+}
+
+var xInputMethodContextGLibType func() types.GType
+
+func InputMethodContextGLibType() types.GType {
+	return xInputMethodContextGLibType()
+}
+
+func InputMethodContextNewFromInternalPtr(ptr uintptr) *InputMethodContext {
+	cls := &InputMethodContext{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xInputMethodContextFilterKeyEvent func(uintptr, uintptr) bool
+
+// Allow @key_event to be handled by the input method.
+//
+// If %TRUE is returned, then no further processing should be
+// done for the key event.
+func (x *InputMethodContext) FilterKeyEvent(KeyEventVar *gdk.Event) bool {
+
+	cret := xInputMethodContextFilterKeyEvent(x.GoPointer(), KeyEventVar.GoPointer())
+	return cret
+}
+
+var xInputMethodContextGetInputHints func(uintptr) InputHints
+
+// Get the value of the #WebKitInputMethodContext:input-hints property.
+func (x *InputMethodContext) GetInputHints() InputHints {
+
+	cret := xInputMethodContextGetInputHints(x.GoPointer())
+	return cret
+}
+
+var xInputMethodContextGetInputPurpose func(uintptr) InputPurpose
+
+// Get the value of the #WebKitInputMethodContext:input-purpose property.
+func (x *InputMethodContext) GetInputPurpose() InputPurpose {
+
+	cret := xInputMethodContextGetInputPurpose(x.GoPointer())
+	return cret
+}
+
+var xInputMethodContextGetPreedit func(uintptr, *string, **glib.List, *uint)
+
+// Get the pre-edit string and a list of WebKitInputMethodUnderline.
+//
+// Get the current pre-edit string for the @context, and a list of WebKitInputMethodUnderline to apply to the string.
+// The string will be displayed inserted at @cursor_offset.
+func (x *InputMethodContext) GetPreedit(TextVar *string, UnderlinesVar **glib.List, CursorOffsetVar *uint) {
+
+	xInputMethodContextGetPreedit(x.GoPointer(), TextVar, UnderlinesVar, CursorOffsetVar)
+
+}
+
+var xInputMethodContextNotifyCursorArea func(uintptr, int, int, int, int)
+
+// Notify @context that cursor area changed in input associated.
+func (x *InputMethodContext) NotifyCursorArea(XVar int, YVar int, WidthVar int, HeightVar int) {
+
+	xInputMethodContextNotifyCursorArea(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
+
+}
+
+var xInputMethodContextNotifyFocusIn func(uintptr)
+
+// Notify @context that input associated has gained focus.
+func (x *InputMethodContext) NotifyFocusIn() {
+
+	xInputMethodContextNotifyFocusIn(x.GoPointer())
+
+}
+
+var xInputMethodContextNotifyFocusOut func(uintptr)
+
+// Notify @context that input associated has lost focus.
+func (x *InputMethodContext) NotifyFocusOut() {
+
+	xInputMethodContextNotifyFocusOut(x.GoPointer())
+
+}
+
+var xInputMethodContextNotifySurrounding func(uintptr, string, int, uint, uint)
+
+// Notify @context that the context surrounding the cursor has changed.
+//
+// If there's no selection @selection_index is the same as @cursor_index.
+func (x *InputMethodContext) NotifySurrounding(TextVar string, LengthVar int, CursorIndexVar uint, SelectionIndexVar uint) {
+
+	xInputMethodContextNotifySurrounding(x.GoPointer(), TextVar, LengthVar, CursorIndexVar, SelectionIndexVar)
+
+}
+
+var xInputMethodContextReset func(uintptr)
+
+// Reset the @context.
+//
+// This will typically cause the input to clear the preedit state.
+func (x *InputMethodContext) Reset() {
+
+	xInputMethodContextReset(x.GoPointer())
+
+}
+
+var xInputMethodContextSetEnablePreedit func(uintptr, bool)
+
+// Set whether @context should enable preedit to display feedback.
+func (x *InputMethodContext) SetEnablePreedit(EnabledVar bool) {
+
+	xInputMethodContextSetEnablePreedit(x.GoPointer(), EnabledVar)
+
+}
+
+var xInputMethodContextSetInputHints func(uintptr, InputHints)
+
+// Set the value of the #WebKitInputMethodContext:input-hints property.
+func (x *InputMethodContext) SetInputHints(HintsVar InputHints) {
+
+	xInputMethodContextSetInputHints(x.GoPointer(), HintsVar)
+
+}
+
+var xInputMethodContextSetInputPurpose func(uintptr, InputPurpose)
+
+// Set the value of the #WebKitInputMethodContext:input-purpose property.
+func (x *InputMethodContext) SetInputPurpose(PurposeVar InputPurpose) {
+
+	xInputMethodContextSetInputPurpose(x.GoPointer(), PurposeVar)
+
+}
+
+func (c *InputMethodContext) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *InputMethodContext) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Emitted when a complete input sequence has been entered by the user.
+// This can be a single character immediately after a key press or the
+// final result of preediting.
+func (x *InputMethodContext) ConnectCommitted(cb *func(InputMethodContext, string)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "committed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, TextVarp string) {
+		fa := InputMethodContext{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, TextVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "committed", cbRefPtr)
+}
+
+// Emitted when the input method wants to delete the context surrounding the cursor.
+// If @offset is a negative value, it means a position before the cursor.
+func (x *InputMethodContext) ConnectDeleteSurrounding(cb *func(InputMethodContext, int, uint)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "delete-surrounding", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, OffsetVarp int, NCharsVarp uint) {
+		fa := InputMethodContext{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, OffsetVarp, NCharsVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "delete-surrounding", cbRefPtr)
+}
+
+// Emitted whenever the preedit sequence currently being entered has changed.
+// It is also emitted at the end of a preedit sequence, in which case
+// webkit_input_method_context_get_preedit() returns the empty string.
+func (x *InputMethodContext) ConnectPreeditChanged(cb *func(InputMethodContext)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "preedit-changed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := InputMethodContext{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "preedit-changed", cbRefPtr)
+}
+
+// Emitted when a preediting sequence has been completed or canceled.
+func (x *InputMethodContext) ConnectPreeditFinished(cb *func(InputMethodContext)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "preedit-finished", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := InputMethodContext{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "preedit-finished", cbRefPtr)
+}
+
+// Emitted when a new preediting sequence starts.
+func (x *InputMethodContext) ConnectPreeditStarted(cb *func(InputMethodContext)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "preedit-started", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := InputMethodContext{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "preedit-started", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xInputHintsGLibType, libs, "webkit_input_hints_get_type")
+
+	core.PuregoSafeRegister(&xInputPurposeGLibType, libs, "webkit_input_purpose_get_type")
+
+	core.PuregoSafeRegister(&xInputMethodUnderlineGLibType, libs, "webkit_input_method_underline_get_type")
+
+	core.PuregoSafeRegister(&xNewInputMethodUnderline, libs, "webkit_input_method_underline_new")
+
+	core.PuregoSafeRegister(&xInputMethodUnderlineCopy, libs, "webkit_input_method_underline_copy")
+	core.PuregoSafeRegister(&xInputMethodUnderlineFree, libs, "webkit_input_method_underline_free")
+	core.PuregoSafeRegister(&xInputMethodUnderlineSetColor, libs, "webkit_input_method_underline_set_color")
+
+	core.PuregoSafeRegister(&xInputMethodContextGLibType, libs, "webkit_input_method_context_get_type")
+
+	core.PuregoSafeRegister(&xInputMethodContextFilterKeyEvent, libs, "webkit_input_method_context_filter_key_event")
+	core.PuregoSafeRegister(&xInputMethodContextGetInputHints, libs, "webkit_input_method_context_get_input_hints")
+	core.PuregoSafeRegister(&xInputMethodContextGetInputPurpose, libs, "webkit_input_method_context_get_input_purpose")
+	core.PuregoSafeRegister(&xInputMethodContextGetPreedit, libs, "webkit_input_method_context_get_preedit")
+	core.PuregoSafeRegister(&xInputMethodContextNotifyCursorArea, libs, "webkit_input_method_context_notify_cursor_area")
+	core.PuregoSafeRegister(&xInputMethodContextNotifyFocusIn, libs, "webkit_input_method_context_notify_focus_in")
+	core.PuregoSafeRegister(&xInputMethodContextNotifyFocusOut, libs, "webkit_input_method_context_notify_focus_out")
+	core.PuregoSafeRegister(&xInputMethodContextNotifySurrounding, libs, "webkit_input_method_context_notify_surrounding")
+	core.PuregoSafeRegister(&xInputMethodContextReset, libs, "webkit_input_method_context_reset")
+	core.PuregoSafeRegister(&xInputMethodContextSetEnablePreedit, libs, "webkit_input_method_context_set_enable_preedit")
+	core.PuregoSafeRegister(&xInputMethodContextSetInputHints, libs, "webkit_input_method_context_set_input_hints")
+	core.PuregoSafeRegister(&xInputMethodContextSetInputPurpose, libs, "webkit_input_method_context_set_input_purpose")
+
+}
diff --git a/v4/webkit/WebKitMediaKeySystemPermissionRequest.go b/v4/webkit/WebKitMediaKeySystemPermissionRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..3840cfed0ce3284859a712966010da54fcf147af
--- /dev/null
+++ b/v4/webkit/WebKitMediaKeySystemPermissionRequest.go
@@ -0,0 +1,101 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type MediaKeySystemPermissionRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *MediaKeySystemPermissionRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xMediaKeySystemPermissionGetName func(uintptr) string
+
+// Get the key system for which access permission is being requested.
+func MediaKeySystemPermissionGetName(RequestVar *MediaKeySystemPermissionRequest) string {
+
+	cret := xMediaKeySystemPermissionGetName(RequestVar.GoPointer())
+	return cret
+}
+
+// A permission request for using an EME Content Decryption Module.
+//
+// WebKitMediaKeySystemPermissionRequest represents a request for permission to decide whether
+// WebKit should use the given CDM to access protected media when requested through the
+// MediaKeySystem API.
+//
+// When a WebKitMediaKeySystemPermissionRequest is not handled by the user,
+// it is denied by default.
+//
+// When handling this permission request the application may perform additional installation of the
+// requested CDM, unless it is already present on the host system.
+type MediaKeySystemPermissionRequest struct {
+	gobject.Object
+}
+
+var xMediaKeySystemPermissionRequestGLibType func() types.GType
+
+func MediaKeySystemPermissionRequestGLibType() types.GType {
+	return xMediaKeySystemPermissionRequestGLibType()
+}
+
+func MediaKeySystemPermissionRequestNewFromInternalPtr(ptr uintptr) *MediaKeySystemPermissionRequest {
+	cls := &MediaKeySystemPermissionRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *MediaKeySystemPermissionRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *MediaKeySystemPermissionRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Allow the action which triggered this request.
+func (x *MediaKeySystemPermissionRequest) Allow() {
+
+	XWebkitPermissionRequestAllow(x.GoPointer())
+
+}
+
+// Deny the action which triggered this request.
+func (x *MediaKeySystemPermissionRequest) Deny() {
+
+	XWebkitPermissionRequestDeny(x.GoPointer())
+
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xMediaKeySystemPermissionGetName, libs, "webkit_media_key_system_permission_get_name")
+
+	core.PuregoSafeRegister(&xMediaKeySystemPermissionRequestGLibType, libs, "webkit_media_key_system_permission_request_get_type")
+
+}
diff --git a/v4/webkit/WebKitMemoryPressureSettings.go b/v4/webkit/WebKitMemoryPressureSettings.go
new file mode 100644
index 0000000000000000000000000000000000000000..48dcf95d0faaab7d20aca5f57804c652636ca2fd
--- /dev/null
+++ b/v4/webkit/WebKitMemoryPressureSettings.go
@@ -0,0 +1,217 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// A boxed type representing the settings for the memory pressure handler
+//
+// #WebKitMemoryPressureSettings is a boxed type that can be used to provide some custom settings
+// to control how the memory pressure situations are handled by the different processes.
+//
+// The memory pressure system implemented inside the different process will try to keep the memory usage
+// under the defined memory limit. In order to do that, it will check the used memory with a user defined
+// frequency and decide whether it should try to release memory. The thresholds passed will define how urgent
+// is to release that memory.
+//
+// Take into account that badly defined parameters can greatly reduce the performance of the engine. For
+// example, setting memory limit too low with a fast poll interval can cause the process to constantly
+// be trying to release memory.
+//
+// A #WebKitMemoryPressureSettings can be passed to a #WebKitWebContext constructor, and the settings will
+// be applied to all the web processes created by that context.
+//
+// A #WebKitMemoryPressureSettings can be passed to webkit_website_data_manager_set_memory_pressure_settings(),
+// and the settings will be applied to all the network processes created after that call by any instance of
+// #WebKitWebsiteDataManager.
+type MemoryPressureSettings struct {
+	_ structs.HostLayout
+}
+
+var xMemoryPressureSettingsGLibType func() types.GType
+
+func MemoryPressureSettingsGLibType() types.GType {
+	return xMemoryPressureSettingsGLibType()
+}
+
+func (x *MemoryPressureSettings) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewMemoryPressureSettings func() *MemoryPressureSettings
+
+// Create a new #WebKitMemoryPressureSettings with the default values.
+func NewMemoryPressureSettings() *MemoryPressureSettings {
+
+	cret := xNewMemoryPressureSettings()
+	return cret
+}
+
+var xMemoryPressureSettingsCopy func(uintptr) *MemoryPressureSettings
+
+// Make a copy of @settings.
+func (x *MemoryPressureSettings) Copy() *MemoryPressureSettings {
+
+	cret := xMemoryPressureSettingsCopy(x.GoPointer())
+	return cret
+}
+
+var xMemoryPressureSettingsFree func(uintptr)
+
+// Free the #WebKitMemoryPressureSettings.
+func (x *MemoryPressureSettings) Free() {
+
+	xMemoryPressureSettingsFree(x.GoPointer())
+
+}
+
+var xMemoryPressureSettingsGetConservativeThreshold func(uintptr) float64
+
+// Gets the conservative memory usage threshold.
+func (x *MemoryPressureSettings) GetConservativeThreshold() float64 {
+
+	cret := xMemoryPressureSettingsGetConservativeThreshold(x.GoPointer())
+	return cret
+}
+
+var xMemoryPressureSettingsGetKillThreshold func(uintptr) float64
+
+// Gets the kill memory usage threshold.
+func (x *MemoryPressureSettings) GetKillThreshold() float64 {
+
+	cret := xMemoryPressureSettingsGetKillThreshold(x.GoPointer())
+	return cret
+}
+
+var xMemoryPressureSettingsGetMemoryLimit func(uintptr) uint
+
+// Gets the memory usage limit.
+func (x *MemoryPressureSettings) GetMemoryLimit() uint {
+
+	cret := xMemoryPressureSettingsGetMemoryLimit(x.GoPointer())
+	return cret
+}
+
+var xMemoryPressureSettingsGetPollInterval func(uintptr) float64
+
+// Gets the interval at which memory usage is checked.
+func (x *MemoryPressureSettings) GetPollInterval() float64 {
+
+	cret := xMemoryPressureSettingsGetPollInterval(x.GoPointer())
+	return cret
+}
+
+var xMemoryPressureSettingsGetStrictThreshold func(uintptr) float64
+
+// Gets the strict memory usage threshold.
+func (x *MemoryPressureSettings) GetStrictThreshold() float64 {
+
+	cret := xMemoryPressureSettingsGetStrictThreshold(x.GoPointer())
+	return cret
+}
+
+var xMemoryPressureSettingsSetConservativeThreshold func(uintptr, float64)
+
+// Sets the memory limit for the conservative policy to start working.
+//
+// Sets @value as the fraction of the defined memory limit where the conservative
+// policy starts working. This policy will try to reduce the memory footprint by
+// releasing non critical memory.
+//
+// The threshold must be bigger than 0 and smaller than 1, and it must be smaller
+// than the strict threshold defined in @settings. The default value is 0.33.
+func (x *MemoryPressureSettings) SetConservativeThreshold(ValueVar float64) {
+
+	xMemoryPressureSettingsSetConservativeThreshold(x.GoPointer(), ValueVar)
+
+}
+
+var xMemoryPressureSettingsSetKillThreshold func(uintptr, float64)
+
+// Sets @value as the fraction of the defined memory limit where the process will be
+// killed.
+//
+// The threshold must be a value bigger or equal to 0. A value of 0 means that the process
+// is never killed. If the threshold is not 0, then it must be bigger than the strict threshold
+// defined in @settings. The threshold can also have values bigger than 1. The default value is 0.
+func (x *MemoryPressureSettings) SetKillThreshold(ValueVar float64) {
+
+	xMemoryPressureSettingsSetKillThreshold(x.GoPointer(), ValueVar)
+
+}
+
+var xMemoryPressureSettingsSetMemoryLimit func(uintptr, uint)
+
+// Sets @memory_limit the memory limit value to @settings.
+//
+// The default value is the system's RAM size with a maximum of 3GB.
+func (x *MemoryPressureSettings) SetMemoryLimit(MemoryLimitVar uint) {
+
+	xMemoryPressureSettingsSetMemoryLimit(x.GoPointer(), MemoryLimitVar)
+
+}
+
+var xMemoryPressureSettingsSetPollInterval func(uintptr, float64)
+
+// Sets @value as the poll interval used by @settings.
+//
+// The poll interval value must be bigger than 0. The default value is 30 seconds.
+func (x *MemoryPressureSettings) SetPollInterval(ValueVar float64) {
+
+	xMemoryPressureSettingsSetPollInterval(x.GoPointer(), ValueVar)
+
+}
+
+var xMemoryPressureSettingsSetStrictThreshold func(uintptr, float64)
+
+// Sets the memory limit for the strict policy to start working.
+//
+// Sets @value as the fraction of the defined memory limit where the strict
+// policy starts working. This policy will try to reduce the memory footprint by
+// releasing critical memory.
+//
+// The threshold must be bigger than 0 and smaller than 1. Also, it must be bigger
+// than the conservative threshold defined in @settings, and smaller than the kill
+// threshold if the latter is not 0. The default value is 0.5.
+func (x *MemoryPressureSettings) SetStrictThreshold(ValueVar float64) {
+
+	xMemoryPressureSettingsSetStrictThreshold(x.GoPointer(), ValueVar)
+
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xMemoryPressureSettingsGLibType, libs, "webkit_memory_pressure_settings_get_type")
+
+	core.PuregoSafeRegister(&xNewMemoryPressureSettings, libs, "webkit_memory_pressure_settings_new")
+
+	core.PuregoSafeRegister(&xMemoryPressureSettingsCopy, libs, "webkit_memory_pressure_settings_copy")
+	core.PuregoSafeRegister(&xMemoryPressureSettingsFree, libs, "webkit_memory_pressure_settings_free")
+	core.PuregoSafeRegister(&xMemoryPressureSettingsGetConservativeThreshold, libs, "webkit_memory_pressure_settings_get_conservative_threshold")
+	core.PuregoSafeRegister(&xMemoryPressureSettingsGetKillThreshold, libs, "webkit_memory_pressure_settings_get_kill_threshold")
+	core.PuregoSafeRegister(&xMemoryPressureSettingsGetMemoryLimit, libs, "webkit_memory_pressure_settings_get_memory_limit")
+	core.PuregoSafeRegister(&xMemoryPressureSettingsGetPollInterval, libs, "webkit_memory_pressure_settings_get_poll_interval")
+	core.PuregoSafeRegister(&xMemoryPressureSettingsGetStrictThreshold, libs, "webkit_memory_pressure_settings_get_strict_threshold")
+	core.PuregoSafeRegister(&xMemoryPressureSettingsSetConservativeThreshold, libs, "webkit_memory_pressure_settings_set_conservative_threshold")
+	core.PuregoSafeRegister(&xMemoryPressureSettingsSetKillThreshold, libs, "webkit_memory_pressure_settings_set_kill_threshold")
+	core.PuregoSafeRegister(&xMemoryPressureSettingsSetMemoryLimit, libs, "webkit_memory_pressure_settings_set_memory_limit")
+	core.PuregoSafeRegister(&xMemoryPressureSettingsSetPollInterval, libs, "webkit_memory_pressure_settings_set_poll_interval")
+	core.PuregoSafeRegister(&xMemoryPressureSettingsSetStrictThreshold, libs, "webkit_memory_pressure_settings_set_strict_threshold")
+
+}
diff --git a/v4/webkit/WebKitNavigationAction.go b/v4/webkit/WebKitNavigationAction.go
new file mode 100644
index 0000000000000000000000000000000000000000..a6d71318d72a01deada4f76267f20dd3895befc7
--- /dev/null
+++ b/v4/webkit/WebKitNavigationAction.go
@@ -0,0 +1,183 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Provides details about interaction resulting in a resource load.
+type NavigationAction struct {
+	_ structs.HostLayout
+}
+
+var xNavigationActionGLibType func() types.GType
+
+func NavigationActionGLibType() types.GType {
+	return xNavigationActionGLibType()
+}
+
+func (x *NavigationAction) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNavigationActionCopy func(uintptr) *NavigationAction
+
+// Make a copy of @navigation.
+func (x *NavigationAction) Copy() *NavigationAction {
+
+	cret := xNavigationActionCopy(x.GoPointer())
+	return cret
+}
+
+var xNavigationActionFree func(uintptr)
+
+// Free the #WebKitNavigationAction
+func (x *NavigationAction) Free() {
+
+	xNavigationActionFree(x.GoPointer())
+
+}
+
+var xNavigationActionGetFrameName func(uintptr) string
+
+// Gets the @navigation target frame name. For example if navigation was triggered by clicking a
+// link with a target attribute equal to "_blank", this will return the value of that attribute.
+// In all other cases this function will return %NULL.
+func (x *NavigationAction) GetFrameName() string {
+
+	cret := xNavigationActionGetFrameName(x.GoPointer())
+	return cret
+}
+
+var xNavigationActionGetModifiers func(uintptr) uint
+
+// Return the modifier keys.
+//
+// Return a bitmask of #GdkModifierType values describing the modifier keys that were in effect
+// when the navigation was requested
+func (x *NavigationAction) GetModifiers() uint {
+
+	cret := xNavigationActionGetModifiers(x.GoPointer())
+	return cret
+}
+
+var xNavigationActionGetMouseButton func(uintptr) uint
+
+// Return the number of the mouse button that triggered the navigation.
+//
+// Return the number of the mouse button that triggered the navigation, or 0 if
+// the navigation was not started by a mouse event.
+func (x *NavigationAction) GetMouseButton() uint {
+
+	cret := xNavigationActionGetMouseButton(x.GoPointer())
+	return cret
+}
+
+var xNavigationActionGetNavigationType func(uintptr) NavigationType
+
+// Return the type of action that triggered the navigation.
+func (x *NavigationAction) GetNavigationType() NavigationType {
+
+	cret := xNavigationActionGetNavigationType(x.GoPointer())
+	return cret
+}
+
+var xNavigationActionGetRequest func(uintptr) uintptr
+
+// Return the #WebKitURIRequest associated with the navigation action.
+//
+// Modifications to the returned object are &lt;emphasis&gt;not&lt;/emphasis&gt; taken
+// into account when the request is sent over the network, and is intended
+// only to aid in evaluating whether a navigation action should be taken or
+// not. To modify requests before they are sent over the network the
+// #WebKitPage::send-request signal can be used instead.
+func (x *NavigationAction) GetRequest() *URIRequest {
+	var cls *URIRequest
+
+	cret := xNavigationActionGetRequest(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &URIRequest{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNavigationActionIsRedirect func(uintptr) bool
+
+// Returns whether the @navigation was redirected.
+func (x *NavigationAction) IsRedirect() bool {
+
+	cret := xNavigationActionIsRedirect(x.GoPointer())
+	return cret
+}
+
+var xNavigationActionIsUserGesture func(uintptr) bool
+
+// Return whether the navigation was triggered by a user gesture like a mouse click.
+func (x *NavigationAction) IsUserGesture() bool {
+
+	cret := xNavigationActionIsUserGesture(x.GoPointer())
+	return cret
+}
+
+// Enum values used to denote the various navigation types.
+type NavigationType int
+
+var xNavigationTypeGLibType func() types.GType
+
+func NavigationTypeGLibType() types.GType {
+	return xNavigationTypeGLibType()
+}
+
+const (
+
+	// The navigation was triggered by clicking a link.
+	NavigationTypeLinkClickedValue NavigationType = 0
+	// The navigation was triggered by submitting a form.
+	NavigationTypeFormSubmittedValue NavigationType = 1
+	// The navigation was triggered by navigating forward or backward.
+	NavigationTypeBackForwardValue NavigationType = 2
+	// The navigation was triggered by reloading.
+	NavigationTypeReloadValue NavigationType = 3
+	// The navigation was triggered by resubmitting a form.
+	NavigationTypeFormResubmittedValue NavigationType = 4
+	// The navigation was triggered by some other action.
+	NavigationTypeOtherValue NavigationType = 5
+)
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xNavigationTypeGLibType, libs, "webkit_navigation_type_get_type")
+
+	core.PuregoSafeRegister(&xNavigationActionGLibType, libs, "webkit_navigation_action_get_type")
+
+	core.PuregoSafeRegister(&xNavigationActionCopy, libs, "webkit_navigation_action_copy")
+	core.PuregoSafeRegister(&xNavigationActionFree, libs, "webkit_navigation_action_free")
+	core.PuregoSafeRegister(&xNavigationActionGetFrameName, libs, "webkit_navigation_action_get_frame_name")
+	core.PuregoSafeRegister(&xNavigationActionGetModifiers, libs, "webkit_navigation_action_get_modifiers")
+	core.PuregoSafeRegister(&xNavigationActionGetMouseButton, libs, "webkit_navigation_action_get_mouse_button")
+	core.PuregoSafeRegister(&xNavigationActionGetNavigationType, libs, "webkit_navigation_action_get_navigation_type")
+	core.PuregoSafeRegister(&xNavigationActionGetRequest, libs, "webkit_navigation_action_get_request")
+	core.PuregoSafeRegister(&xNavigationActionIsRedirect, libs, "webkit_navigation_action_is_redirect")
+	core.PuregoSafeRegister(&xNavigationActionIsUserGesture, libs, "webkit_navigation_action_is_user_gesture")
+
+}
diff --git a/v4/webkit/WebKitNavigationPolicyDecision.go b/v4/webkit/WebKitNavigationPolicyDecision.go
new file mode 100644
index 0000000000000000000000000000000000000000..8d1b6b700dee182f60e6f5ed739c1d23f1de2206
--- /dev/null
+++ b/v4/webkit/WebKitNavigationPolicyDecision.go
@@ -0,0 +1,89 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type NavigationPolicyDecisionClass struct {
+	_ structs.HostLayout
+
+	ParentClass PolicyDecisionClass
+}
+
+func (x *NavigationPolicyDecisionClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A policy decision for navigation actions.
+//
+// WebKitNavigationPolicyDecision represents a policy decision for events associated with
+// navigations. If the value of #WebKitNavigationPolicyDecision:mouse-button is not 0, then
+// the navigation was triggered by a mouse event.
+type NavigationPolicyDecision struct {
+	PolicyDecision
+}
+
+var xNavigationPolicyDecisionGLibType func() types.GType
+
+func NavigationPolicyDecisionGLibType() types.GType {
+	return xNavigationPolicyDecisionGLibType()
+}
+
+func NavigationPolicyDecisionNewFromInternalPtr(ptr uintptr) *NavigationPolicyDecision {
+	cls := &NavigationPolicyDecision{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNavigationPolicyDecisionGetNavigationAction func(uintptr) *NavigationAction
+
+// Gets the value of the #WebKitNavigationPolicyDecision:navigation-action property.
+func (x *NavigationPolicyDecision) GetNavigationAction() *NavigationAction {
+
+	cret := xNavigationPolicyDecisionGetNavigationAction(x.GoPointer())
+	return cret
+}
+
+func (c *NavigationPolicyDecision) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *NavigationPolicyDecision) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// GetPropertyNavigationAction gets the "navigation-action" property.
+// The #WebKitNavigationAction that triggered this policy decision.
+func (x *NavigationPolicyDecision) GetPropertyNavigationAction() uintptr {
+	var v gobject.Value
+	x.GetProperty("navigation-action", &v)
+	return v.GetPointer()
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xNavigationPolicyDecisionGLibType, libs, "webkit_navigation_policy_decision_get_type")
+
+	core.PuregoSafeRegister(&xNavigationPolicyDecisionGetNavigationAction, libs, "webkit_navigation_policy_decision_get_navigation_action")
+
+}
diff --git a/v4/webkit/WebKitNetworkProxySettings.go b/v4/webkit/WebKitNetworkProxySettings.go
new file mode 100644
index 0000000000000000000000000000000000000000..7e8beaf91825696ddddd32bf885cf3e63c891983
--- /dev/null
+++ b/v4/webkit/WebKitNetworkProxySettings.go
@@ -0,0 +1,143 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Configures network proxies.
+//
+// WebKitNetworkProxySettings can be used to provide a custom proxy configuration
+// to a #WebKitNetworkSession. You need to call webkit_network_session_set_network_proxy_settings()
+// with %WEBKIT_NETWORK_PROXY_MODE_CUSTOM and a WebKitNetworkProxySettings.
+type NetworkProxySettings struct {
+	_ structs.HostLayout
+}
+
+var xNetworkProxySettingsGLibType func() types.GType
+
+func NetworkProxySettingsGLibType() types.GType {
+	return xNetworkProxySettingsGLibType()
+}
+
+func (x *NetworkProxySettings) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewNetworkProxySettings func(string, []string) *NetworkProxySettings
+
+// Create a new #WebKitNetworkProxySettings with the given @default_proxy_uri and @ignore_hosts.
+//
+// The default proxy URI will be used for any URI that doesn't match @ignore_hosts, and doesn't match any
+// of the schemes added with webkit_network_proxy_settings_add_proxy_for_scheme().
+// If @default_proxy_uri starts with "socks://", it will be treated as referring to all three of the
+// socks5, socks4a, and socks4 proxy types.
+//
+// @ignore_hosts is a list of hostnames and IP addresses that the resolver should allow direct connections to.
+// Entries can be in one of 4 formats:
+// &lt;itemizedlist&gt;
+// &lt;listitem&gt;&lt;para&gt;
+// A hostname, such as "example.com", ".example.com", or "*.example.com", any of which match "example.com" or
+// any subdomain of it.
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+// An IPv4 or IPv6 address, such as "192.168.1.1", which matches only that address.
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+// A hostname or IP address followed by a port, such as "example.com:80", which matches whatever the hostname or IP
+// address would match, but only for URLs with the (explicitly) indicated port. In the case of an IPv6 address, the address
+// part must appear in brackets: "[::1]:443"
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+// An IP address range, given by a base address and prefix length, such as "fe80::/10", which matches any address in that range.
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;/itemizedlist&gt;
+//
+// Note that when dealing with Unicode hostnames, the matching is done against the ASCII form of the name.
+// Also note that hostname exclusions apply only to connections made to hosts identified by name, and IP address exclusions apply only
+// to connections made to hosts identified by address. That is, if example.com has an address of 192.168.1.1, and @ignore_hosts
+// contains only "192.168.1.1", then a connection to "example.com" will use the proxy, and a connection to 192.168.1.1" will not.
+func NewNetworkProxySettings(DefaultProxyUriVar string, IgnoreHostsVar []string) *NetworkProxySettings {
+
+	cret := xNewNetworkProxySettings(DefaultProxyUriVar, IgnoreHostsVar)
+	return cret
+}
+
+var xNetworkProxySettingsAddProxyForScheme func(uintptr, string, string)
+
+// Adds a URI-scheme-specific proxy.
+//
+// URIs whose scheme matches @uri_scheme will be proxied via @proxy_uri.
+// As with the default proxy URI, if @proxy_uri starts with "socks://", it will be treated as referring to
+// all three of the socks5, socks4a, and socks4 proxy types.
+func (x *NetworkProxySettings) AddProxyForScheme(SchemeVar string, ProxyUriVar string) {
+
+	xNetworkProxySettingsAddProxyForScheme(x.GoPointer(), SchemeVar, ProxyUriVar)
+
+}
+
+var xNetworkProxySettingsCopy func(uintptr) *NetworkProxySettings
+
+// Make a copy of the #WebKitNetworkProxySettings.
+func (x *NetworkProxySettings) Copy() *NetworkProxySettings {
+
+	cret := xNetworkProxySettingsCopy(x.GoPointer())
+	return cret
+}
+
+var xNetworkProxySettingsFree func(uintptr)
+
+// Free the #WebKitNetworkProxySettings.
+func (x *NetworkProxySettings) Free() {
+
+	xNetworkProxySettingsFree(x.GoPointer())
+
+}
+
+// Enum values used to set the network proxy mode.
+type NetworkProxyMode int
+
+var xNetworkProxyModeGLibType func() types.GType
+
+func NetworkProxyModeGLibType() types.GType {
+	return xNetworkProxyModeGLibType()
+}
+
+const (
+
+	// Use the default proxy of the system.
+	NetworkProxyModeDefaultValue NetworkProxyMode = 0
+	// Do not use any proxy.
+	NetworkProxyModeNoProxyValue NetworkProxyMode = 1
+	// Use custom proxy settings.
+	NetworkProxyModeCustomValue NetworkProxyMode = 2
+)
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xNetworkProxyModeGLibType, libs, "webkit_network_proxy_mode_get_type")
+
+	core.PuregoSafeRegister(&xNetworkProxySettingsGLibType, libs, "webkit_network_proxy_settings_get_type")
+
+	core.PuregoSafeRegister(&xNewNetworkProxySettings, libs, "webkit_network_proxy_settings_new")
+
+	core.PuregoSafeRegister(&xNetworkProxySettingsAddProxyForScheme, libs, "webkit_network_proxy_settings_add_proxy_for_scheme")
+	core.PuregoSafeRegister(&xNetworkProxySettingsCopy, libs, "webkit_network_proxy_settings_copy")
+	core.PuregoSafeRegister(&xNetworkProxySettingsFree, libs, "webkit_network_proxy_settings_free")
+
+}
diff --git a/v4/webkit/WebKitNetworkSession.go b/v4/webkit/WebKitNetworkSession.go
new file mode 100644
index 0000000000000000000000000000000000000000..248df216151e1551ac9adff3506006a227b1865d
--- /dev/null
+++ b/v4/webkit/WebKitNetworkSession.go
@@ -0,0 +1,422 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type NetworkSessionClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *NetworkSessionClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Manages network configuration.
+type NetworkSession struct {
+	gobject.Object
+}
+
+var xNetworkSessionGLibType func() types.GType
+
+func NetworkSessionGLibType() types.GType {
+	return xNetworkSessionGLibType()
+}
+
+func NetworkSessionNewFromInternalPtr(ptr uintptr) *NetworkSession {
+	cls := &NetworkSession{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewNetworkSession func(string, string) uintptr
+
+// Creates a new #WebKitNetworkSession with a persistent #WebKitWebsiteDataManager.
+// The parameters @data_directory and @cache_directory will be used as construct
+// properties of the #WebKitWebsiteDataManager of the network session. Note that if
+// %NULL is passed, the default directory will be passed to #WebKitWebsiteDataManager
+// so that webkit_website_data_manager_get_base_data_directory() and
+// webkit_website_data_manager_get_base_cache_directory() always return a value for
+// non ephemeral sessions.
+//
+// It must be passed as construct parameter of a #WebKitWebView.
+func NewNetworkSession(DataDirectoryVar string, CacheDirectoryVar string) *NetworkSession {
+	var cls *NetworkSession
+
+	cret := xNewNetworkSession(DataDirectoryVar, CacheDirectoryVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &NetworkSession{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewNetworkSessionEphemeral func() uintptr
+
+// Creates a new #WebKitNetworkSession with an ephemeral #WebKitWebsiteDataManager.
+func NewNetworkSessionEphemeral() *NetworkSession {
+	var cls *NetworkSession
+
+	cret := xNewNetworkSessionEphemeral()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &NetworkSession{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNetworkSessionAllowTlsCertificateForHost func(uintptr, uintptr, string)
+
+// Ignore further TLS errors on the @host for the certificate present in @info.
+//
+// If @host is an IPv6 address, it should not be surrounded by brackets. This
+// expectation matches g_uri_get_host().
+func (x *NetworkSession) AllowTlsCertificateForHost(CertificateVar *gio.TlsCertificate, HostVar string) {
+
+	xNetworkSessionAllowTlsCertificateForHost(x.GoPointer(), CertificateVar.GoPointer(), HostVar)
+
+}
+
+var xNetworkSessionDownloadUri func(uintptr, string) uintptr
+
+// Requests downloading of the specified URI string.
+//
+// The download operation will not be associated to any #WebKitWebView,
+// if you are interested in starting a download from a particular #WebKitWebView use
+// webkit_web_view_download_uri() instead.
+func (x *NetworkSession) DownloadUri(UriVar string) *Download {
+	var cls *Download
+
+	cret := xNetworkSessionDownloadUri(x.GoPointer(), UriVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Download{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNetworkSessionGetCookieManager func(uintptr) uintptr
+
+// Get the #WebKitCookieManager of @session.
+func (x *NetworkSession) GetCookieManager() *CookieManager {
+	var cls *CookieManager
+
+	cret := xNetworkSessionGetCookieManager(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &CookieManager{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNetworkSessionGetItpEnabled func(uintptr) bool
+
+// Get whether Intelligent Tracking Prevention (ITP) is enabled or not.
+func (x *NetworkSession) GetItpEnabled() bool {
+
+	cret := xNetworkSessionGetItpEnabled(x.GoPointer())
+	return cret
+}
+
+var xNetworkSessionGetItpSummary func(uintptr, uintptr, uintptr, uintptr)
+
+// Asynchronously get the list of #WebKitITPThirdParty seen for @session.
+//
+// Every #WebKitITPThirdParty
+// contains the list of #WebKitITPFirstParty under which it has been seen.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_network_session_get_itp_summary_finish() to get the result of the operation.
+func (x *NetworkSession) GetItpSummary(CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xNetworkSessionGetItpSummary(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xNetworkSessionGetItpSummaryFinish func(uintptr, uintptr, **glib.Error) *glib.List
+
+// Finish an asynchronous operation started with webkit_network_session_get_itp_summary().
+func (x *NetworkSession) GetItpSummaryFinish(ResultVar gio.AsyncResult) (*glib.List, error) {
+	var cerr *glib.Error
+
+	cret := xNetworkSessionGetItpSummaryFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xNetworkSessionGetPersistentCredentialStorageEnabled func(uintptr) bool
+
+// Get whether persistent credential storage is enabled or not.
+//
+// See also webkit_network_session_set_persistent_credential_storage_enabled().
+func (x *NetworkSession) GetPersistentCredentialStorageEnabled() bool {
+
+	cret := xNetworkSessionGetPersistentCredentialStorageEnabled(x.GoPointer())
+	return cret
+}
+
+var xNetworkSessionGetTlsErrorsPolicy func(uintptr) TLSErrorsPolicy
+
+// Get the TLS errors policy of @session.
+func (x *NetworkSession) GetTlsErrorsPolicy() TLSErrorsPolicy {
+
+	cret := xNetworkSessionGetTlsErrorsPolicy(x.GoPointer())
+	return cret
+}
+
+var xNetworkSessionGetWebsiteDataManager func(uintptr) uintptr
+
+// Get the #WebKitWebsiteDataManager of @session.
+func (x *NetworkSession) GetWebsiteDataManager() *WebsiteDataManager {
+	var cls *WebsiteDataManager
+
+	cret := xNetworkSessionGetWebsiteDataManager(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WebsiteDataManager{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNetworkSessionIsEphemeral func(uintptr) bool
+
+// Get whether @session is ephemeral.
+// A #WebKitNetworkSession is ephemeral when its #WebKitWebsiteDataManager is ephemeral.
+// See #WebKitWebsiteDataManager:is-ephemeral for more details.
+func (x *NetworkSession) IsEphemeral() bool {
+
+	cret := xNetworkSessionIsEphemeral(x.GoPointer())
+	return cret
+}
+
+var xNetworkSessionPrefetchDns func(uintptr, string)
+
+// Resolve the domain name of the given @hostname in advance, so that if a URI
+// of @hostname is requested the load will be performed more quickly.
+func (x *NetworkSession) PrefetchDns(HostnameVar string) {
+
+	xNetworkSessionPrefetchDns(x.GoPointer(), HostnameVar)
+
+}
+
+var xNetworkSessionSetItpEnabled func(uintptr, bool)
+
+// Enable or disable Intelligent Tracking Prevention (ITP).
+//
+// When ITP is enabled resource load statistics
+// are collected and used to decide whether to allow or block third-party cookies and prevent user tracking.
+// Note that while ITP is enabled the accept policy %WEBKIT_COOKIE_POLICY_ACCEPT_NO_THIRD_PARTY is ignored and
+// %WEBKIT_COOKIE_POLICY_ACCEPT_ALWAYS is used instead. See also webkit_cookie_session_set_accept_policy().
+func (x *NetworkSession) SetItpEnabled(EnabledVar bool) {
+
+	xNetworkSessionSetItpEnabled(x.GoPointer(), EnabledVar)
+
+}
+
+var xNetworkSessionSetPersistentCredentialStorageEnabled func(uintptr, bool)
+
+// Enable or disable persistent credential storage.
+//
+// When enabled, which is the default for
+// non-ephemeral sessions, the network process will try to read and write HTTP authentiacation
+// credentials from persistent storage.
+func (x *NetworkSession) SetPersistentCredentialStorageEnabled(EnabledVar bool) {
+
+	xNetworkSessionSetPersistentCredentialStorageEnabled(x.GoPointer(), EnabledVar)
+
+}
+
+var xNetworkSessionSetProxySettings func(uintptr, NetworkProxyMode, *NetworkProxySettings)
+
+// Set the network proxy settings to be used by connections started in @session session.
+//
+// By default %WEBKIT_NETWORK_PROXY_MODE_DEFAULT is used, which means that the
+// system settings will be used (g_proxy_resolver_get_default()).
+// If you want to override the system default settings, you can either use
+// %WEBKIT_NETWORK_PROXY_MODE_NO_PROXY to make sure no proxies are used at all,
+// or %WEBKIT_NETWORK_PROXY_MODE_CUSTOM to provide your own proxy settings.
+// When @proxy_mode is %WEBKIT_NETWORK_PROXY_MODE_CUSTOM @proxy_settings must be
+// a valid #WebKitNetworkProxySettings; otherwise, @proxy_settings must be %NULL.
+func (x *NetworkSession) SetProxySettings(ProxyModeVar NetworkProxyMode, ProxySettingsVar *NetworkProxySettings) {
+
+	xNetworkSessionSetProxySettings(x.GoPointer(), ProxyModeVar, ProxySettingsVar)
+
+}
+
+var xNetworkSessionSetTlsErrorsPolicy func(uintptr, TLSErrorsPolicy)
+
+// Set the TLS errors policy of @session as @policy.
+func (x *NetworkSession) SetTlsErrorsPolicy(PolicyVar TLSErrorsPolicy) {
+
+	xNetworkSessionSetTlsErrorsPolicy(x.GoPointer(), PolicyVar)
+
+}
+
+func (c *NetworkSession) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *NetworkSession) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyCacheDirectory sets the "cache-directory" property.
+// The base caches directory used to create the #WebKitWebsiteDataManager. If %NULL, a default location will be used.
+func (x *NetworkSession) SetPropertyCacheDirectory(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("cache-directory", &v)
+}
+
+// SetPropertyDataDirectory sets the "data-directory" property.
+// The base data directory used to create the #WebKitWebsiteDataManager. If %NULL, a default location will be used.
+func (x *NetworkSession) SetPropertyDataDirectory(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("data-directory", &v)
+}
+
+// SetPropertyIsEphemeral sets the "is-ephemeral" property.
+// Whether to create an ephermeral #WebKitWebsiteDataManager for the session.
+func (x *NetworkSession) SetPropertyIsEphemeral(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-ephemeral", &v)
+}
+
+// GetPropertyIsEphemeral gets the "is-ephemeral" property.
+// Whether to create an ephermeral #WebKitWebsiteDataManager for the session.
+func (x *NetworkSession) GetPropertyIsEphemeral() bool {
+	var v gobject.Value
+	x.GetProperty("is-ephemeral", &v)
+	return v.GetBoolean()
+}
+
+// This signal is emitted when a new download request is made.
+func (x *NetworkSession) ConnectDownloadStarted(cb *func(NetworkSession, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "download-started", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, DownloadVarp uintptr) {
+		fa := NetworkSession{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, DownloadVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "download-started", cbRefPtr)
+}
+
+var xNetworkSessionGetDefault func() uintptr
+
+// Get the default network session.
+// The default network session is created using webkit_network_session_new() and passing
+// %NULL as data and cache directories.
+func NetworkSessionGetDefault() *NetworkSession {
+	var cls *NetworkSession
+
+	cret := xNetworkSessionGetDefault()
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &NetworkSession{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNetworkSessionSetMemoryPressureSettings func(*MemoryPressureSettings)
+
+// Sets @settings as the #WebKitMemoryPressureSettings.
+//
+// Sets @settings as the #WebKitMemoryPressureSettings to be used by the network
+// process created by any instance of #WebKitNetworkSession after this function
+// is called.
+//
+// Be sure to call this function before creating any #WebKitNetworkSession.
+//
+// The periodic check for used memory is disabled by default on network processes. This will
+// be enabled only if custom settings have been set using this function. After that, in order
+// to remove the custom settings and disable the periodic check, this function must be called
+// passing %NULL as the value of @settings.
+func NetworkSessionSetMemoryPressureSettings(SettingsVar *MemoryPressureSettings) {
+
+	xNetworkSessionSetMemoryPressureSettings(SettingsVar)
+
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xNetworkSessionGLibType, libs, "webkit_network_session_get_type")
+
+	core.PuregoSafeRegister(&xNewNetworkSession, libs, "webkit_network_session_new")
+	core.PuregoSafeRegister(&xNewNetworkSessionEphemeral, libs, "webkit_network_session_new_ephemeral")
+
+	core.PuregoSafeRegister(&xNetworkSessionAllowTlsCertificateForHost, libs, "webkit_network_session_allow_tls_certificate_for_host")
+	core.PuregoSafeRegister(&xNetworkSessionDownloadUri, libs, "webkit_network_session_download_uri")
+	core.PuregoSafeRegister(&xNetworkSessionGetCookieManager, libs, "webkit_network_session_get_cookie_manager")
+	core.PuregoSafeRegister(&xNetworkSessionGetItpEnabled, libs, "webkit_network_session_get_itp_enabled")
+	core.PuregoSafeRegister(&xNetworkSessionGetItpSummary, libs, "webkit_network_session_get_itp_summary")
+	core.PuregoSafeRegister(&xNetworkSessionGetItpSummaryFinish, libs, "webkit_network_session_get_itp_summary_finish")
+	core.PuregoSafeRegister(&xNetworkSessionGetPersistentCredentialStorageEnabled, libs, "webkit_network_session_get_persistent_credential_storage_enabled")
+	core.PuregoSafeRegister(&xNetworkSessionGetTlsErrorsPolicy, libs, "webkit_network_session_get_tls_errors_policy")
+	core.PuregoSafeRegister(&xNetworkSessionGetWebsiteDataManager, libs, "webkit_network_session_get_website_data_manager")
+	core.PuregoSafeRegister(&xNetworkSessionIsEphemeral, libs, "webkit_network_session_is_ephemeral")
+	core.PuregoSafeRegister(&xNetworkSessionPrefetchDns, libs, "webkit_network_session_prefetch_dns")
+	core.PuregoSafeRegister(&xNetworkSessionSetItpEnabled, libs, "webkit_network_session_set_itp_enabled")
+	core.PuregoSafeRegister(&xNetworkSessionSetPersistentCredentialStorageEnabled, libs, "webkit_network_session_set_persistent_credential_storage_enabled")
+	core.PuregoSafeRegister(&xNetworkSessionSetProxySettings, libs, "webkit_network_session_set_proxy_settings")
+	core.PuregoSafeRegister(&xNetworkSessionSetTlsErrorsPolicy, libs, "webkit_network_session_set_tls_errors_policy")
+
+	core.PuregoSafeRegister(&xNetworkSessionGetDefault, libs, "webkit_network_session_get_default")
+	core.PuregoSafeRegister(&xNetworkSessionSetMemoryPressureSettings, libs, "webkit_network_session_set_memory_pressure_settings")
+
+}
diff --git a/v4/webkit/WebKitNotification.go b/v4/webkit/WebKitNotification.go
new file mode 100644
index 0000000000000000000000000000000000000000..d2d34a8360e856c2f9eba540d068ef279675f629
--- /dev/null
+++ b/v4/webkit/WebKitNotification.go
@@ -0,0 +1,206 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type NotificationClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *NotificationClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Holds information about a notification that should be shown to the user.
+type Notification struct {
+	gobject.Object
+}
+
+var xNotificationGLibType func() types.GType
+
+func NotificationGLibType() types.GType {
+	return xNotificationGLibType()
+}
+
+func NotificationNewFromInternalPtr(ptr uintptr) *Notification {
+	cls := &Notification{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNotificationClicked func(uintptr)
+
+// Tells WebKit the notification has been clicked.
+//
+// This will emit the
+// #WebKitNotification::clicked signal.
+func (x *Notification) Clicked() {
+
+	xNotificationClicked(x.GoPointer())
+
+}
+
+var xNotificationClose func(uintptr)
+
+// Closes the notification.
+func (x *Notification) Close() {
+
+	xNotificationClose(x.GoPointer())
+
+}
+
+var xNotificationGetBody func(uintptr) string
+
+// Obtains the body for the notification.
+func (x *Notification) GetBody() string {
+
+	cret := xNotificationGetBody(x.GoPointer())
+	return cret
+}
+
+var xNotificationGetId func(uintptr) uint64
+
+// Obtains the unique id for the notification.
+func (x *Notification) GetId() uint64 {
+
+	cret := xNotificationGetId(x.GoPointer())
+	return cret
+}
+
+var xNotificationGetTag func(uintptr) string
+
+// Obtains the tag identifier for the notification.
+func (x *Notification) GetTag() string {
+
+	cret := xNotificationGetTag(x.GoPointer())
+	return cret
+}
+
+var xNotificationGetTitle func(uintptr) string
+
+// Obtains the title for the notification.
+func (x *Notification) GetTitle() string {
+
+	cret := xNotificationGetTitle(x.GoPointer())
+	return cret
+}
+
+func (c *Notification) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Notification) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// GetPropertyBody gets the "body" property.
+// The body for the notification.
+func (x *Notification) GetPropertyBody() string {
+	var v gobject.Value
+	x.GetProperty("body", &v)
+	return v.GetString()
+}
+
+// GetPropertyId gets the "id" property.
+// The unique id for the notification.
+func (x *Notification) GetPropertyId() uint64 {
+	var v gobject.Value
+	x.GetProperty("id", &v)
+	return v.GetUint64()
+}
+
+// GetPropertyTag gets the "tag" property.
+// The tag identifier for the notification.
+func (x *Notification) GetPropertyTag() string {
+	var v gobject.Value
+	x.GetProperty("tag", &v)
+	return v.GetString()
+}
+
+// GetPropertyTitle gets the "title" property.
+// The title for the notification.
+func (x *Notification) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// Emitted when a notification has been clicked. See webkit_notification_clicked().
+func (x *Notification) ConnectClicked(cb *func(Notification)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "clicked", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Notification{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "clicked", cbRefPtr)
+}
+
+// Emitted when a notification has been withdrawn.
+//
+// The default handler will close the notification using libnotify, if built with
+// support for it.
+func (x *Notification) ConnectClosed(cb *func(Notification)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := Notification{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xNotificationGLibType, libs, "webkit_notification_get_type")
+
+	core.PuregoSafeRegister(&xNotificationClicked, libs, "webkit_notification_clicked")
+	core.PuregoSafeRegister(&xNotificationClose, libs, "webkit_notification_close")
+	core.PuregoSafeRegister(&xNotificationGetBody, libs, "webkit_notification_get_body")
+	core.PuregoSafeRegister(&xNotificationGetId, libs, "webkit_notification_get_id")
+	core.PuregoSafeRegister(&xNotificationGetTag, libs, "webkit_notification_get_tag")
+	core.PuregoSafeRegister(&xNotificationGetTitle, libs, "webkit_notification_get_title")
+
+}
diff --git a/v4/webkit/WebKitNotificationPermissionRequest.go b/v4/webkit/WebKitNotificationPermissionRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..4d0e7f0596f4c92cc2a7add48e7bc109bc898189
--- /dev/null
+++ b/v4/webkit/WebKitNotificationPermissionRequest.go
@@ -0,0 +1,69 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type NotificationPermissionRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *NotificationPermissionRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A permission request for displaying web notifications.
+//
+// WebKitNotificationPermissionRequest represents a request for
+// permission to decide whether WebKit should provide the user with
+// notifications through the Web Notification API.
+//
+// When a WebKitNotificationPermissionRequest is not handled by the user,
+// it is denied by default.
+type NotificationPermissionRequest struct {
+	gobject.Object
+}
+
+var xNotificationPermissionRequestGLibType func() types.GType
+
+func NotificationPermissionRequestGLibType() types.GType {
+	return xNotificationPermissionRequestGLibType()
+}
+
+func NotificationPermissionRequestNewFromInternalPtr(ptr uintptr) *NotificationPermissionRequest {
+	cls := &NotificationPermissionRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *NotificationPermissionRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *NotificationPermissionRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Allow the action which triggered this request.
+func (x *NotificationPermissionRequest) Allow() {
+
+	XWebkitPermissionRequestAllow(x.GoPointer())
+
+}
+
+// Deny the action which triggered this request.
+func (x *NotificationPermissionRequest) Deny() {
+
+	XWebkitPermissionRequestDeny(x.GoPointer())
+
+}
diff --git a/v4/webkit/WebKitOptionMenu.go b/v4/webkit/WebKitOptionMenu.go
new file mode 100644
index 0000000000000000000000000000000000000000..3980d322672f1944f9136085ac183e4b21cfba9c
--- /dev/null
+++ b/v4/webkit/WebKitOptionMenu.go
@@ -0,0 +1,181 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gdk"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type OptionMenuClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *OptionMenuClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Represents the dropdown menu of a `select` element in a #WebKitWebView.
+//
+// When a select element in a #WebKitWebView needs to display a dropdown menu, the signal
+// #WebKitWebView::show-option-menu is emitted, providing a WebKitOptionMenu with the
+// #WebKitOptionMenuItem&lt;!-- --&gt;s that should be displayed.
+type OptionMenu struct {
+	gobject.Object
+}
+
+var xOptionMenuGLibType func() types.GType
+
+func OptionMenuGLibType() types.GType {
+	return xOptionMenuGLibType()
+}
+
+func OptionMenuNewFromInternalPtr(ptr uintptr) *OptionMenu {
+	cls := &OptionMenu{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xOptionMenuActivateItem func(uintptr, uint)
+
+// Activates the #WebKitOptionMenuItem at @index in @menu.
+//
+// Activating an item changes the value
+// of the element making the item the active one. You are expected to close the menu with
+// webkit_option_menu_close() after activating an item, calling this function again will have no
+// effect.
+func (x *OptionMenu) ActivateItem(IndexVar uint) {
+
+	xOptionMenuActivateItem(x.GoPointer(), IndexVar)
+
+}
+
+var xOptionMenuClose func(uintptr)
+
+// Request to close a #WebKitOptionMenu.
+//
+// This emits WebKitOptionMenu::close signal.
+// This function should always be called to notify WebKit that the associated
+// menu has been closed. If the menu is closed and neither webkit_option_menu_select_item()
+// nor webkit_option_menu_activate_item() have been called, the element value remains
+// unchanged.
+func (x *OptionMenu) Close() {
+
+	xOptionMenuClose(x.GoPointer())
+
+}
+
+var xOptionMenuGetEvent func(uintptr) uintptr
+
+// Gets the #GdkEvent that triggered the dropdown menu.
+// If @menu was not triggered by a user interaction, like a mouse click,
+// %NULL is returned.
+func (x *OptionMenu) GetEvent() *gdk.Event {
+	var cls *gdk.Event
+
+	cret := xOptionMenuGetEvent(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gdk.Event{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xOptionMenuGetItem func(uintptr, uint) *OptionMenuItem
+
+// Returns the #WebKitOptionMenuItem at @index in @menu.
+func (x *OptionMenu) GetItem(IndexVar uint) *OptionMenuItem {
+
+	cret := xOptionMenuGetItem(x.GoPointer(), IndexVar)
+	return cret
+}
+
+var xOptionMenuGetNItems func(uintptr) uint
+
+// Gets the length of the @menu.
+func (x *OptionMenu) GetNItems() uint {
+
+	cret := xOptionMenuGetNItems(x.GoPointer())
+	return cret
+}
+
+var xOptionMenuSelectItem func(uintptr, uint)
+
+// Selects the #WebKitOptionMenuItem at @index in @menu.
+//
+// Selecting an item changes the
+// text shown by the combo button, but it doesn't change the value of the element. You need to
+// explicitly activate the item with webkit_option_menu_select_item() or close the menu with
+// webkit_option_menu_close() in which case the currently selected item will be activated.
+func (x *OptionMenu) SelectItem(IndexVar uint) {
+
+	xOptionMenuSelectItem(x.GoPointer(), IndexVar)
+
+}
+
+func (c *OptionMenu) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *OptionMenu) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Emitted when closing a #WebKitOptionMenu is requested. This can happen
+// when the user explicitly calls webkit_option_menu_close() or when the
+// element is detached from the current page.
+func (x *OptionMenu) ConnectClose(cb *func(OptionMenu)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "close", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := OptionMenu{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "close", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xOptionMenuGLibType, libs, "webkit_option_menu_get_type")
+
+	core.PuregoSafeRegister(&xOptionMenuActivateItem, libs, "webkit_option_menu_activate_item")
+	core.PuregoSafeRegister(&xOptionMenuClose, libs, "webkit_option_menu_close")
+	core.PuregoSafeRegister(&xOptionMenuGetEvent, libs, "webkit_option_menu_get_event")
+	core.PuregoSafeRegister(&xOptionMenuGetItem, libs, "webkit_option_menu_get_item")
+	core.PuregoSafeRegister(&xOptionMenuGetNItems, libs, "webkit_option_menu_get_n_items")
+	core.PuregoSafeRegister(&xOptionMenuSelectItem, libs, "webkit_option_menu_select_item")
+
+}
diff --git a/v4/webkit/WebKitOptionMenuItem.go b/v4/webkit/WebKitOptionMenuItem.go
new file mode 100644
index 0000000000000000000000000000000000000000..9c708f3b16607dbe9a91f463472f688ce3e5d3d9
--- /dev/null
+++ b/v4/webkit/WebKitOptionMenuItem.go
@@ -0,0 +1,128 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// One item of a #WebKitOptionMenu.
+//
+// The #WebKitOptionMenu is composed of WebKitOptionMenuItem&lt;!-- --&gt;s.
+// A WebKitOptionMenuItem always has a label and can contain a tooltip text.
+// You can use the WebKitOptionMenuItem of a #WebKitOptionMenu to build your
+// own menus.
+type OptionMenuItem struct {
+	_ structs.HostLayout
+}
+
+var xOptionMenuItemGLibType func() types.GType
+
+func OptionMenuItemGLibType() types.GType {
+	return xOptionMenuItemGLibType()
+}
+
+func (x *OptionMenuItem) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xOptionMenuItemCopy func(uintptr) *OptionMenuItem
+
+// Make a copy of the #WebKitOptionMenuItem.
+func (x *OptionMenuItem) Copy() *OptionMenuItem {
+
+	cret := xOptionMenuItemCopy(x.GoPointer())
+	return cret
+}
+
+var xOptionMenuItemFree func(uintptr)
+
+// Free the #WebKitOptionMenuItem.
+func (x *OptionMenuItem) Free() {
+
+	xOptionMenuItemFree(x.GoPointer())
+
+}
+
+var xOptionMenuItemGetLabel func(uintptr) string
+
+// Get the label of a #WebKitOptionMenuItem.
+func (x *OptionMenuItem) GetLabel() string {
+
+	cret := xOptionMenuItemGetLabel(x.GoPointer())
+	return cret
+}
+
+var xOptionMenuItemGetTooltip func(uintptr) string
+
+// Get the tooltip of a #WebKitOptionMenuItem.
+func (x *OptionMenuItem) GetTooltip() string {
+
+	cret := xOptionMenuItemGetTooltip(x.GoPointer())
+	return cret
+}
+
+var xOptionMenuItemIsEnabled func(uintptr) bool
+
+// Whether a #WebKitOptionMenuItem is enabled.
+func (x *OptionMenuItem) IsEnabled() bool {
+
+	cret := xOptionMenuItemIsEnabled(x.GoPointer())
+	return cret
+}
+
+var xOptionMenuItemIsGroupChild func(uintptr) bool
+
+// Whether a #WebKitOptionMenuItem is a group child.
+func (x *OptionMenuItem) IsGroupChild() bool {
+
+	cret := xOptionMenuItemIsGroupChild(x.GoPointer())
+	return cret
+}
+
+var xOptionMenuItemIsGroupLabel func(uintptr) bool
+
+// Whether a #WebKitOptionMenuItem is a group label.
+func (x *OptionMenuItem) IsGroupLabel() bool {
+
+	cret := xOptionMenuItemIsGroupLabel(x.GoPointer())
+	return cret
+}
+
+var xOptionMenuItemIsSelected func(uintptr) bool
+
+// Whether a #WebKitOptionMenuItem is the currently selected one.
+func (x *OptionMenuItem) IsSelected() bool {
+
+	cret := xOptionMenuItemIsSelected(x.GoPointer())
+	return cret
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xOptionMenuItemGLibType, libs, "webkit_option_menu_item_get_type")
+
+	core.PuregoSafeRegister(&xOptionMenuItemCopy, libs, "webkit_option_menu_item_copy")
+	core.PuregoSafeRegister(&xOptionMenuItemFree, libs, "webkit_option_menu_item_free")
+	core.PuregoSafeRegister(&xOptionMenuItemGetLabel, libs, "webkit_option_menu_item_get_label")
+	core.PuregoSafeRegister(&xOptionMenuItemGetTooltip, libs, "webkit_option_menu_item_get_tooltip")
+	core.PuregoSafeRegister(&xOptionMenuItemIsEnabled, libs, "webkit_option_menu_item_is_enabled")
+	core.PuregoSafeRegister(&xOptionMenuItemIsGroupChild, libs, "webkit_option_menu_item_is_group_child")
+	core.PuregoSafeRegister(&xOptionMenuItemIsGroupLabel, libs, "webkit_option_menu_item_is_group_label")
+	core.PuregoSafeRegister(&xOptionMenuItemIsSelected, libs, "webkit_option_menu_item_is_selected")
+
+}
diff --git a/v4/webkit/WebKitPermissionRequest.go b/v4/webkit/WebKitPermissionRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..96e2aae7d15f9b678a3bf0cae956794e656bfa76
--- /dev/null
+++ b/v4/webkit/WebKitPermissionRequest.go
@@ -0,0 +1,143 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type PermissionRequestInterface struct {
+	_ structs.HostLayout
+
+	ParentInterface uintptr
+
+	xAllow uintptr
+
+	xDeny uintptr
+}
+
+func (x *PermissionRequestInterface) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideAllow sets the "allow" callback function.
+func (x *PermissionRequestInterface) OverrideAllow(cb func(PermissionRequest)) {
+	if cb == nil {
+		x.xAllow = 0
+	} else {
+		x.xAllow = purego.NewCallback(func(RequestVarp uintptr) {
+			cb(&PermissionRequestBase{Ptr: RequestVarp})
+		})
+	}
+}
+
+// GetAllow gets the "allow" callback function.
+func (x *PermissionRequestInterface) GetAllow() func(PermissionRequest) {
+	if x.xAllow == 0 {
+		return nil
+	}
+	var rawCallback func(RequestVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xAllow)
+	return func(RequestVar PermissionRequest) {
+		rawCallback(RequestVar.GoPointer())
+	}
+}
+
+// OverrideDeny sets the "deny" callback function.
+func (x *PermissionRequestInterface) OverrideDeny(cb func(PermissionRequest)) {
+	if cb == nil {
+		x.xDeny = 0
+	} else {
+		x.xDeny = purego.NewCallback(func(RequestVarp uintptr) {
+			cb(&PermissionRequestBase{Ptr: RequestVarp})
+		})
+	}
+}
+
+// GetDeny gets the "deny" callback function.
+func (x *PermissionRequestInterface) GetDeny() func(PermissionRequest) {
+	if x.xDeny == 0 {
+		return nil
+	}
+	var rawCallback func(RequestVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xDeny)
+	return func(RequestVar PermissionRequest) {
+		rawCallback(RequestVar.GoPointer())
+	}
+}
+
+// A permission request.
+//
+// There are situations where an embedder would need to ask the user
+// for permission to do certain types of operations, such as switching
+// to fullscreen mode or reporting the user's location through the
+// standard Geolocation API. In those cases, WebKit will emit a
+// #WebKitWebView::permission-request signal with a
+// #WebKitPermissionRequest object attached to it.
+type PermissionRequest interface {
+	GoPointer() uintptr
+	SetGoPointer(uintptr)
+	Allow()
+	Deny()
+}
+
+var xPermissionRequestGLibType func() types.GType
+
+func PermissionRequestGLibType() types.GType {
+	return xPermissionRequestGLibType()
+}
+
+type PermissionRequestBase struct {
+	Ptr uintptr
+}
+
+func (x *PermissionRequestBase) GoPointer() uintptr {
+	if x == nil {
+		return 0
+	}
+	return x.Ptr
+}
+
+func (x *PermissionRequestBase) SetGoPointer(ptr uintptr) {
+	x.Ptr = ptr
+}
+
+// Allow the action which triggered this request.
+func (x *PermissionRequestBase) Allow() {
+
+	XWebkitPermissionRequestAllow(x.GoPointer())
+
+}
+
+// Deny the action which triggered this request.
+func (x *PermissionRequestBase) Deny() {
+
+	XWebkitPermissionRequestDeny(x.GoPointer())
+
+}
+
+var XWebkitPermissionRequestAllow func(uintptr)
+var XWebkitPermissionRequestDeny func(uintptr)
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xPermissionRequestGLibType, libs, "webkit_permission_request_get_type")
+
+	core.PuregoSafeRegister(&XWebkitPermissionRequestAllow, libs, "webkit_permission_request_allow")
+	core.PuregoSafeRegister(&XWebkitPermissionRequestDeny, libs, "webkit_permission_request_deny")
+
+}
diff --git a/v4/webkit/WebKitPermissionStateQuery.go b/v4/webkit/WebKitPermissionStateQuery.go
new file mode 100644
index 0000000000000000000000000000000000000000..e69b4cd882ac4d0e09253522565c813c613a6aa6
--- /dev/null
+++ b/v4/webkit/WebKitPermissionStateQuery.go
@@ -0,0 +1,129 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// This query represents a user's choice to allow or deny access to "powerful features" of the
+// platform, as specified in the [Permissions W3C
+// Specification](https://w3c.github.io/permissions/).
+//
+// When signalled by the #WebKitWebView through the `query-permission-state` signal, the application
+// has to eventually respond, via `webkit_permission_state_query_finish()`, whether it grants,
+// denies or requests a dedicated permission prompt for the given query.
+//
+// When a #WebKitPermissionStateQuery is not handled by the user, the user-agent is instructed to
+// `prompt` the user for the given permission.
+type PermissionStateQuery struct {
+	_ structs.HostLayout
+}
+
+var xPermissionStateQueryGLibType func() types.GType
+
+func PermissionStateQueryGLibType() types.GType {
+	return xPermissionStateQueryGLibType()
+}
+
+func (x *PermissionStateQuery) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xPermissionStateQueryFinish func(uintptr, PermissionState)
+
+// Notify the web-engine of the selected permission state for the given query. This function should
+// only be called as a response to the `WebKitWebView::query-permission-state` signal.
+func (x *PermissionStateQuery) Finish(StateVar PermissionState) {
+
+	xPermissionStateQueryFinish(x.GoPointer(), StateVar)
+
+}
+
+var xPermissionStateQueryGetName func(uintptr) string
+
+// Get the permission name for which access is being queried.
+func (x *PermissionStateQuery) GetName() string {
+
+	cret := xPermissionStateQueryGetName(x.GoPointer())
+	return cret
+}
+
+var xPermissionStateQueryGetSecurityOrigin func(uintptr) *SecurityOrigin
+
+// Get the permission origin for which access is being queried.
+func (x *PermissionStateQuery) GetSecurityOrigin() *SecurityOrigin {
+
+	cret := xPermissionStateQueryGetSecurityOrigin(x.GoPointer())
+	return cret
+}
+
+var xPermissionStateQueryRef func(uintptr) *PermissionStateQuery
+
+// Atomically increments the reference count of @query by one.
+//
+// This function is MT-safe and may be called from any thread.
+func (x *PermissionStateQuery) Ref() *PermissionStateQuery {
+
+	cret := xPermissionStateQueryRef(x.GoPointer())
+	return cret
+}
+
+var xPermissionStateQueryUnref func(uintptr)
+
+// Atomically decrements the reference count of @query by one.
+//
+// If the reference count drops to 0, all memory allocated by #WebKitPermissionStateQuery is
+// released. This function is MT-safe and may be called from any thread.
+func (x *PermissionStateQuery) Unref() {
+
+	xPermissionStateQueryUnref(x.GoPointer())
+
+}
+
+// Enum values representing query permission results.
+type PermissionState int
+
+var xPermissionStateGLibType func() types.GType
+
+func PermissionStateGLibType() types.GType {
+	return xPermissionStateGLibType()
+}
+
+const (
+
+	// Access to the feature is granted.
+	PermissionStateGrantedValue PermissionState = 0
+	// Access to the feature is denied.
+	PermissionStateDeniedValue PermissionState = 1
+	// Access to the feature has to be requested via user prompt.
+	PermissionStatePromptValue PermissionState = 2
+)
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xPermissionStateGLibType, libs, "webkit_permission_state_get_type")
+
+	core.PuregoSafeRegister(&xPermissionStateQueryGLibType, libs, "webkit_permission_state_query_get_type")
+
+	core.PuregoSafeRegister(&xPermissionStateQueryFinish, libs, "webkit_permission_state_query_finish")
+	core.PuregoSafeRegister(&xPermissionStateQueryGetName, libs, "webkit_permission_state_query_get_name")
+	core.PuregoSafeRegister(&xPermissionStateQueryGetSecurityOrigin, libs, "webkit_permission_state_query_get_security_origin")
+	core.PuregoSafeRegister(&xPermissionStateQueryRef, libs, "webkit_permission_state_query_ref")
+	core.PuregoSafeRegister(&xPermissionStateQueryUnref, libs, "webkit_permission_state_query_unref")
+
+}
diff --git a/v4/webkit/WebKitPointerLockPermissionRequest.go b/v4/webkit/WebKitPointerLockPermissionRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..35c7a15e54ecb2cdf45b59c8d7f7bbbb7b33e5d6
--- /dev/null
+++ b/v4/webkit/WebKitPointerLockPermissionRequest.go
@@ -0,0 +1,69 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type PointerLockPermissionRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *PointerLockPermissionRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A permission request for locking the pointer.
+//
+// WebKitPointerLockPermissionRequest represents a request for
+// permission to decide whether WebKit can lock the pointer device when
+// requested by web content.
+//
+// When a WebKitPointerLockPermissionRequest is not handled by the user,
+// it is allowed by default.
+type PointerLockPermissionRequest struct {
+	gobject.Object
+}
+
+var xPointerLockPermissionRequestGLibType func() types.GType
+
+func PointerLockPermissionRequestGLibType() types.GType {
+	return xPointerLockPermissionRequestGLibType()
+}
+
+func PointerLockPermissionRequestNewFromInternalPtr(ptr uintptr) *PointerLockPermissionRequest {
+	cls := &PointerLockPermissionRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *PointerLockPermissionRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *PointerLockPermissionRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Allow the action which triggered this request.
+func (x *PointerLockPermissionRequest) Allow() {
+
+	XWebkitPermissionRequestAllow(x.GoPointer())
+
+}
+
+// Deny the action which triggered this request.
+func (x *PointerLockPermissionRequest) Deny() {
+
+	XWebkitPermissionRequestDeny(x.GoPointer())
+
+}
diff --git a/v4/webkit/WebKitPolicyDecision.go b/v4/webkit/WebKitPolicyDecision.go
new file mode 100644
index 0000000000000000000000000000000000000000..f022daaa3764d72e7d22203e2d56bbf713a9919a
--- /dev/null
+++ b/v4/webkit/WebKitPolicyDecision.go
@@ -0,0 +1,336 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type PolicyDecisionClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+
+	xWebkitReserved0 uintptr
+
+	xWebkitReserved1 uintptr
+
+	xWebkitReserved2 uintptr
+
+	xWebkitReserved3 uintptr
+
+	xWebkitReserved4 uintptr
+
+	xWebkitReserved5 uintptr
+
+	xWebkitReserved6 uintptr
+
+	xWebkitReserved7 uintptr
+}
+
+func (x *PolicyDecisionClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideWebkitReserved0 sets the "_webkit_reserved0" callback function.
+func (x *PolicyDecisionClass) OverrideWebkitReserved0(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved0 = 0
+	} else {
+		x.xWebkitReserved0 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved0 gets the "_webkit_reserved0" callback function.
+func (x *PolicyDecisionClass) GetWebkitReserved0() func() {
+	if x.xWebkitReserved0 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved0)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved1 sets the "_webkit_reserved1" callback function.
+func (x *PolicyDecisionClass) OverrideWebkitReserved1(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved1 = 0
+	} else {
+		x.xWebkitReserved1 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved1 gets the "_webkit_reserved1" callback function.
+func (x *PolicyDecisionClass) GetWebkitReserved1() func() {
+	if x.xWebkitReserved1 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved1)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved2 sets the "_webkit_reserved2" callback function.
+func (x *PolicyDecisionClass) OverrideWebkitReserved2(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved2 = 0
+	} else {
+		x.xWebkitReserved2 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved2 gets the "_webkit_reserved2" callback function.
+func (x *PolicyDecisionClass) GetWebkitReserved2() func() {
+	if x.xWebkitReserved2 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved2)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved3 sets the "_webkit_reserved3" callback function.
+func (x *PolicyDecisionClass) OverrideWebkitReserved3(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved3 = 0
+	} else {
+		x.xWebkitReserved3 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved3 gets the "_webkit_reserved3" callback function.
+func (x *PolicyDecisionClass) GetWebkitReserved3() func() {
+	if x.xWebkitReserved3 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved3)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved4 sets the "_webkit_reserved4" callback function.
+func (x *PolicyDecisionClass) OverrideWebkitReserved4(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved4 = 0
+	} else {
+		x.xWebkitReserved4 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved4 gets the "_webkit_reserved4" callback function.
+func (x *PolicyDecisionClass) GetWebkitReserved4() func() {
+	if x.xWebkitReserved4 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved4)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved5 sets the "_webkit_reserved5" callback function.
+func (x *PolicyDecisionClass) OverrideWebkitReserved5(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved5 = 0
+	} else {
+		x.xWebkitReserved5 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved5 gets the "_webkit_reserved5" callback function.
+func (x *PolicyDecisionClass) GetWebkitReserved5() func() {
+	if x.xWebkitReserved5 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved5)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved6 sets the "_webkit_reserved6" callback function.
+func (x *PolicyDecisionClass) OverrideWebkitReserved6(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved6 = 0
+	} else {
+		x.xWebkitReserved6 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved6 gets the "_webkit_reserved6" callback function.
+func (x *PolicyDecisionClass) GetWebkitReserved6() func() {
+	if x.xWebkitReserved6 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved6)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved7 sets the "_webkit_reserved7" callback function.
+func (x *PolicyDecisionClass) OverrideWebkitReserved7(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved7 = 0
+	} else {
+		x.xWebkitReserved7 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved7 gets the "_webkit_reserved7" callback function.
+func (x *PolicyDecisionClass) GetWebkitReserved7() func() {
+	if x.xWebkitReserved7 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved7)
+	return func() {
+		rawCallback()
+	}
+}
+
+type PolicyDecisionPrivate struct {
+	_ structs.HostLayout
+}
+
+func (x *PolicyDecisionPrivate) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A pending policy decision.
+//
+// Often WebKit allows the client to decide the policy for certain
+// operations. For instance, a client may want to open a link in a new
+// tab, block a navigation entirely, query the user or trigger a download
+// instead of a navigation. In these cases WebKit will fire the
+// #WebKitWebView::decide-policy signal with a #WebKitPolicyDecision
+// object. If the signal handler does nothing, WebKit will act as if
+// webkit_policy_decision_use() was called as soon as signal handling
+// completes. To make a policy decision asynchronously, simply increment
+// the reference count of the #WebKitPolicyDecision object.
+type PolicyDecision struct {
+	gobject.Object
+}
+
+var xPolicyDecisionGLibType func() types.GType
+
+func PolicyDecisionGLibType() types.GType {
+	return xPolicyDecisionGLibType()
+}
+
+func PolicyDecisionNewFromInternalPtr(ptr uintptr) *PolicyDecision {
+	cls := &PolicyDecision{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xPolicyDecisionDownload func(uintptr)
+
+// Spawn a download from this decision.
+func (x *PolicyDecision) Download() {
+
+	xPolicyDecisionDownload(x.GoPointer())
+
+}
+
+var xPolicyDecisionIgnore func(uintptr)
+
+// #WebKitResponsePolicyDecision, this would cancel the request.
+//
+// Ignore the action which triggered this decision. For instance, for a
+// #WebKitResponsePolicyDecision, this would cancel the request.
+func (x *PolicyDecision) Ignore() {
+
+	xPolicyDecisionIgnore(x.GoPointer())
+
+}
+
+var xPolicyDecisionUse func(uintptr)
+
+// Accept the action which triggered this decision.
+func (x *PolicyDecision) Use() {
+
+	xPolicyDecisionUse(x.GoPointer())
+
+}
+
+var xPolicyDecisionUseWithPolicies func(uintptr, uintptr)
+
+// Accept the navigation action and continue with provided @policies.
+//
+// Accept the navigation action which triggered this decision, and
+// continue with @policies affecting all subsequent loads of resources
+// in the origin associated with the accepted navigation action.
+//
+// For example, a navigation decision to a video sharing website may
+// be accepted under the priviso no movies are allowed to autoplay. The
+// autoplay policy in this case would be set in the @policies.
+func (x *PolicyDecision) UseWithPolicies(PoliciesVar *WebsitePolicies) {
+
+	xPolicyDecisionUseWithPolicies(x.GoPointer(), PoliciesVar.GoPointer())
+
+}
+
+func (c *PolicyDecision) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *PolicyDecision) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xPolicyDecisionGLibType, libs, "webkit_policy_decision_get_type")
+
+	core.PuregoSafeRegister(&xPolicyDecisionDownload, libs, "webkit_policy_decision_download")
+	core.PuregoSafeRegister(&xPolicyDecisionIgnore, libs, "webkit_policy_decision_ignore")
+	core.PuregoSafeRegister(&xPolicyDecisionUse, libs, "webkit_policy_decision_use")
+	core.PuregoSafeRegister(&xPolicyDecisionUseWithPolicies, libs, "webkit_policy_decision_use_with_policies")
+
+}
diff --git a/v4/webkit/WebKitPrintOperation.go b/v4/webkit/WebKitPrintOperation.go
new file mode 100644
index 0000000000000000000000000000000000000000..4bbb5afa2762e427d1497ee0cb69a6011102929f
--- /dev/null
+++ b/v4/webkit/WebKitPrintOperation.go
@@ -0,0 +1,272 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/gtk"
+)
+
+type PrintOperationClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *PrintOperationClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values representing the response of the print dialog shown with
+// webkit_print_operation_run_dialog().
+type PrintOperationResponse int
+
+var xPrintOperationResponseGLibType func() types.GType
+
+func PrintOperationResponseGLibType() types.GType {
+	return xPrintOperationResponseGLibType()
+}
+
+const (
+
+	// Print button was clicked in print dialog
+	PrintOperationResponsePrintValue PrintOperationResponse = 0
+	// Print dialog was cancelled
+	PrintOperationResponseCancelValue PrintOperationResponse = 1
+)
+
+// Controls a print operation.
+//
+// A #WebKitPrintOperation controls a print operation in WebKit. With
+// a similar API to #GtkPrintOperation, it lets you set the print
+// settings with webkit_print_operation_set_print_settings() or
+// display the print dialog with webkit_print_operation_run_dialog().
+type PrintOperation struct {
+	gobject.Object
+}
+
+var xPrintOperationGLibType func() types.GType
+
+func PrintOperationGLibType() types.GType {
+	return xPrintOperationGLibType()
+}
+
+func PrintOperationNewFromInternalPtr(ptr uintptr) *PrintOperation {
+	cls := &PrintOperation{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewPrintOperation func(uintptr) uintptr
+
+// Create a new #WebKitPrintOperation to print @web_view contents.
+func NewPrintOperation(WebViewVar *WebView) *PrintOperation {
+	var cls *PrintOperation
+
+	cret := xNewPrintOperation(WebViewVar.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &PrintOperation{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xPrintOperationGetPageSetup func(uintptr) uintptr
+
+// Return the current page setup of @print_operation.
+//
+// It returns %NULL until
+// either webkit_print_operation_set_page_setup() or webkit_print_operation_run_dialog()
+// have been called.
+func (x *PrintOperation) GetPageSetup() *gtk.PageSetup {
+	var cls *gtk.PageSetup
+
+	cret := xPrintOperationGetPageSetup(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gtk.PageSetup{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xPrintOperationGetPrintSettings func(uintptr) uintptr
+
+// Return the current print settings of @print_operation.
+//
+// It returns %NULL until
+// either webkit_print_operation_set_print_settings() or webkit_print_operation_run_dialog()
+// have been called.
+func (x *PrintOperation) GetPrintSettings() *gtk.PrintSettings {
+	var cls *gtk.PrintSettings
+
+	cret := xPrintOperationGetPrintSettings(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gtk.PrintSettings{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xPrintOperationPrint func(uintptr)
+
+// Start a print operation using current print settings and page setup.
+//
+// Start a print operation using current print settings and page setup
+// without showing the print dialog. If either print settings or page setup
+// are not set with webkit_print_operation_set_print_settings() and
+// webkit_print_operation_set_page_setup(), the default options will be used
+// and the print job will be sent to the default printer.
+// The #WebKitPrintOperation::finished signal is emitted when the printing
+// operation finishes. If an error occurs while printing the signal
+// #WebKitPrintOperation::failed is emitted before #WebKitPrintOperation::finished.
+//
+// If the app is running in a sandbox, this function only works if printing to
+// a file that is in a location accessible to the sandbox, usually acquired
+// through the File Chooser portal. This function will not work for physical
+// printers when running in a sandbox.
+func (x *PrintOperation) Print() {
+
+	xPrintOperationPrint(x.GoPointer())
+
+}
+
+var xPrintOperationRunDialog func(uintptr, uintptr) PrintOperationResponse
+
+// Run the print dialog and start printing.
+//
+// Run the print dialog and start printing using the options selected by
+// the user. This method returns when the print dialog is closed.
+// If the print dialog is cancelled %WEBKIT_PRINT_OPERATION_RESPONSE_CANCEL
+// is returned. If the user clicks on the print button, %WEBKIT_PRINT_OPERATION_RESPONSE_PRINT
+// is returned and the print operation starts. In this case, the #WebKitPrintOperation::finished
+// signal is emitted when the operation finishes. If an error occurs while printing, the signal
+// #WebKitPrintOperation::failed is emitted before #WebKitPrintOperation::finished.
+// If the print dialog is not cancelled current print settings and page setup of @print_operation
+// are updated with options selected by the user when Print button is pressed in print dialog.
+// You can get the updated print settings and page setup by calling
+// webkit_print_operation_get_print_settings() and webkit_print_operation_get_page_setup()
+// after this method.
+func (x *PrintOperation) RunDialog(ParentVar *gtk.Window) PrintOperationResponse {
+
+	cret := xPrintOperationRunDialog(x.GoPointer(), ParentVar.GoPointer())
+	return cret
+}
+
+var xPrintOperationSetPageSetup func(uintptr, uintptr)
+
+// Set the current page setup of @print_operation.
+//
+// Current page setup is used for the
+// initial values of the print dialog when webkit_print_operation_run_dialog() is called.
+func (x *PrintOperation) SetPageSetup(PageSetupVar *gtk.PageSetup) {
+
+	xPrintOperationSetPageSetup(x.GoPointer(), PageSetupVar.GoPointer())
+
+}
+
+var xPrintOperationSetPrintSettings func(uintptr, uintptr)
+
+// Set the current print settings of @print_operation.
+//
+// Set the current print settings of @print_operation. Current print settings are used for
+// the initial values of the print dialog when webkit_print_operation_run_dialog() is called.
+func (x *PrintOperation) SetPrintSettings(PrintSettingsVar *gtk.PrintSettings) {
+
+	xPrintOperationSetPrintSettings(x.GoPointer(), PrintSettingsVar.GoPointer())
+
+}
+
+func (c *PrintOperation) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *PrintOperation) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Emitted when an error occurs while printing. The given @error, of the domain
+// %WEBKIT_PRINT_ERROR, contains further details of the failure.
+// The #WebKitPrintOperation::finished signal is emitted after this one.
+func (x *PrintOperation) ConnectFailed(cb *func(PrintOperation, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "failed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ErrorVarp uintptr) {
+		fa := PrintOperation{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ErrorVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "failed", cbRefPtr)
+}
+
+// Emitted when the print operation has finished doing everything
+// required for printing.
+func (x *PrintOperation) ConnectFinished(cb *func(PrintOperation)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := PrintOperation{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xPrintOperationResponseGLibType, libs, "webkit_print_operation_response_get_type")
+
+	core.PuregoSafeRegister(&xPrintOperationGLibType, libs, "webkit_print_operation_get_type")
+
+	core.PuregoSafeRegister(&xNewPrintOperation, libs, "webkit_print_operation_new")
+
+	core.PuregoSafeRegister(&xPrintOperationGetPageSetup, libs, "webkit_print_operation_get_page_setup")
+	core.PuregoSafeRegister(&xPrintOperationGetPrintSettings, libs, "webkit_print_operation_get_print_settings")
+	core.PuregoSafeRegister(&xPrintOperationPrint, libs, "webkit_print_operation_print")
+	core.PuregoSafeRegister(&xPrintOperationRunDialog, libs, "webkit_print_operation_run_dialog")
+	core.PuregoSafeRegister(&xPrintOperationSetPageSetup, libs, "webkit_print_operation_set_page_setup")
+	core.PuregoSafeRegister(&xPrintOperationSetPrintSettings, libs, "webkit_print_operation_set_print_settings")
+
+}
diff --git a/v4/webkit/WebKitResponsePolicyDecision.go b/v4/webkit/WebKitResponsePolicyDecision.go
new file mode 100644
index 0000000000000000000000000000000000000000..d7b3f56e1b7a050952eece2e5981794530b97ed9
--- /dev/null
+++ b/v4/webkit/WebKitResponsePolicyDecision.go
@@ -0,0 +1,138 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type ResponsePolicyDecisionClass struct {
+	_ structs.HostLayout
+
+	ParentClass PolicyDecisionClass
+}
+
+func (x *ResponsePolicyDecisionClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A policy decision for resource responses.
+//
+// WebKitResponsePolicyDecision represents a policy decision for a
+// resource response, whether from the network or the local system.
+// A very common use case for these types of decision is deciding
+// whether or not to download a particular resource or to load it
+// normally.
+type ResponsePolicyDecision struct {
+	PolicyDecision
+}
+
+var xResponsePolicyDecisionGLibType func() types.GType
+
+func ResponsePolicyDecisionGLibType() types.GType {
+	return xResponsePolicyDecisionGLibType()
+}
+
+func ResponsePolicyDecisionNewFromInternalPtr(ptr uintptr) *ResponsePolicyDecision {
+	cls := &ResponsePolicyDecision{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xResponsePolicyDecisionGetRequest func(uintptr) uintptr
+
+// Return the #WebKitURIRequest associated with the response decision.
+//
+// Modifications to the returned object are &lt;emphasis&gt;not&lt;/emphasis&gt; taken
+// into account when the request is sent over the network, and is intended
+// only to aid in evaluating whether a response decision should be taken or
+// not. To modify requests before they are sent over the network the
+// #WebKitPage::send-request signal can be used instead.
+func (x *ResponsePolicyDecision) GetRequest() *URIRequest {
+	var cls *URIRequest
+
+	cret := xResponsePolicyDecisionGetRequest(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &URIRequest{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xResponsePolicyDecisionGetResponse func(uintptr) uintptr
+
+// Gets the value of the #WebKitResponsePolicyDecision:response property.
+func (x *ResponsePolicyDecision) GetResponse() *URIResponse {
+	var cls *URIResponse
+
+	cret := xResponsePolicyDecisionGetResponse(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &URIResponse{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xResponsePolicyDecisionIsMainFrameMainResource func(uintptr) bool
+
+// Gets whether the request is the main frame main resource
+func (x *ResponsePolicyDecision) IsMainFrameMainResource() bool {
+
+	cret := xResponsePolicyDecisionIsMainFrameMainResource(x.GoPointer())
+	return cret
+}
+
+var xResponsePolicyDecisionIsMimeTypeSupported func(uintptr) bool
+
+// Gets whether the MIME type of the response can be displayed in the #WebKitWebView.
+//
+// Gets whether the MIME type of the response can be displayed in the #WebKitWebView
+// that triggered this policy decision request. See also webkit_web_view_can_show_mime_type().
+func (x *ResponsePolicyDecision) IsMimeTypeSupported() bool {
+
+	cret := xResponsePolicyDecisionIsMimeTypeSupported(x.GoPointer())
+	return cret
+}
+
+func (c *ResponsePolicyDecision) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *ResponsePolicyDecision) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xResponsePolicyDecisionGLibType, libs, "webkit_response_policy_decision_get_type")
+
+	core.PuregoSafeRegister(&xResponsePolicyDecisionGetRequest, libs, "webkit_response_policy_decision_get_request")
+	core.PuregoSafeRegister(&xResponsePolicyDecisionGetResponse, libs, "webkit_response_policy_decision_get_response")
+	core.PuregoSafeRegister(&xResponsePolicyDecisionIsMainFrameMainResource, libs, "webkit_response_policy_decision_is_main_frame_main_resource")
+	core.PuregoSafeRegister(&xResponsePolicyDecisionIsMimeTypeSupported, libs, "webkit_response_policy_decision_is_mime_type_supported")
+
+}
diff --git a/v4/webkit/WebKitScriptDialog.go b/v4/webkit/WebKitScriptDialog.go
new file mode 100644
index 0000000000000000000000000000000000000000..7ce423e7b26327bf0d2b8e18e15ed0b2547ec1a9
--- /dev/null
+++ b/v4/webkit/WebKitScriptDialog.go
@@ -0,0 +1,180 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Carries details to be shown in user-facing dialogs.
+type ScriptDialog struct {
+	_ structs.HostLayout
+}
+
+var xScriptDialogGLibType func() types.GType
+
+func ScriptDialogGLibType() types.GType {
+	return xScriptDialogGLibType()
+}
+
+func (x *ScriptDialog) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xScriptDialogClose func(uintptr)
+
+// Close @dialog.
+//
+// When handling a #WebKitScriptDialog asynchronously (webkit_script_dialog_ref()
+// was called in #WebKitWebView::script-dialog callback), this function needs to be called to notify
+// that we are done with the script dialog. The dialog will be closed on destruction if this function
+// hasn't been called before.
+func (x *ScriptDialog) Close() {
+
+	xScriptDialogClose(x.GoPointer())
+
+}
+
+var xScriptDialogConfirmSetConfirmed func(uintptr, bool)
+
+// Set whether the user confirmed the dialog.
+//
+// This method is used for %WEBKIT_SCRIPT_DIALOG_CONFIRM and %WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM dialogs when
+// #WebKitWebView::script-dialog signal is emitted to set whether the user
+// confirmed the dialog or not. The default implementation of #WebKitWebView::script-dialog
+// signal sets %TRUE when the OK or Stay buttons are clicked and %FALSE otherwise.
+// It's an error to use this method with a #WebKitScriptDialog that is not of type
+// %WEBKIT_SCRIPT_DIALOG_CONFIRM or %WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM
+func (x *ScriptDialog) ConfirmSetConfirmed(ConfirmedVar bool) {
+
+	xScriptDialogConfirmSetConfirmed(x.GoPointer(), ConfirmedVar)
+
+}
+
+var xScriptDialogGetDialogType func(uintptr) ScriptDialogType
+
+// Get the dialog type of a #WebKitScriptDialog.
+func (x *ScriptDialog) GetDialogType() ScriptDialogType {
+
+	cret := xScriptDialogGetDialogType(x.GoPointer())
+	return cret
+}
+
+var xScriptDialogGetMessage func(uintptr) string
+
+// Get the message of a #WebKitScriptDialog.
+func (x *ScriptDialog) GetMessage() string {
+
+	cret := xScriptDialogGetMessage(x.GoPointer())
+	return cret
+}
+
+var xScriptDialogPromptGetDefaultText func(uintptr) string
+
+// Get the default text of a #WebKitScriptDialog of type %WEBKIT_SCRIPT_DIALOG_PROMPT.
+//
+// It's an error to use this method with a #WebKitScriptDialog that is not of type
+// %WEBKIT_SCRIPT_DIALOG_PROMPT.
+func (x *ScriptDialog) PromptGetDefaultText() string {
+
+	cret := xScriptDialogPromptGetDefaultText(x.GoPointer())
+	return cret
+}
+
+var xScriptDialogPromptSetText func(uintptr, string)
+
+// Set the text entered by the user in the dialog.
+//
+// This method is used for %WEBKIT_SCRIPT_DIALOG_PROMPT dialogs when
+// #WebKitWebView::script-dialog signal is emitted to set the text
+// entered by the user. The default implementation of #WebKitWebView::script-dialog
+// signal sets the text of the entry form when OK button is clicked, otherwise %NULL is set.
+// It's an error to use this method with a #WebKitScriptDialog that is not of type
+// %WEBKIT_SCRIPT_DIALOG_PROMPT.
+func (x *ScriptDialog) PromptSetText(TextVar string) {
+
+	xScriptDialogPromptSetText(x.GoPointer(), TextVar)
+
+}
+
+var xScriptDialogRef func(uintptr) *ScriptDialog
+
+// Atomically increments the reference count of @dialog by one.
+//
+// This
+// function is MT-safe and may be called from any thread.
+func (x *ScriptDialog) Ref() *ScriptDialog {
+
+	cret := xScriptDialogRef(x.GoPointer())
+	return cret
+}
+
+var xScriptDialogUnref func(uintptr)
+
+// Atomically decrements the reference count of @dialog by one.
+//
+// If the
+// reference count drops to 0, all memory allocated by the #WebKitScriptdialog is
+// released. This function is MT-safe and may be called from any
+// thread.
+func (x *ScriptDialog) Unref() {
+
+	xScriptDialogUnref(x.GoPointer())
+
+}
+
+// Enum values used for determining the type of #WebKitScriptDialog
+type ScriptDialogType int
+
+var xScriptDialogTypeGLibType func() types.GType
+
+func ScriptDialogTypeGLibType() types.GType {
+	return xScriptDialogTypeGLibType()
+}
+
+const (
+
+	// Alert script dialog, used to show a
+	// message to the user.
+	ScriptDialogAlertValue ScriptDialogType = 0
+	// Confirm script dialog, used to ask
+	// confirmation to the user.
+	ScriptDialogConfirmValue ScriptDialogType = 1
+	// Prompt script dialog, used to ask
+	// information to the user.
+	ScriptDialogPromptValue ScriptDialogType = 2
+	// Before unload confirm dialog,
+	// used to ask confirmation to leave the current page to the user. Since 2.12
+	ScriptDialogBeforeUnloadConfirmValue ScriptDialogType = 3
+)
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xScriptDialogTypeGLibType, libs, "webkit_script_dialog_type_get_type")
+
+	core.PuregoSafeRegister(&xScriptDialogGLibType, libs, "webkit_script_dialog_get_type")
+
+	core.PuregoSafeRegister(&xScriptDialogClose, libs, "webkit_script_dialog_close")
+	core.PuregoSafeRegister(&xScriptDialogConfirmSetConfirmed, libs, "webkit_script_dialog_confirm_set_confirmed")
+	core.PuregoSafeRegister(&xScriptDialogGetDialogType, libs, "webkit_script_dialog_get_dialog_type")
+	core.PuregoSafeRegister(&xScriptDialogGetMessage, libs, "webkit_script_dialog_get_message")
+	core.PuregoSafeRegister(&xScriptDialogPromptGetDefaultText, libs, "webkit_script_dialog_prompt_get_default_text")
+	core.PuregoSafeRegister(&xScriptDialogPromptSetText, libs, "webkit_script_dialog_prompt_set_text")
+	core.PuregoSafeRegister(&xScriptDialogRef, libs, "webkit_script_dialog_ref")
+	core.PuregoSafeRegister(&xScriptDialogUnref, libs, "webkit_script_dialog_unref")
+
+}
diff --git a/v4/webkit/WebKitSecurityManager.go b/v4/webkit/WebKitSecurityManager.go
new file mode 100644
index 0000000000000000000000000000000000000000..44d0b5a186d0e2ad3e7cd15203d6d8e127c02251
--- /dev/null
+++ b/v4/webkit/WebKitSecurityManager.go
@@ -0,0 +1,224 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type SecurityManagerClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *SecurityManagerClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Controls security settings in a #WebKitWebContext.
+//
+// The #WebKitSecurityManager defines security settings for URI
+// schemes in a #WebKitWebContext. Get it from the context with
+// webkit_web_context_get_security_manager(), and use it to register a
+// URI scheme with a certain security level, or to check if it already
+// has it.
+type SecurityManager struct {
+	gobject.Object
+}
+
+var xSecurityManagerGLibType func() types.GType
+
+func SecurityManagerGLibType() types.GType {
+	return xSecurityManagerGLibType()
+}
+
+func SecurityManagerNewFromInternalPtr(ptr uintptr) *SecurityManager {
+	cls := &SecurityManager{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xSecurityManagerRegisterUriSchemeAsCorsEnabled func(uintptr, string)
+
+// Register @scheme as a CORS (Cross-origin resource sharing) enabled scheme.
+//
+// This means that CORS requests are allowed. See W3C CORS specification
+// http://www.w3.org/TR/cors/.
+func (x *SecurityManager) RegisterUriSchemeAsCorsEnabled(SchemeVar string) {
+
+	xSecurityManagerRegisterUriSchemeAsCorsEnabled(x.GoPointer(), SchemeVar)
+
+}
+
+var xSecurityManagerRegisterUriSchemeAsDisplayIsolated func(uintptr, string)
+
+// Register @scheme as a display isolated scheme.
+//
+// This means that pages cannot
+// display these URIs unless they are from the same scheme.
+func (x *SecurityManager) RegisterUriSchemeAsDisplayIsolated(SchemeVar string) {
+
+	xSecurityManagerRegisterUriSchemeAsDisplayIsolated(x.GoPointer(), SchemeVar)
+
+}
+
+var xSecurityManagerRegisterUriSchemeAsEmptyDocument func(uintptr, string)
+
+// Register @scheme as an empty document scheme.
+//
+// This means that
+// they are allowed to commit synchronously.
+func (x *SecurityManager) RegisterUriSchemeAsEmptyDocument(SchemeVar string) {
+
+	xSecurityManagerRegisterUriSchemeAsEmptyDocument(x.GoPointer(), SchemeVar)
+
+}
+
+var xSecurityManagerRegisterUriSchemeAsLocal func(uintptr, string)
+
+// Register @scheme as a local scheme.
+//
+// This means that other non-local pages
+// cannot link to or access URIs of this scheme.
+func (x *SecurityManager) RegisterUriSchemeAsLocal(SchemeVar string) {
+
+	xSecurityManagerRegisterUriSchemeAsLocal(x.GoPointer(), SchemeVar)
+
+}
+
+var xSecurityManagerRegisterUriSchemeAsNoAccess func(uintptr, string)
+
+// Register @scheme as a no-access scheme.
+//
+// This means that pages loaded
+// with this URI scheme cannot access pages loaded with any other URI scheme.
+func (x *SecurityManager) RegisterUriSchemeAsNoAccess(SchemeVar string) {
+
+	xSecurityManagerRegisterUriSchemeAsNoAccess(x.GoPointer(), SchemeVar)
+
+}
+
+var xSecurityManagerRegisterUriSchemeAsSecure func(uintptr, string)
+
+// Register @scheme as a secure scheme.
+//
+// This means that mixed
+// content warnings won't be generated for this scheme when
+// included by an HTTPS page.
+func (x *SecurityManager) RegisterUriSchemeAsSecure(SchemeVar string) {
+
+	xSecurityManagerRegisterUriSchemeAsSecure(x.GoPointer(), SchemeVar)
+
+}
+
+var xSecurityManagerUriSchemeIsCorsEnabled func(uintptr, string) bool
+
+// Whether @scheme is considered as a CORS enabled scheme.
+//
+// See also webkit_security_manager_register_uri_scheme_as_cors_enabled().
+func (x *SecurityManager) UriSchemeIsCorsEnabled(SchemeVar string) bool {
+
+	cret := xSecurityManagerUriSchemeIsCorsEnabled(x.GoPointer(), SchemeVar)
+	return cret
+}
+
+var xSecurityManagerUriSchemeIsDisplayIsolated func(uintptr, string) bool
+
+// Whether @scheme is considered as a display isolated scheme.
+//
+// See also webkit_security_manager_register_uri_scheme_as_display_isolated().
+func (x *SecurityManager) UriSchemeIsDisplayIsolated(SchemeVar string) bool {
+
+	cret := xSecurityManagerUriSchemeIsDisplayIsolated(x.GoPointer(), SchemeVar)
+	return cret
+}
+
+var xSecurityManagerUriSchemeIsEmptyDocument func(uintptr, string) bool
+
+// Whether @scheme is considered as an empty document scheme.
+//
+// See also webkit_security_manager_register_uri_scheme_as_empty_document().
+func (x *SecurityManager) UriSchemeIsEmptyDocument(SchemeVar string) bool {
+
+	cret := xSecurityManagerUriSchemeIsEmptyDocument(x.GoPointer(), SchemeVar)
+	return cret
+}
+
+var xSecurityManagerUriSchemeIsLocal func(uintptr, string) bool
+
+// Whether @scheme is considered as a local scheme.
+//
+// See also webkit_security_manager_register_uri_scheme_as_local().
+func (x *SecurityManager) UriSchemeIsLocal(SchemeVar string) bool {
+
+	cret := xSecurityManagerUriSchemeIsLocal(x.GoPointer(), SchemeVar)
+	return cret
+}
+
+var xSecurityManagerUriSchemeIsNoAccess func(uintptr, string) bool
+
+// Whether @scheme is considered as a no-access scheme.
+//
+// See also webkit_security_manager_register_uri_scheme_as_no_access().
+func (x *SecurityManager) UriSchemeIsNoAccess(SchemeVar string) bool {
+
+	cret := xSecurityManagerUriSchemeIsNoAccess(x.GoPointer(), SchemeVar)
+	return cret
+}
+
+var xSecurityManagerUriSchemeIsSecure func(uintptr, string) bool
+
+// Whether @scheme is considered as a secure scheme.
+//
+// See also webkit_security_manager_register_uri_scheme_as_secure().
+func (x *SecurityManager) UriSchemeIsSecure(SchemeVar string) bool {
+
+	cret := xSecurityManagerUriSchemeIsSecure(x.GoPointer(), SchemeVar)
+	return cret
+}
+
+func (c *SecurityManager) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *SecurityManager) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xSecurityManagerGLibType, libs, "webkit_security_manager_get_type")
+
+	core.PuregoSafeRegister(&xSecurityManagerRegisterUriSchemeAsCorsEnabled, libs, "webkit_security_manager_register_uri_scheme_as_cors_enabled")
+	core.PuregoSafeRegister(&xSecurityManagerRegisterUriSchemeAsDisplayIsolated, libs, "webkit_security_manager_register_uri_scheme_as_display_isolated")
+	core.PuregoSafeRegister(&xSecurityManagerRegisterUriSchemeAsEmptyDocument, libs, "webkit_security_manager_register_uri_scheme_as_empty_document")
+	core.PuregoSafeRegister(&xSecurityManagerRegisterUriSchemeAsLocal, libs, "webkit_security_manager_register_uri_scheme_as_local")
+	core.PuregoSafeRegister(&xSecurityManagerRegisterUriSchemeAsNoAccess, libs, "webkit_security_manager_register_uri_scheme_as_no_access")
+	core.PuregoSafeRegister(&xSecurityManagerRegisterUriSchemeAsSecure, libs, "webkit_security_manager_register_uri_scheme_as_secure")
+	core.PuregoSafeRegister(&xSecurityManagerUriSchemeIsCorsEnabled, libs, "webkit_security_manager_uri_scheme_is_cors_enabled")
+	core.PuregoSafeRegister(&xSecurityManagerUriSchemeIsDisplayIsolated, libs, "webkit_security_manager_uri_scheme_is_display_isolated")
+	core.PuregoSafeRegister(&xSecurityManagerUriSchemeIsEmptyDocument, libs, "webkit_security_manager_uri_scheme_is_empty_document")
+	core.PuregoSafeRegister(&xSecurityManagerUriSchemeIsLocal, libs, "webkit_security_manager_uri_scheme_is_local")
+	core.PuregoSafeRegister(&xSecurityManagerUriSchemeIsNoAccess, libs, "webkit_security_manager_uri_scheme_is_no_access")
+	core.PuregoSafeRegister(&xSecurityManagerUriSchemeIsSecure, libs, "webkit_security_manager_uri_scheme_is_secure")
+
+}
diff --git a/v4/webkit/WebKitSecurityOrigin.go b/v4/webkit/WebKitSecurityOrigin.go
new file mode 100644
index 0000000000000000000000000000000000000000..78bc258d01ff2792e0d3988ddb644e5f4ee2b3a8
--- /dev/null
+++ b/v4/webkit/WebKitSecurityOrigin.go
@@ -0,0 +1,157 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// A security boundary for websites.
+//
+// #WebKitSecurityOrigin is a representation of a security domain
+// defined by websites. A security origin consists of a protocol, a
+// hostname, and an optional port number.
+//
+// Resources with the same security origin can generally access each
+// other for client-side scripting or database access. When comparing
+// origins, beware that if both protocol and host are %NULL, the origins
+// should not be treated as equal.
+type SecurityOrigin struct {
+	_ structs.HostLayout
+}
+
+var xSecurityOriginGLibType func() types.GType
+
+func SecurityOriginGLibType() types.GType {
+	return xSecurityOriginGLibType()
+}
+
+func (x *SecurityOrigin) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewSecurityOrigin func(string, string, uint16) *SecurityOrigin
+
+// Create a new security origin from the provided protocol, host and
+// port.
+func NewSecurityOrigin(ProtocolVar string, HostVar string, PortVar uint16) *SecurityOrigin {
+
+	cret := xNewSecurityOrigin(ProtocolVar, HostVar, PortVar)
+	return cret
+}
+
+var xNewSecurityOriginForUri func(string) *SecurityOrigin
+
+// Create a new security origin from the provided.
+//
+// Create a new security origin from the provided URI. Components of
+// @uri other than protocol, host, and port do not affect the created
+// #WebKitSecurityOrigin.
+func NewSecurityOriginForUri(UriVar string) *SecurityOrigin {
+
+	cret := xNewSecurityOriginForUri(UriVar)
+	return cret
+}
+
+var xSecurityOriginGetHost func(uintptr) string
+
+// Gets the hostname of @origin.
+//
+// It is reasonable for this to be %NULL
+// if its protocol does not require a host component.
+func (x *SecurityOrigin) GetHost() string {
+
+	cret := xSecurityOriginGetHost(x.GoPointer())
+	return cret
+}
+
+var xSecurityOriginGetPort func(uintptr) uint16
+
+// Gets the port of @origin.
+//
+// This function will always return 0 if the
+// port is the default port for the given protocol. For example,
+// http://example.com has the same security origin as
+// http://example.com:80, and this function will return 0 for a
+// #WebKitSecurityOrigin constructed from either URI.
+func (x *SecurityOrigin) GetPort() uint16 {
+
+	cret := xSecurityOriginGetPort(x.GoPointer())
+	return cret
+}
+
+var xSecurityOriginGetProtocol func(uintptr) string
+
+// Gets the protocol of @origin.
+func (x *SecurityOrigin) GetProtocol() string {
+
+	cret := xSecurityOriginGetProtocol(x.GoPointer())
+	return cret
+}
+
+var xSecurityOriginRef func(uintptr) *SecurityOrigin
+
+// Atomically increments the reference count of @origin by one.
+//
+// This function is MT-safe and may be called from any thread.
+func (x *SecurityOrigin) Ref() *SecurityOrigin {
+
+	cret := xSecurityOriginRef(x.GoPointer())
+	return cret
+}
+
+var xSecurityOriginToString func(uintptr) string
+
+// Gets a string representation of @origin.
+//
+// The string representation
+// is a valid URI with only protocol, host, and port components, or
+// %NULL.
+func (x *SecurityOrigin) ToString() string {
+
+	cret := xSecurityOriginToString(x.GoPointer())
+	return cret
+}
+
+var xSecurityOriginUnref func(uintptr)
+
+// Atomically decrements the reference count of @origin by one.
+//
+// If the reference count drops to 0, all memory allocated by
+// #WebKitSecurityOrigin is released. This function is MT-safe and may be
+// called from any thread.
+func (x *SecurityOrigin) Unref() {
+
+	xSecurityOriginUnref(x.GoPointer())
+
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xSecurityOriginGLibType, libs, "webkit_security_origin_get_type")
+
+	core.PuregoSafeRegister(&xNewSecurityOrigin, libs, "webkit_security_origin_new")
+	core.PuregoSafeRegister(&xNewSecurityOriginForUri, libs, "webkit_security_origin_new_for_uri")
+
+	core.PuregoSafeRegister(&xSecurityOriginGetHost, libs, "webkit_security_origin_get_host")
+	core.PuregoSafeRegister(&xSecurityOriginGetPort, libs, "webkit_security_origin_get_port")
+	core.PuregoSafeRegister(&xSecurityOriginGetProtocol, libs, "webkit_security_origin_get_protocol")
+	core.PuregoSafeRegister(&xSecurityOriginRef, libs, "webkit_security_origin_ref")
+	core.PuregoSafeRegister(&xSecurityOriginToString, libs, "webkit_security_origin_to_string")
+	core.PuregoSafeRegister(&xSecurityOriginUnref, libs, "webkit_security_origin_unref")
+
+}
diff --git a/v4/webkit/WebKitSettings.go b/v4/webkit/WebKitSettings.go
new file mode 100644
index 0000000000000000000000000000000000000000..657c2e64b1117a52801fae77739ee191c1adba85
--- /dev/null
+++ b/v4/webkit/WebKitSettings.go
@@ -0,0 +1,2623 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type SettingsClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *SettingsClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values used for determining the hardware acceleration policy.
+type HardwareAccelerationPolicy int
+
+var xHardwareAccelerationPolicyGLibType func() types.GType
+
+func HardwareAccelerationPolicyGLibType() types.GType {
+	return xHardwareAccelerationPolicyGLibType()
+}
+
+const (
+
+	// Hardware acceleration is always enabled, even for websites not requesting it.
+	HardwareAccelerationPolicyAlwaysValue HardwareAccelerationPolicy = 0
+	// Hardware acceleration is always disabled, even for websites requesting it.
+	HardwareAccelerationPolicyNeverValue HardwareAccelerationPolicy = 1
+)
+
+// Control the behaviour of a #WebKitWebView.
+//
+// #WebKitSettings can be applied to a #WebKitWebView to control text charset,
+// color, font sizes, printing mode, script support, loading of images and various
+// other things on a #WebKitWebView. After creation, a #WebKitSettings object
+// contains default settings.
+//
+// ```c
+// // Disable JavaScript
+// WebKitSettings *settings = webkit_web_view_group_get_settings (my_view_group);
+// webkit_settings_set_enable_javascript (settings, FALSE);
+// ```
+type Settings struct {
+	gobject.Object
+}
+
+var xSettingsGLibType func() types.GType
+
+func SettingsGLibType() types.GType {
+	return xSettingsGLibType()
+}
+
+func SettingsNewFromInternalPtr(ptr uintptr) *Settings {
+	cls := &Settings{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewSettings func() uintptr
+
+// Creates a new #WebKitSettings instance with default values.
+//
+// It must be manually attached to a #WebKitWebView.
+// See also webkit_settings_new_with_settings().
+func NewSettings() *Settings {
+	var cls *Settings
+
+	cret := xNewSettings()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Settings{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewSettingsWithSettings func(string, ...interface{}) uintptr
+
+// Creates a new #WebKitSettings instance with the given settings.
+//
+// It must be manually attached to a #WebKitWebView.
+func NewSettingsWithSettings(FirstSettingNameVar string, varArgs ...interface{}) *Settings {
+	var cls *Settings
+
+	cret := xNewSettingsWithSettings(FirstSettingNameVar, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Settings{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xSettingsApplyFromKeyFile func(uintptr, *glib.KeyFile, string, **glib.Error) bool
+
+// Reads the contents of the given @group_name from the given @key_file and apply the value of
+// each key/value to the corresponding property on the @settings.
+//
+// Value types have to match with the corresponding setting property type and the group keys have to
+// match existing setting property names. If those conditions are not met, the function will return
+// %FALSE.
+//
+// Supported value types are strings (unquoted), booleans (0, 1, true, false) and unsigned integers.
+func (x *Settings) ApplyFromKeyFile(KeyFileVar *glib.KeyFile, GroupNameVar string) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xSettingsApplyFromKeyFile(x.GoPointer(), KeyFileVar, GroupNameVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xSettingsGetAllowFileAccessFromFileUrls func(uintptr) bool
+
+// Get the #WebKitSettings:allow-file-access-from-file-urls property.
+func (x *Settings) GetAllowFileAccessFromFileUrls() bool {
+
+	cret := xSettingsGetAllowFileAccessFromFileUrls(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetAllowModalDialogs func(uintptr) bool
+
+// Get the #WebKitSettings:allow-modal-dialogs property.
+func (x *Settings) GetAllowModalDialogs() bool {
+
+	cret := xSettingsGetAllowModalDialogs(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetAllowTopNavigationToDataUrls func(uintptr) bool
+
+// Get the #WebKitSettings:allow-top-navigation-to-data-urls property.
+func (x *Settings) GetAllowTopNavigationToDataUrls() bool {
+
+	cret := xSettingsGetAllowTopNavigationToDataUrls(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetAllowUniversalAccessFromFileUrls func(uintptr) bool
+
+// Get the #WebKitSettings:allow-universal-access-from-file-urls property.
+func (x *Settings) GetAllowUniversalAccessFromFileUrls() bool {
+
+	cret := xSettingsGetAllowUniversalAccessFromFileUrls(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetAutoLoadImages func(uintptr) bool
+
+// Get the #WebKitSettings:auto-load-images property.
+func (x *Settings) GetAutoLoadImages() bool {
+
+	cret := xSettingsGetAutoLoadImages(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetCursiveFontFamily func(uintptr) string
+
+// Gets the #WebKitSettings:cursive-font-family property.
+func (x *Settings) GetCursiveFontFamily() string {
+
+	cret := xSettingsGetCursiveFontFamily(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetDefaultCharset func(uintptr) string
+
+// Gets the #WebKitSettings:default-charset property.
+func (x *Settings) GetDefaultCharset() string {
+
+	cret := xSettingsGetDefaultCharset(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetDefaultFontFamily func(uintptr) string
+
+// Gets the #WebKitSettings:default-font-family property.
+func (x *Settings) GetDefaultFontFamily() string {
+
+	cret := xSettingsGetDefaultFontFamily(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetDefaultFontSize func(uintptr) uint32
+
+// Gets the #WebKitSettings:default-font-size property.
+func (x *Settings) GetDefaultFontSize() uint32 {
+
+	cret := xSettingsGetDefaultFontSize(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetDefaultMonospaceFontSize func(uintptr) uint32
+
+// Gets the #WebKitSettings:default-monospace-font-size property.
+func (x *Settings) GetDefaultMonospaceFontSize() uint32 {
+
+	cret := xSettingsGetDefaultMonospaceFontSize(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetDisableWebSecurity func(uintptr) bool
+
+// Get the #WebKitSettings:disable-web-security property.
+func (x *Settings) GetDisableWebSecurity() bool {
+
+	cret := xSettingsGetDisableWebSecurity(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetDrawCompositingIndicators func(uintptr) bool
+
+// Get the #WebKitSettings:draw-compositing-indicators property.
+func (x *Settings) GetDrawCompositingIndicators() bool {
+
+	cret := xSettingsGetDrawCompositingIndicators(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnable2dCanvasAcceleration func(uintptr) bool
+
+// Get the #WebKitSettings:enable-2d-canvas-acceleration property.
+func (x *Settings) GetEnable2dCanvasAcceleration() bool {
+
+	cret := xSettingsGetEnable2dCanvasAcceleration(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableBackForwardNavigationGestures func(uintptr) bool
+
+// Get the #WebKitSettings:enable-back-forward-navigation-gestures property.
+func (x *Settings) GetEnableBackForwardNavigationGestures() bool {
+
+	cret := xSettingsGetEnableBackForwardNavigationGestures(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableCaretBrowsing func(uintptr) bool
+
+// Get the #WebKitSettings:enable-caret-browsing property.
+func (x *Settings) GetEnableCaretBrowsing() bool {
+
+	cret := xSettingsGetEnableCaretBrowsing(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableDeveloperExtras func(uintptr) bool
+
+// Get the #WebKitSettings:enable-developer-extras property.
+func (x *Settings) GetEnableDeveloperExtras() bool {
+
+	cret := xSettingsGetEnableDeveloperExtras(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableDnsPrefetching func(uintptr) bool
+
+// Get the #WebKitSettings:enable-dns-prefetching property.
+func (x *Settings) GetEnableDnsPrefetching() bool {
+
+	cret := xSettingsGetEnableDnsPrefetching(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableEncryptedMedia func(uintptr) bool
+
+// Get the #WebKitSettings:enable-encrypted-media property.
+func (x *Settings) GetEnableEncryptedMedia() bool {
+
+	cret := xSettingsGetEnableEncryptedMedia(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableFullscreen func(uintptr) bool
+
+// Get the #WebKitSettings:enable-fullscreen property.
+func (x *Settings) GetEnableFullscreen() bool {
+
+	cret := xSettingsGetEnableFullscreen(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableHtml5Database func(uintptr) bool
+
+// Get the #WebKitSettings:enable-html5-database property.
+func (x *Settings) GetEnableHtml5Database() bool {
+
+	cret := xSettingsGetEnableHtml5Database(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableHtml5LocalStorage func(uintptr) bool
+
+// Get the #WebKitSettings:enable-html5-local-storage property.
+func (x *Settings) GetEnableHtml5LocalStorage() bool {
+
+	cret := xSettingsGetEnableHtml5LocalStorage(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableHyperlinkAuditing func(uintptr) bool
+
+// Get the #WebKitSettings:enable-hyperlink-auditing property.
+func (x *Settings) GetEnableHyperlinkAuditing() bool {
+
+	cret := xSettingsGetEnableHyperlinkAuditing(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableJavascript func(uintptr) bool
+
+// Get the #WebKitSettings:enable-javascript property.
+func (x *Settings) GetEnableJavascript() bool {
+
+	cret := xSettingsGetEnableJavascript(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableJavascriptMarkup func(uintptr) bool
+
+// Get the #WebKitSettings:enable-javascript-markup property.
+func (x *Settings) GetEnableJavascriptMarkup() bool {
+
+	cret := xSettingsGetEnableJavascriptMarkup(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableMedia func(uintptr) bool
+
+// Get the #WebKitSettings:enable-media property.
+func (x *Settings) GetEnableMedia() bool {
+
+	cret := xSettingsGetEnableMedia(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableMediaCapabilities func(uintptr) bool
+
+// Get the #WebKitSettings:enable-media-capabilities property.
+func (x *Settings) GetEnableMediaCapabilities() bool {
+
+	cret := xSettingsGetEnableMediaCapabilities(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableMediaStream func(uintptr) bool
+
+// Get the #WebKitSettings:enable-media-stream property.
+func (x *Settings) GetEnableMediaStream() bool {
+
+	cret := xSettingsGetEnableMediaStream(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableMediasource func(uintptr) bool
+
+// Get the #WebKitSettings:enable-mediasource property.
+func (x *Settings) GetEnableMediasource() bool {
+
+	cret := xSettingsGetEnableMediasource(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableMockCaptureDevices func(uintptr) bool
+
+// Get the #WebKitSettings:enable-mock-capture-devices property.
+func (x *Settings) GetEnableMockCaptureDevices() bool {
+
+	cret := xSettingsGetEnableMockCaptureDevices(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableOfflineWebApplicationCache func(uintptr) bool
+
+// Get the #WebKitSettings:enable-offline-web-application-cache property.
+func (x *Settings) GetEnableOfflineWebApplicationCache() bool {
+
+	cret := xSettingsGetEnableOfflineWebApplicationCache(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnablePageCache func(uintptr) bool
+
+// Get the #WebKitSettings:enable-page-cache property.
+func (x *Settings) GetEnablePageCache() bool {
+
+	cret := xSettingsGetEnablePageCache(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableResizableTextAreas func(uintptr) bool
+
+// Get the #WebKitSettings:enable-resizable-text-areas property.
+func (x *Settings) GetEnableResizableTextAreas() bool {
+
+	cret := xSettingsGetEnableResizableTextAreas(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableSiteSpecificQuirks func(uintptr) bool
+
+// Get the #WebKitSettings:enable-site-specific-quirks property.
+func (x *Settings) GetEnableSiteSpecificQuirks() bool {
+
+	cret := xSettingsGetEnableSiteSpecificQuirks(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableSmoothScrolling func(uintptr) bool
+
+// Get the #WebKitSettings:enable-smooth-scrolling property.
+func (x *Settings) GetEnableSmoothScrolling() bool {
+
+	cret := xSettingsGetEnableSmoothScrolling(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableSpatialNavigation func(uintptr) bool
+
+// Get the #WebKitSettings:enable-spatial-navigation property.
+func (x *Settings) GetEnableSpatialNavigation() bool {
+
+	cret := xSettingsGetEnableSpatialNavigation(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableTabsToLinks func(uintptr) bool
+
+// Get the #WebKitSettings:enable-tabs-to-links property.
+func (x *Settings) GetEnableTabsToLinks() bool {
+
+	cret := xSettingsGetEnableTabsToLinks(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableWebaudio func(uintptr) bool
+
+// Get the #WebKitSettings:enable-webaudio property.
+func (x *Settings) GetEnableWebaudio() bool {
+
+	cret := xSettingsGetEnableWebaudio(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableWebgl func(uintptr) bool
+
+// Get the #WebKitSettings:enable-webgl property.
+func (x *Settings) GetEnableWebgl() bool {
+
+	cret := xSettingsGetEnableWebgl(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableWebrtc func(uintptr) bool
+
+// Get the [property@Settings:enable-webrtc] property.
+func (x *Settings) GetEnableWebrtc() bool {
+
+	cret := xSettingsGetEnableWebrtc(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetEnableWriteConsoleMessagesToStdout func(uintptr) bool
+
+// Get the #WebKitSettings:enable-write-console-messages-to-stdout property.
+func (x *Settings) GetEnableWriteConsoleMessagesToStdout() bool {
+
+	cret := xSettingsGetEnableWriteConsoleMessagesToStdout(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetFantasyFontFamily func(uintptr) string
+
+// Gets the #WebKitSettings:fantasy-font-family property.
+func (x *Settings) GetFantasyFontFamily() string {
+
+	cret := xSettingsGetFantasyFontFamily(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetFeatureEnabled func(uintptr, *Feature) bool
+
+// Gets whether a feature is enabled.
+func (x *Settings) GetFeatureEnabled(FeatureVar *Feature) bool {
+
+	cret := xSettingsGetFeatureEnabled(x.GoPointer(), FeatureVar)
+	return cret
+}
+
+var xSettingsGetHardwareAccelerationPolicy func(uintptr) HardwareAccelerationPolicy
+
+// Get the #WebKitSettings:hardware-acceleration-policy property.
+func (x *Settings) GetHardwareAccelerationPolicy() HardwareAccelerationPolicy {
+
+	cret := xSettingsGetHardwareAccelerationPolicy(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetJavascriptCanAccessClipboard func(uintptr) bool
+
+// Get the #WebKitSettings:javascript-can-access-clipboard property.
+func (x *Settings) GetJavascriptCanAccessClipboard() bool {
+
+	cret := xSettingsGetJavascriptCanAccessClipboard(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetJavascriptCanOpenWindowsAutomatically func(uintptr) bool
+
+// Get the #WebKitSettings:javascript-can-open-windows-automatically property.
+func (x *Settings) GetJavascriptCanOpenWindowsAutomatically() bool {
+
+	cret := xSettingsGetJavascriptCanOpenWindowsAutomatically(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetLoadIconsIgnoringImageLoadSetting func(uintptr) bool
+
+// Setting no longer supported. This function returns %FALSE.
+func (x *Settings) GetLoadIconsIgnoringImageLoadSetting() bool {
+
+	cret := xSettingsGetLoadIconsIgnoringImageLoadSetting(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetMediaContentTypesRequiringHardwareSupport func(uintptr) string
+
+// Gets the #WebKitSettings:media-content-types-requiring-hardware-support property.
+func (x *Settings) GetMediaContentTypesRequiringHardwareSupport() string {
+
+	cret := xSettingsGetMediaContentTypesRequiringHardwareSupport(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetMediaPlaybackAllowsInline func(uintptr) bool
+
+// Get the #WebKitSettings:media-playback-allows-inline property.
+func (x *Settings) GetMediaPlaybackAllowsInline() bool {
+
+	cret := xSettingsGetMediaPlaybackAllowsInline(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetMediaPlaybackRequiresUserGesture func(uintptr) bool
+
+// Get the #WebKitSettings:media-playback-requires-user-gesture property.
+func (x *Settings) GetMediaPlaybackRequiresUserGesture() bool {
+
+	cret := xSettingsGetMediaPlaybackRequiresUserGesture(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetMinimumFontSize func(uintptr) uint32
+
+// Gets the #WebKitSettings:minimum-font-size property.
+func (x *Settings) GetMinimumFontSize() uint32 {
+
+	cret := xSettingsGetMinimumFontSize(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetMonospaceFontFamily func(uintptr) string
+
+// Gets the #WebKitSettings:monospace-font-family property.
+func (x *Settings) GetMonospaceFontFamily() string {
+
+	cret := xSettingsGetMonospaceFontFamily(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetPictographFontFamily func(uintptr) string
+
+// Gets the #WebKitSettings:pictograph-font-family property.
+func (x *Settings) GetPictographFontFamily() string {
+
+	cret := xSettingsGetPictographFontFamily(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetPrintBackgrounds func(uintptr) bool
+
+// Get the #WebKitSettings:print-backgrounds property.
+func (x *Settings) GetPrintBackgrounds() bool {
+
+	cret := xSettingsGetPrintBackgrounds(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetSansSerifFontFamily func(uintptr) string
+
+// Gets the #WebKitSettings:sans-serif-font-family property.
+func (x *Settings) GetSansSerifFontFamily() string {
+
+	cret := xSettingsGetSansSerifFontFamily(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetSerifFontFamily func(uintptr) string
+
+// Gets the #WebKitSettings:serif-font-family property.
+func (x *Settings) GetSerifFontFamily() string {
+
+	cret := xSettingsGetSerifFontFamily(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetUserAgent func(uintptr) string
+
+// Get the #WebKitSettings:user-agent property.
+func (x *Settings) GetUserAgent() string {
+
+	cret := xSettingsGetUserAgent(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetWebrtcUdpPortsRange func(uintptr) string
+
+// Get the [property@Settings:webrtc-udp-ports-range] property.
+func (x *Settings) GetWebrtcUdpPortsRange() string {
+
+	cret := xSettingsGetWebrtcUdpPortsRange(x.GoPointer())
+	return cret
+}
+
+var xSettingsGetZoomTextOnly func(uintptr) bool
+
+// Get the #WebKitSettings:zoom-text-only property.
+func (x *Settings) GetZoomTextOnly() bool {
+
+	cret := xSettingsGetZoomTextOnly(x.GoPointer())
+	return cret
+}
+
+var xSettingsSetAllowFileAccessFromFileUrls func(uintptr, bool)
+
+// Set the #WebKitSettings:allow-file-access-from-file-urls property.
+func (x *Settings) SetAllowFileAccessFromFileUrls(AllowedVar bool) {
+
+	xSettingsSetAllowFileAccessFromFileUrls(x.GoPointer(), AllowedVar)
+
+}
+
+var xSettingsSetAllowModalDialogs func(uintptr, bool)
+
+// Set the #WebKitSettings:allow-modal-dialogs property.
+func (x *Settings) SetAllowModalDialogs(AllowedVar bool) {
+
+	xSettingsSetAllowModalDialogs(x.GoPointer(), AllowedVar)
+
+}
+
+var xSettingsSetAllowTopNavigationToDataUrls func(uintptr, bool)
+
+// Set the #WebKitSettings:allow-top-navigation-to-data-urls property.
+func (x *Settings) SetAllowTopNavigationToDataUrls(AllowedVar bool) {
+
+	xSettingsSetAllowTopNavigationToDataUrls(x.GoPointer(), AllowedVar)
+
+}
+
+var xSettingsSetAllowUniversalAccessFromFileUrls func(uintptr, bool)
+
+// Set the #WebKitSettings:allow-universal-access-from-file-urls property.
+func (x *Settings) SetAllowUniversalAccessFromFileUrls(AllowedVar bool) {
+
+	xSettingsSetAllowUniversalAccessFromFileUrls(x.GoPointer(), AllowedVar)
+
+}
+
+var xSettingsSetAutoLoadImages func(uintptr, bool)
+
+// Set the #WebKitSettings:auto-load-images property.
+func (x *Settings) SetAutoLoadImages(EnabledVar bool) {
+
+	xSettingsSetAutoLoadImages(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetCursiveFontFamily func(uintptr, string)
+
+// Set the #WebKitSettings:cursive-font-family property.
+func (x *Settings) SetCursiveFontFamily(CursiveFontFamilyVar string) {
+
+	xSettingsSetCursiveFontFamily(x.GoPointer(), CursiveFontFamilyVar)
+
+}
+
+var xSettingsSetDefaultCharset func(uintptr, string)
+
+// Set the #WebKitSettings:default-charset property.
+func (x *Settings) SetDefaultCharset(DefaultCharsetVar string) {
+
+	xSettingsSetDefaultCharset(x.GoPointer(), DefaultCharsetVar)
+
+}
+
+var xSettingsSetDefaultFontFamily func(uintptr, string)
+
+// Set the #WebKitSettings:default-font-family property.
+func (x *Settings) SetDefaultFontFamily(DefaultFontFamilyVar string) {
+
+	xSettingsSetDefaultFontFamily(x.GoPointer(), DefaultFontFamilyVar)
+
+}
+
+var xSettingsSetDefaultFontSize func(uintptr, uint32)
+
+// Set the #WebKitSettings:default-font-size property.
+func (x *Settings) SetDefaultFontSize(FontSizeVar uint32) {
+
+	xSettingsSetDefaultFontSize(x.GoPointer(), FontSizeVar)
+
+}
+
+var xSettingsSetDefaultMonospaceFontSize func(uintptr, uint32)
+
+// Set the #WebKitSettings:default-monospace-font-size property.
+func (x *Settings) SetDefaultMonospaceFontSize(FontSizeVar uint32) {
+
+	xSettingsSetDefaultMonospaceFontSize(x.GoPointer(), FontSizeVar)
+
+}
+
+var xSettingsSetDisableWebSecurity func(uintptr, bool)
+
+// Set the #WebKitSettings:disable-web-security property.
+func (x *Settings) SetDisableWebSecurity(DisabledVar bool) {
+
+	xSettingsSetDisableWebSecurity(x.GoPointer(), DisabledVar)
+
+}
+
+var xSettingsSetDrawCompositingIndicators func(uintptr, bool)
+
+// Set the #WebKitSettings:draw-compositing-indicators property.
+func (x *Settings) SetDrawCompositingIndicators(EnabledVar bool) {
+
+	xSettingsSetDrawCompositingIndicators(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnable2dCanvasAcceleration func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-2d-canvas-acceleration property.
+func (x *Settings) SetEnable2dCanvasAcceleration(EnabledVar bool) {
+
+	xSettingsSetEnable2dCanvasAcceleration(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableBackForwardNavigationGestures func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-back-forward-navigation-gestures property.
+func (x *Settings) SetEnableBackForwardNavigationGestures(EnabledVar bool) {
+
+	xSettingsSetEnableBackForwardNavigationGestures(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableCaretBrowsing func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-caret-browsing property.
+func (x *Settings) SetEnableCaretBrowsing(EnabledVar bool) {
+
+	xSettingsSetEnableCaretBrowsing(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableDeveloperExtras func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-developer-extras property.
+func (x *Settings) SetEnableDeveloperExtras(EnabledVar bool) {
+
+	xSettingsSetEnableDeveloperExtras(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableDnsPrefetching func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-dns-prefetching property.
+func (x *Settings) SetEnableDnsPrefetching(EnabledVar bool) {
+
+	xSettingsSetEnableDnsPrefetching(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableEncryptedMedia func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-encrypted-media property.
+func (x *Settings) SetEnableEncryptedMedia(EnabledVar bool) {
+
+	xSettingsSetEnableEncryptedMedia(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableFullscreen func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-fullscreen property.
+func (x *Settings) SetEnableFullscreen(EnabledVar bool) {
+
+	xSettingsSetEnableFullscreen(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableHtml5Database func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-html5-database property.
+func (x *Settings) SetEnableHtml5Database(EnabledVar bool) {
+
+	xSettingsSetEnableHtml5Database(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableHtml5LocalStorage func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-html5-local-storage property.
+func (x *Settings) SetEnableHtml5LocalStorage(EnabledVar bool) {
+
+	xSettingsSetEnableHtml5LocalStorage(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableHyperlinkAuditing func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-hyperlink-auditing property.
+func (x *Settings) SetEnableHyperlinkAuditing(EnabledVar bool) {
+
+	xSettingsSetEnableHyperlinkAuditing(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableJavascript func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-javascript property.
+func (x *Settings) SetEnableJavascript(EnabledVar bool) {
+
+	xSettingsSetEnableJavascript(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableJavascriptMarkup func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-javascript-markup property.
+func (x *Settings) SetEnableJavascriptMarkup(EnabledVar bool) {
+
+	xSettingsSetEnableJavascriptMarkup(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableMedia func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-media property.
+func (x *Settings) SetEnableMedia(EnabledVar bool) {
+
+	xSettingsSetEnableMedia(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableMediaCapabilities func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-media-capabilities property.
+func (x *Settings) SetEnableMediaCapabilities(EnabledVar bool) {
+
+	xSettingsSetEnableMediaCapabilities(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableMediaStream func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-media-stream property.
+func (x *Settings) SetEnableMediaStream(EnabledVar bool) {
+
+	xSettingsSetEnableMediaStream(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableMediasource func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-mediasource property.
+func (x *Settings) SetEnableMediasource(EnabledVar bool) {
+
+	xSettingsSetEnableMediasource(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableMockCaptureDevices func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-mock-capture-devices property.
+func (x *Settings) SetEnableMockCaptureDevices(EnabledVar bool) {
+
+	xSettingsSetEnableMockCaptureDevices(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableOfflineWebApplicationCache func(uintptr, bool)
+
+// Setting no longer supported. This function does nothing.
+func (x *Settings) SetEnableOfflineWebApplicationCache(EnabledVar bool) {
+
+	xSettingsSetEnableOfflineWebApplicationCache(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnablePageCache func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-page-cache property.
+func (x *Settings) SetEnablePageCache(EnabledVar bool) {
+
+	xSettingsSetEnablePageCache(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableResizableTextAreas func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-resizable-text-areas property.
+func (x *Settings) SetEnableResizableTextAreas(EnabledVar bool) {
+
+	xSettingsSetEnableResizableTextAreas(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableSiteSpecificQuirks func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-site-specific-quirks property.
+func (x *Settings) SetEnableSiteSpecificQuirks(EnabledVar bool) {
+
+	xSettingsSetEnableSiteSpecificQuirks(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableSmoothScrolling func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-smooth-scrolling property.
+func (x *Settings) SetEnableSmoothScrolling(EnabledVar bool) {
+
+	xSettingsSetEnableSmoothScrolling(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableSpatialNavigation func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-spatial-navigation property.
+func (x *Settings) SetEnableSpatialNavigation(EnabledVar bool) {
+
+	xSettingsSetEnableSpatialNavigation(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableTabsToLinks func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-tabs-to-links property.
+func (x *Settings) SetEnableTabsToLinks(EnabledVar bool) {
+
+	xSettingsSetEnableTabsToLinks(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableWebaudio func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-webaudio property.
+func (x *Settings) SetEnableWebaudio(EnabledVar bool) {
+
+	xSettingsSetEnableWebaudio(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableWebgl func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-webgl property.
+func (x *Settings) SetEnableWebgl(EnabledVar bool) {
+
+	xSettingsSetEnableWebgl(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableWebrtc func(uintptr, bool)
+
+// Set the [property@Settings:enable-webrtc] property.
+//
+// Setting this property to %TRUE implies the media-stream web-setting will also be enabled.
+func (x *Settings) SetEnableWebrtc(EnabledVar bool) {
+
+	xSettingsSetEnableWebrtc(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetEnableWriteConsoleMessagesToStdout func(uintptr, bool)
+
+// Set the #WebKitSettings:enable-write-console-messages-to-stdout property.
+func (x *Settings) SetEnableWriteConsoleMessagesToStdout(EnabledVar bool) {
+
+	xSettingsSetEnableWriteConsoleMessagesToStdout(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetFantasyFontFamily func(uintptr, string)
+
+// Set the #WebKitSettings:fantasy-font-family property.
+func (x *Settings) SetFantasyFontFamily(FantasyFontFamilyVar string) {
+
+	xSettingsSetFantasyFontFamily(x.GoPointer(), FantasyFontFamilyVar)
+
+}
+
+var xSettingsSetFeatureEnabled func(uintptr, *Feature, bool)
+
+// Enables or disables a feature.
+//
+// The current status of the feature can be determined with
+// [id@webkit_settings_get_feature_enabled]. To reset a feature to its
+// initial status, pass the value returned by
+// [id@webkit_feature_get_default_value] as the @enabled parameter.
+func (x *Settings) SetFeatureEnabled(FeatureVar *Feature, EnabledVar bool) {
+
+	xSettingsSetFeatureEnabled(x.GoPointer(), FeatureVar, EnabledVar)
+
+}
+
+var xSettingsSetHardwareAccelerationPolicy func(uintptr, HardwareAccelerationPolicy)
+
+// Set the #WebKitSettings:hardware-acceleration-policy property.
+func (x *Settings) SetHardwareAccelerationPolicy(PolicyVar HardwareAccelerationPolicy) {
+
+	xSettingsSetHardwareAccelerationPolicy(x.GoPointer(), PolicyVar)
+
+}
+
+var xSettingsSetJavascriptCanAccessClipboard func(uintptr, bool)
+
+// Set the #WebKitSettings:javascript-can-access-clipboard property.
+func (x *Settings) SetJavascriptCanAccessClipboard(EnabledVar bool) {
+
+	xSettingsSetJavascriptCanAccessClipboard(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetJavascriptCanOpenWindowsAutomatically func(uintptr, bool)
+
+// Set the #WebKitSettings:javascript-can-open-windows-automatically property.
+func (x *Settings) SetJavascriptCanOpenWindowsAutomatically(EnabledVar bool) {
+
+	xSettingsSetJavascriptCanOpenWindowsAutomatically(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetLoadIconsIgnoringImageLoadSetting func(uintptr, bool)
+
+// Setting no longer supported. This function does nothing.
+func (x *Settings) SetLoadIconsIgnoringImageLoadSetting(EnabledVar bool) {
+
+	xSettingsSetLoadIconsIgnoringImageLoadSetting(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetMediaContentTypesRequiringHardwareSupport func(uintptr, string)
+
+// Set the #WebKitSettings:media-content-types-requiring-hardware-support property.
+func (x *Settings) SetMediaContentTypesRequiringHardwareSupport(ContentTypesVar string) {
+
+	xSettingsSetMediaContentTypesRequiringHardwareSupport(x.GoPointer(), ContentTypesVar)
+
+}
+
+var xSettingsSetMediaPlaybackAllowsInline func(uintptr, bool)
+
+// Set the #WebKitSettings:media-playback-allows-inline property.
+func (x *Settings) SetMediaPlaybackAllowsInline(EnabledVar bool) {
+
+	xSettingsSetMediaPlaybackAllowsInline(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetMediaPlaybackRequiresUserGesture func(uintptr, bool)
+
+// Set the #WebKitSettings:media-playback-requires-user-gesture property.
+func (x *Settings) SetMediaPlaybackRequiresUserGesture(EnabledVar bool) {
+
+	xSettingsSetMediaPlaybackRequiresUserGesture(x.GoPointer(), EnabledVar)
+
+}
+
+var xSettingsSetMinimumFontSize func(uintptr, uint32)
+
+// Set the #WebKitSettings:minimum-font-size property.
+func (x *Settings) SetMinimumFontSize(FontSizeVar uint32) {
+
+	xSettingsSetMinimumFontSize(x.GoPointer(), FontSizeVar)
+
+}
+
+var xSettingsSetMonospaceFontFamily func(uintptr, string)
+
+// Set the #WebKitSettings:monospace-font-family property.
+func (x *Settings) SetMonospaceFontFamily(MonospaceFontFamilyVar string) {
+
+	xSettingsSetMonospaceFontFamily(x.GoPointer(), MonospaceFontFamilyVar)
+
+}
+
+var xSettingsSetPictographFontFamily func(uintptr, string)
+
+// Set the #WebKitSettings:pictograph-font-family property.
+func (x *Settings) SetPictographFontFamily(PictographFontFamilyVar string) {
+
+	xSettingsSetPictographFontFamily(x.GoPointer(), PictographFontFamilyVar)
+
+}
+
+var xSettingsSetPrintBackgrounds func(uintptr, bool)
+
+// Set the #WebKitSettings:print-backgrounds property.
+func (x *Settings) SetPrintBackgrounds(PrintBackgroundsVar bool) {
+
+	xSettingsSetPrintBackgrounds(x.GoPointer(), PrintBackgroundsVar)
+
+}
+
+var xSettingsSetSansSerifFontFamily func(uintptr, string)
+
+// Set the #WebKitSettings:sans-serif-font-family property.
+func (x *Settings) SetSansSerifFontFamily(SansSerifFontFamilyVar string) {
+
+	xSettingsSetSansSerifFontFamily(x.GoPointer(), SansSerifFontFamilyVar)
+
+}
+
+var xSettingsSetSerifFontFamily func(uintptr, string)
+
+// Set the #WebKitSettings:serif-font-family property.
+func (x *Settings) SetSerifFontFamily(SerifFontFamilyVar string) {
+
+	xSettingsSetSerifFontFamily(x.GoPointer(), SerifFontFamilyVar)
+
+}
+
+var xSettingsSetUserAgent func(uintptr, string)
+
+// Set the #WebKitSettings:user-agent property.
+func (x *Settings) SetUserAgent(UserAgentVar string) {
+
+	xSettingsSetUserAgent(x.GoPointer(), UserAgentVar)
+
+}
+
+var xSettingsSetUserAgentWithApplicationDetails func(uintptr, string, string)
+
+// Set the #WebKitSettings:user-agent property by appending the application details.
+//
+// Set the #WebKitSettings:user-agent property by appending the application details to the default user
+// agent. If no application name or version is given, the default user agent used will be used. If only
+// the version is given, the default engine version is used with the given application name.
+func (x *Settings) SetUserAgentWithApplicationDetails(ApplicationNameVar string, ApplicationVersionVar string) {
+
+	xSettingsSetUserAgentWithApplicationDetails(x.GoPointer(), ApplicationNameVar, ApplicationVersionVar)
+
+}
+
+var xSettingsSetWebrtcUdpPortsRange func(uintptr, string)
+
+// Set the [property@Settings:webrtc-udp-ports-range] property.
+func (x *Settings) SetWebrtcUdpPortsRange(UdpPortRangeVar string) {
+
+	xSettingsSetWebrtcUdpPortsRange(x.GoPointer(), UdpPortRangeVar)
+
+}
+
+var xSettingsSetZoomTextOnly func(uintptr, bool)
+
+// Set the #WebKitSettings:zoom-text-only property.
+func (x *Settings) SetZoomTextOnly(ZoomTextOnlyVar bool) {
+
+	xSettingsSetZoomTextOnly(x.GoPointer(), ZoomTextOnlyVar)
+
+}
+
+func (c *Settings) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *Settings) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyAllowFileAccessFromFileUrls sets the "allow-file-access-from-file-urls" property.
+// Whether file access is allowed from file URLs. By default, when
+// something is loaded in a #WebKitWebView using a file URI, cross
+// origin requests to other file resources are not allowed. This
+// setting allows you to change that behaviour, so that it would be
+// possible to do a XMLHttpRequest of a local file, for example.
+func (x *Settings) SetPropertyAllowFileAccessFromFileUrls(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-file-access-from-file-urls", &v)
+}
+
+// GetPropertyAllowFileAccessFromFileUrls gets the "allow-file-access-from-file-urls" property.
+// Whether file access is allowed from file URLs. By default, when
+// something is loaded in a #WebKitWebView using a file URI, cross
+// origin requests to other file resources are not allowed. This
+// setting allows you to change that behaviour, so that it would be
+// possible to do a XMLHttpRequest of a local file, for example.
+func (x *Settings) GetPropertyAllowFileAccessFromFileUrls() bool {
+	var v gobject.Value
+	x.GetProperty("allow-file-access-from-file-urls", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyAllowModalDialogs sets the "allow-modal-dialogs" property.
+// Determine whether it's allowed to create and run modal dialogs
+// from a #WebKitWebView through JavaScript with
+// &lt;function&gt;window.showModalDialog&lt;/function&gt;. If it's set to
+// %FALSE, the associated #WebKitWebView won't be able to create
+// new modal dialogs, so not even the #WebKitWebView::create
+// signal will be emitted.
+func (x *Settings) SetPropertyAllowModalDialogs(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-modal-dialogs", &v)
+}
+
+// GetPropertyAllowModalDialogs gets the "allow-modal-dialogs" property.
+// Determine whether it's allowed to create and run modal dialogs
+// from a #WebKitWebView through JavaScript with
+// &lt;function&gt;window.showModalDialog&lt;/function&gt;. If it's set to
+// %FALSE, the associated #WebKitWebView won't be able to create
+// new modal dialogs, so not even the #WebKitWebView::create
+// signal will be emitted.
+func (x *Settings) GetPropertyAllowModalDialogs() bool {
+	var v gobject.Value
+	x.GetProperty("allow-modal-dialogs", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyAllowTopNavigationToDataUrls sets the "allow-top-navigation-to-data-urls" property.
+// Whether or not the top frame is allowed to navigate to data URLs. It is disabled by default
+// due to the risk it poses when loading untrusted URLs, with data URLs being used in scamming
+// and phishing attacks. In contrast, a scenario where it could be enabled could be an app that
+// embeds a WebView and you have control of the pages being show instead of a generic browser.
+func (x *Settings) SetPropertyAllowTopNavigationToDataUrls(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-top-navigation-to-data-urls", &v)
+}
+
+// GetPropertyAllowTopNavigationToDataUrls gets the "allow-top-navigation-to-data-urls" property.
+// Whether or not the top frame is allowed to navigate to data URLs. It is disabled by default
+// due to the risk it poses when loading untrusted URLs, with data URLs being used in scamming
+// and phishing attacks. In contrast, a scenario where it could be enabled could be an app that
+// embeds a WebView and you have control of the pages being show instead of a generic browser.
+func (x *Settings) GetPropertyAllowTopNavigationToDataUrls() bool {
+	var v gobject.Value
+	x.GetProperty("allow-top-navigation-to-data-urls", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyAllowUniversalAccessFromFileUrls sets the "allow-universal-access-from-file-urls" property.
+// Whether or not JavaScript running in the context of a file scheme URL
+// should be allowed to access content from any origin.  By default, when
+// something is loaded in a #WebKitWebView using a file scheme URL,
+// access to the local file system and arbitrary local storage is not
+// allowed. This setting allows you to change that behaviour, so that
+// it would be possible to use local storage, for example.
+func (x *Settings) SetPropertyAllowUniversalAccessFromFileUrls(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("allow-universal-access-from-file-urls", &v)
+}
+
+// GetPropertyAllowUniversalAccessFromFileUrls gets the "allow-universal-access-from-file-urls" property.
+// Whether or not JavaScript running in the context of a file scheme URL
+// should be allowed to access content from any origin.  By default, when
+// something is loaded in a #WebKitWebView using a file scheme URL,
+// access to the local file system and arbitrary local storage is not
+// allowed. This setting allows you to change that behaviour, so that
+// it would be possible to use local storage, for example.
+func (x *Settings) GetPropertyAllowUniversalAccessFromFileUrls() bool {
+	var v gobject.Value
+	x.GetProperty("allow-universal-access-from-file-urls", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyAutoLoadImages sets the "auto-load-images" property.
+// Determines whether images should be automatically loaded or not.
+// On devices where network bandwidth is of concern, it might be
+// useful to turn this property off.
+func (x *Settings) SetPropertyAutoLoadImages(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("auto-load-images", &v)
+}
+
+// GetPropertyAutoLoadImages gets the "auto-load-images" property.
+// Determines whether images should be automatically loaded or not.
+// On devices where network bandwidth is of concern, it might be
+// useful to turn this property off.
+func (x *Settings) GetPropertyAutoLoadImages() bool {
+	var v gobject.Value
+	x.GetProperty("auto-load-images", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyCursiveFontFamily sets the "cursive-font-family" property.
+// The font family used as the default for content using a cursive font.
+func (x *Settings) SetPropertyCursiveFontFamily(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("cursive-font-family", &v)
+}
+
+// GetPropertyCursiveFontFamily gets the "cursive-font-family" property.
+// The font family used as the default for content using a cursive font.
+func (x *Settings) GetPropertyCursiveFontFamily() string {
+	var v gobject.Value
+	x.GetProperty("cursive-font-family", &v)
+	return v.GetString()
+}
+
+// SetPropertyDefaultCharset sets the "default-charset" property.
+// The default text charset used when interpreting content with an unspecified charset.
+func (x *Settings) SetPropertyDefaultCharset(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("default-charset", &v)
+}
+
+// GetPropertyDefaultCharset gets the "default-charset" property.
+// The default text charset used when interpreting content with an unspecified charset.
+func (x *Settings) GetPropertyDefaultCharset() string {
+	var v gobject.Value
+	x.GetProperty("default-charset", &v)
+	return v.GetString()
+}
+
+// SetPropertyDefaultFontFamily sets the "default-font-family" property.
+// The font family to use as the default for content that does not specify a font.
+func (x *Settings) SetPropertyDefaultFontFamily(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("default-font-family", &v)
+}
+
+// GetPropertyDefaultFontFamily gets the "default-font-family" property.
+// The font family to use as the default for content that does not specify a font.
+func (x *Settings) GetPropertyDefaultFontFamily() string {
+	var v gobject.Value
+	x.GetProperty("default-font-family", &v)
+	return v.GetString()
+}
+
+// SetPropertyDefaultFontSize sets the "default-font-size" property.
+// The default font size in pixels to use for content displayed if
+// no font size is specified.
+func (x *Settings) SetPropertyDefaultFontSize(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("default-font-size", &v)
+}
+
+// GetPropertyDefaultFontSize gets the "default-font-size" property.
+// The default font size in pixels to use for content displayed if
+// no font size is specified.
+func (x *Settings) GetPropertyDefaultFontSize() uint {
+	var v gobject.Value
+	x.GetProperty("default-font-size", &v)
+	return v.GetUint()
+}
+
+// SetPropertyDefaultMonospaceFontSize sets the "default-monospace-font-size" property.
+// The default font size in pixels to use for content displayed in
+// monospace font if no font size is specified.
+func (x *Settings) SetPropertyDefaultMonospaceFontSize(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("default-monospace-font-size", &v)
+}
+
+// GetPropertyDefaultMonospaceFontSize gets the "default-monospace-font-size" property.
+// The default font size in pixels to use for content displayed in
+// monospace font if no font size is specified.
+func (x *Settings) GetPropertyDefaultMonospaceFontSize() uint {
+	var v gobject.Value
+	x.GetProperty("default-monospace-font-size", &v)
+	return v.GetUint()
+}
+
+// SetPropertyDisableWebSecurity sets the "disable-web-security" property.
+// Enable or disable support for Web Security on pages.
+//
+// This setting disables the same-origin policy, allowing every website full control over
+// all other websites. This is for use in special environments where you wish to disable
+// all security and allow websites to hack each other. It is impossible to use this setting
+// securely.
+func (x *Settings) SetPropertyDisableWebSecurity(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("disable-web-security", &v)
+}
+
+// GetPropertyDisableWebSecurity gets the "disable-web-security" property.
+// Enable or disable support for Web Security on pages.
+//
+// This setting disables the same-origin policy, allowing every website full control over
+// all other websites. This is for use in special environments where you wish to disable
+// all security and allow websites to hack each other. It is impossible to use this setting
+// securely.
+func (x *Settings) GetPropertyDisableWebSecurity() bool {
+	var v gobject.Value
+	x.GetProperty("disable-web-security", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyDrawCompositingIndicators sets the "draw-compositing-indicators" property.
+// Whether to draw compositing borders and repaint counters on layers drawn
+// with accelerated compositing. This is useful for debugging issues related
+// to web content that is composited with the GPU.
+func (x *Settings) SetPropertyDrawCompositingIndicators(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("draw-compositing-indicators", &v)
+}
+
+// GetPropertyDrawCompositingIndicators gets the "draw-compositing-indicators" property.
+// Whether to draw compositing borders and repaint counters on layers drawn
+// with accelerated compositing. This is useful for debugging issues related
+// to web content that is composited with the GPU.
+func (x *Settings) GetPropertyDrawCompositingIndicators() bool {
+	var v gobject.Value
+	x.GetProperty("draw-compositing-indicators", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnable2dCanvasAcceleration sets the "enable-2d-canvas-acceleration" property.
+// Enable or disable 2D canvas acceleration.
+// If this setting is enabled, the 2D canvas will be accelerated even if Skia CPU
+// is used for rendering. However, the canvas can be unaccelerated even when this setting
+// is enabled, for other reasons like its size or when willReadFrequently property is used.
+func (x *Settings) SetPropertyEnable2dCanvasAcceleration(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-2d-canvas-acceleration", &v)
+}
+
+// GetPropertyEnable2dCanvasAcceleration gets the "enable-2d-canvas-acceleration" property.
+// Enable or disable 2D canvas acceleration.
+// If this setting is enabled, the 2D canvas will be accelerated even if Skia CPU
+// is used for rendering. However, the canvas can be unaccelerated even when this setting
+// is enabled, for other reasons like its size or when willReadFrequently property is used.
+func (x *Settings) GetPropertyEnable2dCanvasAcceleration() bool {
+	var v gobject.Value
+	x.GetProperty("enable-2d-canvas-acceleration", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableBackForwardNavigationGestures sets the "enable-back-forward-navigation-gestures" property.
+// Enable or disable horizontal swipe gesture for back-forward navigation.
+func (x *Settings) SetPropertyEnableBackForwardNavigationGestures(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-back-forward-navigation-gestures", &v)
+}
+
+// GetPropertyEnableBackForwardNavigationGestures gets the "enable-back-forward-navigation-gestures" property.
+// Enable or disable horizontal swipe gesture for back-forward navigation.
+func (x *Settings) GetPropertyEnableBackForwardNavigationGestures() bool {
+	var v gobject.Value
+	x.GetProperty("enable-back-forward-navigation-gestures", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableCaretBrowsing sets the "enable-caret-browsing" property.
+// Whether to enable accessibility enhanced keyboard navigation.
+func (x *Settings) SetPropertyEnableCaretBrowsing(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-caret-browsing", &v)
+}
+
+// GetPropertyEnableCaretBrowsing gets the "enable-caret-browsing" property.
+// Whether to enable accessibility enhanced keyboard navigation.
+func (x *Settings) GetPropertyEnableCaretBrowsing() bool {
+	var v gobject.Value
+	x.GetProperty("enable-caret-browsing", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableDeveloperExtras sets the "enable-developer-extras" property.
+// Determines whether or not developer tools, such as the Web Inspector, are enabled.
+func (x *Settings) SetPropertyEnableDeveloperExtras(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-developer-extras", &v)
+}
+
+// GetPropertyEnableDeveloperExtras gets the "enable-developer-extras" property.
+// Determines whether or not developer tools, such as the Web Inspector, are enabled.
+func (x *Settings) GetPropertyEnableDeveloperExtras() bool {
+	var v gobject.Value
+	x.GetProperty("enable-developer-extras", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableDnsPrefetching sets the "enable-dns-prefetching" property.
+// Determines whether or not to prefetch domain names. DNS prefetching attempts
+// to resolve domain names before a user tries to follow a link.
+func (x *Settings) SetPropertyEnableDnsPrefetching(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-dns-prefetching", &v)
+}
+
+// GetPropertyEnableDnsPrefetching gets the "enable-dns-prefetching" property.
+// Determines whether or not to prefetch domain names. DNS prefetching attempts
+// to resolve domain names before a user tries to follow a link.
+func (x *Settings) GetPropertyEnableDnsPrefetching() bool {
+	var v gobject.Value
+	x.GetProperty("enable-dns-prefetching", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableEncryptedMedia sets the "enable-encrypted-media" property.
+// Enable or disable support for Encrypted Media API on pages.
+// EncryptedMedia is an experimental JavaScript API for playing encrypted media in HTML.
+// This property will only work as intended if the EncryptedMedia feature is enabled at build time
+// with the ENABLE_ENCRYPTED_MEDIA flag.
+//
+// See https://www.w3.org/TR/encrypted-media/
+func (x *Settings) SetPropertyEnableEncryptedMedia(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-encrypted-media", &v)
+}
+
+// GetPropertyEnableEncryptedMedia gets the "enable-encrypted-media" property.
+// Enable or disable support for Encrypted Media API on pages.
+// EncryptedMedia is an experimental JavaScript API for playing encrypted media in HTML.
+// This property will only work as intended if the EncryptedMedia feature is enabled at build time
+// with the ENABLE_ENCRYPTED_MEDIA flag.
+//
+// See https://www.w3.org/TR/encrypted-media/
+func (x *Settings) GetPropertyEnableEncryptedMedia() bool {
+	var v gobject.Value
+	x.GetProperty("enable-encrypted-media", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableFullscreen sets the "enable-fullscreen" property.
+// Whether to enable the Javascript Fullscreen API. The API
+// allows any HTML element to request fullscreen display. See also
+// the current draft of the spec:
+// http://www.w3.org/TR/fullscreen/
+func (x *Settings) SetPropertyEnableFullscreen(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-fullscreen", &v)
+}
+
+// GetPropertyEnableFullscreen gets the "enable-fullscreen" property.
+// Whether to enable the Javascript Fullscreen API. The API
+// allows any HTML element to request fullscreen display. See also
+// the current draft of the spec:
+// http://www.w3.org/TR/fullscreen/
+func (x *Settings) GetPropertyEnableFullscreen() bool {
+	var v gobject.Value
+	x.GetProperty("enable-fullscreen", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableHtml5Database sets the "enable-html5-database" property.
+// Whether to enable HTML5 client-side SQL database support (IndexedDB).
+func (x *Settings) SetPropertyEnableHtml5Database(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-html5-database", &v)
+}
+
+// GetPropertyEnableHtml5Database gets the "enable-html5-database" property.
+// Whether to enable HTML5 client-side SQL database support (IndexedDB).
+func (x *Settings) GetPropertyEnableHtml5Database() bool {
+	var v gobject.Value
+	x.GetProperty("enable-html5-database", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableHtml5LocalStorage sets the "enable-html5-local-storage" property.
+// Whether to enable HTML5 local storage support. Local storage provides
+// simple synchronous storage access.
+//
+// HTML5 local storage specification is available at
+// http://dev.w3.org/html5/webstorage/.
+func (x *Settings) SetPropertyEnableHtml5LocalStorage(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-html5-local-storage", &v)
+}
+
+// GetPropertyEnableHtml5LocalStorage gets the "enable-html5-local-storage" property.
+// Whether to enable HTML5 local storage support. Local storage provides
+// simple synchronous storage access.
+//
+// HTML5 local storage specification is available at
+// http://dev.w3.org/html5/webstorage/.
+func (x *Settings) GetPropertyEnableHtml5LocalStorage() bool {
+	var v gobject.Value
+	x.GetProperty("enable-html5-local-storage", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableHyperlinkAuditing sets the "enable-hyperlink-auditing" property.
+// Determines whether or not hyperlink auditing is enabled.
+//
+// The hyperlink auditing specification is available at
+// http://www.whatwg.org/specs/web-apps/current-work/multipage/links.html#hyperlink-auditing.
+func (x *Settings) SetPropertyEnableHyperlinkAuditing(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-hyperlink-auditing", &v)
+}
+
+// GetPropertyEnableHyperlinkAuditing gets the "enable-hyperlink-auditing" property.
+// Determines whether or not hyperlink auditing is enabled.
+//
+// The hyperlink auditing specification is available at
+// http://www.whatwg.org/specs/web-apps/current-work/multipage/links.html#hyperlink-auditing.
+func (x *Settings) GetPropertyEnableHyperlinkAuditing() bool {
+	var v gobject.Value
+	x.GetProperty("enable-hyperlink-auditing", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableJavascript sets the "enable-javascript" property.
+// Determines whether or not JavaScript executes within a page.
+func (x *Settings) SetPropertyEnableJavascript(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-javascript", &v)
+}
+
+// GetPropertyEnableJavascript gets the "enable-javascript" property.
+// Determines whether or not JavaScript executes within a page.
+func (x *Settings) GetPropertyEnableJavascript() bool {
+	var v gobject.Value
+	x.GetProperty("enable-javascript", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableJavascriptMarkup sets the "enable-javascript-markup" property.
+// Determines whether or not JavaScript markup is allowed in document. When this setting is disabled,
+// all JavaScript-related elements and attributes are removed from the document during parsing. Note that
+// executing JavaScript is still allowed if #WebKitSettings:enable-javascript is %TRUE.
+func (x *Settings) SetPropertyEnableJavascriptMarkup(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-javascript-markup", &v)
+}
+
+// GetPropertyEnableJavascriptMarkup gets the "enable-javascript-markup" property.
+// Determines whether or not JavaScript markup is allowed in document. When this setting is disabled,
+// all JavaScript-related elements and attributes are removed from the document during parsing. Note that
+// executing JavaScript is still allowed if #WebKitSettings:enable-javascript is %TRUE.
+func (x *Settings) GetPropertyEnableJavascriptMarkup() bool {
+	var v gobject.Value
+	x.GetProperty("enable-javascript-markup", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableMedia sets the "enable-media" property.
+// Enable or disable support for media playback on pages. This setting is enabled by
+// default. Disabling it means `&lt;audio&gt;`, `&lt;track&gt;` and `&lt;video&gt;` elements will have
+// playback support disabled.
+func (x *Settings) SetPropertyEnableMedia(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-media", &v)
+}
+
+// GetPropertyEnableMedia gets the "enable-media" property.
+// Enable or disable support for media playback on pages. This setting is enabled by
+// default. Disabling it means `&lt;audio&gt;`, `&lt;track&gt;` and `&lt;video&gt;` elements will have
+// playback support disabled.
+func (x *Settings) GetPropertyEnableMedia() bool {
+	var v gobject.Value
+	x.GetProperty("enable-media", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableMediaCapabilities sets the "enable-media-capabilities" property.
+// Enable or disable support for MediaCapabilities on pages. This
+// specification intends to provide APIs to allow websites to make an optimal
+// decision when picking media content for the user. The APIs will expose
+// information about the decoding and encoding capabilities for a given format
+// but also output capabilities to find the best match based on the devices
+// display.
+//
+// See also https://wicg.github.io/media-capabilities/
+func (x *Settings) SetPropertyEnableMediaCapabilities(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-media-capabilities", &v)
+}
+
+// GetPropertyEnableMediaCapabilities gets the "enable-media-capabilities" property.
+// Enable or disable support for MediaCapabilities on pages. This
+// specification intends to provide APIs to allow websites to make an optimal
+// decision when picking media content for the user. The APIs will expose
+// information about the decoding and encoding capabilities for a given format
+// but also output capabilities to find the best match based on the devices
+// display.
+//
+// See also https://wicg.github.io/media-capabilities/
+func (x *Settings) GetPropertyEnableMediaCapabilities() bool {
+	var v gobject.Value
+	x.GetProperty("enable-media-capabilities", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableMediaStream sets the "enable-media-stream" property.
+// Enable or disable support for MediaStream on pages. MediaStream
+// is an experimental proposal for allowing web pages to access
+// audio and video devices for capture.
+//
+// See also http://dev.w3.org/2011/webrtc/editor/getusermedia.html
+func (x *Settings) SetPropertyEnableMediaStream(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-media-stream", &v)
+}
+
+// GetPropertyEnableMediaStream gets the "enable-media-stream" property.
+// Enable or disable support for MediaStream on pages. MediaStream
+// is an experimental proposal for allowing web pages to access
+// audio and video devices for capture.
+//
+// See also http://dev.w3.org/2011/webrtc/editor/getusermedia.html
+func (x *Settings) GetPropertyEnableMediaStream() bool {
+	var v gobject.Value
+	x.GetProperty("enable-media-stream", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableMediasource sets the "enable-mediasource" property.
+// Enable or disable support for MediaSource on pages. MediaSource
+// extends HTMLMediaElement to allow JavaScript to generate media
+// streams for playback.
+//
+// See also http://www.w3.org/TR/media-source/
+func (x *Settings) SetPropertyEnableMediasource(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-mediasource", &v)
+}
+
+// GetPropertyEnableMediasource gets the "enable-mediasource" property.
+// Enable or disable support for MediaSource on pages. MediaSource
+// extends HTMLMediaElement to allow JavaScript to generate media
+// streams for playback.
+//
+// See also http://www.w3.org/TR/media-source/
+func (x *Settings) GetPropertyEnableMediasource() bool {
+	var v gobject.Value
+	x.GetProperty("enable-mediasource", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableMockCaptureDevices sets the "enable-mock-capture-devices" property.
+// Enable or disable the Mock Capture Devices. Those are fake
+// Microphone and Camera devices to be used as MediaStream
+// sources.
+func (x *Settings) SetPropertyEnableMockCaptureDevices(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-mock-capture-devices", &v)
+}
+
+// GetPropertyEnableMockCaptureDevices gets the "enable-mock-capture-devices" property.
+// Enable or disable the Mock Capture Devices. Those are fake
+// Microphone and Camera devices to be used as MediaStream
+// sources.
+func (x *Settings) GetPropertyEnableMockCaptureDevices() bool {
+	var v gobject.Value
+	x.GetProperty("enable-mock-capture-devices", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableOfflineWebApplicationCache sets the "enable-offline-web-application-cache" property.
+// Unsupported setting. This property does nothing.
+func (x *Settings) SetPropertyEnableOfflineWebApplicationCache(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-offline-web-application-cache", &v)
+}
+
+// GetPropertyEnableOfflineWebApplicationCache gets the "enable-offline-web-application-cache" property.
+// Unsupported setting. This property does nothing.
+func (x *Settings) GetPropertyEnableOfflineWebApplicationCache() bool {
+	var v gobject.Value
+	x.GetProperty("enable-offline-web-application-cache", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnablePageCache sets the "enable-page-cache" property.
+// Enable or disable the page cache. Disabling the page cache is
+// generally only useful for special circumstances like low-memory
+// scenarios or special purpose applications like static HTML
+// viewers. This setting only controls the Page Cache, this cache
+// is different than the disk-based or memory-based traditional
+// resource caches, its point is to make going back and forth
+// between pages much faster. For details about the different types
+// of caches and their purposes see:
+// http://webkit.org/blog/427/webkit-page-cache-i-the-basics/
+func (x *Settings) SetPropertyEnablePageCache(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-page-cache", &v)
+}
+
+// GetPropertyEnablePageCache gets the "enable-page-cache" property.
+// Enable or disable the page cache. Disabling the page cache is
+// generally only useful for special circumstances like low-memory
+// scenarios or special purpose applications like static HTML
+// viewers. This setting only controls the Page Cache, this cache
+// is different than the disk-based or memory-based traditional
+// resource caches, its point is to make going back and forth
+// between pages much faster. For details about the different types
+// of caches and their purposes see:
+// http://webkit.org/blog/427/webkit-page-cache-i-the-basics/
+func (x *Settings) GetPropertyEnablePageCache() bool {
+	var v gobject.Value
+	x.GetProperty("enable-page-cache", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableResizableTextAreas sets the "enable-resizable-text-areas" property.
+// Determines whether or not text areas can be resized.
+func (x *Settings) SetPropertyEnableResizableTextAreas(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-resizable-text-areas", &v)
+}
+
+// GetPropertyEnableResizableTextAreas gets the "enable-resizable-text-areas" property.
+// Determines whether or not text areas can be resized.
+func (x *Settings) GetPropertyEnableResizableTextAreas() bool {
+	var v gobject.Value
+	x.GetProperty("enable-resizable-text-areas", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableSiteSpecificQuirks sets the "enable-site-specific-quirks" property.
+// Whether to turn on site-specific quirks. Turning this on will
+// tell WebKit to use some site-specific workarounds for
+// better web compatibility. For example, older versions of
+// MediaWiki will incorrectly send to WebKit a CSS file with KHTML
+// workarounds. By turning on site-specific quirks, WebKit will
+// special-case this and other cases to make some specific sites work.
+func (x *Settings) SetPropertyEnableSiteSpecificQuirks(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-site-specific-quirks", &v)
+}
+
+// GetPropertyEnableSiteSpecificQuirks gets the "enable-site-specific-quirks" property.
+// Whether to turn on site-specific quirks. Turning this on will
+// tell WebKit to use some site-specific workarounds for
+// better web compatibility. For example, older versions of
+// MediaWiki will incorrectly send to WebKit a CSS file with KHTML
+// workarounds. By turning on site-specific quirks, WebKit will
+// special-case this and other cases to make some specific sites work.
+func (x *Settings) GetPropertyEnableSiteSpecificQuirks() bool {
+	var v gobject.Value
+	x.GetProperty("enable-site-specific-quirks", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableSmoothScrolling sets the "enable-smooth-scrolling" property.
+// Enable or disable smooth scrolling.
+func (x *Settings) SetPropertyEnableSmoothScrolling(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-smooth-scrolling", &v)
+}
+
+// GetPropertyEnableSmoothScrolling gets the "enable-smooth-scrolling" property.
+// Enable or disable smooth scrolling.
+func (x *Settings) GetPropertyEnableSmoothScrolling() bool {
+	var v gobject.Value
+	x.GetProperty("enable-smooth-scrolling", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableSpatialNavigation sets the "enable-spatial-navigation" property.
+// Whether to enable Spatial Navigation. This feature consists in the ability
+// to navigate between focusable elements in a Web page, such as hyperlinks
+// and form controls, by using Left, Right, Up and Down arrow keys.
+// For example, if an user presses the Right key, heuristics determine whether
+// there is an element they might be trying to reach towards the right, and if
+// there are multiple elements, which element they probably wants.
+func (x *Settings) SetPropertyEnableSpatialNavigation(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-spatial-navigation", &v)
+}
+
+// GetPropertyEnableSpatialNavigation gets the "enable-spatial-navigation" property.
+// Whether to enable Spatial Navigation. This feature consists in the ability
+// to navigate between focusable elements in a Web page, such as hyperlinks
+// and form controls, by using Left, Right, Up and Down arrow keys.
+// For example, if an user presses the Right key, heuristics determine whether
+// there is an element they might be trying to reach towards the right, and if
+// there are multiple elements, which element they probably wants.
+func (x *Settings) GetPropertyEnableSpatialNavigation() bool {
+	var v gobject.Value
+	x.GetProperty("enable-spatial-navigation", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableTabsToLinks sets the "enable-tabs-to-links" property.
+// Determines whether the tab key cycles through the elements on the page.
+// When this setting is enabled, users will be able to focus the next element
+// in the page by pressing the tab key. If the selected element is editable,
+// then pressing tab key will insert the tab character.
+func (x *Settings) SetPropertyEnableTabsToLinks(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-tabs-to-links", &v)
+}
+
+// GetPropertyEnableTabsToLinks gets the "enable-tabs-to-links" property.
+// Determines whether the tab key cycles through the elements on the page.
+// When this setting is enabled, users will be able to focus the next element
+// in the page by pressing the tab key. If the selected element is editable,
+// then pressing tab key will insert the tab character.
+func (x *Settings) GetPropertyEnableTabsToLinks() bool {
+	var v gobject.Value
+	x.GetProperty("enable-tabs-to-links", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableWebaudio sets the "enable-webaudio" property.
+// Enable or disable support for WebAudio on pages. WebAudio is an
+// API for processing and synthesizing audio in web applications
+//
+// See also https://webaudio.github.io/web-audio-api
+func (x *Settings) SetPropertyEnableWebaudio(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-webaudio", &v)
+}
+
+// GetPropertyEnableWebaudio gets the "enable-webaudio" property.
+// Enable or disable support for WebAudio on pages. WebAudio is an
+// API for processing and synthesizing audio in web applications
+//
+// See also https://webaudio.github.io/web-audio-api
+func (x *Settings) GetPropertyEnableWebaudio() bool {
+	var v gobject.Value
+	x.GetProperty("enable-webaudio", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableWebgl sets the "enable-webgl" property.
+// Enable or disable support for WebGL on pages. WebGL enables web
+// content to use an API based on OpenGL ES 2.0.
+func (x *Settings) SetPropertyEnableWebgl(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-webgl", &v)
+}
+
+// GetPropertyEnableWebgl gets the "enable-webgl" property.
+// Enable or disable support for WebGL on pages. WebGL enables web
+// content to use an API based on OpenGL ES 2.0.
+func (x *Settings) GetPropertyEnableWebgl() bool {
+	var v gobject.Value
+	x.GetProperty("enable-webgl", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableWebrtc sets the "enable-webrtc" property.
+// Enable WebRTC support for loaded pages.
+//
+// Enabling this setting implies that [property@Settings:enable-media-stream]
+// will be enabled as well.
+//
+// See also https://www.w3.org/TR/webrtc/
+func (x *Settings) SetPropertyEnableWebrtc(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-webrtc", &v)
+}
+
+// GetPropertyEnableWebrtc gets the "enable-webrtc" property.
+// Enable WebRTC support for loaded pages.
+//
+// Enabling this setting implies that [property@Settings:enable-media-stream]
+// will be enabled as well.
+//
+// See also https://www.w3.org/TR/webrtc/
+func (x *Settings) GetPropertyEnableWebrtc() bool {
+	var v gobject.Value
+	x.GetProperty("enable-webrtc", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyEnableWriteConsoleMessagesToStdout sets the "enable-write-console-messages-to-stdout" property.
+// Enable or disable writing console messages to stdout. These are messages
+// sent to the console with console.log and related methods.
+func (x *Settings) SetPropertyEnableWriteConsoleMessagesToStdout(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("enable-write-console-messages-to-stdout", &v)
+}
+
+// GetPropertyEnableWriteConsoleMessagesToStdout gets the "enable-write-console-messages-to-stdout" property.
+// Enable or disable writing console messages to stdout. These are messages
+// sent to the console with console.log and related methods.
+func (x *Settings) GetPropertyEnableWriteConsoleMessagesToStdout() bool {
+	var v gobject.Value
+	x.GetProperty("enable-write-console-messages-to-stdout", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyFantasyFontFamily sets the "fantasy-font-family" property.
+// The font family used as the default for content using a fantasy font.
+func (x *Settings) SetPropertyFantasyFontFamily(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("fantasy-font-family", &v)
+}
+
+// GetPropertyFantasyFontFamily gets the "fantasy-font-family" property.
+// The font family used as the default for content using a fantasy font.
+func (x *Settings) GetPropertyFantasyFontFamily() string {
+	var v gobject.Value
+	x.GetProperty("fantasy-font-family", &v)
+	return v.GetString()
+}
+
+// SetPropertyJavascriptCanAccessClipboard sets the "javascript-can-access-clipboard" property.
+// Whether JavaScript can access the clipboard. The default value is %FALSE. If
+// set to %TRUE, document.execCommand() allows cut, copy and paste commands.
+func (x *Settings) SetPropertyJavascriptCanAccessClipboard(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("javascript-can-access-clipboard", &v)
+}
+
+// GetPropertyJavascriptCanAccessClipboard gets the "javascript-can-access-clipboard" property.
+// Whether JavaScript can access the clipboard. The default value is %FALSE. If
+// set to %TRUE, document.execCommand() allows cut, copy and paste commands.
+func (x *Settings) GetPropertyJavascriptCanAccessClipboard() bool {
+	var v gobject.Value
+	x.GetProperty("javascript-can-access-clipboard", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyJavascriptCanOpenWindowsAutomatically sets the "javascript-can-open-windows-automatically" property.
+// Whether JavaScript can open popup windows automatically without user
+// intervention.
+func (x *Settings) SetPropertyJavascriptCanOpenWindowsAutomatically(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("javascript-can-open-windows-automatically", &v)
+}
+
+// GetPropertyJavascriptCanOpenWindowsAutomatically gets the "javascript-can-open-windows-automatically" property.
+// Whether JavaScript can open popup windows automatically without user
+// intervention.
+func (x *Settings) GetPropertyJavascriptCanOpenWindowsAutomatically() bool {
+	var v gobject.Value
+	x.GetProperty("javascript-can-open-windows-automatically", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyLoadIconsIgnoringImageLoadSetting sets the "load-icons-ignoring-image-load-setting" property.
+// Unsupported setting. This property does nothing.
+func (x *Settings) SetPropertyLoadIconsIgnoringImageLoadSetting(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("load-icons-ignoring-image-load-setting", &v)
+}
+
+// GetPropertyLoadIconsIgnoringImageLoadSetting gets the "load-icons-ignoring-image-load-setting" property.
+// Unsupported setting. This property does nothing.
+func (x *Settings) GetPropertyLoadIconsIgnoringImageLoadSetting() bool {
+	var v gobject.Value
+	x.GetProperty("load-icons-ignoring-image-load-setting", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyMediaContentTypesRequiringHardwareSupport sets the "media-content-types-requiring-hardware-support" property.
+// List of media content types requiring hardware support, split by semicolons (:).
+// For example: 'video/webm; codecs="vp*":video/mp4; codecs="avc*":video/&amp;ast; codecs="av1*"'.
+func (x *Settings) SetPropertyMediaContentTypesRequiringHardwareSupport(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("media-content-types-requiring-hardware-support", &v)
+}
+
+// GetPropertyMediaContentTypesRequiringHardwareSupport gets the "media-content-types-requiring-hardware-support" property.
+// List of media content types requiring hardware support, split by semicolons (:).
+// For example: 'video/webm; codecs="vp*":video/mp4; codecs="avc*":video/&amp;ast; codecs="av1*"'.
+func (x *Settings) GetPropertyMediaContentTypesRequiringHardwareSupport() string {
+	var v gobject.Value
+	x.GetProperty("media-content-types-requiring-hardware-support", &v)
+	return v.GetString()
+}
+
+// SetPropertyMediaPlaybackAllowsInline sets the "media-playback-allows-inline" property.
+// Whether media playback is full-screen only or inline playback is allowed.
+// This is %TRUE by default, so media playback can be inline. Setting it to
+// %FALSE allows specifying that media playback should be always fullscreen.
+func (x *Settings) SetPropertyMediaPlaybackAllowsInline(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("media-playback-allows-inline", &v)
+}
+
+// GetPropertyMediaPlaybackAllowsInline gets the "media-playback-allows-inline" property.
+// Whether media playback is full-screen only or inline playback is allowed.
+// This is %TRUE by default, so media playback can be inline. Setting it to
+// %FALSE allows specifying that media playback should be always fullscreen.
+func (x *Settings) GetPropertyMediaPlaybackAllowsInline() bool {
+	var v gobject.Value
+	x.GetProperty("media-playback-allows-inline", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyMediaPlaybackRequiresUserGesture sets the "media-playback-requires-user-gesture" property.
+// Whether a user gesture (such as clicking the play button)
+// would be required to start media playback or load media. This is off
+// by default, so media playback could start automatically.
+// Setting it on requires a gesture by the user to start playback, or to
+// load the media.
+func (x *Settings) SetPropertyMediaPlaybackRequiresUserGesture(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("media-playback-requires-user-gesture", &v)
+}
+
+// GetPropertyMediaPlaybackRequiresUserGesture gets the "media-playback-requires-user-gesture" property.
+// Whether a user gesture (such as clicking the play button)
+// would be required to start media playback or load media. This is off
+// by default, so media playback could start automatically.
+// Setting it on requires a gesture by the user to start playback, or to
+// load the media.
+func (x *Settings) GetPropertyMediaPlaybackRequiresUserGesture() bool {
+	var v gobject.Value
+	x.GetProperty("media-playback-requires-user-gesture", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyMinimumFontSize sets the "minimum-font-size" property.
+// The minimum font size in pixels used to display text. This setting
+// controls the absolute smallest size. Values other than 0 can
+// potentially break page layouts.
+func (x *Settings) SetPropertyMinimumFontSize(value uint) {
+	var v gobject.Value
+	v.Init(gobject.TypeUintVal)
+	v.SetUint(value)
+	x.SetProperty("minimum-font-size", &v)
+}
+
+// GetPropertyMinimumFontSize gets the "minimum-font-size" property.
+// The minimum font size in pixels used to display text. This setting
+// controls the absolute smallest size. Values other than 0 can
+// potentially break page layouts.
+func (x *Settings) GetPropertyMinimumFontSize() uint {
+	var v gobject.Value
+	x.GetProperty("minimum-font-size", &v)
+	return v.GetUint()
+}
+
+// SetPropertyMonospaceFontFamily sets the "monospace-font-family" property.
+// The font family used as the default for content using a monospace font.
+func (x *Settings) SetPropertyMonospaceFontFamily(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("monospace-font-family", &v)
+}
+
+// GetPropertyMonospaceFontFamily gets the "monospace-font-family" property.
+// The font family used as the default for content using a monospace font.
+func (x *Settings) GetPropertyMonospaceFontFamily() string {
+	var v gobject.Value
+	x.GetProperty("monospace-font-family", &v)
+	return v.GetString()
+}
+
+// SetPropertyPictographFontFamily sets the "pictograph-font-family" property.
+// The font family used as the default for content using a pictograph font.
+func (x *Settings) SetPropertyPictographFontFamily(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("pictograph-font-family", &v)
+}
+
+// GetPropertyPictographFontFamily gets the "pictograph-font-family" property.
+// The font family used as the default for content using a pictograph font.
+func (x *Settings) GetPropertyPictographFontFamily() string {
+	var v gobject.Value
+	x.GetProperty("pictograph-font-family", &v)
+	return v.GetString()
+}
+
+// SetPropertyPrintBackgrounds sets the "print-backgrounds" property.
+// Whether background images should be drawn during printing.
+func (x *Settings) SetPropertyPrintBackgrounds(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("print-backgrounds", &v)
+}
+
+// GetPropertyPrintBackgrounds gets the "print-backgrounds" property.
+// Whether background images should be drawn during printing.
+func (x *Settings) GetPropertyPrintBackgrounds() bool {
+	var v gobject.Value
+	x.GetProperty("print-backgrounds", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertySansSerifFontFamily sets the "sans-serif-font-family" property.
+// The font family used as the default for content using a sans-serif font.
+func (x *Settings) SetPropertySansSerifFontFamily(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("sans-serif-font-family", &v)
+}
+
+// GetPropertySansSerifFontFamily gets the "sans-serif-font-family" property.
+// The font family used as the default for content using a sans-serif font.
+func (x *Settings) GetPropertySansSerifFontFamily() string {
+	var v gobject.Value
+	x.GetProperty("sans-serif-font-family", &v)
+	return v.GetString()
+}
+
+// SetPropertySerifFontFamily sets the "serif-font-family" property.
+// The font family used as the default for content using a serif font.
+func (x *Settings) SetPropertySerifFontFamily(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("serif-font-family", &v)
+}
+
+// GetPropertySerifFontFamily gets the "serif-font-family" property.
+// The font family used as the default for content using a serif font.
+func (x *Settings) GetPropertySerifFontFamily() string {
+	var v gobject.Value
+	x.GetProperty("serif-font-family", &v)
+	return v.GetString()
+}
+
+// SetPropertyUserAgent sets the "user-agent" property.
+// The user-agent string used by WebKit. Unusual user-agent strings may cause web
+// content to render incorrectly or fail to run, as many web pages are written to
+// parse the user-agent strings of only the most popular browsers. Therefore, it's
+// typically better to not completely override the standard user-agent, but to use
+// webkit_settings_set_user_agent_with_application_details() instead.
+//
+// If this property is set to the empty string or %NULL, it will revert to the standard
+// user-agent.
+func (x *Settings) SetPropertyUserAgent(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("user-agent", &v)
+}
+
+// GetPropertyUserAgent gets the "user-agent" property.
+// The user-agent string used by WebKit. Unusual user-agent strings may cause web
+// content to render incorrectly or fail to run, as many web pages are written to
+// parse the user-agent strings of only the most popular browsers. Therefore, it's
+// typically better to not completely override the standard user-agent, but to use
+// webkit_settings_set_user_agent_with_application_details() instead.
+//
+// If this property is set to the empty string or %NULL, it will revert to the standard
+// user-agent.
+func (x *Settings) GetPropertyUserAgent() string {
+	var v gobject.Value
+	x.GetProperty("user-agent", &v)
+	return v.GetString()
+}
+
+// SetPropertyWebrtcUdpPortsRange sets the "webrtc-udp-ports-range" property.
+// Allow customization of the WebRTC UDP ports range.
+//
+// In some constrained environments where a firewall blocks UDP network traffic excepted on a
+// specific port range, this settings can be used to give hints to the WebRTC backend regarding
+// which ports to allocate. The format is min-port:max-port, so for instance 20000:30000. The
+// default empty string value means the OS will use no hints from the WebRTC backend. Using 0
+// for one of the values is allowed and means the value is unspecified.
+func (x *Settings) SetPropertyWebrtcUdpPortsRange(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("webrtc-udp-ports-range", &v)
+}
+
+// GetPropertyWebrtcUdpPortsRange gets the "webrtc-udp-ports-range" property.
+// Allow customization of the WebRTC UDP ports range.
+//
+// In some constrained environments where a firewall blocks UDP network traffic excepted on a
+// specific port range, this settings can be used to give hints to the WebRTC backend regarding
+// which ports to allocate. The format is min-port:max-port, so for instance 20000:30000. The
+// default empty string value means the OS will use no hints from the WebRTC backend. Using 0
+// for one of the values is allowed and means the value is unspecified.
+func (x *Settings) GetPropertyWebrtcUdpPortsRange() string {
+	var v gobject.Value
+	x.GetProperty("webrtc-udp-ports-range", &v)
+	return v.GetString()
+}
+
+// SetPropertyZoomTextOnly sets the "zoom-text-only" property.
+// Whether #WebKitWebView:zoom-level affects only the
+// text of the page or all the contents. Other contents containing text
+// like form controls will be also affected by zoom factor when
+// this property is enabled.
+func (x *Settings) SetPropertyZoomTextOnly(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("zoom-text-only", &v)
+}
+
+// GetPropertyZoomTextOnly gets the "zoom-text-only" property.
+// Whether #WebKitWebView:zoom-level affects only the
+// text of the page or all the contents. Other contents containing text
+// like form controls will be also affected by zoom factor when
+// this property is enabled.
+func (x *Settings) GetPropertyZoomTextOnly() bool {
+	var v gobject.Value
+	x.GetProperty("zoom-text-only", &v)
+	return v.GetBoolean()
+}
+
+var xSettingsFontSizeToPixels func(uint32) uint32
+
+// Convert @points to the equivalent value in pixels.
+//
+// Applications can use this function to convert font size values
+// in points to font size values in pixels when setting the font size properties
+// of #WebKitSettings.
+func SettingsFontSizeToPixels(PointsVar uint32) uint32 {
+
+	cret := xSettingsFontSizeToPixels(PointsVar)
+	return cret
+}
+
+var xSettingsFontSizeToPoints func(uint32) uint32
+
+// Convert @pixels to the equivalent value in points.
+//
+// Applications can use this function to convert font size values
+// in pixels to font size values in points when getting the font size properties
+// of #WebKitSettings.
+func SettingsFontSizeToPoints(PixelsVar uint32) uint32 {
+
+	cret := xSettingsFontSizeToPoints(PixelsVar)
+	return cret
+}
+
+var xSettingsGetAllFeatures func() *FeatureList
+
+// Gets the list of all available WebKit features.
+//
+// Features can be toggled with [method@Settings.set_feature_enabled],
+// and their current state determined with
+// [method@Settings.get_feature_enabled].
+//
+// Note that most applications should use
+// [func@Settings.get_development_features] and
+// [func@Settings.get_experimental_features] instead.
+func SettingsGetAllFeatures() *FeatureList {
+
+	cret := xSettingsGetAllFeatures()
+	return cret
+}
+
+var xSettingsGetDevelopmentFeatures func() *FeatureList
+
+// Gets the list of available development WebKit features.
+//
+// The returned features are a subset of those returned by
+// [func@Settings.get_all_features], and includes those which
+// web and WebKit developers might find useful, but in general should
+// *not* be exposed to end users; see [enum@FeatureStatus] for
+// more details.
+func SettingsGetDevelopmentFeatures() *FeatureList {
+
+	cret := xSettingsGetDevelopmentFeatures()
+	return cret
+}
+
+var xSettingsGetExperimentalFeatures func() *FeatureList
+
+// Gets the list of available experimental WebKit features.
+//
+// The returned features are a subset of those returned by
+// [func@Settings.get_all_features], and includes those which
+// certain applications may want to expose to end users; see
+// [enum@FeatureStatus] for more details.
+func SettingsGetExperimentalFeatures() *FeatureList {
+
+	cret := xSettingsGetExperimentalFeatures()
+	return cret
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xHardwareAccelerationPolicyGLibType, libs, "webkit_hardware_acceleration_policy_get_type")
+
+	core.PuregoSafeRegister(&xSettingsGLibType, libs, "webkit_settings_get_type")
+
+	core.PuregoSafeRegister(&xNewSettings, libs, "webkit_settings_new")
+	core.PuregoSafeRegister(&xNewSettingsWithSettings, libs, "webkit_settings_new_with_settings")
+
+	core.PuregoSafeRegister(&xSettingsApplyFromKeyFile, libs, "webkit_settings_apply_from_key_file")
+	core.PuregoSafeRegister(&xSettingsGetAllowFileAccessFromFileUrls, libs, "webkit_settings_get_allow_file_access_from_file_urls")
+	core.PuregoSafeRegister(&xSettingsGetAllowModalDialogs, libs, "webkit_settings_get_allow_modal_dialogs")
+	core.PuregoSafeRegister(&xSettingsGetAllowTopNavigationToDataUrls, libs, "webkit_settings_get_allow_top_navigation_to_data_urls")
+	core.PuregoSafeRegister(&xSettingsGetAllowUniversalAccessFromFileUrls, libs, "webkit_settings_get_allow_universal_access_from_file_urls")
+	core.PuregoSafeRegister(&xSettingsGetAutoLoadImages, libs, "webkit_settings_get_auto_load_images")
+	core.PuregoSafeRegister(&xSettingsGetCursiveFontFamily, libs, "webkit_settings_get_cursive_font_family")
+	core.PuregoSafeRegister(&xSettingsGetDefaultCharset, libs, "webkit_settings_get_default_charset")
+	core.PuregoSafeRegister(&xSettingsGetDefaultFontFamily, libs, "webkit_settings_get_default_font_family")
+	core.PuregoSafeRegister(&xSettingsGetDefaultFontSize, libs, "webkit_settings_get_default_font_size")
+	core.PuregoSafeRegister(&xSettingsGetDefaultMonospaceFontSize, libs, "webkit_settings_get_default_monospace_font_size")
+	core.PuregoSafeRegister(&xSettingsGetDisableWebSecurity, libs, "webkit_settings_get_disable_web_security")
+	core.PuregoSafeRegister(&xSettingsGetDrawCompositingIndicators, libs, "webkit_settings_get_draw_compositing_indicators")
+	core.PuregoSafeRegister(&xSettingsGetEnable2dCanvasAcceleration, libs, "webkit_settings_get_enable_2d_canvas_acceleration")
+	core.PuregoSafeRegister(&xSettingsGetEnableBackForwardNavigationGestures, libs, "webkit_settings_get_enable_back_forward_navigation_gestures")
+	core.PuregoSafeRegister(&xSettingsGetEnableCaretBrowsing, libs, "webkit_settings_get_enable_caret_browsing")
+	core.PuregoSafeRegister(&xSettingsGetEnableDeveloperExtras, libs, "webkit_settings_get_enable_developer_extras")
+	core.PuregoSafeRegister(&xSettingsGetEnableDnsPrefetching, libs, "webkit_settings_get_enable_dns_prefetching")
+	core.PuregoSafeRegister(&xSettingsGetEnableEncryptedMedia, libs, "webkit_settings_get_enable_encrypted_media")
+	core.PuregoSafeRegister(&xSettingsGetEnableFullscreen, libs, "webkit_settings_get_enable_fullscreen")
+	core.PuregoSafeRegister(&xSettingsGetEnableHtml5Database, libs, "webkit_settings_get_enable_html5_database")
+	core.PuregoSafeRegister(&xSettingsGetEnableHtml5LocalStorage, libs, "webkit_settings_get_enable_html5_local_storage")
+	core.PuregoSafeRegister(&xSettingsGetEnableHyperlinkAuditing, libs, "webkit_settings_get_enable_hyperlink_auditing")
+	core.PuregoSafeRegister(&xSettingsGetEnableJavascript, libs, "webkit_settings_get_enable_javascript")
+	core.PuregoSafeRegister(&xSettingsGetEnableJavascriptMarkup, libs, "webkit_settings_get_enable_javascript_markup")
+	core.PuregoSafeRegister(&xSettingsGetEnableMedia, libs, "webkit_settings_get_enable_media")
+	core.PuregoSafeRegister(&xSettingsGetEnableMediaCapabilities, libs, "webkit_settings_get_enable_media_capabilities")
+	core.PuregoSafeRegister(&xSettingsGetEnableMediaStream, libs, "webkit_settings_get_enable_media_stream")
+	core.PuregoSafeRegister(&xSettingsGetEnableMediasource, libs, "webkit_settings_get_enable_mediasource")
+	core.PuregoSafeRegister(&xSettingsGetEnableMockCaptureDevices, libs, "webkit_settings_get_enable_mock_capture_devices")
+	core.PuregoSafeRegister(&xSettingsGetEnableOfflineWebApplicationCache, libs, "webkit_settings_get_enable_offline_web_application_cache")
+	core.PuregoSafeRegister(&xSettingsGetEnablePageCache, libs, "webkit_settings_get_enable_page_cache")
+	core.PuregoSafeRegister(&xSettingsGetEnableResizableTextAreas, libs, "webkit_settings_get_enable_resizable_text_areas")
+	core.PuregoSafeRegister(&xSettingsGetEnableSiteSpecificQuirks, libs, "webkit_settings_get_enable_site_specific_quirks")
+	core.PuregoSafeRegister(&xSettingsGetEnableSmoothScrolling, libs, "webkit_settings_get_enable_smooth_scrolling")
+	core.PuregoSafeRegister(&xSettingsGetEnableSpatialNavigation, libs, "webkit_settings_get_enable_spatial_navigation")
+	core.PuregoSafeRegister(&xSettingsGetEnableTabsToLinks, libs, "webkit_settings_get_enable_tabs_to_links")
+	core.PuregoSafeRegister(&xSettingsGetEnableWebaudio, libs, "webkit_settings_get_enable_webaudio")
+	core.PuregoSafeRegister(&xSettingsGetEnableWebgl, libs, "webkit_settings_get_enable_webgl")
+	core.PuregoSafeRegister(&xSettingsGetEnableWebrtc, libs, "webkit_settings_get_enable_webrtc")
+	core.PuregoSafeRegister(&xSettingsGetEnableWriteConsoleMessagesToStdout, libs, "webkit_settings_get_enable_write_console_messages_to_stdout")
+	core.PuregoSafeRegister(&xSettingsGetFantasyFontFamily, libs, "webkit_settings_get_fantasy_font_family")
+	core.PuregoSafeRegister(&xSettingsGetFeatureEnabled, libs, "webkit_settings_get_feature_enabled")
+	core.PuregoSafeRegister(&xSettingsGetHardwareAccelerationPolicy, libs, "webkit_settings_get_hardware_acceleration_policy")
+	core.PuregoSafeRegister(&xSettingsGetJavascriptCanAccessClipboard, libs, "webkit_settings_get_javascript_can_access_clipboard")
+	core.PuregoSafeRegister(&xSettingsGetJavascriptCanOpenWindowsAutomatically, libs, "webkit_settings_get_javascript_can_open_windows_automatically")
+	core.PuregoSafeRegister(&xSettingsGetLoadIconsIgnoringImageLoadSetting, libs, "webkit_settings_get_load_icons_ignoring_image_load_setting")
+	core.PuregoSafeRegister(&xSettingsGetMediaContentTypesRequiringHardwareSupport, libs, "webkit_settings_get_media_content_types_requiring_hardware_support")
+	core.PuregoSafeRegister(&xSettingsGetMediaPlaybackAllowsInline, libs, "webkit_settings_get_media_playback_allows_inline")
+	core.PuregoSafeRegister(&xSettingsGetMediaPlaybackRequiresUserGesture, libs, "webkit_settings_get_media_playback_requires_user_gesture")
+	core.PuregoSafeRegister(&xSettingsGetMinimumFontSize, libs, "webkit_settings_get_minimum_font_size")
+	core.PuregoSafeRegister(&xSettingsGetMonospaceFontFamily, libs, "webkit_settings_get_monospace_font_family")
+	core.PuregoSafeRegister(&xSettingsGetPictographFontFamily, libs, "webkit_settings_get_pictograph_font_family")
+	core.PuregoSafeRegister(&xSettingsGetPrintBackgrounds, libs, "webkit_settings_get_print_backgrounds")
+	core.PuregoSafeRegister(&xSettingsGetSansSerifFontFamily, libs, "webkit_settings_get_sans_serif_font_family")
+	core.PuregoSafeRegister(&xSettingsGetSerifFontFamily, libs, "webkit_settings_get_serif_font_family")
+	core.PuregoSafeRegister(&xSettingsGetUserAgent, libs, "webkit_settings_get_user_agent")
+	core.PuregoSafeRegister(&xSettingsGetWebrtcUdpPortsRange, libs, "webkit_settings_get_webrtc_udp_ports_range")
+	core.PuregoSafeRegister(&xSettingsGetZoomTextOnly, libs, "webkit_settings_get_zoom_text_only")
+	core.PuregoSafeRegister(&xSettingsSetAllowFileAccessFromFileUrls, libs, "webkit_settings_set_allow_file_access_from_file_urls")
+	core.PuregoSafeRegister(&xSettingsSetAllowModalDialogs, libs, "webkit_settings_set_allow_modal_dialogs")
+	core.PuregoSafeRegister(&xSettingsSetAllowTopNavigationToDataUrls, libs, "webkit_settings_set_allow_top_navigation_to_data_urls")
+	core.PuregoSafeRegister(&xSettingsSetAllowUniversalAccessFromFileUrls, libs, "webkit_settings_set_allow_universal_access_from_file_urls")
+	core.PuregoSafeRegister(&xSettingsSetAutoLoadImages, libs, "webkit_settings_set_auto_load_images")
+	core.PuregoSafeRegister(&xSettingsSetCursiveFontFamily, libs, "webkit_settings_set_cursive_font_family")
+	core.PuregoSafeRegister(&xSettingsSetDefaultCharset, libs, "webkit_settings_set_default_charset")
+	core.PuregoSafeRegister(&xSettingsSetDefaultFontFamily, libs, "webkit_settings_set_default_font_family")
+	core.PuregoSafeRegister(&xSettingsSetDefaultFontSize, libs, "webkit_settings_set_default_font_size")
+	core.PuregoSafeRegister(&xSettingsSetDefaultMonospaceFontSize, libs, "webkit_settings_set_default_monospace_font_size")
+	core.PuregoSafeRegister(&xSettingsSetDisableWebSecurity, libs, "webkit_settings_set_disable_web_security")
+	core.PuregoSafeRegister(&xSettingsSetDrawCompositingIndicators, libs, "webkit_settings_set_draw_compositing_indicators")
+	core.PuregoSafeRegister(&xSettingsSetEnable2dCanvasAcceleration, libs, "webkit_settings_set_enable_2d_canvas_acceleration")
+	core.PuregoSafeRegister(&xSettingsSetEnableBackForwardNavigationGestures, libs, "webkit_settings_set_enable_back_forward_navigation_gestures")
+	core.PuregoSafeRegister(&xSettingsSetEnableCaretBrowsing, libs, "webkit_settings_set_enable_caret_browsing")
+	core.PuregoSafeRegister(&xSettingsSetEnableDeveloperExtras, libs, "webkit_settings_set_enable_developer_extras")
+	core.PuregoSafeRegister(&xSettingsSetEnableDnsPrefetching, libs, "webkit_settings_set_enable_dns_prefetching")
+	core.PuregoSafeRegister(&xSettingsSetEnableEncryptedMedia, libs, "webkit_settings_set_enable_encrypted_media")
+	core.PuregoSafeRegister(&xSettingsSetEnableFullscreen, libs, "webkit_settings_set_enable_fullscreen")
+	core.PuregoSafeRegister(&xSettingsSetEnableHtml5Database, libs, "webkit_settings_set_enable_html5_database")
+	core.PuregoSafeRegister(&xSettingsSetEnableHtml5LocalStorage, libs, "webkit_settings_set_enable_html5_local_storage")
+	core.PuregoSafeRegister(&xSettingsSetEnableHyperlinkAuditing, libs, "webkit_settings_set_enable_hyperlink_auditing")
+	core.PuregoSafeRegister(&xSettingsSetEnableJavascript, libs, "webkit_settings_set_enable_javascript")
+	core.PuregoSafeRegister(&xSettingsSetEnableJavascriptMarkup, libs, "webkit_settings_set_enable_javascript_markup")
+	core.PuregoSafeRegister(&xSettingsSetEnableMedia, libs, "webkit_settings_set_enable_media")
+	core.PuregoSafeRegister(&xSettingsSetEnableMediaCapabilities, libs, "webkit_settings_set_enable_media_capabilities")
+	core.PuregoSafeRegister(&xSettingsSetEnableMediaStream, libs, "webkit_settings_set_enable_media_stream")
+	core.PuregoSafeRegister(&xSettingsSetEnableMediasource, libs, "webkit_settings_set_enable_mediasource")
+	core.PuregoSafeRegister(&xSettingsSetEnableMockCaptureDevices, libs, "webkit_settings_set_enable_mock_capture_devices")
+	core.PuregoSafeRegister(&xSettingsSetEnableOfflineWebApplicationCache, libs, "webkit_settings_set_enable_offline_web_application_cache")
+	core.PuregoSafeRegister(&xSettingsSetEnablePageCache, libs, "webkit_settings_set_enable_page_cache")
+	core.PuregoSafeRegister(&xSettingsSetEnableResizableTextAreas, libs, "webkit_settings_set_enable_resizable_text_areas")
+	core.PuregoSafeRegister(&xSettingsSetEnableSiteSpecificQuirks, libs, "webkit_settings_set_enable_site_specific_quirks")
+	core.PuregoSafeRegister(&xSettingsSetEnableSmoothScrolling, libs, "webkit_settings_set_enable_smooth_scrolling")
+	core.PuregoSafeRegister(&xSettingsSetEnableSpatialNavigation, libs, "webkit_settings_set_enable_spatial_navigation")
+	core.PuregoSafeRegister(&xSettingsSetEnableTabsToLinks, libs, "webkit_settings_set_enable_tabs_to_links")
+	core.PuregoSafeRegister(&xSettingsSetEnableWebaudio, libs, "webkit_settings_set_enable_webaudio")
+	core.PuregoSafeRegister(&xSettingsSetEnableWebgl, libs, "webkit_settings_set_enable_webgl")
+	core.PuregoSafeRegister(&xSettingsSetEnableWebrtc, libs, "webkit_settings_set_enable_webrtc")
+	core.PuregoSafeRegister(&xSettingsSetEnableWriteConsoleMessagesToStdout, libs, "webkit_settings_set_enable_write_console_messages_to_stdout")
+	core.PuregoSafeRegister(&xSettingsSetFantasyFontFamily, libs, "webkit_settings_set_fantasy_font_family")
+	core.PuregoSafeRegister(&xSettingsSetFeatureEnabled, libs, "webkit_settings_set_feature_enabled")
+	core.PuregoSafeRegister(&xSettingsSetHardwareAccelerationPolicy, libs, "webkit_settings_set_hardware_acceleration_policy")
+	core.PuregoSafeRegister(&xSettingsSetJavascriptCanAccessClipboard, libs, "webkit_settings_set_javascript_can_access_clipboard")
+	core.PuregoSafeRegister(&xSettingsSetJavascriptCanOpenWindowsAutomatically, libs, "webkit_settings_set_javascript_can_open_windows_automatically")
+	core.PuregoSafeRegister(&xSettingsSetLoadIconsIgnoringImageLoadSetting, libs, "webkit_settings_set_load_icons_ignoring_image_load_setting")
+	core.PuregoSafeRegister(&xSettingsSetMediaContentTypesRequiringHardwareSupport, libs, "webkit_settings_set_media_content_types_requiring_hardware_support")
+	core.PuregoSafeRegister(&xSettingsSetMediaPlaybackAllowsInline, libs, "webkit_settings_set_media_playback_allows_inline")
+	core.PuregoSafeRegister(&xSettingsSetMediaPlaybackRequiresUserGesture, libs, "webkit_settings_set_media_playback_requires_user_gesture")
+	core.PuregoSafeRegister(&xSettingsSetMinimumFontSize, libs, "webkit_settings_set_minimum_font_size")
+	core.PuregoSafeRegister(&xSettingsSetMonospaceFontFamily, libs, "webkit_settings_set_monospace_font_family")
+	core.PuregoSafeRegister(&xSettingsSetPictographFontFamily, libs, "webkit_settings_set_pictograph_font_family")
+	core.PuregoSafeRegister(&xSettingsSetPrintBackgrounds, libs, "webkit_settings_set_print_backgrounds")
+	core.PuregoSafeRegister(&xSettingsSetSansSerifFontFamily, libs, "webkit_settings_set_sans_serif_font_family")
+	core.PuregoSafeRegister(&xSettingsSetSerifFontFamily, libs, "webkit_settings_set_serif_font_family")
+	core.PuregoSafeRegister(&xSettingsSetUserAgent, libs, "webkit_settings_set_user_agent")
+	core.PuregoSafeRegister(&xSettingsSetUserAgentWithApplicationDetails, libs, "webkit_settings_set_user_agent_with_application_details")
+	core.PuregoSafeRegister(&xSettingsSetWebrtcUdpPortsRange, libs, "webkit_settings_set_webrtc_udp_ports_range")
+	core.PuregoSafeRegister(&xSettingsSetZoomTextOnly, libs, "webkit_settings_set_zoom_text_only")
+
+	core.PuregoSafeRegister(&xSettingsFontSizeToPixels, libs, "webkit_settings_font_size_to_pixels")
+	core.PuregoSafeRegister(&xSettingsFontSizeToPoints, libs, "webkit_settings_font_size_to_points")
+	core.PuregoSafeRegister(&xSettingsGetAllFeatures, libs, "webkit_settings_get_all_features")
+	core.PuregoSafeRegister(&xSettingsGetDevelopmentFeatures, libs, "webkit_settings_get_development_features")
+	core.PuregoSafeRegister(&xSettingsGetExperimentalFeatures, libs, "webkit_settings_get_experimental_features")
+
+}
diff --git a/v4/webkit/WebKitURIRequest.go b/v4/webkit/WebKitURIRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..2acb5b4e260e086e910ac58290b3dae403e7b43e
--- /dev/null
+++ b/v4/webkit/WebKitURIRequest.go
@@ -0,0 +1,147 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/soup"
+)
+
+type URIRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *URIRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Represents a URI request.
+//
+// A #WebKitURIRequest can be created with a URI using the
+// webkit_uri_request_new() method, and you can get the URI of an
+// existing request with the webkit_uri_request_get_uri() one.
+type URIRequest struct {
+	gobject.Object
+}
+
+var xURIRequestGLibType func() types.GType
+
+func URIRequestGLibType() types.GType {
+	return xURIRequestGLibType()
+}
+
+func URIRequestNewFromInternalPtr(ptr uintptr) *URIRequest {
+	cls := &URIRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewURIRequest func(string) uintptr
+
+// Creates a new #WebKitURIRequest for the given URI.
+func NewURIRequest(UriVar string) *URIRequest {
+	var cls *URIRequest
+
+	cret := xNewURIRequest(UriVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &URIRequest{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xURIRequestGetHttpHeaders func(uintptr) *soup.MessageHeaders
+
+// Get the HTTP headers of a #WebKitURIRequest as a #SoupMessageHeaders.
+func (x *URIRequest) GetHttpHeaders() *soup.MessageHeaders {
+
+	cret := xURIRequestGetHttpHeaders(x.GoPointer())
+	return cret
+}
+
+var xURIRequestGetHttpMethod func(uintptr) string
+
+// Get the HTTP method of the #WebKitURIRequest.
+func (x *URIRequest) GetHttpMethod() string {
+
+	cret := xURIRequestGetHttpMethod(x.GoPointer())
+	return cret
+}
+
+var xURIRequestGetUri func(uintptr) string
+
+// Obtains the request URI.
+func (x *URIRequest) GetUri() string {
+
+	cret := xURIRequestGetUri(x.GoPointer())
+	return cret
+}
+
+var xURIRequestSetUri func(uintptr, string)
+
+// Set the URI of @request
+func (x *URIRequest) SetUri(UriVar string) {
+
+	xURIRequestSetUri(x.GoPointer(), UriVar)
+
+}
+
+func (c *URIRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *URIRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyUri sets the "uri" property.
+// The URI to which the request will be made.
+func (x *URIRequest) SetPropertyUri(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("uri", &v)
+}
+
+// GetPropertyUri gets the "uri" property.
+// The URI to which the request will be made.
+func (x *URIRequest) GetPropertyUri() string {
+	var v gobject.Value
+	x.GetProperty("uri", &v)
+	return v.GetString()
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xURIRequestGLibType, libs, "webkit_uri_request_get_type")
+
+	core.PuregoSafeRegister(&xNewURIRequest, libs, "webkit_uri_request_new")
+
+	core.PuregoSafeRegister(&xURIRequestGetHttpHeaders, libs, "webkit_uri_request_get_http_headers")
+	core.PuregoSafeRegister(&xURIRequestGetHttpMethod, libs, "webkit_uri_request_get_http_method")
+	core.PuregoSafeRegister(&xURIRequestGetUri, libs, "webkit_uri_request_get_uri")
+	core.PuregoSafeRegister(&xURIRequestSetUri, libs, "webkit_uri_request_set_uri")
+
+}
diff --git a/v4/webkit/WebKitURIResponse.go b/v4/webkit/WebKitURIResponse.go
new file mode 100644
index 0000000000000000000000000000000000000000..2016eacd69320972626e9754f596707d99ded354
--- /dev/null
+++ b/v4/webkit/WebKitURIResponse.go
@@ -0,0 +1,191 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/soup"
+)
+
+type URIResponseClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *URIResponseClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Represents an URI response.
+//
+// A #WebKitURIResponse contains information such as the URI, the
+// status code, the content length, the mime type, the HTTP status or
+// the suggested filename.
+type URIResponse struct {
+	gobject.Object
+}
+
+var xURIResponseGLibType func() types.GType
+
+func URIResponseGLibType() types.GType {
+	return xURIResponseGLibType()
+}
+
+func URIResponseNewFromInternalPtr(ptr uintptr) *URIResponse {
+	cls := &URIResponse{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xURIResponseGetContentLength func(uintptr) uint64
+
+// Get the expected content length of the #WebKitURIResponse.
+//
+// It can be 0 if the server provided an incorrect or missing Content-Length.
+func (x *URIResponse) GetContentLength() uint64 {
+
+	cret := xURIResponseGetContentLength(x.GoPointer())
+	return cret
+}
+
+var xURIResponseGetHttpHeaders func(uintptr) *soup.MessageHeaders
+
+// Get the HTTP headers of a #WebKitURIResponse as a #SoupMessageHeaders.
+func (x *URIResponse) GetHttpHeaders() *soup.MessageHeaders {
+
+	cret := xURIResponseGetHttpHeaders(x.GoPointer())
+	return cret
+}
+
+var xURIResponseGetMimeType func(uintptr) string
+
+// Gets the MIME type of the response.
+func (x *URIResponse) GetMimeType() string {
+
+	cret := xURIResponseGetMimeType(x.GoPointer())
+	return cret
+}
+
+var xURIResponseGetStatusCode func(uintptr) uint
+
+// Get the status code of the #WebKitURIResponse.
+//
+// Get the status code of the #WebKitURIResponse as returned by
+// the server. It will normally be a #SoupKnownStatusCode, for
+// example %SOUP_STATUS_OK, though the server can respond with any
+// unsigned integer.
+func (x *URIResponse) GetStatusCode() uint {
+
+	cret := xURIResponseGetStatusCode(x.GoPointer())
+	return cret
+}
+
+var xURIResponseGetSuggestedFilename func(uintptr) string
+
+// Get the suggested filename for @response.
+//
+// Get the suggested filename for @response, as specified by
+// the 'Content-Disposition' HTTP header, or %NULL if it's not
+// present.
+func (x *URIResponse) GetSuggestedFilename() string {
+
+	cret := xURIResponseGetSuggestedFilename(x.GoPointer())
+	return cret
+}
+
+var xURIResponseGetUri func(uintptr) string
+
+// Gets the URI which resulted in the response.
+func (x *URIResponse) GetUri() string {
+
+	cret := xURIResponseGetUri(x.GoPointer())
+	return cret
+}
+
+func (c *URIResponse) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *URIResponse) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// GetPropertyContentLength gets the "content-length" property.
+// The expected content length of the response.
+func (x *URIResponse) GetPropertyContentLength() uint64 {
+	var v gobject.Value
+	x.GetProperty("content-length", &v)
+	return v.GetUint64()
+}
+
+// GetPropertyHttpHeaders gets the "http-headers" property.
+// The HTTP headers of the response, or %NULL if the response is not an HTTP response.
+func (x *URIResponse) GetPropertyHttpHeaders() uintptr {
+	var v gobject.Value
+	x.GetProperty("http-headers", &v)
+	return v.GetPointer()
+}
+
+// GetPropertyMimeType gets the "mime-type" property.
+// The MIME type of the response.
+func (x *URIResponse) GetPropertyMimeType() string {
+	var v gobject.Value
+	x.GetProperty("mime-type", &v)
+	return v.GetString()
+}
+
+// GetPropertyStatusCode gets the "status-code" property.
+// The status code of the response as returned by the server.
+func (x *URIResponse) GetPropertyStatusCode() uint {
+	var v gobject.Value
+	x.GetProperty("status-code", &v)
+	return v.GetUint()
+}
+
+// GetPropertySuggestedFilename gets the "suggested-filename" property.
+// The suggested filename for the URI response.
+func (x *URIResponse) GetPropertySuggestedFilename() string {
+	var v gobject.Value
+	x.GetProperty("suggested-filename", &v)
+	return v.GetString()
+}
+
+// GetPropertyUri gets the "uri" property.
+// The URI for which the response was made.
+func (x *URIResponse) GetPropertyUri() string {
+	var v gobject.Value
+	x.GetProperty("uri", &v)
+	return v.GetString()
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xURIResponseGLibType, libs, "webkit_uri_response_get_type")
+
+	core.PuregoSafeRegister(&xURIResponseGetContentLength, libs, "webkit_uri_response_get_content_length")
+	core.PuregoSafeRegister(&xURIResponseGetHttpHeaders, libs, "webkit_uri_response_get_http_headers")
+	core.PuregoSafeRegister(&xURIResponseGetMimeType, libs, "webkit_uri_response_get_mime_type")
+	core.PuregoSafeRegister(&xURIResponseGetStatusCode, libs, "webkit_uri_response_get_status_code")
+	core.PuregoSafeRegister(&xURIResponseGetSuggestedFilename, libs, "webkit_uri_response_get_suggested_filename")
+	core.PuregoSafeRegister(&xURIResponseGetUri, libs, "webkit_uri_response_get_uri")
+
+}
diff --git a/v4/webkit/WebKitURISchemeRequest.go b/v4/webkit/WebKitURISchemeRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..d2e2ce84b6457ede1b3da31d4276808655f7c33e
--- /dev/null
+++ b/v4/webkit/WebKitURISchemeRequest.go
@@ -0,0 +1,194 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/soup"
+)
+
+type URISchemeRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *URISchemeRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Represents a URI scheme request.
+//
+// If you register a particular URI scheme in a #WebKitWebContext,
+// using webkit_web_context_register_uri_scheme(), you have to provide
+// a #WebKitURISchemeRequestCallback. After that, when a URI request
+// is made with that particular scheme, your callback will be
+// called. There you will be able to access properties such as the
+// scheme, the URI and path, and the #WebKitWebView that initiated the
+// request, and also finish the request with
+// webkit_uri_scheme_request_finish().
+type URISchemeRequest struct {
+	gobject.Object
+}
+
+var xURISchemeRequestGLibType func() types.GType
+
+func URISchemeRequestGLibType() types.GType {
+	return xURISchemeRequestGLibType()
+}
+
+func URISchemeRequestNewFromInternalPtr(ptr uintptr) *URISchemeRequest {
+	cls := &URISchemeRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xURISchemeRequestFinish func(uintptr, uintptr, int64, string)
+
+// Finish a #WebKitURISchemeRequest by setting the contents of the request and its mime type.
+func (x *URISchemeRequest) Finish(StreamVar *gio.InputStream, StreamLengthVar int64, ContentTypeVar string) {
+
+	xURISchemeRequestFinish(x.GoPointer(), StreamVar.GoPointer(), StreamLengthVar, ContentTypeVar)
+
+}
+
+var xURISchemeRequestFinishError func(uintptr, *glib.Error)
+
+// Finish a #WebKitURISchemeRequest with a #GError.
+func (x *URISchemeRequest) FinishError(ErrorVar *glib.Error) {
+
+	xURISchemeRequestFinishError(x.GoPointer(), ErrorVar)
+
+}
+
+var xURISchemeRequestFinishWithResponse func(uintptr, uintptr)
+
+// Finish a #WebKitURISchemeRequest by returning a #WebKitURISchemeResponse
+func (x *URISchemeRequest) FinishWithResponse(ResponseVar *URISchemeResponse) {
+
+	xURISchemeRequestFinishWithResponse(x.GoPointer(), ResponseVar.GoPointer())
+
+}
+
+var xURISchemeRequestGetHttpBody func(uintptr) uintptr
+
+// Get the request body.
+func (x *URISchemeRequest) GetHttpBody() *gio.InputStream {
+	var cls *gio.InputStream
+
+	cret := xURISchemeRequestGetHttpBody(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &gio.InputStream{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xURISchemeRequestGetHttpHeaders func(uintptr) *soup.MessageHeaders
+
+// Get the #SoupMessageHeaders of the request.
+func (x *URISchemeRequest) GetHttpHeaders() *soup.MessageHeaders {
+
+	cret := xURISchemeRequestGetHttpHeaders(x.GoPointer())
+	return cret
+}
+
+var xURISchemeRequestGetHttpMethod func(uintptr) string
+
+// Get the HTTP method of the @request.
+func (x *URISchemeRequest) GetHttpMethod() string {
+
+	cret := xURISchemeRequestGetHttpMethod(x.GoPointer())
+	return cret
+}
+
+var xURISchemeRequestGetPath func(uintptr) string
+
+// Get the URI path of @request.
+func (x *URISchemeRequest) GetPath() string {
+
+	cret := xURISchemeRequestGetPath(x.GoPointer())
+	return cret
+}
+
+var xURISchemeRequestGetScheme func(uintptr) string
+
+// Get the URI scheme of @request.
+func (x *URISchemeRequest) GetScheme() string {
+
+	cret := xURISchemeRequestGetScheme(x.GoPointer())
+	return cret
+}
+
+var xURISchemeRequestGetUri func(uintptr) string
+
+// Get the URI of @request.
+func (x *URISchemeRequest) GetUri() string {
+
+	cret := xURISchemeRequestGetUri(x.GoPointer())
+	return cret
+}
+
+var xURISchemeRequestGetWebView func(uintptr) uintptr
+
+// Get the #WebKitWebView that initiated the request.
+func (x *URISchemeRequest) GetWebView() *WebView {
+	var cls *WebView
+
+	cret := xURISchemeRequestGetWebView(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WebView{}
+	cls.Ptr = cret
+	return cls
+}
+
+func (c *URISchemeRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *URISchemeRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xURISchemeRequestGLibType, libs, "webkit_uri_scheme_request_get_type")
+
+	core.PuregoSafeRegister(&xURISchemeRequestFinish, libs, "webkit_uri_scheme_request_finish")
+	core.PuregoSafeRegister(&xURISchemeRequestFinishError, libs, "webkit_uri_scheme_request_finish_error")
+	core.PuregoSafeRegister(&xURISchemeRequestFinishWithResponse, libs, "webkit_uri_scheme_request_finish_with_response")
+	core.PuregoSafeRegister(&xURISchemeRequestGetHttpBody, libs, "webkit_uri_scheme_request_get_http_body")
+	core.PuregoSafeRegister(&xURISchemeRequestGetHttpHeaders, libs, "webkit_uri_scheme_request_get_http_headers")
+	core.PuregoSafeRegister(&xURISchemeRequestGetHttpMethod, libs, "webkit_uri_scheme_request_get_http_method")
+	core.PuregoSafeRegister(&xURISchemeRequestGetPath, libs, "webkit_uri_scheme_request_get_path")
+	core.PuregoSafeRegister(&xURISchemeRequestGetScheme, libs, "webkit_uri_scheme_request_get_scheme")
+	core.PuregoSafeRegister(&xURISchemeRequestGetUri, libs, "webkit_uri_scheme_request_get_uri")
+	core.PuregoSafeRegister(&xURISchemeRequestGetWebView, libs, "webkit_uri_scheme_request_get_web_view")
+
+}
diff --git a/v4/webkit/WebKitURISchemeResponse.go b/v4/webkit/WebKitURISchemeResponse.go
new file mode 100644
index 0000000000000000000000000000000000000000..f933a1ac0830b04cbf55a7682af98a7fca062947
--- /dev/null
+++ b/v4/webkit/WebKitURISchemeResponse.go
@@ -0,0 +1,142 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/soup"
+)
+
+type URISchemeResponseClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *URISchemeResponseClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Represents a URI scheme response.
+//
+// If you register a particular URI scheme in a #WebKitWebContext,
+// using webkit_web_context_register_uri_scheme(), you have to provide
+// a #WebKitURISchemeRequestCallback. After that, when a URI response
+// is made with that particular scheme, your callback will be
+// called. There you will be able to provide more response parameters
+// when the methods and properties of a #WebKitURISchemeRequest is not
+// enough.
+//
+// When you finished setting up your #WebKitURISchemeResponse, call
+// webkit_uri_request_finish_with_response() with it to return the response.
+type URISchemeResponse struct {
+	gobject.Object
+}
+
+var xURISchemeResponseGLibType func() types.GType
+
+func URISchemeResponseGLibType() types.GType {
+	return xURISchemeResponseGLibType()
+}
+
+func URISchemeResponseNewFromInternalPtr(ptr uintptr) *URISchemeResponse {
+	cls := &URISchemeResponse{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewURISchemeResponse func(uintptr, int64) uintptr
+
+// Create a new #WebKitURISchemeResponse
+func NewURISchemeResponse(InputStreamVar *gio.InputStream, StreamLengthVar int64) *URISchemeResponse {
+	var cls *URISchemeResponse
+
+	cret := xNewURISchemeResponse(InputStreamVar.GoPointer(), StreamLengthVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &URISchemeResponse{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xURISchemeResponseSetContentType func(uintptr, string)
+
+// Sets the content type for the @response
+func (x *URISchemeResponse) SetContentType(ContentTypeVar string) {
+
+	xURISchemeResponseSetContentType(x.GoPointer(), ContentTypeVar)
+
+}
+
+var xURISchemeResponseSetHttpHeaders func(uintptr, *soup.MessageHeaders)
+
+// Assign the provided #SoupMessageHeaders to the response.
+//
+// @headers need to be of the type %SOUP_MESSAGE_HEADERS_RESPONSE.
+// Any existing headers will be overwritten.
+func (x *URISchemeResponse) SetHttpHeaders(HeadersVar *soup.MessageHeaders) {
+
+	xURISchemeResponseSetHttpHeaders(x.GoPointer(), HeadersVar)
+
+}
+
+var xURISchemeResponseSetStatus func(uintptr, uint, string)
+
+// Sets the status code and reason phrase for the @response.
+//
+// If @status_code is a known value and @reason_phrase is %NULL, the @reason_phrase will be set automatically.
+func (x *URISchemeResponse) SetStatus(StatusCodeVar uint, ReasonPhraseVar string) {
+
+	xURISchemeResponseSetStatus(x.GoPointer(), StatusCodeVar, ReasonPhraseVar)
+
+}
+
+func (c *URISchemeResponse) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *URISchemeResponse) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyStreamLength sets the "stream-length" property.
+// The input stream length in bytes, `-1` for unknown length.
+func (x *URISchemeResponse) SetPropertyStreamLength(value int64) {
+	var v gobject.Value
+	v.Init(gobject.TypeInt64Val)
+	v.SetInt64(value)
+	x.SetProperty("stream-length", &v)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xURISchemeResponseGLibType, libs, "webkit_uri_scheme_response_get_type")
+
+	core.PuregoSafeRegister(&xNewURISchemeResponse, libs, "webkit_uri_scheme_response_new")
+
+	core.PuregoSafeRegister(&xURISchemeResponseSetContentType, libs, "webkit_uri_scheme_response_set_content_type")
+	core.PuregoSafeRegister(&xURISchemeResponseSetHttpHeaders, libs, "webkit_uri_scheme_response_set_http_headers")
+	core.PuregoSafeRegister(&xURISchemeResponseSetStatus, libs, "webkit_uri_scheme_response_set_status")
+
+}
diff --git a/v4/webkit/WebKitURIUtilities.go b/v4/webkit/WebKitURIUtilities.go
new file mode 100644
index 0000000000000000000000000000000000000000..d9291ea915194f52a5a41c733f8affba24860f69
--- /dev/null
+++ b/v4/webkit/WebKitURIUtilities.go
@@ -0,0 +1,38 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+)
+
+var xUriForDisplay func(string) string
+
+// Use this function to format a URI for display.
+//
+// The URIs used internally by
+// WebKit may contain percent-encoded characters or Punycode, which are not
+// generally suitable to display to users. This function provides protection
+// against IDN homograph attacks, so in some cases the host part of the returned
+// URI may be in Punycode if the safety check fails.
+func UriForDisplay(UriVar string) string {
+
+	cret := xUriForDisplay(UriVar)
+	return cret
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xUriForDisplay, libs, "webkit_uri_for_display")
+
+}
diff --git a/v4/webkit/WebKitUserContent.go b/v4/webkit/WebKitUserContent.go
new file mode 100644
index 0000000000000000000000000000000000000000..e6c472258a40398aba500588da6f75ae070a5c07
--- /dev/null
+++ b/v4/webkit/WebKitUserContent.go
@@ -0,0 +1,299 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// A compiled set of rules which applied to resource loads.
+type UserContentFilter struct {
+	_ structs.HostLayout
+}
+
+var xUserContentFilterGLibType func() types.GType
+
+func UserContentFilterGLibType() types.GType {
+	return xUserContentFilterGLibType()
+}
+
+func (x *UserContentFilter) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xUserContentFilterGetIdentifier func(uintptr) string
+
+// Obtain the identifier previously used to save the @user_content_filter.
+//
+// Obtain the identifier previously used to save the @user_content_filter in the
+// #WebKitUserContentFilterStore.
+func (x *UserContentFilter) GetIdentifier() string {
+
+	cret := xUserContentFilterGetIdentifier(x.GoPointer())
+	return cret
+}
+
+var xUserContentFilterRef func(uintptr) *UserContentFilter
+
+// Atomically increments the reference count of @user_content_filter by one.
+//
+// This function is MT-safe and may be called from any thread.
+func (x *UserContentFilter) Ref() *UserContentFilter {
+
+	cret := xUserContentFilterRef(x.GoPointer())
+	return cret
+}
+
+var xUserContentFilterUnref func(uintptr)
+
+// Atomically decrements the reference count of @user_content_filter by one.
+//
+// If the reference count drops to 0, all the memory allocated by the
+// #WebKitUserContentFilter is released. This function is MT-safe and may
+// be called from any thread.
+func (x *UserContentFilter) Unref() {
+
+	xUserContentFilterUnref(x.GoPointer())
+
+}
+
+// A JavaScript snippet which can be injected in loaded pages.
+type UserScript struct {
+	_ structs.HostLayout
+}
+
+var xUserScriptGLibType func() types.GType
+
+func UserScriptGLibType() types.GType {
+	return xUserScriptGLibType()
+}
+
+func (x *UserScript) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewUserScript func(string, UserContentInjectedFrames, UserScriptInjectionTime, []string, []string) *UserScript
+
+// Creates a new user script.
+//
+// Scripts can be applied to some URIs
+// only by passing non-null values for @allow_list or @block_list. Passing a
+// %NULL allow_list implies that all URIs are on the allow_list. The script
+// is applied if an URI matches the allow_list and not the block_list.
+// URI patterns must be of the form `[protocol]://[host]/[path]`, where the
+// *host* and *path* components can contain the wildcard character (`*`) to
+// represent zero or more other characters.
+func NewUserScript(SourceVar string, InjectedFramesVar UserContentInjectedFrames, InjectionTimeVar UserScriptInjectionTime, AllowListVar []string, BlockListVar []string) *UserScript {
+
+	cret := xNewUserScript(SourceVar, InjectedFramesVar, InjectionTimeVar, AllowListVar, BlockListVar)
+	return cret
+}
+
+var xNewUserScriptForWorld func(string, UserContentInjectedFrames, UserScriptInjectionTime, string, []string, []string) *UserScript
+
+// Creates a new user script for script world with name @world_name.
+//
+// See webkit_user_script_new() for a full description.
+func NewUserScriptForWorld(SourceVar string, InjectedFramesVar UserContentInjectedFrames, InjectionTimeVar UserScriptInjectionTime, WorldNameVar string, AllowListVar []string, BlockListVar []string) *UserScript {
+
+	cret := xNewUserScriptForWorld(SourceVar, InjectedFramesVar, InjectionTimeVar, WorldNameVar, AllowListVar, BlockListVar)
+	return cret
+}
+
+var xUserScriptRef func(uintptr) *UserScript
+
+// Atomically increments the reference count of @user_script by one.
+//
+// This function is MT-safe and may be called from any thread.
+func (x *UserScript) Ref() *UserScript {
+
+	cret := xUserScriptRef(x.GoPointer())
+	return cret
+}
+
+var xUserScriptUnref func(uintptr)
+
+// Atomically decrements the reference count of @user_script by one.
+//
+// If the reference count drops to 0, all memory allocated by
+// #WebKitUserScript is released. This function is MT-safe and may be called
+// from any thread.
+func (x *UserScript) Unref() {
+
+	xUserScriptUnref(x.GoPointer())
+
+}
+
+// A CSS style sheet which can be injected in loaded pages.
+type UserStyleSheet struct {
+	_ structs.HostLayout
+}
+
+var xUserStyleSheetGLibType func() types.GType
+
+func UserStyleSheetGLibType() types.GType {
+	return xUserStyleSheetGLibType()
+}
+
+func (x *UserStyleSheet) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewUserStyleSheet func(string, UserContentInjectedFrames, UserStyleLevel, []string, []string) *UserStyleSheet
+
+// Creates a new user style sheet.
+//
+// Style sheets can be applied to some URIs
+// only by passing non-null values for @allow_list or @block_list. Passing a
+// %NULL allow_list implies that all URIs are on the allow_list. The style
+// sheet is applied if an URI matches the allow_list and not the block_list.
+// URI patterns must be of the form `[protocol]://[host]/[path]`, where the
+// *host* and *path* components can contain the wildcard character (`*`) to
+// represent zero or more other characters.
+func NewUserStyleSheet(SourceVar string, InjectedFramesVar UserContentInjectedFrames, LevelVar UserStyleLevel, AllowListVar []string, BlockListVar []string) *UserStyleSheet {
+
+	cret := xNewUserStyleSheet(SourceVar, InjectedFramesVar, LevelVar, AllowListVar, BlockListVar)
+	return cret
+}
+
+var xNewUserStyleSheetForWorld func(string, UserContentInjectedFrames, UserStyleLevel, string, []string, []string) *UserStyleSheet
+
+// Creates a new user style sheet for script world.
+//
+// Creates a new user style sheet for script world with name @world_name.
+// See webkit_user_style_sheet_new() for a full description.
+func NewUserStyleSheetForWorld(SourceVar string, InjectedFramesVar UserContentInjectedFrames, LevelVar UserStyleLevel, WorldNameVar string, AllowListVar []string, BlockListVar []string) *UserStyleSheet {
+
+	cret := xNewUserStyleSheetForWorld(SourceVar, InjectedFramesVar, LevelVar, WorldNameVar, AllowListVar, BlockListVar)
+	return cret
+}
+
+var xUserStyleSheetRef func(uintptr) *UserStyleSheet
+
+// Atomically increments the reference count of @user_style_sheet by one.
+//
+// This function is MT-safe and may be called from any thread.
+func (x *UserStyleSheet) Ref() *UserStyleSheet {
+
+	cret := xUserStyleSheetRef(x.GoPointer())
+	return cret
+}
+
+var xUserStyleSheetUnref func(uintptr)
+
+// Atomically decrements the reference count of @user_style_sheet by one.
+//
+// If the reference count drops to 0, all memory allocated by
+// #WebKitUserStyleSheet is released. This function is MT-safe and may be
+// called from any thread.
+func (x *UserStyleSheet) Unref() {
+
+	xUserStyleSheetUnref(x.GoPointer())
+
+}
+
+// Specifies in which frames user style sheets are to be inserted in.
+type UserContentInjectedFrames int
+
+var xUserContentInjectedFramesGLibType func() types.GType
+
+func UserContentInjectedFramesGLibType() types.GType {
+	return xUserContentInjectedFramesGLibType()
+}
+
+const (
+
+	// Insert the user style
+	//   sheet in all the frames loaded by the web view, including
+	//   nested frames. This is the default.
+	UserContentInjectAllFramesValue UserContentInjectedFrames = 0
+	// Insert the user style
+	//   sheet *only* in the top-level frame loaded by the web view,
+	//   and *not* in the nested frames.
+	UserContentInjectTopFrameValue UserContentInjectedFrames = 1
+)
+
+// Specifies at which place of documents an user script will be inserted.
+type UserScriptInjectionTime int
+
+var xUserScriptInjectionTimeGLibType func() types.GType
+
+func UserScriptInjectionTimeGLibType() types.GType {
+	return xUserScriptInjectionTimeGLibType()
+}
+
+const (
+
+	// Insert the code of the user
+	//   script at the beginning of loaded documents. This is the default.
+	UserScriptInjectAtDocumentStartValue UserScriptInjectionTime = 0
+	// Insert the code of the user
+	//   script at the end of the loaded documents.
+	UserScriptInjectAtDocumentEndValue UserScriptInjectionTime = 1
+)
+
+// Specifies how to treat an user style sheet.
+type UserStyleLevel int
+
+var xUserStyleLevelGLibType func() types.GType
+
+func UserStyleLevelGLibType() types.GType {
+	return xUserStyleLevelGLibType()
+}
+
+const (
+
+	// The style sheet is an user style sheet,
+	//   its contents always override other style sheets. This is the default.
+	UserStyleLevelUserValue UserStyleLevel = 0
+	// The style sheet will be treated as if
+	//   it was provided by the loaded documents. That means other user style
+	//   sheets may still override it.
+	UserStyleLevelAuthorValue UserStyleLevel = 1
+)
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xUserContentInjectedFramesGLibType, libs, "webkit_user_content_injected_frames_get_type")
+
+	core.PuregoSafeRegister(&xUserScriptInjectionTimeGLibType, libs, "webkit_user_script_injection_time_get_type")
+
+	core.PuregoSafeRegister(&xUserStyleLevelGLibType, libs, "webkit_user_style_level_get_type")
+
+	core.PuregoSafeRegister(&xUserContentFilterGLibType, libs, "webkit_user_content_filter_get_type")
+
+	core.PuregoSafeRegister(&xUserContentFilterGetIdentifier, libs, "webkit_user_content_filter_get_identifier")
+	core.PuregoSafeRegister(&xUserContentFilterRef, libs, "webkit_user_content_filter_ref")
+	core.PuregoSafeRegister(&xUserContentFilterUnref, libs, "webkit_user_content_filter_unref")
+
+	core.PuregoSafeRegister(&xUserScriptGLibType, libs, "webkit_user_script_get_type")
+
+	core.PuregoSafeRegister(&xNewUserScript, libs, "webkit_user_script_new")
+	core.PuregoSafeRegister(&xNewUserScriptForWorld, libs, "webkit_user_script_new_for_world")
+
+	core.PuregoSafeRegister(&xUserScriptRef, libs, "webkit_user_script_ref")
+	core.PuregoSafeRegister(&xUserScriptUnref, libs, "webkit_user_script_unref")
+
+	core.PuregoSafeRegister(&xUserStyleSheetGLibType, libs, "webkit_user_style_sheet_get_type")
+
+	core.PuregoSafeRegister(&xNewUserStyleSheet, libs, "webkit_user_style_sheet_new")
+	core.PuregoSafeRegister(&xNewUserStyleSheetForWorld, libs, "webkit_user_style_sheet_new_for_world")
+
+	core.PuregoSafeRegister(&xUserStyleSheetRef, libs, "webkit_user_style_sheet_ref")
+	core.PuregoSafeRegister(&xUserStyleSheetUnref, libs, "webkit_user_style_sheet_unref")
+
+}
diff --git a/v4/webkit/WebKitUserContentFilterStore.go b/v4/webkit/WebKitUserContentFilterStore.go
new file mode 100644
index 0000000000000000000000000000000000000000..d00e82dd358535c9c19e4cebc6c447ad7c88aaeb
--- /dev/null
+++ b/v4/webkit/WebKitUserContentFilterStore.go
@@ -0,0 +1,290 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type UserContentFilterStoreClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *UserContentFilterStoreClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Handles storage of user content filters on disk.
+//
+// The WebKitUserContentFilterStore provides the means to import and save
+// [JSON rule sets](https://webkit.org/blog/3476/content-blockers-first-look/),
+// which can be loaded later in an efficient manner. Once filters are stored,
+// the #WebKitUserContentFilter objects which represent them can be added to
+// a #WebKitUserContentManager with webkit_user_content_manager_add_filter().
+//
+// JSON rule sets are imported using webkit_user_content_filter_store_save() and stored
+// on disk in an implementation defined format. The contents of a filter store must be
+// managed using the #WebKitUserContentFilterStore: a list of all the stored filters
+// can be obtained with webkit_user_content_filter_store_fetch_identifiers(),
+// webkit_user_content_filter_store_load() can be used to retrieve a previously saved
+// filter, and removed from the store with webkit_user_content_filter_store_remove().
+type UserContentFilterStore struct {
+	gobject.Object
+}
+
+var xUserContentFilterStoreGLibType func() types.GType
+
+func UserContentFilterStoreGLibType() types.GType {
+	return xUserContentFilterStoreGLibType()
+}
+
+func UserContentFilterStoreNewFromInternalPtr(ptr uintptr) *UserContentFilterStore {
+	cls := &UserContentFilterStore{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewUserContentFilterStore func(string) uintptr
+
+// Create a new #WebKitUserContentFilterStore to manipulate filters stored at @storage_path.
+//
+// The path must point to a local filesystem, and will be created if needed.
+func NewUserContentFilterStore(StoragePathVar string) *UserContentFilterStore {
+	var cls *UserContentFilterStore
+
+	cret := xNewUserContentFilterStore(StoragePathVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &UserContentFilterStore{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xUserContentFilterStoreFetchIdentifiers func(uintptr, uintptr, uintptr, uintptr)
+
+// Asynchronously retrieve a list of the identifiers for all the stored filters.
+//
+// When the operation is finished, @callback will be invoked, which then can use
+// webkit_user_content_filter_store_fetch_identifiers_finish() to obtain the list of
+// filter identifiers.
+func (x *UserContentFilterStore) FetchIdentifiers(CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xUserContentFilterStoreFetchIdentifiers(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xUserContentFilterStoreFetchIdentifiersFinish func(uintptr, uintptr) []string
+
+// Finishes an asynchronous fetch of the list of stored filters.
+//
+// Finishes an asynchronous fetch of the list of identifiers for the stored filters previously
+// started with webkit_user_content_filter_store_fetch_identifiers().
+func (x *UserContentFilterStore) FetchIdentifiersFinish(ResultVar gio.AsyncResult) []string {
+
+	cret := xUserContentFilterStoreFetchIdentifiersFinish(x.GoPointer(), ResultVar.GoPointer())
+	return cret
+}
+
+var xUserContentFilterStoreGetPath func(uintptr) string
+
+// Gets the storage path for user content filters.
+func (x *UserContentFilterStore) GetPath() string {
+
+	cret := xUserContentFilterStoreGetPath(x.GoPointer())
+	return cret
+}
+
+var xUserContentFilterStoreLoad func(uintptr, string, uintptr, uintptr, uintptr)
+
+// Asynchronously load a content filter given its @identifier.
+//
+// The filter must have been
+// previously stored using webkit_user_content_filter_store_save().
+//
+// When the operation is finished, @callback will be invoked, which then can use
+// webkit_user_content_filter_store_load_finish() to obtain the resulting filter.
+func (x *UserContentFilterStore) Load(IdentifierVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xUserContentFilterStoreLoad(x.GoPointer(), IdentifierVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xUserContentFilterStoreLoadFinish func(uintptr, uintptr, **glib.Error) *UserContentFilter
+
+// Finishes an asynchronous filter load previously started with
+// webkit_user_content_filter_store_load().
+func (x *UserContentFilterStore) LoadFinish(ResultVar gio.AsyncResult) (*UserContentFilter, error) {
+	var cerr *glib.Error
+
+	cret := xUserContentFilterStoreLoadFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xUserContentFilterStoreRemove func(uintptr, string, uintptr, uintptr, uintptr)
+
+// Asynchronously remove a content filter given its @identifier.
+//
+// When the operation is finished, @callback will be invoked, which then can use
+// webkit_user_content_filter_store_remove_finish() to check whether the removal was
+// successful.
+func (x *UserContentFilterStore) Remove(IdentifierVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xUserContentFilterStoreRemove(x.GoPointer(), IdentifierVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xUserContentFilterStoreRemoveFinish func(uintptr, uintptr, **glib.Error) bool
+
+// Finishes an asynchronous filter removal previously started with
+// webkit_user_content_filter_store_remove().
+func (x *UserContentFilterStore) RemoveFinish(ResultVar gio.AsyncResult) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xUserContentFilterStoreRemoveFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xUserContentFilterStoreSave func(uintptr, string, *glib.Bytes, uintptr, uintptr, uintptr)
+
+// Asynchronously save a content filter from a set source rule.
+//
+// Asynchronously save a content filter from a source rule set in the
+// [WebKit content extesions JSON format](https://webkit.org/blog/3476/content-blockers-first-look/).
+//
+// The @identifier can be used afterwards to refer to the filter when using
+// webkit_user_content_filter_store_remove() and webkit_user_content_filter_store_load().
+// When the @identifier has been used in the past, the new filter source will replace
+// the one saved beforehand for the same identifier.
+//
+// When the operation is finished, @callback will be invoked, which then can use
+// webkit_user_content_filter_store_save_finish() to obtain the resulting filter.
+func (x *UserContentFilterStore) Save(IdentifierVar string, SourceVar *glib.Bytes, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xUserContentFilterStoreSave(x.GoPointer(), IdentifierVar, SourceVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xUserContentFilterStoreSaveFinish func(uintptr, uintptr, **glib.Error) *UserContentFilter
+
+// Finishes an asynchronous filter save previously started with
+// webkit_user_content_filter_store_save().
+func (x *UserContentFilterStore) SaveFinish(ResultVar gio.AsyncResult) (*UserContentFilter, error) {
+	var cerr *glib.Error
+
+	cret := xUserContentFilterStoreSaveFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xUserContentFilterStoreSaveFromFile func(uintptr, string, uintptr, uintptr, uintptr, uintptr)
+
+// Asynchronously save a content filter from the contents of a file.
+//
+// Asynchronously save a content filter from the contents of a file, which must be
+// native to the platform, as checked by g_file_is_native(). See
+// webkit_user_content_filter_store_save() for more details.
+//
+// When the operation is finished, @callback will be invoked, which then can use
+// webkit_user_content_filter_store_save_finish() to obtain the resulting filter.
+func (x *UserContentFilterStore) SaveFromFile(IdentifierVar string, FileVar gio.File, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xUserContentFilterStoreSaveFromFile(x.GoPointer(), IdentifierVar, FileVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xUserContentFilterStoreSaveFromFileFinish func(uintptr, uintptr, **glib.Error) *UserContentFilter
+
+// Finishes and asynchronous filter save previously started with
+// webkit_user_content_filter_store_save_from_file().
+func (x *UserContentFilterStore) SaveFromFileFinish(ResultVar gio.AsyncResult) (*UserContentFilter, error) {
+	var cerr *glib.Error
+
+	cret := xUserContentFilterStoreSaveFromFileFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+func (c *UserContentFilterStore) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *UserContentFilterStore) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyPath sets the "path" property.
+// The directory used for filter storage. This path is used as the base
+// directory where user content filters are stored on disk.
+func (x *UserContentFilterStore) SetPropertyPath(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("path", &v)
+}
+
+// GetPropertyPath gets the "path" property.
+// The directory used for filter storage. This path is used as the base
+// directory where user content filters are stored on disk.
+func (x *UserContentFilterStore) GetPropertyPath() string {
+	var v gobject.Value
+	x.GetProperty("path", &v)
+	return v.GetString()
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xUserContentFilterStoreGLibType, libs, "webkit_user_content_filter_store_get_type")
+
+	core.PuregoSafeRegister(&xNewUserContentFilterStore, libs, "webkit_user_content_filter_store_new")
+
+	core.PuregoSafeRegister(&xUserContentFilterStoreFetchIdentifiers, libs, "webkit_user_content_filter_store_fetch_identifiers")
+	core.PuregoSafeRegister(&xUserContentFilterStoreFetchIdentifiersFinish, libs, "webkit_user_content_filter_store_fetch_identifiers_finish")
+	core.PuregoSafeRegister(&xUserContentFilterStoreGetPath, libs, "webkit_user_content_filter_store_get_path")
+	core.PuregoSafeRegister(&xUserContentFilterStoreLoad, libs, "webkit_user_content_filter_store_load")
+	core.PuregoSafeRegister(&xUserContentFilterStoreLoadFinish, libs, "webkit_user_content_filter_store_load_finish")
+	core.PuregoSafeRegister(&xUserContentFilterStoreRemove, libs, "webkit_user_content_filter_store_remove")
+	core.PuregoSafeRegister(&xUserContentFilterStoreRemoveFinish, libs, "webkit_user_content_filter_store_remove_finish")
+	core.PuregoSafeRegister(&xUserContentFilterStoreSave, libs, "webkit_user_content_filter_store_save")
+	core.PuregoSafeRegister(&xUserContentFilterStoreSaveFinish, libs, "webkit_user_content_filter_store_save_finish")
+	core.PuregoSafeRegister(&xUserContentFilterStoreSaveFromFile, libs, "webkit_user_content_filter_store_save_from_file")
+	core.PuregoSafeRegister(&xUserContentFilterStoreSaveFromFileFinish, libs, "webkit_user_content_filter_store_save_from_file_finish")
+
+}
diff --git a/v4/webkit/WebKitUserContentManager.go b/v4/webkit/WebKitUserContentManager.go
new file mode 100644
index 0000000000000000000000000000000000000000..b8cb3f9164e55a5d2037092c6faa42580927a017
--- /dev/null
+++ b/v4/webkit/WebKitUserContentManager.go
@@ -0,0 +1,421 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/javascriptcore"
+)
+
+// A reply for a script message received.
+// If no reply has been sent by the user, an automatically generated reply with
+// undefined value with be sent.
+type ScriptMessageReply struct {
+	_ structs.HostLayout
+}
+
+var xScriptMessageReplyGLibType func() types.GType
+
+func ScriptMessageReplyGLibType() types.GType {
+	return xScriptMessageReplyGLibType()
+}
+
+func (x *ScriptMessageReply) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xScriptMessageReplyRef func(uintptr) *ScriptMessageReply
+
+// Atomically increments the reference count of @script_message_reply by one.
+func (x *ScriptMessageReply) Ref() *ScriptMessageReply {
+
+	cret := xScriptMessageReplyRef(x.GoPointer())
+	return cret
+}
+
+var xScriptMessageReplyReturnErrorMessage func(uintptr, string)
+
+// Reply to a script message with an error message.
+func (x *ScriptMessageReply) ReturnErrorMessage(ErrorMessageVar string) {
+
+	xScriptMessageReplyReturnErrorMessage(x.GoPointer(), ErrorMessageVar)
+
+}
+
+var xScriptMessageReplyReturnValue func(uintptr, uintptr)
+
+// Reply to a script message with a value.
+//
+// This function can be called twice for passing the reply value in.
+func (x *ScriptMessageReply) ReturnValue(ReplyValueVar *javascriptcore.Value) {
+
+	xScriptMessageReplyReturnValue(x.GoPointer(), ReplyValueVar.GoPointer())
+
+}
+
+var xScriptMessageReplyUnref func(uintptr)
+
+// Atomically decrements the reference count of @script_message_reply by one.
+//
+// If the reference count drops to 0, all the memory allocated by the
+// #WebKitScriptMessageReply is released. This function is MT-safe and may
+// be called from any thread.
+func (x *ScriptMessageReply) Unref() {
+
+	xScriptMessageReplyUnref(x.GoPointer())
+
+}
+
+type UserContentManagerClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *UserContentManagerClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Manages user-defined content which affects web pages.
+//
+// Using a #WebKitUserContentManager user CSS style sheets can be set to
+// be injected in the web pages loaded by a #WebKitWebView, by
+// webkit_user_content_manager_add_style_sheet().
+//
+// To use a #WebKitUserContentManager, it must be created using
+// webkit_user_content_manager_new(), and then used to construct
+// a #WebKitWebView. User style sheets can be created with
+// webkit_user_style_sheet_new().
+//
+// User style sheets can be added and removed at any time, but
+// they will affect the web pages loaded afterwards.
+type UserContentManager struct {
+	gobject.Object
+}
+
+var xUserContentManagerGLibType func() types.GType
+
+func UserContentManagerGLibType() types.GType {
+	return xUserContentManagerGLibType()
+}
+
+func UserContentManagerNewFromInternalPtr(ptr uintptr) *UserContentManager {
+	cls := &UserContentManager{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewUserContentManager func() uintptr
+
+// Creates a new user content manager.
+func NewUserContentManager() *UserContentManager {
+	var cls *UserContentManager
+
+	cret := xNewUserContentManager()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &UserContentManager{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xUserContentManagerAddFilter func(uintptr, *UserContentFilter)
+
+// Adds a #WebKitUserContentFilter to the given #WebKitUserContentManager.
+//
+// The same #WebKitUserContentFilter can be reused with multiple
+// #WebKitUserContentManager instances.
+//
+// Filters need to be saved and loaded from #WebKitUserContentFilterStore.
+func (x *UserContentManager) AddFilter(FilterVar *UserContentFilter) {
+
+	xUserContentManagerAddFilter(x.GoPointer(), FilterVar)
+
+}
+
+var xUserContentManagerAddScript func(uintptr, *UserScript)
+
+// Adds a #WebKitUserScript to the given #WebKitUserContentManager.
+//
+// The same #WebKitUserScript can be reused with multiple
+// #WebKitUserContentManager instances.
+func (x *UserContentManager) AddScript(ScriptVar *UserScript) {
+
+	xUserContentManagerAddScript(x.GoPointer(), ScriptVar)
+
+}
+
+var xUserContentManagerAddStyleSheet func(uintptr, *UserStyleSheet)
+
+// Adds a #WebKitUserStyleSheet to the given #WebKitUserContentManager.
+//
+// The same #WebKitUserStyleSheet can be reused with multiple
+// #WebKitUserContentManager instances.
+func (x *UserContentManager) AddStyleSheet(StylesheetVar *UserStyleSheet) {
+
+	xUserContentManagerAddStyleSheet(x.GoPointer(), StylesheetVar)
+
+}
+
+var xUserContentManagerRegisterScriptMessageHandler func(uintptr, string, string) bool
+
+// Registers a new user script message handler in script world.
+//
+// After it is registered,
+// scripts can use `window.webkit.messageHandlers.&lt;name&gt;.postMessage(value)`
+// to send messages. Those messages are received by connecting handlers
+// to the #WebKitUserContentManager::script-message-received signal. The
+// handler name is used as the detail of the signal. To avoid race
+// conditions between registering the handler name, and starting to
+// receive the signals, it is recommended to connect to the signal
+// *before* registering the handler name:
+//
+// ```c
+// WebKitWebView *view = webkit_web_view_new ();
+// WebKitUserContentManager *manager = webkit_web_view_get_user_content_manager ();
+// g_signal_connect (manager, "script-message-received::foobar",
+//
+//	G_CALLBACK (handle_script_message), NULL);
+//
+// webkit_user_content_manager_register_script_message_handler (manager, "foobar");
+// ```
+//
+// Registering a script message handler will fail if the requested
+// name has been already registered before.
+//
+// If %NULL is passed as the @world_name, the default world will be used.
+//
+// The registered handler can be unregistered by using
+// webkit_user_content_manager_unregister_script_message_handler().
+func (x *UserContentManager) RegisterScriptMessageHandler(NameVar string, WorldNameVar string) bool {
+
+	cret := xUserContentManagerRegisterScriptMessageHandler(x.GoPointer(), NameVar, WorldNameVar)
+	return cret
+}
+
+var xUserContentManagerRegisterScriptMessageHandlerWithReply func(uintptr, string, string) bool
+
+// Registers a new user script message handler in script world with name @world_name.
+//
+// Different from webkit_user_content_manager_register_script_message_handler(),
+// when using this function to register the handler, the connected signal is
+// script-message-with-reply-received, and a reply provided by the user is expected.
+// Otherwise, the user will receive a default undefined value.
+//
+// If %NULL is passed as the @world_name, the default world will be used.
+// See webkit_user_content_manager_register_script_message_handler() for full description.
+//
+// Registering a script message handler will fail if the requested
+// name has been already registered before.
+//
+// The registered handler can be unregistered by using
+// webkit_user_content_manager_unregister_script_message_handler().
+func (x *UserContentManager) RegisterScriptMessageHandlerWithReply(NameVar string, WorldNameVar string) bool {
+
+	cret := xUserContentManagerRegisterScriptMessageHandlerWithReply(x.GoPointer(), NameVar, WorldNameVar)
+	return cret
+}
+
+var xUserContentManagerRemoveAllFilters func(uintptr)
+
+// Removes all content filters from the given #WebKitUserContentManager.
+func (x *UserContentManager) RemoveAllFilters() {
+
+	xUserContentManagerRemoveAllFilters(x.GoPointer())
+
+}
+
+var xUserContentManagerRemoveAllScripts func(uintptr)
+
+// Removes all user scripts from the given #WebKitUserContentManager
+//
+// See also webkit_user_content_manager_remove_script().
+func (x *UserContentManager) RemoveAllScripts() {
+
+	xUserContentManagerRemoveAllScripts(x.GoPointer())
+
+}
+
+var xUserContentManagerRemoveAllStyleSheets func(uintptr)
+
+// Removes all user style sheets from the given #WebKitUserContentManager.
+func (x *UserContentManager) RemoveAllStyleSheets() {
+
+	xUserContentManagerRemoveAllStyleSheets(x.GoPointer())
+
+}
+
+var xUserContentManagerRemoveFilter func(uintptr, *UserContentFilter)
+
+// Removes a filter from the given #WebKitUserContentManager.
+//
+// Since 2.24
+func (x *UserContentManager) RemoveFilter(FilterVar *UserContentFilter) {
+
+	xUserContentManagerRemoveFilter(x.GoPointer(), FilterVar)
+
+}
+
+var xUserContentManagerRemoveFilterById func(uintptr, string)
+
+// Removes a filter by the given identifier.
+//
+// Removes a filter from the given #WebKitUserContentManager given the
+// identifier of a #WebKitUserContentFilter as returned by
+// webkit_user_content_filter_get_identifier().
+func (x *UserContentManager) RemoveFilterById(FilterIdVar string) {
+
+	xUserContentManagerRemoveFilterById(x.GoPointer(), FilterIdVar)
+
+}
+
+var xUserContentManagerRemoveScript func(uintptr, *UserScript)
+
+// Removes a #WebKitUserScript from the given #WebKitUserContentManager.
+//
+// See also webkit_user_content_manager_remove_all_scripts().
+func (x *UserContentManager) RemoveScript(ScriptVar *UserScript) {
+
+	xUserContentManagerRemoveScript(x.GoPointer(), ScriptVar)
+
+}
+
+var xUserContentManagerRemoveStyleSheet func(uintptr, *UserStyleSheet)
+
+// Removes a #WebKitUserStyleSheet from the given #WebKitUserContentManager.
+//
+// See also webkit_user_content_manager_remove_all_style_sheets().
+func (x *UserContentManager) RemoveStyleSheet(StylesheetVar *UserStyleSheet) {
+
+	xUserContentManagerRemoveStyleSheet(x.GoPointer(), StylesheetVar)
+
+}
+
+var xUserContentManagerUnregisterScriptMessageHandler func(uintptr, string, string)
+
+// Unregisters a previously registered message handler in script world with name @world_name.
+// If %NULL is passed as the @world_name, the default world will be used.
+//
+// Note that this does *not* disconnect handlers for the
+// #WebKitUserContentManager::script-message-received signal;
+// they will be kept connected, but the signal will not be emitted
+// unless the handler name is registered again.
+//
+// See also webkit_user_content_manager_register_script_message_handler().
+func (x *UserContentManager) UnregisterScriptMessageHandler(NameVar string, WorldNameVar string) {
+
+	xUserContentManagerUnregisterScriptMessageHandler(x.GoPointer(), NameVar, WorldNameVar)
+
+}
+
+func (c *UserContentManager) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *UserContentManager) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// This signal is emitted when JavaScript in a web view calls
+// &lt;code&gt;window.webkit.messageHandlers.&lt;name&gt;.postMessage()&lt;/code&gt;, after registering
+// &lt;code&gt;&lt;name&gt;&lt;/code&gt; using
+// webkit_user_content_manager_register_script_message_handler()
+func (x *UserContentManager) ConnectScriptMessageReceived(cb *func(UserContentManager, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "script-message-received", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ValueVarp uintptr) {
+		fa := UserContentManager{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ValueVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "script-message-received", cbRefPtr)
+}
+
+// This signal is emitted when JavaScript in a web view calls
+// &lt;code&gt;window.webkit.messageHandlers.&lt;name&gt;.postMessage()&lt;/code&gt;, after registering
+// &lt;code&gt;&lt;name&gt;&lt;/code&gt; using
+// webkit_user_content_manager_register_script_message_handler_with_reply()
+//
+// The given @reply can be used to send a return value with
+// webkit_script_message_reply_return_value() or an error message with
+// webkit_script_message_reply_return_error_message(). If none of them are
+// called, an automatic reply with an undefined value will be sent.
+//
+// It is possible to handle the reply asynchronously, by simply calling
+// g_object_ref() on the @reply and returning %TRUE.
+func (x *UserContentManager) ConnectScriptMessageWithReplyReceived(cb *func(UserContentManager, uintptr, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "script-message-with-reply-received", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ValueVarp uintptr, ReplyVarp uintptr) bool {
+		fa := UserContentManager{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, ValueVarp, ReplyVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "script-message-with-reply-received", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xScriptMessageReplyGLibType, libs, "webkit_script_message_reply_get_type")
+
+	core.PuregoSafeRegister(&xScriptMessageReplyRef, libs, "webkit_script_message_reply_ref")
+	core.PuregoSafeRegister(&xScriptMessageReplyReturnErrorMessage, libs, "webkit_script_message_reply_return_error_message")
+	core.PuregoSafeRegister(&xScriptMessageReplyReturnValue, libs, "webkit_script_message_reply_return_value")
+	core.PuregoSafeRegister(&xScriptMessageReplyUnref, libs, "webkit_script_message_reply_unref")
+
+	core.PuregoSafeRegister(&xUserContentManagerGLibType, libs, "webkit_user_content_manager_get_type")
+
+	core.PuregoSafeRegister(&xNewUserContentManager, libs, "webkit_user_content_manager_new")
+
+	core.PuregoSafeRegister(&xUserContentManagerAddFilter, libs, "webkit_user_content_manager_add_filter")
+	core.PuregoSafeRegister(&xUserContentManagerAddScript, libs, "webkit_user_content_manager_add_script")
+	core.PuregoSafeRegister(&xUserContentManagerAddStyleSheet, libs, "webkit_user_content_manager_add_style_sheet")
+	core.PuregoSafeRegister(&xUserContentManagerRegisterScriptMessageHandler, libs, "webkit_user_content_manager_register_script_message_handler")
+	core.PuregoSafeRegister(&xUserContentManagerRegisterScriptMessageHandlerWithReply, libs, "webkit_user_content_manager_register_script_message_handler_with_reply")
+	core.PuregoSafeRegister(&xUserContentManagerRemoveAllFilters, libs, "webkit_user_content_manager_remove_all_filters")
+	core.PuregoSafeRegister(&xUserContentManagerRemoveAllScripts, libs, "webkit_user_content_manager_remove_all_scripts")
+	core.PuregoSafeRegister(&xUserContentManagerRemoveAllStyleSheets, libs, "webkit_user_content_manager_remove_all_style_sheets")
+	core.PuregoSafeRegister(&xUserContentManagerRemoveFilter, libs, "webkit_user_content_manager_remove_filter")
+	core.PuregoSafeRegister(&xUserContentManagerRemoveFilterById, libs, "webkit_user_content_manager_remove_filter_by_id")
+	core.PuregoSafeRegister(&xUserContentManagerRemoveScript, libs, "webkit_user_content_manager_remove_script")
+	core.PuregoSafeRegister(&xUserContentManagerRemoveStyleSheet, libs, "webkit_user_content_manager_remove_style_sheet")
+	core.PuregoSafeRegister(&xUserContentManagerUnregisterScriptMessageHandler, libs, "webkit_user_content_manager_unregister_script_message_handler")
+
+}
diff --git a/v4/webkit/WebKitUserMediaPermissionRequest.go b/v4/webkit/WebKitUserMediaPermissionRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..185a1a8dc43805b571a1cf49fa43cf27dd8c212e
--- /dev/null
+++ b/v4/webkit/WebKitUserMediaPermissionRequest.go
@@ -0,0 +1,134 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type UserMediaPermissionRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *UserMediaPermissionRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xUserMediaPermissionIsForAudioDevice func(uintptr) bool
+
+// Check whether the permission request is for an audio device.
+func UserMediaPermissionIsForAudioDevice(RequestVar *UserMediaPermissionRequest) bool {
+
+	cret := xUserMediaPermissionIsForAudioDevice(RequestVar.GoPointer())
+	return cret
+}
+
+var xUserMediaPermissionIsForDisplayDevice func(uintptr) bool
+
+// Check whether the permission request is for a display device.
+func UserMediaPermissionIsForDisplayDevice(RequestVar *UserMediaPermissionRequest) bool {
+
+	cret := xUserMediaPermissionIsForDisplayDevice(RequestVar.GoPointer())
+	return cret
+}
+
+var xUserMediaPermissionIsForVideoDevice func(uintptr) bool
+
+// Check whether the permission request is for a video device.
+func UserMediaPermissionIsForVideoDevice(RequestVar *UserMediaPermissionRequest) bool {
+
+	cret := xUserMediaPermissionIsForVideoDevice(RequestVar.GoPointer())
+	return cret
+}
+
+// A permission request for accessing user's audio/video devices.
+//
+// WebKitUserMediaPermissionRequest represents a request for
+// permission to decide whether WebKit should be allowed to access the user's
+// audio and video source devices when requested through the getUserMedia API.
+//
+// When a WebKitUserMediaPermissionRequest is not handled by the user,
+// it is denied by default.
+type UserMediaPermissionRequest struct {
+	gobject.Object
+}
+
+var xUserMediaPermissionRequestGLibType func() types.GType
+
+func UserMediaPermissionRequestGLibType() types.GType {
+	return xUserMediaPermissionRequestGLibType()
+}
+
+func UserMediaPermissionRequestNewFromInternalPtr(ptr uintptr) *UserMediaPermissionRequest {
+	cls := &UserMediaPermissionRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *UserMediaPermissionRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *UserMediaPermissionRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// GetPropertyIsForAudioDevice gets the "is-for-audio-device" property.
+// Whether the media device to which the permission was requested has a microphone or not.
+func (x *UserMediaPermissionRequest) GetPropertyIsForAudioDevice() bool {
+	var v gobject.Value
+	x.GetProperty("is-for-audio-device", &v)
+	return v.GetBoolean()
+}
+
+// GetPropertyIsForVideoDevice gets the "is-for-video-device" property.
+// Whether the media device to which the permission was requested has a video capture capability or not.
+func (x *UserMediaPermissionRequest) GetPropertyIsForVideoDevice() bool {
+	var v gobject.Value
+	x.GetProperty("is-for-video-device", &v)
+	return v.GetBoolean()
+}
+
+// Allow the action which triggered this request.
+func (x *UserMediaPermissionRequest) Allow() {
+
+	XWebkitPermissionRequestAllow(x.GoPointer())
+
+}
+
+// Deny the action which triggered this request.
+func (x *UserMediaPermissionRequest) Deny() {
+
+	XWebkitPermissionRequestDeny(x.GoPointer())
+
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xUserMediaPermissionIsForAudioDevice, libs, "webkit_user_media_permission_is_for_audio_device")
+	core.PuregoSafeRegister(&xUserMediaPermissionIsForDisplayDevice, libs, "webkit_user_media_permission_is_for_display_device")
+	core.PuregoSafeRegister(&xUserMediaPermissionIsForVideoDevice, libs, "webkit_user_media_permission_is_for_video_device")
+
+	core.PuregoSafeRegister(&xUserMediaPermissionRequestGLibType, libs, "webkit_user_media_permission_request_get_type")
+
+}
diff --git a/v4/webkit/WebKitUserMessage.go b/v4/webkit/WebKitUserMessage.go
new file mode 100644
index 0000000000000000000000000000000000000000..42227bcfc07ad986bae0aae6dd6db80792cc9fb2
--- /dev/null
+++ b/v4/webkit/WebKitUserMessage.go
@@ -0,0 +1,231 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type UserMessageClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.InitiallyUnownedClass
+}
+
+func (x *UserMessageClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values used to denote errors happening when sending user messages.
+type UserMessageError int
+
+var xUserMessageErrorGLibType func() types.GType
+
+func UserMessageErrorGLibType() types.GType {
+	return xUserMessageErrorGLibType()
+}
+
+const (
+
+	// The message was not handled by the receiver.
+	UserMessageUnhandledMessageValue UserMessageError = 0
+)
+
+var xUserMessageErrorQuark func() glib.Quark
+
+// Gets the quark for the domain of user message errors.
+func UserMessageErrorQuark() glib.Quark {
+
+	cret := xUserMessageErrorQuark()
+	return cret
+}
+
+// Message that can be sent between the UI process and web process extensions.
+//
+// A WebKitUserMessage is a message that can be used for the communication between the UI process
+// and web process extensions. A WebKitUserMessage always has a name, and it can also include parameters and
+// UNIX file descriptors. Messages can be sent from a #WebKitWebContext to all web process extensions,
+// from a web process extension to its corresponding #WebKitWebContext, and from a #WebKitWebView to its
+// corresponding #WebKitWebPage (and vice versa). One to one messages can be replied to directly with
+// webkit_user_message_send_reply().
+type UserMessage struct {
+	gobject.InitiallyUnowned
+}
+
+var xUserMessageGLibType func() types.GType
+
+func UserMessageGLibType() types.GType {
+	return xUserMessageGLibType()
+}
+
+func UserMessageNewFromInternalPtr(ptr uintptr) *UserMessage {
+	cls := &UserMessage{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewUserMessage func(string, *glib.Variant) uintptr
+
+// Create a new #WebKitUserMessage with @name.
+func NewUserMessage(NameVar string, ParametersVar *glib.Variant) *UserMessage {
+	var cls *UserMessage
+
+	cret := xNewUserMessage(NameVar, ParametersVar)
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &UserMessage{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewUserMessageWithFdList func(string, *glib.Variant, uintptr) uintptr
+
+// Create a new #WebKitUserMessage including also a list of UNIX file descriptors to be sent.
+func NewUserMessageWithFdList(NameVar string, ParametersVar *glib.Variant, FdListVar *gio.UnixFDList) *UserMessage {
+	var cls *UserMessage
+
+	cret := xNewUserMessageWithFdList(NameVar, ParametersVar, FdListVar.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &UserMessage{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xUserMessageGetFdList func(uintptr) uintptr
+
+// Get the @message list of file descritpor.
+func (x *UserMessage) GetFdList() *gio.UnixFDList {
+	var cls *gio.UnixFDList
+
+	cret := xUserMessageGetFdList(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gio.UnixFDList{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xUserMessageGetName func(uintptr) string
+
+// Get the @message name.
+func (x *UserMessage) GetName() string {
+
+	cret := xUserMessageGetName(x.GoPointer())
+	return cret
+}
+
+var xUserMessageGetParameters func(uintptr) *glib.Variant
+
+// Get the @message parameters.
+func (x *UserMessage) GetParameters() *glib.Variant {
+
+	cret := xUserMessageGetParameters(x.GoPointer())
+	return cret
+}
+
+var xUserMessageSendReply func(uintptr, uintptr)
+
+// Send a reply to an user message.
+//
+// If @reply is floating, it's consumed.
+// You can only send a reply to a #WebKitUserMessage that has been
+// received.
+func (x *UserMessage) SendReply(ReplyVar *UserMessage) {
+
+	xUserMessageSendReply(x.GoPointer(), ReplyVar.GoPointer())
+
+}
+
+func (c *UserMessage) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *UserMessage) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyName sets the "name" property.
+// The name of the user message.
+func (x *UserMessage) SetPropertyName(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("name", &v)
+}
+
+// GetPropertyName gets the "name" property.
+// The name of the user message.
+func (x *UserMessage) GetPropertyName() string {
+	var v gobject.Value
+	x.GetProperty("name", &v)
+	return v.GetString()
+}
+
+// SetPropertyParameters sets the "parameters" property.
+// The parameters of the user message as a #GVariant, or %NULL
+// if the message doesn't include parameters. Note that only complete types are
+// allowed.
+func (x *UserMessage) SetPropertyParameters(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("parameters", &v)
+}
+
+// GetPropertyParameters gets the "parameters" property.
+// The parameters of the user message as a #GVariant, or %NULL
+// if the message doesn't include parameters. Note that only complete types are
+// allowed.
+func (x *UserMessage) GetPropertyParameters() uintptr {
+	var v gobject.Value
+	x.GetProperty("parameters", &v)
+	return v.GetPointer()
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xUserMessageErrorGLibType, libs, "webkit_user_message_error_get_type")
+
+	core.PuregoSafeRegister(&xUserMessageErrorQuark, libs, "webkit_user_message_error_quark")
+
+	core.PuregoSafeRegister(&xUserMessageGLibType, libs, "webkit_user_message_get_type")
+
+	core.PuregoSafeRegister(&xNewUserMessage, libs, "webkit_user_message_new")
+	core.PuregoSafeRegister(&xNewUserMessageWithFdList, libs, "webkit_user_message_new_with_fd_list")
+
+	core.PuregoSafeRegister(&xUserMessageGetFdList, libs, "webkit_user_message_get_fd_list")
+	core.PuregoSafeRegister(&xUserMessageGetName, libs, "webkit_user_message_get_name")
+	core.PuregoSafeRegister(&xUserMessageGetParameters, libs, "webkit_user_message_get_parameters")
+	core.PuregoSafeRegister(&xUserMessageSendReply, libs, "webkit_user_message_send_reply")
+
+}
diff --git a/v4/webkit/WebKitVersion.go b/v4/webkit/WebKitVersion.go
new file mode 100644
index 0000000000000000000000000000000000000000..f84f3622dc3ba1fa1865e3cd53a0a9d7eea00ce8
--- /dev/null
+++ b/v4/webkit/WebKitVersion.go
@@ -0,0 +1,88 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+)
+
+const (
+	// Like webkit_get_major_version(), but from the headers used at
+	// application compile time, rather than from the library linked
+	// against at application run time.
+	MAJOR_VERSION int = 2
+	// Like webkit_get_micro_version(), but from the headers used at
+	// application compile time, rather than from the library linked
+	// against at application run time.
+	MICRO_VERSION int = 3
+	// Like webkit_get_minor_version(), but from the headers used at
+	// application compile time, rather than from the library linked
+	// against at application run time.
+	MINOR_VERSION int = 50
+)
+
+var xGetMajorVersion func() uint
+
+// Returns the major version number of the WebKit library.
+//
+// (e.g. in WebKit version 1.8.3 this is 1.)
+//
+// This function is in the library, so it represents the WebKit library
+// your code is running against. Contrast with the #WEBKIT_MAJOR_VERSION
+// macro, which represents the major version of the WebKit headers you
+// have included when compiling your code.
+func GetMajorVersion() uint {
+
+	cret := xGetMajorVersion()
+	return cret
+}
+
+var xGetMicroVersion func() uint
+
+// Returns the micro version number of the WebKit library.
+//
+// (e.g. in WebKit version 1.8.3 this is 3.)
+//
+// This function is in the library, so it represents the WebKit library
+// your code is running against. Contrast with the #WEBKIT_MICRO_VERSION
+// macro, which represents the micro version of the WebKit headers you
+// have included when compiling your code.
+func GetMicroVersion() uint {
+
+	cret := xGetMicroVersion()
+	return cret
+}
+
+var xGetMinorVersion func() uint
+
+// Returns the minor version number of the WebKit library.
+//
+// (e.g. in WebKit version 1.8.3 this is 8.)
+//
+// This function is in the library, so it represents the WebKit library
+// your code is running against. Contrast with the #WEBKIT_MINOR_VERSION
+// macro, which represents the minor version of the WebKit headers you
+// have included when compiling your code.
+func GetMinorVersion() uint {
+
+	cret := xGetMinorVersion()
+	return cret
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xGetMajorVersion, libs, "webkit_get_major_version")
+	core.PuregoSafeRegister(&xGetMicroVersion, libs, "webkit_get_micro_version")
+	core.PuregoSafeRegister(&xGetMinorVersion, libs, "webkit_get_minor_version")
+
+}
diff --git a/v4/webkit/WebKitWebContext.go b/v4/webkit/WebKitWebContext.go
new file mode 100644
index 0000000000000000000000000000000000000000..205a45c3d72d1dad01b408b77dbe1aaf62c1f130
--- /dev/null
+++ b/v4/webkit/WebKitWebContext.go
@@ -0,0 +1,650 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Type definition for a function that will be called back when an URI request is
+// made for a user registered URI scheme.
+type URISchemeRequestCallback func(uintptr, uintptr)
+
+type WebContextClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *WebContextClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values used for determining the #WebKitWebContext cache model.
+type CacheModel int
+
+var xCacheModelGLibType func() types.GType
+
+func CacheModelGLibType() types.GType {
+	return xCacheModelGLibType()
+}
+
+const (
+
+	// Disable the cache completely, which
+	//   substantially reduces memory usage. Useful for applications that only
+	//   access a single local file, with no navigation to other pages. No remote
+	//   resources will be cached.
+	CacheModelDocumentViewerValue CacheModel = 0
+	// Improve document load speed substantially
+	//   by caching a very large number of resources and previously viewed content.
+	CacheModelWebBrowserValue CacheModel = 1
+	// A cache model optimized for viewing
+	//   a series of local files -- for example, a documentation viewer or a website
+	//   designer. WebKit will cache a moderate number of resources.
+	CacheModelDocumentBrowserValue CacheModel = 2
+)
+
+// Manages aspects common to all #WebKitWebView&lt;!-- --&gt;s
+//
+// The #WebKitWebContext manages all aspects common to all
+// #WebKitWebView&lt;!-- --&gt;s.
+//
+// You can define the #WebKitCacheModel with
+// webkit_web_context_set_cache_model(), depending on the needs of
+// your application. You can access the #WebKitSecurityManager to specify
+// the behaviour of your application regarding security using
+// webkit_web_context_get_security_manager().
+//
+// It is also possible to change your preferred language or enable
+// spell checking, using webkit_web_context_set_preferred_languages(),
+// webkit_web_context_set_spell_checking_languages() and
+// webkit_web_context_set_spell_checking_enabled().
+//
+// You can use webkit_web_context_register_uri_scheme() to register
+// custom URI schemes, and manage several other settings.
+//
+// TLS certificate validation failure is now treated as a transport
+// error by default. To handle TLS failures differently, you can
+// connect to #WebKitWebView::load-failed-with-tls-errors.
+// Alternatively, you can use webkit_web_context_set_tls_errors_policy()
+// to set the policy %WEBKIT_TLS_ERRORS_POLICY_IGNORE; however, this is
+// not appropriate for Internet applications.
+type WebContext struct {
+	gobject.Object
+}
+
+var xWebContextGLibType func() types.GType
+
+func WebContextGLibType() types.GType {
+	return xWebContextGLibType()
+}
+
+func WebContextNewFromInternalPtr(ptr uintptr) *WebContext {
+	cls := &WebContext{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewWebContext func() uintptr
+
+// Create a new #WebKitWebContext.
+func NewWebContext() *WebContext {
+	var cls *WebContext
+
+	cret := xNewWebContext()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &WebContext{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebContextAddPathToSandbox func(uintptr, string, bool)
+
+// Adds a path to be mounted in the sandbox.
+//
+// @path must exist before any web process has been created. It is a fatal error
+// to add paths after a web process has been spawned.
+//
+// Paths under `/sys`, `/proc`, and `/dev` are invalid. Attempting to
+// add all of `/` is not valid. Since 2.40, adding the user's entire
+// home directory or /home is also not valid.
+//
+// See also webkit_web_context_set_sandbox_enabled()
+func (x *WebContext) AddPathToSandbox(PathVar string, ReadOnlyVar bool) {
+
+	xWebContextAddPathToSandbox(x.GoPointer(), PathVar, ReadOnlyVar)
+
+}
+
+var xWebContextGetCacheModel func(uintptr) CacheModel
+
+// Returns the current cache model.
+//
+// For more information about this
+// value check the documentation of the function
+// webkit_web_context_set_cache_model().
+func (x *WebContext) GetCacheModel() CacheModel {
+
+	cret := xWebContextGetCacheModel(x.GoPointer())
+	return cret
+}
+
+var xWebContextGetGeolocationManager func(uintptr) uintptr
+
+// Get the #WebKitGeolocationManager of @context.
+func (x *WebContext) GetGeolocationManager() *GeolocationManager {
+	var cls *GeolocationManager
+
+	cret := xWebContextGetGeolocationManager(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &GeolocationManager{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebContextGetNetworkSessionForAutomation func(uintptr) uintptr
+
+// Get the #WebKitNetworkSession used for automation sessions started in @context.
+func (x *WebContext) GetNetworkSessionForAutomation() *NetworkSession {
+	var cls *NetworkSession
+
+	cret := xWebContextGetNetworkSessionForAutomation(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &NetworkSession{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebContextGetSecurityManager func(uintptr) uintptr
+
+// Get the #WebKitSecurityManager of @context.
+func (x *WebContext) GetSecurityManager() *SecurityManager {
+	var cls *SecurityManager
+
+	cret := xWebContextGetSecurityManager(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &SecurityManager{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebContextGetSpellCheckingEnabled func(uintptr) bool
+
+// Get whether spell checking feature is currently enabled.
+func (x *WebContext) GetSpellCheckingEnabled() bool {
+
+	cret := xWebContextGetSpellCheckingEnabled(x.GoPointer())
+	return cret
+}
+
+var xWebContextGetSpellCheckingLanguages func(uintptr) []string
+
+// Get the the list of spell checking languages.
+//
+// Get the the list of spell checking languages associated with
+// @context, or %NULL if no languages have been previously set.
+//
+// See webkit_web_context_set_spell_checking_languages() for more
+// details on the format of the languages in the list.
+func (x *WebContext) GetSpellCheckingLanguages() []string {
+
+	cret := xWebContextGetSpellCheckingLanguages(x.GoPointer())
+	return cret
+}
+
+var xWebContextGetTimeZoneOverride func(uintptr) string
+
+// Get the #WebKitWebContext:time-zone-override property.
+func (x *WebContext) GetTimeZoneOverride() string {
+
+	cret := xWebContextGetTimeZoneOverride(x.GoPointer())
+	return cret
+}
+
+var xWebContextInitializeNotificationPermissions func(uintptr, *glib.List, *glib.List)
+
+// Sets initial desktop notification permissions for the @context.
+//
+// @allowed_origins and @disallowed_origins must each be #GList of
+// #WebKitSecurityOrigin objects representing origins that will,
+// respectively, either always or never have permission to show desktop
+// notifications. No #WebKitNotificationPermissionRequest will ever be
+// generated for any of the security origins represented in
+// @allowed_origins or @disallowed_origins. This function is necessary
+// because some webpages proactively check whether they have permission
+// to display notifications without ever creating a permission request.
+//
+// This function only affects web processes that have not already been
+// created. The best time to call it is when handling
+// #WebKitWebContext::initialize-notification-permissions so as to
+// ensure that new web processes receive the most recent set of
+// permissions.
+func (x *WebContext) InitializeNotificationPermissions(AllowedOriginsVar *glib.List, DisallowedOriginsVar *glib.List) {
+
+	xWebContextInitializeNotificationPermissions(x.GoPointer(), AllowedOriginsVar, DisallowedOriginsVar)
+
+}
+
+var xWebContextIsAutomationAllowed func(uintptr) bool
+
+// Get whether automation is allowed in @context.
+//
+// See also webkit_web_context_set_automation_allowed().
+func (x *WebContext) IsAutomationAllowed() bool {
+
+	cret := xWebContextIsAutomationAllowed(x.GoPointer())
+	return cret
+}
+
+var xWebContextRegisterUriScheme func(uintptr, string, uintptr, uintptr, uintptr)
+
+// Register @scheme in @context.
+//
+// Register @scheme in @context, so that when an URI request with @scheme is made in the
+// #WebKitWebContext, the #WebKitURISchemeRequestCallback registered will be called with a
+// #WebKitURISchemeRequest.
+// It is possible to handle URI scheme requests asynchronously, by calling g_object_ref() on the
+// #WebKitURISchemeRequest and calling webkit_uri_scheme_request_finish() later
+// when the data of the request is available or
+// webkit_uri_scheme_request_finish_error() in case of error.
+//
+// ```c
+// static void
+// about_uri_scheme_request_cb (WebKitURISchemeRequest *request,
+//
+//	gpointer                user_data)
+//
+//	{
+//	    GInputStream *stream;
+//	    gsize         stream_length;
+//	    const gchar  *path = webkit_uri_scheme_request_get_path (request);
+//
+//	    if (!g_strcmp0 (path, "memory")) {
+//	        // Create a GInputStream with the contents of memory about page, and set its length to stream_length
+//	    } else if (!g_strcmp0 (path, "applications")) {
+//	        // Create a GInputStream with the contents of applications about page, and set its length to stream_length
+//	    } else if (!g_strcmp0 (path, "example")) {
+//	        gchar *contents = g_strdup_printf ("&lt;html&gt;&lt;body&gt;&lt;p&gt;Example about page&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;");
+//	        stream_length = strlen (contents);
+//	        stream = g_memory_input_stream_new_from_data (contents, stream_length, g_free);
+//	    } else {
+//	        GError *error = g_error_new (ABOUT_HANDLER_ERROR, ABOUT_HANDLER_ERROR_INVALID, "Invalid about:%s page.", path);
+//	        webkit_uri_scheme_request_finish_error (request, error);
+//	        g_error_free (error);
+//	        return;
+//	    }
+//	    webkit_uri_scheme_request_finish (request, stream, stream_length, "text/html");
+//	    g_object_unref (stream);
+//	}
+//
+// ```
+func (x *WebContext) RegisterUriScheme(SchemeVar string, CallbackVar *URISchemeRequestCallback, UserDataVar uintptr, UserDataDestroyFuncVar *glib.DestroyNotify) {
+
+	xWebContextRegisterUriScheme(x.GoPointer(), SchemeVar, glib.NewCallback(CallbackVar), UserDataVar, glib.NewCallback(UserDataDestroyFuncVar))
+
+}
+
+var xWebContextSendMessageToAllExtensions func(uintptr, uintptr)
+
+// Send @message to all web process extensions associated to @context.
+//
+// If @message is floating, it's consumed.
+func (x *WebContext) SendMessageToAllExtensions(MessageVar *UserMessage) {
+
+	xWebContextSendMessageToAllExtensions(x.GoPointer(), MessageVar.GoPointer())
+
+}
+
+var xWebContextSetAutomationAllowed func(uintptr, bool)
+
+// Set whether automation is allowed in @context.
+//
+// When automation is enabled the browser could
+// be controlled by another process by requesting an automation session. When a new automation
+// session is requested the signal #WebKitWebContext::automation-started is emitted.
+// Automation is disabled by default, so you need to explicitly call this method passing %TRUE
+// to enable it.
+//
+// Note that only one #WebKitWebContext can have automation enabled, so this will do nothing
+// if there's another #WebKitWebContext with automation already enabled.
+func (x *WebContext) SetAutomationAllowed(AllowedVar bool) {
+
+	xWebContextSetAutomationAllowed(x.GoPointer(), AllowedVar)
+
+}
+
+var xWebContextSetCacheModel func(uintptr, CacheModel)
+
+// Specifies a usage model for WebViews.
+//
+// Specifies a usage model for WebViews, which WebKit will use to
+// determine its caching behavior. All web views follow the cache
+// model. This cache model determines the RAM and disk space to use
+// for caching previously viewed content .
+//
+// Research indicates that users tend to browse within clusters of
+// documents that hold resources in common, and to revisit previously
+// visited documents. WebKit and the frameworks below it include
+// built-in caches that take advantage of these patterns,
+// substantially improving document load speed in browsing
+// situations. The WebKit cache model controls the behaviors of all of
+// these caches, including various WebCore caches.
+//
+// Browsers can improve document load speed substantially by
+// specifying %WEBKIT_CACHE_MODEL_WEB_BROWSER. Applications without a
+// browsing interface can reduce memory usage substantially by
+// specifying %WEBKIT_CACHE_MODEL_DOCUMENT_VIEWER. The default value is
+// %WEBKIT_CACHE_MODEL_WEB_BROWSER.
+func (x *WebContext) SetCacheModel(CacheModelVar CacheModel) {
+
+	xWebContextSetCacheModel(x.GoPointer(), CacheModelVar)
+
+}
+
+var xWebContextSetPreferredLanguages func(uintptr, []string)
+
+// Set the list of preferred languages.
+//
+// Set the list of preferred languages, sorted from most desirable
+// to least desirable. The list will be used in the following ways:
+//
+//   - Determining how to build the `Accept-Language` HTTP header that will be
+//     included in the network requests started by the #WebKitWebContext.
+//   - Setting the values of `navigator.language` and `navigator.languages`.
+//   - The first item in the list sets the default locale for JavaScript
+//     `Intl` functions.
+func (x *WebContext) SetPreferredLanguages(LanguagesVar []string) {
+
+	xWebContextSetPreferredLanguages(x.GoPointer(), LanguagesVar)
+
+}
+
+var xWebContextSetSpellCheckingEnabled func(uintptr, bool)
+
+// Enable or disable the spell checking feature.
+func (x *WebContext) SetSpellCheckingEnabled(EnabledVar bool) {
+
+	xWebContextSetSpellCheckingEnabled(x.GoPointer(), EnabledVar)
+
+}
+
+var xWebContextSetSpellCheckingLanguages func(uintptr, []string)
+
+// Set the list of spell checking languages to be used for spell
+// checking.
+//
+// The locale string typically is in the form lang_COUNTRY, where lang
+// is an ISO-639 language code, and COUNTRY is an ISO-3166 country code.
+// For instance, sv_FI for Swedish as written in Finland or pt_BR
+// for Portuguese as written in Brazil.
+//
+// You need to call this function with a valid list of languages at
+// least once in order to properly enable the spell checking feature
+// in WebKit.
+func (x *WebContext) SetSpellCheckingLanguages(LanguagesVar []string) {
+
+	xWebContextSetSpellCheckingLanguages(x.GoPointer(), LanguagesVar)
+
+}
+
+var xWebContextSetWebProcessExtensionsDirectory func(uintptr, string)
+
+// Set the directory where WebKit will look for web process extensions.
+//
+// This method must be called before loading anything in this context,
+// otherwise it will not have any effect. You can connect to
+// #WebKitWebContext::initialize-web-process-extensions to call this method
+// before anything is loaded.
+//
+// If your web process extension is installed to an unusual location,
+// then you may also need to call webkit_web_context_add_path_to_sandbox().
+func (x *WebContext) SetWebProcessExtensionsDirectory(DirectoryVar string) {
+
+	xWebContextSetWebProcessExtensionsDirectory(x.GoPointer(), DirectoryVar)
+
+}
+
+var xWebContextSetWebProcessExtensionsInitializationUserData func(uintptr, *glib.Variant)
+
+// Set user data to be passed to Web Extensions on initialization.
+//
+// The data will be passed to the
+// #WebKitWebProcessExtensionInitializeWithUserDataFunction.
+// This method must be called before loading anything in this context,
+// otherwise it will not have any effect. You can connect to
+// #WebKitWebContext::initialize-web-process-extensions to call this method
+// before anything is loaded.
+func (x *WebContext) SetWebProcessExtensionsInitializationUserData(UserDataVar *glib.Variant) {
+
+	xWebContextSetWebProcessExtensionsInitializationUserData(x.GoPointer(), UserDataVar)
+
+}
+
+func (c *WebContext) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebContext) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyMemoryPressureSettings sets the "memory-pressure-settings" property.
+// The #WebKitMemoryPressureSettings applied to the web processes created by this context.
+func (x *WebContext) SetPropertyMemoryPressureSettings(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("memory-pressure-settings", &v)
+}
+
+// SetPropertyTimeZoneOverride sets the "time-zone-override" property.
+// The timezone override for this web context. Setting this property provides a better
+// alternative to configure the timezone information for all webviews managed by the WebContext.
+// The other, less optimal, approach is to globally set the TZ environment variable in the
+// process before creating the context. However this approach might not be very convenient and
+// can have side-effects in your application.
+//
+// The expected values for this property are defined in the IANA timezone database. See this
+// wikipedia page for instance, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
+func (x *WebContext) SetPropertyTimeZoneOverride(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("time-zone-override", &v)
+}
+
+// GetPropertyTimeZoneOverride gets the "time-zone-override" property.
+// The timezone override for this web context. Setting this property provides a better
+// alternative to configure the timezone information for all webviews managed by the WebContext.
+// The other, less optimal, approach is to globally set the TZ environment variable in the
+// process before creating the context. However this approach might not be very convenient and
+// can have side-effects in your application.
+//
+// The expected values for this property are defined in the IANA timezone database. See this
+// wikipedia page for instance, https://en.wikipedia.org/wiki/List_of_tz_database_time_zones.
+func (x *WebContext) GetPropertyTimeZoneOverride() string {
+	var v gobject.Value
+	x.GetProperty("time-zone-override", &v)
+	return v.GetString()
+}
+
+// This signal is emitted when a new automation request is made.
+// Note that it will never be emitted if automation is not enabled in @context,
+// see webkit_web_context_set_automation_allowed() for more details.
+func (x *WebContext) ConnectAutomationStarted(cb *func(WebContext, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "automation-started", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, SessionVarp uintptr) {
+		fa := WebContext{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, SessionVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "automation-started", cbRefPtr)
+}
+
+// This signal is emitted when a #WebKitWebContext needs to set
+// initial notification permissions for a web process. It is emitted
+// when a new web process is about to be launched, and signals the
+// most appropriate moment to use
+// webkit_web_context_initialize_notification_permissions(). If no
+// notification permissions have changed since the last time this
+// signal was emitted, then there is no need to call
+// webkit_web_context_initialize_notification_permissions() again.
+func (x *WebContext) ConnectInitializeNotificationPermissions(cb *func(WebContext)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "initialize-notification-permissions", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := WebContext{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "initialize-notification-permissions", cbRefPtr)
+}
+
+// This signal is emitted when a new web process is about to be
+// launched. It signals the most appropriate moment to use
+// webkit_web_context_set_web_process_extensions_initialization_user_data()
+// and webkit_web_context_set_web_process_extensions_directory().
+func (x *WebContext) ConnectInitializeWebProcessExtensions(cb *func(WebContext)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "initialize-web-process-extensions", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := WebContext{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "initialize-web-process-extensions", cbRefPtr)
+}
+
+// This signal is emitted when a #WebKitUserMessage is received from a
+// web process extension. You can reply to the message using
+// webkit_user_message_send_reply().
+//
+// You can handle the user message asynchronously by calling g_object_ref() on
+// @message and returning %TRUE.
+func (x *WebContext) ConnectUserMessageReceived(cb *func(WebContext, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MessageVarp uintptr) bool {
+		fa := WebContext{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, MessageVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
+}
+
+var xWebContextGetDefault func() uintptr
+
+// Gets the default web context.
+func WebContextGetDefault() *WebContext {
+	var cls *WebContext
+
+	cret := xWebContextGetDefault()
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WebContext{}
+	cls.Ptr = cret
+	return cls
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xCacheModelGLibType, libs, "webkit_cache_model_get_type")
+
+	core.PuregoSafeRegister(&xWebContextGLibType, libs, "webkit_web_context_get_type")
+
+	core.PuregoSafeRegister(&xNewWebContext, libs, "webkit_web_context_new")
+
+	core.PuregoSafeRegister(&xWebContextAddPathToSandbox, libs, "webkit_web_context_add_path_to_sandbox")
+	core.PuregoSafeRegister(&xWebContextGetCacheModel, libs, "webkit_web_context_get_cache_model")
+	core.PuregoSafeRegister(&xWebContextGetGeolocationManager, libs, "webkit_web_context_get_geolocation_manager")
+	core.PuregoSafeRegister(&xWebContextGetNetworkSessionForAutomation, libs, "webkit_web_context_get_network_session_for_automation")
+	core.PuregoSafeRegister(&xWebContextGetSecurityManager, libs, "webkit_web_context_get_security_manager")
+	core.PuregoSafeRegister(&xWebContextGetSpellCheckingEnabled, libs, "webkit_web_context_get_spell_checking_enabled")
+	core.PuregoSafeRegister(&xWebContextGetSpellCheckingLanguages, libs, "webkit_web_context_get_spell_checking_languages")
+	core.PuregoSafeRegister(&xWebContextGetTimeZoneOverride, libs, "webkit_web_context_get_time_zone_override")
+	core.PuregoSafeRegister(&xWebContextInitializeNotificationPermissions, libs, "webkit_web_context_initialize_notification_permissions")
+	core.PuregoSafeRegister(&xWebContextIsAutomationAllowed, libs, "webkit_web_context_is_automation_allowed")
+	core.PuregoSafeRegister(&xWebContextRegisterUriScheme, libs, "webkit_web_context_register_uri_scheme")
+	core.PuregoSafeRegister(&xWebContextSendMessageToAllExtensions, libs, "webkit_web_context_send_message_to_all_extensions")
+	core.PuregoSafeRegister(&xWebContextSetAutomationAllowed, libs, "webkit_web_context_set_automation_allowed")
+	core.PuregoSafeRegister(&xWebContextSetCacheModel, libs, "webkit_web_context_set_cache_model")
+	core.PuregoSafeRegister(&xWebContextSetPreferredLanguages, libs, "webkit_web_context_set_preferred_languages")
+	core.PuregoSafeRegister(&xWebContextSetSpellCheckingEnabled, libs, "webkit_web_context_set_spell_checking_enabled")
+	core.PuregoSafeRegister(&xWebContextSetSpellCheckingLanguages, libs, "webkit_web_context_set_spell_checking_languages")
+	core.PuregoSafeRegister(&xWebContextSetWebProcessExtensionsDirectory, libs, "webkit_web_context_set_web_process_extensions_directory")
+	core.PuregoSafeRegister(&xWebContextSetWebProcessExtensionsInitializationUserData, libs, "webkit_web_context_set_web_process_extensions_initialization_user_data")
+
+	core.PuregoSafeRegister(&xWebContextGetDefault, libs, "webkit_web_context_get_default")
+
+}
diff --git a/v4/webkit/WebKitWebExtensionMatchPattern.go b/v4/webkit/WebKitWebExtensionMatchPattern.go
new file mode 100644
index 0000000000000000000000000000000000000000..7e2502f4f91f546fa86640740bfd96f29620bc97
--- /dev/null
+++ b/v4/webkit/WebKitWebExtensionMatchPattern.go
@@ -0,0 +1,245 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Represents a way to specify a group of URLs for use in WebExtensions.
+//
+// All match patterns are specified as strings. Apart from the special `&lt;all_urls&gt;` pattern, match patterns
+// consist of three parts: scheme, host, and path.
+//
+// Generally, match patterns are returned from a #WebKitWebExtension.
+type WebExtensionMatchPattern struct {
+	_ structs.HostLayout
+}
+
+var xWebExtensionMatchPatternGLibType func() types.GType
+
+func WebExtensionMatchPatternGLibType() types.GType {
+	return xWebExtensionMatchPatternGLibType()
+}
+
+func (x *WebExtensionMatchPattern) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewWebExtensionMatchPatternAllHostsAndSchemes func() *WebExtensionMatchPattern
+
+// Returns a new #WebKitWebExtensionMatchPattern that has `*` for scheme, host, and path.
+func NewWebExtensionMatchPatternAllHostsAndSchemes() *WebExtensionMatchPattern {
+
+	cret := xNewWebExtensionMatchPatternAllHostsAndSchemes()
+	return cret
+}
+
+var xNewWebExtensionMatchPatternAllUrls func() *WebExtensionMatchPattern
+
+// Returns a new #WebKitWebExtensionMatchPattern for `&lt;all_urls&gt;`.
+func NewWebExtensionMatchPatternAllUrls() *WebExtensionMatchPattern {
+
+	cret := xNewWebExtensionMatchPatternAllUrls()
+	return cret
+}
+
+var xNewWebExtensionMatchPatternWithScheme func(string, string, string, **glib.Error) *WebExtensionMatchPattern
+
+// Returns a new #WebKitWebExtensionMatchPattern for the specified @scheme, @host, and @path strings.
+func NewWebExtensionMatchPatternWithScheme(SchemeVar string, HostVar string, PathVar string) (*WebExtensionMatchPattern, error) {
+	var cerr *glib.Error
+
+	cret := xNewWebExtensionMatchPatternWithScheme(SchemeVar, HostVar, PathVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xNewWebExtensionMatchPatternWithString func(string, **glib.Error) *WebExtensionMatchPattern
+
+// Returns a new #WebKitWebExtensionMatchPattern for the specified @string.
+func NewWebExtensionMatchPatternWithString(StringVar string) (*WebExtensionMatchPattern, error) {
+	var cerr *glib.Error
+
+	cret := xNewWebExtensionMatchPatternWithString(StringVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebExtensionMatchPatternGetHost func(uintptr) string
+
+// Gets the host part of the pattern string, unless `webkit_web_extension_match_pattern_get_matches_all_urls` is %TRUE.
+func (x *WebExtensionMatchPattern) GetHost() string {
+
+	cret := xWebExtensionMatchPatternGetHost(x.GoPointer())
+	return cret
+}
+
+var xWebExtensionMatchPatternGetMatchesAllHosts func(uintptr) bool
+
+// Gets whether the match pattern matches all host. This happens when
+// the pattern is `&lt;all_urls&gt;`, or if `*` is set as the host string.
+func (x *WebExtensionMatchPattern) GetMatchesAllHosts() bool {
+
+	cret := xWebExtensionMatchPatternGetMatchesAllHosts(x.GoPointer())
+	return cret
+}
+
+var xWebExtensionMatchPatternGetMatchesAllUrls func(uintptr) bool
+
+// Gets whether the match pattern matches all URLs, in other words, whether
+// the pattern is `&lt;all_urls&gt;`.
+func (x *WebExtensionMatchPattern) GetMatchesAllUrls() bool {
+
+	cret := xWebExtensionMatchPatternGetMatchesAllUrls(x.GoPointer())
+	return cret
+}
+
+var xWebExtensionMatchPatternGetPath func(uintptr) string
+
+// Gets the path part of the pattern string, unless [method@WebExtensionMatchPattern.get_matches_all_urls] is %TRUE.
+func (x *WebExtensionMatchPattern) GetPath() string {
+
+	cret := xWebExtensionMatchPatternGetPath(x.GoPointer())
+	return cret
+}
+
+var xWebExtensionMatchPatternGetScheme func(uintptr) string
+
+// Gets the scheme part of the pattern string, unless `webkit_web_extension_match_pattern_get_matches_all_urls` is %TRUE.
+func (x *WebExtensionMatchPattern) GetScheme() string {
+
+	cret := xWebExtensionMatchPatternGetScheme(x.GoPointer())
+	return cret
+}
+
+var xWebExtensionMatchPatternGetString func(uintptr) string
+
+// Gets the original pattern string.
+func (x *WebExtensionMatchPattern) GetString() string {
+
+	cret := xWebExtensionMatchPatternGetString(x.GoPointer())
+	return cret
+}
+
+var xWebExtensionMatchPatternMatchesPattern func(uintptr, *WebExtensionMatchPattern, WebExtensionMatchPatternOptions) bool
+
+// Matches the @matchPattern against the specified @pattern with options.
+func (x *WebExtensionMatchPattern) MatchesPattern(PatternVar *WebExtensionMatchPattern, OptionsVar WebExtensionMatchPatternOptions) bool {
+
+	cret := xWebExtensionMatchPatternMatchesPattern(x.GoPointer(), PatternVar, OptionsVar)
+	return cret
+}
+
+var xWebExtensionMatchPatternMatchesUrl func(uintptr, string, WebExtensionMatchPatternOptions) bool
+
+// Matches the @matchPattern against the specified URL with options.
+func (x *WebExtensionMatchPattern) MatchesUrl(UrlVar string, OptionsVar WebExtensionMatchPatternOptions) bool {
+
+	cret := xWebExtensionMatchPatternMatchesUrl(x.GoPointer(), UrlVar, OptionsVar)
+	return cret
+}
+
+var xWebExtensionMatchPatternRef func(uintptr) *WebExtensionMatchPattern
+
+// Atomically acquires a reference on the given @matchPattern.
+//
+// This function is MT-safe and may be called from any thread.
+func (x *WebExtensionMatchPattern) Ref() *WebExtensionMatchPattern {
+
+	cret := xWebExtensionMatchPatternRef(x.GoPointer())
+	return cret
+}
+
+var xWebExtensionMatchPatternUnref func(uintptr)
+
+// Atomically releases a reference on the given @matchPattern.
+//
+// If the reference was the last, the resources associated to the
+// @matchPattern are freed. This function is MT-safe and may be called from
+// any thread.
+func (x *WebExtensionMatchPattern) Unref() {
+
+	xWebExtensionMatchPatternUnref(x.GoPointer())
+
+}
+
+// Enum values representing matching options.
+type WebExtensionMatchPatternOptions int
+
+var xWebExtensionMatchPatternOptionsGLibType func() types.GType
+
+func WebExtensionMatchPatternOptionsGLibType() types.GType {
+	return xWebExtensionMatchPatternOptionsGLibType()
+}
+
+const (
+
+	// No special matching options.
+	WebExtensionMatchPatternOptionsNoneValue WebExtensionMatchPatternOptions = 1
+	// The scheme components should be ignored while matching.
+	WebExtensionMatchPatternOptionsIgnoreSchemesValue WebExtensionMatchPatternOptions = 2
+	// The host components should be ignored while matching.
+	WebExtensionMatchPatternOptionsIgnorePathsValue WebExtensionMatchPatternOptions = 4
+	// Two patterns should be checked in either direction while matching (A matches B, or B matches A). Invalid for matching URLs.
+	WebExtensionMatchPatternOptionsMatchBidirectionallyValue WebExtensionMatchPatternOptions = 8
+)
+
+var xWebExtensionMatchPatternRegisterCustomURLScheme func(string)
+
+// Registers a custom URL scheme that can be used in match patterns.
+//
+// This method should be used to register any custom URL schemes used by the app for the extension base URLs,
+// other than `webkit-extension`, or if extensions should have access to other supported URL schemes when using `&lt;all_urls&gt;`.
+func WebExtensionMatchPatternRegisterCustomURLScheme(UrlSchemeVar string) {
+
+	xWebExtensionMatchPatternRegisterCustomURLScheme(UrlSchemeVar)
+
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternOptionsGLibType, libs, "webkit_web_extension_match_pattern_options_get_type")
+
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternRegisterCustomURLScheme, libs, "webkit_web_extension_match_pattern_register_custom_URL_scheme")
+
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternGLibType, libs, "webkit_web_extension_match_pattern_get_type")
+
+	core.PuregoSafeRegister(&xNewWebExtensionMatchPatternAllHostsAndSchemes, libs, "webkit_web_extension_match_pattern_new_all_hosts_and_schemes")
+	core.PuregoSafeRegister(&xNewWebExtensionMatchPatternAllUrls, libs, "webkit_web_extension_match_pattern_new_all_urls")
+	core.PuregoSafeRegister(&xNewWebExtensionMatchPatternWithScheme, libs, "webkit_web_extension_match_pattern_new_with_scheme")
+	core.PuregoSafeRegister(&xNewWebExtensionMatchPatternWithString, libs, "webkit_web_extension_match_pattern_new_with_string")
+
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternGetHost, libs, "webkit_web_extension_match_pattern_get_host")
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternGetMatchesAllHosts, libs, "webkit_web_extension_match_pattern_get_matches_all_hosts")
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternGetMatchesAllUrls, libs, "webkit_web_extension_match_pattern_get_matches_all_urls")
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternGetPath, libs, "webkit_web_extension_match_pattern_get_path")
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternGetScheme, libs, "webkit_web_extension_match_pattern_get_scheme")
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternGetString, libs, "webkit_web_extension_match_pattern_get_string")
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternMatchesPattern, libs, "webkit_web_extension_match_pattern_matches_pattern")
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternMatchesUrl, libs, "webkit_web_extension_match_pattern_matches_url")
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternRef, libs, "webkit_web_extension_match_pattern_ref")
+	core.PuregoSafeRegister(&xWebExtensionMatchPatternUnref, libs, "webkit_web_extension_match_pattern_unref")
+
+}
diff --git a/v4/webkit/WebKitWebInspector.go b/v4/webkit/WebKitWebInspector.go
new file mode 100644
index 0000000000000000000000000000000000000000..ad6eea008ac4a2bf3c00921a08d6b832556e7554
--- /dev/null
+++ b/v4/webkit/WebKitWebInspector.go
@@ -0,0 +1,369 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type WebInspectorClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *WebInspectorClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Access to the WebKit inspector.
+//
+// The WebKit Inspector is a graphical tool to inspect and change the
+// content of a #WebKitWebView. It also includes an interactive
+// JavaScript debugger. Using this class one can get a #GtkWidget
+// which can be embedded into an application to show the inspector.
+//
+// The inspector is available when the #WebKitSettings of the
+// #WebKitWebView has set the #WebKitSettings:enable-developer-extras
+// to true, otherwise no inspector is available.
+//
+// ```c
+// // Enable the developer extras
+// WebKitSettings *settings = webkit_web_view_get_settings (WEBKIT_WEB_VIEW(my_webview));
+// g_object_set (G_OBJECT(settings), "enable-developer-extras", TRUE, NULL);
+//
+// // Load some data or reload to be able to inspect the page
+// webkit_web_view_load_uri (WEBKIT_WEB_VIEW(my_webview), "http://www.gnome.org");
+//
+// // Show the inspector
+// WebKitWebInspector *inspector = webkit_web_view_get_inspector (WEBKIT_WEB_VIEW(my_webview));
+// webkit_web_inspector_show (WEBKIT_WEB_INSPECTOR(inspector));
+// ```
+type WebInspector struct {
+	gobject.Object
+}
+
+var xWebInspectorGLibType func() types.GType
+
+func WebInspectorGLibType() types.GType {
+	return xWebInspectorGLibType()
+}
+
+func WebInspectorNewFromInternalPtr(ptr uintptr) *WebInspector {
+	cls := &WebInspector{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xWebInspectorAttach func(uintptr)
+
+// Request @inspector to be attached.
+//
+// The signal #WebKitWebInspector::attach
+// will be emitted. If the inspector is already attached it does nothing.
+func (x *WebInspector) Attach() {
+
+	xWebInspectorAttach(x.GoPointer())
+
+}
+
+var xWebInspectorClose func(uintptr)
+
+// Request @inspector to be closed.
+func (x *WebInspector) Close() {
+
+	xWebInspectorClose(x.GoPointer())
+
+}
+
+var xWebInspectorDetach func(uintptr)
+
+// Request @inspector to be detached.
+//
+// The signal #WebKitWebInspector::detach
+// will be emitted. If the inspector is already detached it does nothing.
+func (x *WebInspector) Detach() {
+
+	xWebInspectorDetach(x.GoPointer())
+
+}
+
+var xWebInspectorGetAttachedHeight func(uintptr) uint
+
+// Get the height that the inspector view when attached.
+//
+// Get the height that the inspector view should have when
+// it's attached. If the inspector view is not attached this
+// returns 0.
+func (x *WebInspector) GetAttachedHeight() uint {
+
+	cret := xWebInspectorGetAttachedHeight(x.GoPointer())
+	return cret
+}
+
+var xWebInspectorGetCanAttach func(uintptr) bool
+
+// Whether the @inspector can be attached to the same window that contains
+// the inspected view.
+func (x *WebInspector) GetCanAttach() bool {
+
+	cret := xWebInspectorGetCanAttach(x.GoPointer())
+	return cret
+}
+
+var xWebInspectorGetInspectedUri func(uintptr) string
+
+// Get the URI that is currently being inspected.
+//
+// This can be %NULL if
+// nothing has been loaded yet in the inspected view, if the inspector
+// has been closed or when inspected view was loaded from a HTML string
+// instead of a URI.
+func (x *WebInspector) GetInspectedUri() string {
+
+	cret := xWebInspectorGetInspectedUri(x.GoPointer())
+	return cret
+}
+
+var xWebInspectorGetWebView func(uintptr) uintptr
+
+// Get the #WebKitWebViewBase used to display the inspector.
+//
+// This might be %NULL if the inspector hasn't been loaded yet,
+// or it has been closed.
+func (x *WebInspector) GetWebView() *WebViewBase {
+	var cls *WebViewBase
+
+	cret := xWebInspectorGetWebView(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WebViewBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebInspectorIsAttached func(uintptr) bool
+
+// Whether the @inspector view is currently attached to the same window that contains
+// the inspected view.
+func (x *WebInspector) IsAttached() bool {
+
+	cret := xWebInspectorIsAttached(x.GoPointer())
+	return cret
+}
+
+var xWebInspectorShow func(uintptr)
+
+// Request @inspector to be shown.
+func (x *WebInspector) Show() {
+
+	xWebInspectorShow(x.GoPointer())
+
+}
+
+func (c *WebInspector) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebInspector) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// GetPropertyAttachedHeight gets the "attached-height" property.
+// The height that the inspector view should have when it is attached.
+func (x *WebInspector) GetPropertyAttachedHeight() uint {
+	var v gobject.Value
+	x.GetProperty("attached-height", &v)
+	return v.GetUint()
+}
+
+// GetPropertyCanAttach gets the "can-attach" property.
+// Whether the @inspector can be attached to the same window that contains
+// the inspected view.
+func (x *WebInspector) GetPropertyCanAttach() bool {
+	var v gobject.Value
+	x.GetProperty("can-attach", &v)
+	return v.GetBoolean()
+}
+
+// GetPropertyInspectedUri gets the "inspected-uri" property.
+// The URI that is currently being inspected.
+func (x *WebInspector) GetPropertyInspectedUri() string {
+	var v gobject.Value
+	x.GetProperty("inspected-uri", &v)
+	return v.GetString()
+}
+
+// Emitted when the inspector is requested to be attached to the window
+// where the inspected web view is.
+// If this signal is not handled the inspector view will be automatically
+// attached to the inspected view, so you only need to handle this signal
+// if you want to attach the inspector view yourself (for example, to add
+// the inspector view to a browser tab).
+//
+// To prevent the inspector view from being attached you can connect to this
+// signal and simply return %TRUE.
+func (x *WebInspector) ConnectAttach(cb *func(WebInspector) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "attach", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) bool {
+		fa := WebInspector{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "attach", cbRefPtr)
+}
+
+// Emitted when the inspector should be shown.
+//
+// If the inspector is not attached the inspector window should be shown
+// on top of any other windows.
+// If the inspector is attached the inspector view should be made visible.
+// For example, if the inspector view is attached using a tab in a browser
+// window, the browser window should be raised and the tab containing the
+// inspector view should be the active one.
+// In both cases, if this signal is not handled, the default implementation
+// calls gtk_window_present() on the current toplevel #GtkWindow of the
+// inspector view.
+func (x *WebInspector) ConnectBringToFront(cb *func(WebInspector) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "bring-to-front", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) bool {
+		fa := WebInspector{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "bring-to-front", cbRefPtr)
+}
+
+// Emitted when the inspector page is closed. If you are using your own
+// inspector window, you should connect to this signal and destroy your
+// window.
+func (x *WebInspector) ConnectClosed(cb *func(WebInspector)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := WebInspector{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "closed", cbRefPtr)
+}
+
+// Emitted when the inspector is requested to be detached from the window
+// it is currently attached to. The inspector is detached when the inspector page
+// is about to be closed, and this signal is emitted right before
+// #WebKitWebInspector::closed, or when the user clicks on the detach button
+// in the inspector view to show the inspector in a separate window. In this case
+// the signal #WebKitWebInspector::open-window is emitted after this one.
+//
+// To prevent the inspector view from being detached you can connect to this
+// signal and simply return %TRUE.
+func (x *WebInspector) ConnectDetach(cb *func(WebInspector) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "detach", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) bool {
+		fa := WebInspector{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "detach", cbRefPtr)
+}
+
+// Emitted when the inspector is requested to open in a separate window.
+// If this signal is not handled, a #GtkWindow with the inspector will be
+// created and shown, so you only need to handle this signal if you want
+// to use your own window.
+// This signal is emitted after #WebKitWebInspector::detach to show
+// the inspector in a separate window after being detached.
+//
+// To prevent the inspector from being shown you can connect to this
+// signal and simply return %TRUE
+func (x *WebInspector) ConnectOpenWindow(cb *func(WebInspector) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "open-window", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) bool {
+		fa := WebInspector{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "open-window", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xWebInspectorGLibType, libs, "webkit_web_inspector_get_type")
+
+	core.PuregoSafeRegister(&xWebInspectorAttach, libs, "webkit_web_inspector_attach")
+	core.PuregoSafeRegister(&xWebInspectorClose, libs, "webkit_web_inspector_close")
+	core.PuregoSafeRegister(&xWebInspectorDetach, libs, "webkit_web_inspector_detach")
+	core.PuregoSafeRegister(&xWebInspectorGetAttachedHeight, libs, "webkit_web_inspector_get_attached_height")
+	core.PuregoSafeRegister(&xWebInspectorGetCanAttach, libs, "webkit_web_inspector_get_can_attach")
+	core.PuregoSafeRegister(&xWebInspectorGetInspectedUri, libs, "webkit_web_inspector_get_inspected_uri")
+	core.PuregoSafeRegister(&xWebInspectorGetWebView, libs, "webkit_web_inspector_get_web_view")
+	core.PuregoSafeRegister(&xWebInspectorIsAttached, libs, "webkit_web_inspector_is_attached")
+	core.PuregoSafeRegister(&xWebInspectorShow, libs, "webkit_web_inspector_show")
+
+}
diff --git a/v4/webkit/WebKitWebResource.go b/v4/webkit/WebKitWebResource.go
new file mode 100644
index 0000000000000000000000000000000000000000..234269a259331a49ad52e8f7e9face572abbbb5d
--- /dev/null
+++ b/v4/webkit/WebKitWebResource.go
@@ -0,0 +1,270 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type WebResourceClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *WebResourceClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Represents a resource at the end of a URI.
+//
+// A #WebKitWebResource encapsulates content for each resource at the
+// end of a particular URI. For example, one #WebKitWebResource will
+// be created for each separate image and stylesheet when a page is
+// loaded.
+//
+// You can access the response and the URI for a given
+// #WebKitWebResource, using webkit_web_resource_get_uri() and
+// webkit_web_resource_get_response(), as well as the raw data, using
+// webkit_web_resource_get_data().
+type WebResource struct {
+	gobject.Object
+}
+
+var xWebResourceGLibType func() types.GType
+
+func WebResourceGLibType() types.GType {
+	return xWebResourceGLibType()
+}
+
+func WebResourceNewFromInternalPtr(ptr uintptr) *WebResource {
+	cls := &WebResource{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xWebResourceGetData func(uintptr, uintptr, uintptr, uintptr)
+
+// Asynchronously get the raw data for @resource.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_web_resource_get_data_finish() to get the result of the operation.
+func (x *WebResource) GetData(CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebResourceGetData(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebResourceGetDataFinish func(uintptr, uintptr, *uint, **glib.Error) uintptr
+
+// Finish an asynchronous operation started with webkit_web_resource_get_data().
+func (x *WebResource) GetDataFinish(ResultVar gio.AsyncResult, LengthVar *uint) (uintptr, error) {
+	var cerr *glib.Error
+
+	cret := xWebResourceGetDataFinish(x.GoPointer(), ResultVar.GoPointer(), LengthVar, &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebResourceGetResponse func(uintptr) uintptr
+
+// Retrieves the #WebKitURIResponse of the resource load operation.
+//
+// This method returns %NULL if called before the response
+// is received from the server. You can connect to notify::response
+// signal to be notified when the response is received.
+func (x *WebResource) GetResponse() *URIResponse {
+	var cls *URIResponse
+
+	cret := xWebResourceGetResponse(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &URIResponse{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebResourceGetUri func(uintptr) string
+
+// Returns the current active URI of @resource.
+//
+// The active URI might change during
+// a load operation:
+//
+// &lt;orderedlist&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	When the resource load starts, the active URI is the requested URI
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	When the initial request is sent to the server, #WebKitWebResource::sent-request
+//	signal is emitted without a redirected response, the active URI is the URI of
+//	the request sent to the server.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	In case of a server redirection, #WebKitWebResource::sent-request signal
+//	is emitted again with a redirected response, the active URI is the URI the request
+//	was redirected to.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	When the response is received from the server, the active URI is the final
+//	one and it will not change again.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;/orderedlist&gt;
+//
+// You can monitor the active URI by connecting to the notify::uri
+// signal of @resource.
+func (x *WebResource) GetUri() string {
+
+	cret := xWebResourceGetUri(x.GoPointer())
+	return cret
+}
+
+func (c *WebResource) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebResource) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// GetPropertyUri gets the "uri" property.
+// The current active URI of the #WebKitWebResource.
+// See webkit_web_resource_get_uri() for more details.
+func (x *WebResource) GetPropertyUri() string {
+	var v gobject.Value
+	x.GetProperty("uri", &v)
+	return v.GetString()
+}
+
+// This signal is emitted when an error occurs during the resource
+// load operation.
+func (x *WebResource) ConnectFailed(cb *func(WebResource, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "failed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ErrorVarp uintptr) {
+		fa := WebResource{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ErrorVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "failed", cbRefPtr)
+}
+
+// This signal is emitted when a TLS error occurs during the resource load operation.
+func (x *WebResource) ConnectFailedWithTlsErrors(cb *func(WebResource, uintptr, gio.TlsCertificateFlags)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "failed-with-tls-errors", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, CertificateVarp uintptr, ErrorsVarp gio.TlsCertificateFlags) {
+		fa := WebResource{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, CertificateVarp, ErrorsVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "failed-with-tls-errors", cbRefPtr)
+}
+
+// This signal is emitted when the resource load finishes successfully
+// or due to an error. In case of errors #WebKitWebResource::failed signal
+// is emitted before this one.
+func (x *WebResource) ConnectFinished(cb *func(WebResource)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := WebResource{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "finished", cbRefPtr)
+}
+
+// This signal is emitted when @request has been sent to the
+// server. In case of a server redirection this signal is
+// emitted again with the @request argument containing the new
+// request sent to the server due to the redirection and the
+// @redirected_response parameter containing the response
+// received by the server for the initial request.
+func (x *WebResource) ConnectSentRequest(cb *func(WebResource, uintptr, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "sent-request", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, RequestVarp uintptr, RedirectedResponseVarp uintptr) {
+		fa := WebResource{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, RequestVarp, RedirectedResponseVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "sent-request", cbRefPtr)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xWebResourceGLibType, libs, "webkit_web_resource_get_type")
+
+	core.PuregoSafeRegister(&xWebResourceGetData, libs, "webkit_web_resource_get_data")
+	core.PuregoSafeRegister(&xWebResourceGetDataFinish, libs, "webkit_web_resource_get_data_finish")
+	core.PuregoSafeRegister(&xWebResourceGetResponse, libs, "webkit_web_resource_get_response")
+	core.PuregoSafeRegister(&xWebResourceGetUri, libs, "webkit_web_resource_get_uri")
+
+}
diff --git a/v4/webkit/WebKitWebView.go b/v4/webkit/WebKitWebView.go
new file mode 100644
index 0000000000000000000000000000000000000000..6d2713511e6c2f864b439275e18d93d29e470021
--- /dev/null
+++ b/v4/webkit/WebKitWebView.go
@@ -0,0 +1,4608 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gdk"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/gtk"
+	"github.com/jwijenbergh/puregotk/v4/javascriptcore"
+)
+
+type WebViewClass struct {
+	_ structs.HostLayout
+
+	Parent uintptr
+
+	xLoadChanged uintptr
+
+	xLoadFailed uintptr
+
+	xCreate uintptr
+
+	xReadyToShow uintptr
+
+	xRunAsModal uintptr
+
+	xClose uintptr
+
+	xScriptDialog uintptr
+
+	xDecidePolicy uintptr
+
+	xPermissionRequest uintptr
+
+	xMouseTargetChanged uintptr
+
+	xPrint uintptr
+
+	xResourceLoadStarted uintptr
+
+	xEnterFullscreen uintptr
+
+	xLeaveFullscreen uintptr
+
+	xRunFileChooser uintptr
+
+	xContextMenu uintptr
+
+	xContextMenuDismissed uintptr
+
+	xSubmitForm uintptr
+
+	xInsecureContentDetected uintptr
+
+	xWebProcessCrashed uintptr
+
+	xAuthenticate uintptr
+
+	xLoadFailedWithTlsErrors uintptr
+
+	xShowNotification uintptr
+
+	xRunColorChooser uintptr
+
+	xShowOptionMenu uintptr
+
+	xWebProcessTerminated uintptr
+
+	xUserMessageReceived uintptr
+
+	xQueryPermissionState uintptr
+
+	xWebkitReserved0 uintptr
+
+	xWebkitReserved1 uintptr
+
+	xWebkitReserved2 uintptr
+
+	xWebkitReserved3 uintptr
+
+	xWebkitReserved4 uintptr
+
+	xWebkitReserved5 uintptr
+
+	xWebkitReserved6 uintptr
+
+	xWebkitReserved7 uintptr
+
+	xWebkitReserved8 uintptr
+
+	xWebkitReserved9 uintptr
+
+	xWebkitReserved10 uintptr
+
+	xWebkitReserved11 uintptr
+
+	xWebkitReserved12 uintptr
+
+	xWebkitReserved13 uintptr
+
+	xWebkitReserved14 uintptr
+
+	xWebkitReserved15 uintptr
+
+	xWebkitReserved16 uintptr
+
+	xWebkitReserved17 uintptr
+
+	xWebkitReserved18 uintptr
+
+	xWebkitReserved19 uintptr
+
+	xWebkitReserved20 uintptr
+
+	xWebkitReserved21 uintptr
+
+	xWebkitReserved22 uintptr
+
+	xWebkitReserved23 uintptr
+
+	xWebkitReserved24 uintptr
+
+	xWebkitReserved25 uintptr
+
+	xWebkitReserved26 uintptr
+
+	xWebkitReserved27 uintptr
+
+	xWebkitReserved28 uintptr
+
+	xWebkitReserved29 uintptr
+
+	xWebkitReserved30 uintptr
+}
+
+func (x *WebViewClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideLoadChanged sets the "load_changed" callback function.
+func (x *WebViewClass) OverrideLoadChanged(cb func(*WebView, LoadEvent)) {
+	if cb == nil {
+		x.xLoadChanged = 0
+	} else {
+		x.xLoadChanged = purego.NewCallback(func(WebViewVarp uintptr, LoadEventVarp LoadEvent) {
+			cb(WebViewNewFromInternalPtr(WebViewVarp), LoadEventVarp)
+		})
+	}
+}
+
+// GetLoadChanged gets the "load_changed" callback function.
+func (x *WebViewClass) GetLoadChanged() func(*WebView, LoadEvent) {
+	if x.xLoadChanged == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, LoadEventVarp LoadEvent)
+	purego.RegisterFunc(&rawCallback, x.xLoadChanged)
+	return func(WebViewVar *WebView, LoadEventVar LoadEvent) {
+		rawCallback(WebViewVar.GoPointer(), LoadEventVar)
+	}
+}
+
+// OverrideLoadFailed sets the "load_failed" callback function.
+func (x *WebViewClass) OverrideLoadFailed(cb func(*WebView, LoadEvent, string, *glib.Error) bool) {
+	if cb == nil {
+		x.xLoadFailed = 0
+	} else {
+		x.xLoadFailed = purego.NewCallback(func(WebViewVarp uintptr, LoadEventVarp LoadEvent, FailingUriVarp string, ErrorVarp *glib.Error) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), LoadEventVarp, FailingUriVarp, ErrorVarp)
+		})
+	}
+}
+
+// GetLoadFailed gets the "load_failed" callback function.
+func (x *WebViewClass) GetLoadFailed() func(*WebView, LoadEvent, string, *glib.Error) bool {
+	if x.xLoadFailed == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, LoadEventVarp LoadEvent, FailingUriVarp string, ErrorVarp *glib.Error) bool
+	purego.RegisterFunc(&rawCallback, x.xLoadFailed)
+	return func(WebViewVar *WebView, LoadEventVar LoadEvent, FailingUriVar string, ErrorVar *glib.Error) bool {
+		return rawCallback(WebViewVar.GoPointer(), LoadEventVar, FailingUriVar, ErrorVar)
+	}
+}
+
+// OverrideCreate sets the "create" callback function.
+func (x *WebViewClass) OverrideCreate(cb func(*WebView, *NavigationAction) *gtk.Widget) {
+	if cb == nil {
+		x.xCreate = 0
+	} else {
+		x.xCreate = purego.NewCallback(func(WebViewVarp uintptr, NavigationActionVarp *NavigationAction) uintptr {
+			ret := cb(WebViewNewFromInternalPtr(WebViewVarp), NavigationActionVarp)
+			if ret == nil {
+				return 0
+			}
+			return ret.GoPointer()
+		})
+	}
+}
+
+// GetCreate gets the "create" callback function.
+func (x *WebViewClass) GetCreate() func(*WebView, *NavigationAction) *gtk.Widget {
+	if x.xCreate == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, NavigationActionVarp *NavigationAction) uintptr
+	purego.RegisterFunc(&rawCallback, x.xCreate)
+	return func(WebViewVar *WebView, NavigationActionVar *NavigationAction) *gtk.Widget {
+		rawRet := rawCallback(WebViewVar.GoPointer(), NavigationActionVar)
+		if rawRet == 0 {
+			return nil
+		}
+		ret := &gtk.Widget{}
+		ret.Ptr = rawRet
+		return ret
+	}
+}
+
+// OverrideReadyToShow sets the "ready_to_show" callback function.
+func (x *WebViewClass) OverrideReadyToShow(cb func(*WebView)) {
+	if cb == nil {
+		x.xReadyToShow = 0
+	} else {
+		x.xReadyToShow = purego.NewCallback(func(WebViewVarp uintptr) {
+			cb(WebViewNewFromInternalPtr(WebViewVarp))
+		})
+	}
+}
+
+// GetReadyToShow gets the "ready_to_show" callback function.
+func (x *WebViewClass) GetReadyToShow() func(*WebView) {
+	if x.xReadyToShow == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xReadyToShow)
+	return func(WebViewVar *WebView) {
+		rawCallback(WebViewVar.GoPointer())
+	}
+}
+
+// OverrideRunAsModal sets the "run_as_modal" callback function.
+func (x *WebViewClass) OverrideRunAsModal(cb func(*WebView)) {
+	if cb == nil {
+		x.xRunAsModal = 0
+	} else {
+		x.xRunAsModal = purego.NewCallback(func(WebViewVarp uintptr) {
+			cb(WebViewNewFromInternalPtr(WebViewVarp))
+		})
+	}
+}
+
+// GetRunAsModal gets the "run_as_modal" callback function.
+func (x *WebViewClass) GetRunAsModal() func(*WebView) {
+	if x.xRunAsModal == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xRunAsModal)
+	return func(WebViewVar *WebView) {
+		rawCallback(WebViewVar.GoPointer())
+	}
+}
+
+// OverrideClose sets the "close" callback function.
+func (x *WebViewClass) OverrideClose(cb func(*WebView)) {
+	if cb == nil {
+		x.xClose = 0
+	} else {
+		x.xClose = purego.NewCallback(func(WebViewVarp uintptr) {
+			cb(WebViewNewFromInternalPtr(WebViewVarp))
+		})
+	}
+}
+
+// GetClose gets the "close" callback function.
+func (x *WebViewClass) GetClose() func(*WebView) {
+	if x.xClose == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xClose)
+	return func(WebViewVar *WebView) {
+		rawCallback(WebViewVar.GoPointer())
+	}
+}
+
+// OverrideScriptDialog sets the "script_dialog" callback function.
+func (x *WebViewClass) OverrideScriptDialog(cb func(*WebView, *ScriptDialog) bool) {
+	if cb == nil {
+		x.xScriptDialog = 0
+	} else {
+		x.xScriptDialog = purego.NewCallback(func(WebViewVarp uintptr, DialogVarp *ScriptDialog) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), DialogVarp)
+		})
+	}
+}
+
+// GetScriptDialog gets the "script_dialog" callback function.
+func (x *WebViewClass) GetScriptDialog() func(*WebView, *ScriptDialog) bool {
+	if x.xScriptDialog == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, DialogVarp *ScriptDialog) bool
+	purego.RegisterFunc(&rawCallback, x.xScriptDialog)
+	return func(WebViewVar *WebView, DialogVar *ScriptDialog) bool {
+		return rawCallback(WebViewVar.GoPointer(), DialogVar)
+	}
+}
+
+// OverrideDecidePolicy sets the "decide_policy" callback function.
+func (x *WebViewClass) OverrideDecidePolicy(cb func(*WebView, *PolicyDecision, PolicyDecisionType) bool) {
+	if cb == nil {
+		x.xDecidePolicy = 0
+	} else {
+		x.xDecidePolicy = purego.NewCallback(func(WebViewVarp uintptr, DecisionVarp uintptr, TypeVarp PolicyDecisionType) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), PolicyDecisionNewFromInternalPtr(DecisionVarp), TypeVarp)
+		})
+	}
+}
+
+// GetDecidePolicy gets the "decide_policy" callback function.
+func (x *WebViewClass) GetDecidePolicy() func(*WebView, *PolicyDecision, PolicyDecisionType) bool {
+	if x.xDecidePolicy == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, DecisionVarp uintptr, TypeVarp PolicyDecisionType) bool
+	purego.RegisterFunc(&rawCallback, x.xDecidePolicy)
+	return func(WebViewVar *WebView, DecisionVar *PolicyDecision, TypeVar PolicyDecisionType) bool {
+		return rawCallback(WebViewVar.GoPointer(), DecisionVar.GoPointer(), TypeVar)
+	}
+}
+
+// OverridePermissionRequest sets the "permission_request" callback function.
+func (x *WebViewClass) OverridePermissionRequest(cb func(*WebView, PermissionRequest) bool) {
+	if cb == nil {
+		x.xPermissionRequest = 0
+	} else {
+		x.xPermissionRequest = purego.NewCallback(func(WebViewVarp uintptr, PermissionRequestVarp uintptr) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), &PermissionRequestBase{Ptr: PermissionRequestVarp})
+		})
+	}
+}
+
+// GetPermissionRequest gets the "permission_request" callback function.
+func (x *WebViewClass) GetPermissionRequest() func(*WebView, PermissionRequest) bool {
+	if x.xPermissionRequest == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, PermissionRequestVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xPermissionRequest)
+	return func(WebViewVar *WebView, PermissionRequestVar PermissionRequest) bool {
+		return rawCallback(WebViewVar.GoPointer(), PermissionRequestVar.GoPointer())
+	}
+}
+
+// OverrideMouseTargetChanged sets the "mouse_target_changed" callback function.
+func (x *WebViewClass) OverrideMouseTargetChanged(cb func(*WebView, *HitTestResult, uint)) {
+	if cb == nil {
+		x.xMouseTargetChanged = 0
+	} else {
+		x.xMouseTargetChanged = purego.NewCallback(func(WebViewVarp uintptr, HitTestResultVarp uintptr, ModifiersVarp uint) {
+			cb(WebViewNewFromInternalPtr(WebViewVarp), HitTestResultNewFromInternalPtr(HitTestResultVarp), ModifiersVarp)
+		})
+	}
+}
+
+// GetMouseTargetChanged gets the "mouse_target_changed" callback function.
+func (x *WebViewClass) GetMouseTargetChanged() func(*WebView, *HitTestResult, uint) {
+	if x.xMouseTargetChanged == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, HitTestResultVarp uintptr, ModifiersVarp uint)
+	purego.RegisterFunc(&rawCallback, x.xMouseTargetChanged)
+	return func(WebViewVar *WebView, HitTestResultVar *HitTestResult, ModifiersVar uint) {
+		rawCallback(WebViewVar.GoPointer(), HitTestResultVar.GoPointer(), ModifiersVar)
+	}
+}
+
+// OverridePrint sets the "print" callback function.
+func (x *WebViewClass) OverridePrint(cb func(*WebView, *PrintOperation) bool) {
+	if cb == nil {
+		x.xPrint = 0
+	} else {
+		x.xPrint = purego.NewCallback(func(WebViewVarp uintptr, PrintOperationVarp uintptr) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), PrintOperationNewFromInternalPtr(PrintOperationVarp))
+		})
+	}
+}
+
+// GetPrint gets the "print" callback function.
+func (x *WebViewClass) GetPrint() func(*WebView, *PrintOperation) bool {
+	if x.xPrint == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, PrintOperationVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xPrint)
+	return func(WebViewVar *WebView, PrintOperationVar *PrintOperation) bool {
+		return rawCallback(WebViewVar.GoPointer(), PrintOperationVar.GoPointer())
+	}
+}
+
+// OverrideResourceLoadStarted sets the "resource_load_started" callback function.
+func (x *WebViewClass) OverrideResourceLoadStarted(cb func(*WebView, *WebResource, *URIRequest)) {
+	if cb == nil {
+		x.xResourceLoadStarted = 0
+	} else {
+		x.xResourceLoadStarted = purego.NewCallback(func(WebViewVarp uintptr, ResourceVarp uintptr, RequestVarp uintptr) {
+			cb(WebViewNewFromInternalPtr(WebViewVarp), WebResourceNewFromInternalPtr(ResourceVarp), URIRequestNewFromInternalPtr(RequestVarp))
+		})
+	}
+}
+
+// GetResourceLoadStarted gets the "resource_load_started" callback function.
+func (x *WebViewClass) GetResourceLoadStarted() func(*WebView, *WebResource, *URIRequest) {
+	if x.xResourceLoadStarted == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, ResourceVarp uintptr, RequestVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xResourceLoadStarted)
+	return func(WebViewVar *WebView, ResourceVar *WebResource, RequestVar *URIRequest) {
+		rawCallback(WebViewVar.GoPointer(), ResourceVar.GoPointer(), RequestVar.GoPointer())
+	}
+}
+
+// OverrideEnterFullscreen sets the "enter_fullscreen" callback function.
+func (x *WebViewClass) OverrideEnterFullscreen(cb func(*WebView) bool) {
+	if cb == nil {
+		x.xEnterFullscreen = 0
+	} else {
+		x.xEnterFullscreen = purego.NewCallback(func(WebViewVarp uintptr) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp))
+		})
+	}
+}
+
+// GetEnterFullscreen gets the "enter_fullscreen" callback function.
+func (x *WebViewClass) GetEnterFullscreen() func(*WebView) bool {
+	if x.xEnterFullscreen == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xEnterFullscreen)
+	return func(WebViewVar *WebView) bool {
+		return rawCallback(WebViewVar.GoPointer())
+	}
+}
+
+// OverrideLeaveFullscreen sets the "leave_fullscreen" callback function.
+func (x *WebViewClass) OverrideLeaveFullscreen(cb func(*WebView) bool) {
+	if cb == nil {
+		x.xLeaveFullscreen = 0
+	} else {
+		x.xLeaveFullscreen = purego.NewCallback(func(WebViewVarp uintptr) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp))
+		})
+	}
+}
+
+// GetLeaveFullscreen gets the "leave_fullscreen" callback function.
+func (x *WebViewClass) GetLeaveFullscreen() func(*WebView) bool {
+	if x.xLeaveFullscreen == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xLeaveFullscreen)
+	return func(WebViewVar *WebView) bool {
+		return rawCallback(WebViewVar.GoPointer())
+	}
+}
+
+// OverrideRunFileChooser sets the "run_file_chooser" callback function.
+func (x *WebViewClass) OverrideRunFileChooser(cb func(*WebView, *FileChooserRequest) bool) {
+	if cb == nil {
+		x.xRunFileChooser = 0
+	} else {
+		x.xRunFileChooser = purego.NewCallback(func(WebViewVarp uintptr, RequestVarp uintptr) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), FileChooserRequestNewFromInternalPtr(RequestVarp))
+		})
+	}
+}
+
+// GetRunFileChooser gets the "run_file_chooser" callback function.
+func (x *WebViewClass) GetRunFileChooser() func(*WebView, *FileChooserRequest) bool {
+	if x.xRunFileChooser == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, RequestVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xRunFileChooser)
+	return func(WebViewVar *WebView, RequestVar *FileChooserRequest) bool {
+		return rawCallback(WebViewVar.GoPointer(), RequestVar.GoPointer())
+	}
+}
+
+// OverrideContextMenu sets the "context_menu" callback function.
+func (x *WebViewClass) OverrideContextMenu(cb func(*WebView, *ContextMenu, *HitTestResult) bool) {
+	if cb == nil {
+		x.xContextMenu = 0
+	} else {
+		x.xContextMenu = purego.NewCallback(func(WebViewVarp uintptr, ContextMenuVarp uintptr, HitTestResultVarp uintptr) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), ContextMenuNewFromInternalPtr(ContextMenuVarp), HitTestResultNewFromInternalPtr(HitTestResultVarp))
+		})
+	}
+}
+
+// GetContextMenu gets the "context_menu" callback function.
+func (x *WebViewClass) GetContextMenu() func(*WebView, *ContextMenu, *HitTestResult) bool {
+	if x.xContextMenu == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, ContextMenuVarp uintptr, HitTestResultVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xContextMenu)
+	return func(WebViewVar *WebView, ContextMenuVar *ContextMenu, HitTestResultVar *HitTestResult) bool {
+		return rawCallback(WebViewVar.GoPointer(), ContextMenuVar.GoPointer(), HitTestResultVar.GoPointer())
+	}
+}
+
+// OverrideContextMenuDismissed sets the "context_menu_dismissed" callback function.
+func (x *WebViewClass) OverrideContextMenuDismissed(cb func(*WebView)) {
+	if cb == nil {
+		x.xContextMenuDismissed = 0
+	} else {
+		x.xContextMenuDismissed = purego.NewCallback(func(WebViewVarp uintptr) {
+			cb(WebViewNewFromInternalPtr(WebViewVarp))
+		})
+	}
+}
+
+// GetContextMenuDismissed gets the "context_menu_dismissed" callback function.
+func (x *WebViewClass) GetContextMenuDismissed() func(*WebView) {
+	if x.xContextMenuDismissed == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xContextMenuDismissed)
+	return func(WebViewVar *WebView) {
+		rawCallback(WebViewVar.GoPointer())
+	}
+}
+
+// OverrideSubmitForm sets the "submit_form" callback function.
+func (x *WebViewClass) OverrideSubmitForm(cb func(*WebView, *FormSubmissionRequest)) {
+	if cb == nil {
+		x.xSubmitForm = 0
+	} else {
+		x.xSubmitForm = purego.NewCallback(func(WebViewVarp uintptr, RequestVarp uintptr) {
+			cb(WebViewNewFromInternalPtr(WebViewVarp), FormSubmissionRequestNewFromInternalPtr(RequestVarp))
+		})
+	}
+}
+
+// GetSubmitForm gets the "submit_form" callback function.
+func (x *WebViewClass) GetSubmitForm() func(*WebView, *FormSubmissionRequest) {
+	if x.xSubmitForm == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, RequestVarp uintptr)
+	purego.RegisterFunc(&rawCallback, x.xSubmitForm)
+	return func(WebViewVar *WebView, RequestVar *FormSubmissionRequest) {
+		rawCallback(WebViewVar.GoPointer(), RequestVar.GoPointer())
+	}
+}
+
+// OverrideInsecureContentDetected sets the "insecure_content_detected" callback function.
+func (x *WebViewClass) OverrideInsecureContentDetected(cb func(*WebView, InsecureContentEvent)) {
+	if cb == nil {
+		x.xInsecureContentDetected = 0
+	} else {
+		x.xInsecureContentDetected = purego.NewCallback(func(WebViewVarp uintptr, EventVarp InsecureContentEvent) {
+			cb(WebViewNewFromInternalPtr(WebViewVarp), EventVarp)
+		})
+	}
+}
+
+// GetInsecureContentDetected gets the "insecure_content_detected" callback function.
+func (x *WebViewClass) GetInsecureContentDetected() func(*WebView, InsecureContentEvent) {
+	if x.xInsecureContentDetected == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, EventVarp InsecureContentEvent)
+	purego.RegisterFunc(&rawCallback, x.xInsecureContentDetected)
+	return func(WebViewVar *WebView, EventVar InsecureContentEvent) {
+		rawCallback(WebViewVar.GoPointer(), EventVar)
+	}
+}
+
+// OverrideWebProcessCrashed sets the "web_process_crashed" callback function.
+func (x *WebViewClass) OverrideWebProcessCrashed(cb func(*WebView) bool) {
+	if cb == nil {
+		x.xWebProcessCrashed = 0
+	} else {
+		x.xWebProcessCrashed = purego.NewCallback(func(WebViewVarp uintptr) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp))
+		})
+	}
+}
+
+// GetWebProcessCrashed gets the "web_process_crashed" callback function.
+func (x *WebViewClass) GetWebProcessCrashed() func(*WebView) bool {
+	if x.xWebProcessCrashed == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xWebProcessCrashed)
+	return func(WebViewVar *WebView) bool {
+		return rawCallback(WebViewVar.GoPointer())
+	}
+}
+
+// OverrideAuthenticate sets the "authenticate" callback function.
+func (x *WebViewClass) OverrideAuthenticate(cb func(*WebView, *AuthenticationRequest) bool) {
+	if cb == nil {
+		x.xAuthenticate = 0
+	} else {
+		x.xAuthenticate = purego.NewCallback(func(WebViewVarp uintptr, RequestVarp uintptr) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), AuthenticationRequestNewFromInternalPtr(RequestVarp))
+		})
+	}
+}
+
+// GetAuthenticate gets the "authenticate" callback function.
+func (x *WebViewClass) GetAuthenticate() func(*WebView, *AuthenticationRequest) bool {
+	if x.xAuthenticate == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, RequestVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xAuthenticate)
+	return func(WebViewVar *WebView, RequestVar *AuthenticationRequest) bool {
+		return rawCallback(WebViewVar.GoPointer(), RequestVar.GoPointer())
+	}
+}
+
+// OverrideLoadFailedWithTlsErrors sets the "load_failed_with_tls_errors" callback function.
+func (x *WebViewClass) OverrideLoadFailedWithTlsErrors(cb func(*WebView, string, *gio.TlsCertificate, gio.TlsCertificateFlags) bool) {
+	if cb == nil {
+		x.xLoadFailedWithTlsErrors = 0
+	} else {
+		x.xLoadFailedWithTlsErrors = purego.NewCallback(func(WebViewVarp uintptr, FailingUriVarp string, CertificateVarp uintptr, ErrorsVarp gio.TlsCertificateFlags) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), FailingUriVarp, gio.TlsCertificateNewFromInternalPtr(CertificateVarp), ErrorsVarp)
+		})
+	}
+}
+
+// GetLoadFailedWithTlsErrors gets the "load_failed_with_tls_errors" callback function.
+func (x *WebViewClass) GetLoadFailedWithTlsErrors() func(*WebView, string, *gio.TlsCertificate, gio.TlsCertificateFlags) bool {
+	if x.xLoadFailedWithTlsErrors == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, FailingUriVarp string, CertificateVarp uintptr, ErrorsVarp gio.TlsCertificateFlags) bool
+	purego.RegisterFunc(&rawCallback, x.xLoadFailedWithTlsErrors)
+	return func(WebViewVar *WebView, FailingUriVar string, CertificateVar *gio.TlsCertificate, ErrorsVar gio.TlsCertificateFlags) bool {
+		return rawCallback(WebViewVar.GoPointer(), FailingUriVar, CertificateVar.GoPointer(), ErrorsVar)
+	}
+}
+
+// OverrideShowNotification sets the "show_notification" callback function.
+func (x *WebViewClass) OverrideShowNotification(cb func(*WebView, *Notification) bool) {
+	if cb == nil {
+		x.xShowNotification = 0
+	} else {
+		x.xShowNotification = purego.NewCallback(func(WebViewVarp uintptr, NotificationVarp uintptr) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), NotificationNewFromInternalPtr(NotificationVarp))
+		})
+	}
+}
+
+// GetShowNotification gets the "show_notification" callback function.
+func (x *WebViewClass) GetShowNotification() func(*WebView, *Notification) bool {
+	if x.xShowNotification == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, NotificationVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xShowNotification)
+	return func(WebViewVar *WebView, NotificationVar *Notification) bool {
+		return rawCallback(WebViewVar.GoPointer(), NotificationVar.GoPointer())
+	}
+}
+
+// OverrideRunColorChooser sets the "run_color_chooser" callback function.
+func (x *WebViewClass) OverrideRunColorChooser(cb func(*WebView, *ColorChooserRequest) bool) {
+	if cb == nil {
+		x.xRunColorChooser = 0
+	} else {
+		x.xRunColorChooser = purego.NewCallback(func(WebViewVarp uintptr, RequestVarp uintptr) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), ColorChooserRequestNewFromInternalPtr(RequestVarp))
+		})
+	}
+}
+
+// GetRunColorChooser gets the "run_color_chooser" callback function.
+func (x *WebViewClass) GetRunColorChooser() func(*WebView, *ColorChooserRequest) bool {
+	if x.xRunColorChooser == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, RequestVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xRunColorChooser)
+	return func(WebViewVar *WebView, RequestVar *ColorChooserRequest) bool {
+		return rawCallback(WebViewVar.GoPointer(), RequestVar.GoPointer())
+	}
+}
+
+// OverrideShowOptionMenu sets the "show_option_menu" callback function.
+func (x *WebViewClass) OverrideShowOptionMenu(cb func(*WebView, *OptionMenu, *gdk.Rectangle) bool) {
+	if cb == nil {
+		x.xShowOptionMenu = 0
+	} else {
+		x.xShowOptionMenu = purego.NewCallback(func(WebViewVarp uintptr, MenuVarp uintptr, RectangleVarp *gdk.Rectangle) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), OptionMenuNewFromInternalPtr(MenuVarp), RectangleVarp)
+		})
+	}
+}
+
+// GetShowOptionMenu gets the "show_option_menu" callback function.
+func (x *WebViewClass) GetShowOptionMenu() func(*WebView, *OptionMenu, *gdk.Rectangle) bool {
+	if x.xShowOptionMenu == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, MenuVarp uintptr, RectangleVarp *gdk.Rectangle) bool
+	purego.RegisterFunc(&rawCallback, x.xShowOptionMenu)
+	return func(WebViewVar *WebView, MenuVar *OptionMenu, RectangleVar *gdk.Rectangle) bool {
+		return rawCallback(WebViewVar.GoPointer(), MenuVar.GoPointer(), RectangleVar)
+	}
+}
+
+// OverrideWebProcessTerminated sets the "web_process_terminated" callback function.
+func (x *WebViewClass) OverrideWebProcessTerminated(cb func(*WebView, WebProcessTerminationReason)) {
+	if cb == nil {
+		x.xWebProcessTerminated = 0
+	} else {
+		x.xWebProcessTerminated = purego.NewCallback(func(WebViewVarp uintptr, ReasonVarp WebProcessTerminationReason) {
+			cb(WebViewNewFromInternalPtr(WebViewVarp), ReasonVarp)
+		})
+	}
+}
+
+// GetWebProcessTerminated gets the "web_process_terminated" callback function.
+func (x *WebViewClass) GetWebProcessTerminated() func(*WebView, WebProcessTerminationReason) {
+	if x.xWebProcessTerminated == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, ReasonVarp WebProcessTerminationReason)
+	purego.RegisterFunc(&rawCallback, x.xWebProcessTerminated)
+	return func(WebViewVar *WebView, ReasonVar WebProcessTerminationReason) {
+		rawCallback(WebViewVar.GoPointer(), ReasonVar)
+	}
+}
+
+// OverrideUserMessageReceived sets the "user_message_received" callback function.
+func (x *WebViewClass) OverrideUserMessageReceived(cb func(*WebView, *UserMessage) bool) {
+	if cb == nil {
+		x.xUserMessageReceived = 0
+	} else {
+		x.xUserMessageReceived = purego.NewCallback(func(WebViewVarp uintptr, MessageVarp uintptr) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), UserMessageNewFromInternalPtr(MessageVarp))
+		})
+	}
+}
+
+// GetUserMessageReceived gets the "user_message_received" callback function.
+func (x *WebViewClass) GetUserMessageReceived() func(*WebView, *UserMessage) bool {
+	if x.xUserMessageReceived == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, MessageVarp uintptr) bool
+	purego.RegisterFunc(&rawCallback, x.xUserMessageReceived)
+	return func(WebViewVar *WebView, MessageVar *UserMessage) bool {
+		return rawCallback(WebViewVar.GoPointer(), MessageVar.GoPointer())
+	}
+}
+
+// OverrideQueryPermissionState sets the "query_permission_state" callback function.
+func (x *WebViewClass) OverrideQueryPermissionState(cb func(*WebView, *PermissionStateQuery) bool) {
+	if cb == nil {
+		x.xQueryPermissionState = 0
+	} else {
+		x.xQueryPermissionState = purego.NewCallback(func(WebViewVarp uintptr, QueryVarp *PermissionStateQuery) bool {
+			return cb(WebViewNewFromInternalPtr(WebViewVarp), QueryVarp)
+		})
+	}
+}
+
+// GetQueryPermissionState gets the "query_permission_state" callback function.
+func (x *WebViewClass) GetQueryPermissionState() func(*WebView, *PermissionStateQuery) bool {
+	if x.xQueryPermissionState == 0 {
+		return nil
+	}
+	var rawCallback func(WebViewVarp uintptr, QueryVarp *PermissionStateQuery) bool
+	purego.RegisterFunc(&rawCallback, x.xQueryPermissionState)
+	return func(WebViewVar *WebView, QueryVar *PermissionStateQuery) bool {
+		return rawCallback(WebViewVar.GoPointer(), QueryVar)
+	}
+}
+
+// OverrideWebkitReserved0 sets the "_webkit_reserved0" callback function.
+func (x *WebViewClass) OverrideWebkitReserved0(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved0 = 0
+	} else {
+		x.xWebkitReserved0 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved0 gets the "_webkit_reserved0" callback function.
+func (x *WebViewClass) GetWebkitReserved0() func() {
+	if x.xWebkitReserved0 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved0)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved1 sets the "_webkit_reserved1" callback function.
+func (x *WebViewClass) OverrideWebkitReserved1(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved1 = 0
+	} else {
+		x.xWebkitReserved1 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved1 gets the "_webkit_reserved1" callback function.
+func (x *WebViewClass) GetWebkitReserved1() func() {
+	if x.xWebkitReserved1 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved1)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved2 sets the "_webkit_reserved2" callback function.
+func (x *WebViewClass) OverrideWebkitReserved2(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved2 = 0
+	} else {
+		x.xWebkitReserved2 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved2 gets the "_webkit_reserved2" callback function.
+func (x *WebViewClass) GetWebkitReserved2() func() {
+	if x.xWebkitReserved2 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved2)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved3 sets the "_webkit_reserved3" callback function.
+func (x *WebViewClass) OverrideWebkitReserved3(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved3 = 0
+	} else {
+		x.xWebkitReserved3 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved3 gets the "_webkit_reserved3" callback function.
+func (x *WebViewClass) GetWebkitReserved3() func() {
+	if x.xWebkitReserved3 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved3)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved4 sets the "_webkit_reserved4" callback function.
+func (x *WebViewClass) OverrideWebkitReserved4(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved4 = 0
+	} else {
+		x.xWebkitReserved4 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved4 gets the "_webkit_reserved4" callback function.
+func (x *WebViewClass) GetWebkitReserved4() func() {
+	if x.xWebkitReserved4 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved4)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved5 sets the "_webkit_reserved5" callback function.
+func (x *WebViewClass) OverrideWebkitReserved5(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved5 = 0
+	} else {
+		x.xWebkitReserved5 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved5 gets the "_webkit_reserved5" callback function.
+func (x *WebViewClass) GetWebkitReserved5() func() {
+	if x.xWebkitReserved5 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved5)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved6 sets the "_webkit_reserved6" callback function.
+func (x *WebViewClass) OverrideWebkitReserved6(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved6 = 0
+	} else {
+		x.xWebkitReserved6 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved6 gets the "_webkit_reserved6" callback function.
+func (x *WebViewClass) GetWebkitReserved6() func() {
+	if x.xWebkitReserved6 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved6)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved7 sets the "_webkit_reserved7" callback function.
+func (x *WebViewClass) OverrideWebkitReserved7(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved7 = 0
+	} else {
+		x.xWebkitReserved7 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved7 gets the "_webkit_reserved7" callback function.
+func (x *WebViewClass) GetWebkitReserved7() func() {
+	if x.xWebkitReserved7 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved7)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved8 sets the "_webkit_reserved8" callback function.
+func (x *WebViewClass) OverrideWebkitReserved8(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved8 = 0
+	} else {
+		x.xWebkitReserved8 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved8 gets the "_webkit_reserved8" callback function.
+func (x *WebViewClass) GetWebkitReserved8() func() {
+	if x.xWebkitReserved8 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved8)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved9 sets the "_webkit_reserved9" callback function.
+func (x *WebViewClass) OverrideWebkitReserved9(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved9 = 0
+	} else {
+		x.xWebkitReserved9 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved9 gets the "_webkit_reserved9" callback function.
+func (x *WebViewClass) GetWebkitReserved9() func() {
+	if x.xWebkitReserved9 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved9)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved10 sets the "_webkit_reserved10" callback function.
+func (x *WebViewClass) OverrideWebkitReserved10(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved10 = 0
+	} else {
+		x.xWebkitReserved10 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved10 gets the "_webkit_reserved10" callback function.
+func (x *WebViewClass) GetWebkitReserved10() func() {
+	if x.xWebkitReserved10 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved10)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved11 sets the "_webkit_reserved11" callback function.
+func (x *WebViewClass) OverrideWebkitReserved11(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved11 = 0
+	} else {
+		x.xWebkitReserved11 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved11 gets the "_webkit_reserved11" callback function.
+func (x *WebViewClass) GetWebkitReserved11() func() {
+	if x.xWebkitReserved11 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved11)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved12 sets the "_webkit_reserved12" callback function.
+func (x *WebViewClass) OverrideWebkitReserved12(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved12 = 0
+	} else {
+		x.xWebkitReserved12 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved12 gets the "_webkit_reserved12" callback function.
+func (x *WebViewClass) GetWebkitReserved12() func() {
+	if x.xWebkitReserved12 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved12)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved13 sets the "_webkit_reserved13" callback function.
+func (x *WebViewClass) OverrideWebkitReserved13(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved13 = 0
+	} else {
+		x.xWebkitReserved13 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved13 gets the "_webkit_reserved13" callback function.
+func (x *WebViewClass) GetWebkitReserved13() func() {
+	if x.xWebkitReserved13 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved13)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved14 sets the "_webkit_reserved14" callback function.
+func (x *WebViewClass) OverrideWebkitReserved14(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved14 = 0
+	} else {
+		x.xWebkitReserved14 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved14 gets the "_webkit_reserved14" callback function.
+func (x *WebViewClass) GetWebkitReserved14() func() {
+	if x.xWebkitReserved14 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved14)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved15 sets the "_webkit_reserved15" callback function.
+func (x *WebViewClass) OverrideWebkitReserved15(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved15 = 0
+	} else {
+		x.xWebkitReserved15 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved15 gets the "_webkit_reserved15" callback function.
+func (x *WebViewClass) GetWebkitReserved15() func() {
+	if x.xWebkitReserved15 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved15)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved16 sets the "_webkit_reserved16" callback function.
+func (x *WebViewClass) OverrideWebkitReserved16(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved16 = 0
+	} else {
+		x.xWebkitReserved16 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved16 gets the "_webkit_reserved16" callback function.
+func (x *WebViewClass) GetWebkitReserved16() func() {
+	if x.xWebkitReserved16 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved16)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved17 sets the "_webkit_reserved17" callback function.
+func (x *WebViewClass) OverrideWebkitReserved17(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved17 = 0
+	} else {
+		x.xWebkitReserved17 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved17 gets the "_webkit_reserved17" callback function.
+func (x *WebViewClass) GetWebkitReserved17() func() {
+	if x.xWebkitReserved17 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved17)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved18 sets the "_webkit_reserved18" callback function.
+func (x *WebViewClass) OverrideWebkitReserved18(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved18 = 0
+	} else {
+		x.xWebkitReserved18 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved18 gets the "_webkit_reserved18" callback function.
+func (x *WebViewClass) GetWebkitReserved18() func() {
+	if x.xWebkitReserved18 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved18)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved19 sets the "_webkit_reserved19" callback function.
+func (x *WebViewClass) OverrideWebkitReserved19(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved19 = 0
+	} else {
+		x.xWebkitReserved19 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved19 gets the "_webkit_reserved19" callback function.
+func (x *WebViewClass) GetWebkitReserved19() func() {
+	if x.xWebkitReserved19 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved19)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved20 sets the "_webkit_reserved20" callback function.
+func (x *WebViewClass) OverrideWebkitReserved20(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved20 = 0
+	} else {
+		x.xWebkitReserved20 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved20 gets the "_webkit_reserved20" callback function.
+func (x *WebViewClass) GetWebkitReserved20() func() {
+	if x.xWebkitReserved20 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved20)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved21 sets the "_webkit_reserved21" callback function.
+func (x *WebViewClass) OverrideWebkitReserved21(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved21 = 0
+	} else {
+		x.xWebkitReserved21 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved21 gets the "_webkit_reserved21" callback function.
+func (x *WebViewClass) GetWebkitReserved21() func() {
+	if x.xWebkitReserved21 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved21)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved22 sets the "_webkit_reserved22" callback function.
+func (x *WebViewClass) OverrideWebkitReserved22(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved22 = 0
+	} else {
+		x.xWebkitReserved22 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved22 gets the "_webkit_reserved22" callback function.
+func (x *WebViewClass) GetWebkitReserved22() func() {
+	if x.xWebkitReserved22 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved22)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved23 sets the "_webkit_reserved23" callback function.
+func (x *WebViewClass) OverrideWebkitReserved23(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved23 = 0
+	} else {
+		x.xWebkitReserved23 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved23 gets the "_webkit_reserved23" callback function.
+func (x *WebViewClass) GetWebkitReserved23() func() {
+	if x.xWebkitReserved23 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved23)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved24 sets the "_webkit_reserved24" callback function.
+func (x *WebViewClass) OverrideWebkitReserved24(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved24 = 0
+	} else {
+		x.xWebkitReserved24 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved24 gets the "_webkit_reserved24" callback function.
+func (x *WebViewClass) GetWebkitReserved24() func() {
+	if x.xWebkitReserved24 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved24)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved25 sets the "_webkit_reserved25" callback function.
+func (x *WebViewClass) OverrideWebkitReserved25(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved25 = 0
+	} else {
+		x.xWebkitReserved25 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved25 gets the "_webkit_reserved25" callback function.
+func (x *WebViewClass) GetWebkitReserved25() func() {
+	if x.xWebkitReserved25 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved25)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved26 sets the "_webkit_reserved26" callback function.
+func (x *WebViewClass) OverrideWebkitReserved26(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved26 = 0
+	} else {
+		x.xWebkitReserved26 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved26 gets the "_webkit_reserved26" callback function.
+func (x *WebViewClass) GetWebkitReserved26() func() {
+	if x.xWebkitReserved26 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved26)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved27 sets the "_webkit_reserved27" callback function.
+func (x *WebViewClass) OverrideWebkitReserved27(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved27 = 0
+	} else {
+		x.xWebkitReserved27 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved27 gets the "_webkit_reserved27" callback function.
+func (x *WebViewClass) GetWebkitReserved27() func() {
+	if x.xWebkitReserved27 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved27)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved28 sets the "_webkit_reserved28" callback function.
+func (x *WebViewClass) OverrideWebkitReserved28(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved28 = 0
+	} else {
+		x.xWebkitReserved28 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved28 gets the "_webkit_reserved28" callback function.
+func (x *WebViewClass) GetWebkitReserved28() func() {
+	if x.xWebkitReserved28 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved28)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved29 sets the "_webkit_reserved29" callback function.
+func (x *WebViewClass) OverrideWebkitReserved29(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved29 = 0
+	} else {
+		x.xWebkitReserved29 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved29 gets the "_webkit_reserved29" callback function.
+func (x *WebViewClass) GetWebkitReserved29() func() {
+	if x.xWebkitReserved29 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved29)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved30 sets the "_webkit_reserved30" callback function.
+func (x *WebViewClass) OverrideWebkitReserved30(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved30 = 0
+	} else {
+		x.xWebkitReserved30 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved30 gets the "_webkit_reserved30" callback function.
+func (x *WebViewClass) GetWebkitReserved30() func() {
+	if x.xWebkitReserved30 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved30)
+	return func() {
+		rawCallback()
+	}
+}
+
+type WebViewPrivate struct {
+	_ structs.HostLayout
+}
+
+func (x *WebViewPrivate) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values used to specify options when taking a snapshot
+// from a #WebKitWebView.
+type SnapshotOptions int
+
+var xSnapshotOptionsGLibType func() types.GType
+
+func SnapshotOptionsGLibType() types.GType {
+	return xSnapshotOptionsGLibType()
+}
+
+const (
+
+	// Do not include any special options.
+	SnapshotOptionsNoneValue SnapshotOptions = 0
+	// Whether to include in the
+	// snapshot the highlight of the selected content.
+	SnapshotOptionsIncludeSelectionHighlightingValue SnapshotOptions = 1
+	// Do not fill the background with white before
+	// rendering the snapshot. Since 2.8
+	SnapshotOptionsTransparentBackgroundValue SnapshotOptions = 2
+)
+
+// Enum values previously used to denote the different events which can trigger
+// the detection of insecure content. Since 2.46, WebKit generally no longer
+// loads insecure content in secure contexts.
+type InsecureContentEvent int
+
+var xInsecureContentEventGLibType func() types.GType
+
+func InsecureContentEventGLibType() types.GType {
+	return xInsecureContentEventGLibType()
+}
+
+const (
+
+	// Insecure content has been detected by
+	// trying to execute any kind of logic (e.g. a script) from an
+	// untrusted source.
+	InsecureContentRunValue InsecureContentEvent = 0
+	// Insecure content has been
+	// detected by trying to display any kind of resource (e.g. an image)
+	// from an untrusted source.
+	InsecureContentDisplayedValue InsecureContentEvent = 1
+)
+
+// Enum values used to denote the different events that happen during a
+// #WebKitWebView load operation.
+type LoadEvent int
+
+var xLoadEventGLibType func() types.GType
+
+func LoadEventGLibType() types.GType {
+	return xLoadEventGLibType()
+}
+
+const (
+
+	// A new load request has been made.
+	// No data has been received yet, empty structures have
+	// been allocated to perform the load; the load may still
+	// fail due to transport issues such as not being able to
+	// resolve a name, or connect to a port.
+	LoadStartedValue LoadEvent = 0
+	// A provisional data source received
+	// a server redirect.
+	LoadRedirectedValue LoadEvent = 1
+	// The content started arriving for a page load.
+	// The necessary transport requirements are established, and the
+	// load is being performed.
+	LoadCommittedValue LoadEvent = 2
+	// Load completed. All resources are done loading
+	// or there was an error during the load operation.
+	LoadFinishedValue LoadEvent = 3
+)
+
+// Enum values used to specify the capture state of a media device.
+type MediaCaptureState int
+
+var xMediaCaptureStateGLibType func() types.GType
+
+func MediaCaptureStateGLibType() types.GType {
+	return xMediaCaptureStateGLibType()
+}
+
+const (
+
+	// Media capture is disabled.
+	MediaCaptureStateNoneValue MediaCaptureState = 0
+	// Media capture is active.
+	MediaCaptureStateActiveValue MediaCaptureState = 1
+	// Media capture is muted.
+	MediaCaptureStateMutedValue MediaCaptureState = 2
+)
+
+// Enum values used for determining the type of a policy decision during
+// #WebKitWebView::decide-policy.
+type PolicyDecisionType int
+
+var xPolicyDecisionTypeGLibType func() types.GType
+
+func PolicyDecisionTypeGLibType() types.GType {
+	return xPolicyDecisionTypeGLibType()
+}
+
+const (
+
+	// This type of policy decision
+	//   is requested when WebKit is about to navigate to a new page in either the
+	//   main frame or a subframe. Acceptable policy decisions are either
+	//   webkit_policy_decision_use() or webkit_policy_decision_ignore(). This
+	//   type of policy decision is always a #WebKitNavigationPolicyDecision.
+	PolicyDecisionTypeNavigationActionValue PolicyDecisionType = 0
+	// This type of policy decision
+	//   is requested when WebKit is about to create a new window. Acceptable policy
+	//   decisions are either webkit_policy_decision_use() or
+	//   webkit_policy_decision_ignore(). This type of policy decision is always
+	//   a #WebKitNavigationPolicyDecision. These decisions are useful for implementing
+	//   special actions for new windows, such as forcing the new window to open
+	//   in a tab when a keyboard modifier is active or handling a special
+	//   target attribute on &lt;a&gt; elements.
+	PolicyDecisionTypeNewWindowActionValue PolicyDecisionType = 1
+	// This type of decision is used when WebKit has
+	//   received a response for a network resource and is about to start the load.
+	//   Note that these resources include all subresources of a page such as images
+	//   and stylesheets as well as main documents. Appropriate policy responses to
+	//   this decision are webkit_policy_decision_use(), webkit_policy_decision_ignore(),
+	//   or webkit_policy_decision_download(). This type of policy decision is always
+	//   a #WebKitResponsePolicyDecision. This decision is useful for forcing
+	//   some types of resources to be downloaded rather than rendered in the WebView
+	//   or to block the transfer of resources entirely.
+	PolicyDecisionTypeResponseValue PolicyDecisionType = 2
+)
+
+// Enum values to specify the different ways in which a #WebKitWebView
+// can save its current web page into a self-contained file.
+type SaveMode int
+
+var xSaveModeGLibType func() types.GType
+
+func SaveModeGLibType() types.GType {
+	return xSaveModeGLibType()
+}
+
+const (
+
+	// Save the current page using the MHTML format.
+	SaveModeMhtmlValue SaveMode = 0
+)
+
+// Enum values used to specify the region from which to get a #WebKitWebView
+// snapshot
+type SnapshotRegion int
+
+var xSnapshotRegionGLibType func() types.GType
+
+func SnapshotRegionGLibType() types.GType {
+	return xSnapshotRegionGLibType()
+}
+
+const (
+
+	// Specifies a snapshot only for the area that is
+	// visible in the webview
+	SnapshotRegionVisibleValue SnapshotRegion = 0
+	// A snapshot of the entire document.
+	SnapshotRegionFullDocumentValue SnapshotRegion = 1
+)
+
+// Enum values used for setting if a #WebKitWebView is intended for
+// WebExtensions.
+type WebExtensionMode int
+
+var xWebExtensionModeGLibType func() types.GType
+
+func WebExtensionModeGLibType() types.GType {
+	return xWebExtensionModeGLibType()
+}
+
+const (
+
+	// Not for an extension.
+	WebExtensionModeNoneValue WebExtensionMode = 0
+	// For a ManifestV2 extension.
+	WebExtensionModeManifestv2Value WebExtensionMode = 1
+	// For a ManifestV3 extension.
+	WebExtensionModeManifestv3Value WebExtensionMode = 2
+)
+
+// Enum values used to specify the reason why the web process terminated abnormally.
+type WebProcessTerminationReason int
+
+var xWebProcessTerminationReasonGLibType func() types.GType
+
+func WebProcessTerminationReasonGLibType() types.GType {
+	return xWebProcessTerminationReasonGLibType()
+}
+
+const (
+
+	// the web process crashed.
+	WebProcessCrashedValue WebProcessTerminationReason = 0
+	// the web process exceeded the memory limit.
+	WebProcessExceededMemoryLimitValue WebProcessTerminationReason = 1
+	// the web process termination was requested by an API call. Since: 2.34
+	WebProcessTerminatedByApiValue WebProcessTerminationReason = 2
+)
+
+// The central class of the WPE WebKit and WebKitGTK APIs.
+//
+// #WebKitWebView is the central class of the WPE WebKit and WebKitGTK
+// APIs. It is responsible for managing the drawing of the content and
+// forwarding of events. You can load any URI into the #WebKitWebView or
+// a data string. With #WebKitSettings you can control various aspects
+// of the rendering and loading of the content.
+//
+// Note that in WebKitGTK, #WebKitWebView is scrollable by itself, so
+// you don't need to embed it in a #GtkScrolledWindow.
+type WebView struct {
+	WebViewBase
+}
+
+var xWebViewGLibType func() types.GType
+
+func WebViewGLibType() types.GType {
+	return xWebViewGLibType()
+}
+
+func WebViewNewFromInternalPtr(ptr uintptr) *WebView {
+	cls := &WebView{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewWebView func() uintptr
+
+// Creates a new #WebKitWebView with the default #WebKitWebContext.
+//
+// Creates a new #WebKitWebView with the default #WebKitWebContext and
+// no #WebKitUserContentManager associated with it.
+// See also webkit_web_view_new_with_context(),
+// webkit_web_view_new_with_user_content_manager(), and
+// webkit_web_view_new_with_settings().
+func NewWebView() *WebView {
+	var cls *WebView
+
+	cret := xNewWebView()
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WebView{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewCallAsyncJavascriptFunction func(uintptr, string, int, *glib.Variant, string, string, uintptr, uintptr, uintptr)
+
+// Asynchronously call @body with @arguments in the script world with name @world_name of the main frame current context in @web_view.
+// The @arguments values must be one of the following types, or contain only the following GVariant types: number, string and dictionary.
+// The result of the operation can be a Promise that will be properly passed to the callback.
+// If @world_name is %NULL, the default world is used. Any value that is not %NULL is a distin ct world.
+// The @source_uri will be shown in exceptions and doesn't affect the behavior of the script.
+// When not provided, the document URL is used.
+//
+// Note that if #WebKitSettings:enable-javascript is %FALSE, this method will do nothing.
+// If you want to use this method but still prevent web content from executing its own
+// JavaScript, then use #WebKitSettings:enable-javascript-markup.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_web_view_call_async_javascript_function_finish() to get the result of the operation.
+//
+// This is an example that shows how to pass arguments to a JS function that returns a Promise
+// that resolves with the passed argument:
+//
+// ```c
+// static void
+// web_view_javascript_finished (GObject      *object,
+//
+//	GAsyncResult *result,
+//	gpointer      user_data)
+//
+//	{
+//	    JSCValue               *value;
+//	    GError                 *error = NULL;
+//
+//	    value = webkit_web_view_call_async_javascript_function_finish (WEBKIT_WEB_VIEW (object), result, &amp;error);
+//	    if (!value) {
+//	        g_warning ("Error running javascript: %s", error-&gt;message);
+//	        g_error_free (error);
+//	        return;
+//	    }
+//
+//	    if (jsc_value_is_number (value)) {
+//	        gint32        int_value = jsc_value_to_string (value);
+//	        JSCException *exception = jsc_context_get_exception (jsc_value_get_context (value));
+//	        if (exception)
+//	            g_warning ("Error running javascript: %s", jsc_exception_get_message (exception));
+//	        else
+//	            g_print ("Script result: %d\n", int_value);
+//	        g_free (str_value);
+//	    } else {
+//	        g_warning ("Error running javascript: unexpected return value");
+//	    }
+//	    g_object_unref (value);
+//	}
+//
+// static void
+// web_view_evaluate_promise (WebKitWebView *web_view)
+//
+//	{
+//	    GVariantDict dict;
+//	    g_variant_dict_init (&amp;dict, NULL);
+//	    g_variant_dict_insert (&amp;dict, "count", "u", 42);
+//	    GVariant *args = g_variant_dict_end (&amp;dict);
+//	    const gchar *body = "return new Promise((resolve) =&gt; { resolve(count); });";
+//	    webkit_web_view_call_async_javascript_function (web_view, body, -1, arguments, NULL, NULL, NULL, web_view_javascript_finished, NULL);
+//	}
+//
+// ```
+func (x *WebView) CallAsyncJavascriptFunction(BodyVar string, LengthVar int, ArgumentsVar *glib.Variant, WorldNameVar string, SourceUriVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebViewCallAsyncJavascriptFunction(x.GoPointer(), BodyVar, LengthVar, ArgumentsVar, WorldNameVar, SourceUriVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebViewCallAsyncJavascriptFunctionFinish func(uintptr, uintptr, **glib.Error) uintptr
+
+// Finish an asynchronous operation started with webkit_web_view_call_async_javascript_function().
+func (x *WebView) CallAsyncJavascriptFunctionFinish(ResultVar gio.AsyncResult) (*javascriptcore.Value, error) {
+	var cls *javascriptcore.Value
+	var cerr *glib.Error
+
+	cret := xWebViewCallAsyncJavascriptFunctionFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+
+	if cret == 0 {
+		return nil, cerr
+	}
+	cls = &javascriptcore.Value{}
+	cls.Ptr = cret
+	if cerr == nil {
+		return cls, nil
+	}
+	return cls, cerr
+
+}
+
+var xWebViewCanExecuteEditingCommand func(uintptr, string, uintptr, uintptr, uintptr)
+
+// Asynchronously check if it is possible to execute the given editing command.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_web_view_can_execute_editing_command_finish() to get the result of the operation.
+func (x *WebView) CanExecuteEditingCommand(CommandVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebViewCanExecuteEditingCommand(x.GoPointer(), CommandVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebViewCanExecuteEditingCommandFinish func(uintptr, uintptr, **glib.Error) bool
+
+// Finish an asynchronous operation started with webkit_web_view_can_execute_editing_command().
+func (x *WebView) CanExecuteEditingCommandFinish(ResultVar gio.AsyncResult) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xWebViewCanExecuteEditingCommandFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebViewCanGoBack func(uintptr) bool
+
+// Determines whether @web_view has a previous history item.
+func (x *WebView) CanGoBack() bool {
+
+	cret := xWebViewCanGoBack(x.GoPointer())
+	return cret
+}
+
+var xWebViewCanGoForward func(uintptr) bool
+
+// Determines whether @web_view has a next history item.
+func (x *WebView) CanGoForward() bool {
+
+	cret := xWebViewCanGoForward(x.GoPointer())
+	return cret
+}
+
+var xWebViewCanShowMimeType func(uintptr, string) bool
+
+// Whether or not a MIME type can be displayed in @web_view.
+func (x *WebView) CanShowMimeType(MimeTypeVar string) bool {
+
+	cret := xWebViewCanShowMimeType(x.GoPointer(), MimeTypeVar)
+	return cret
+}
+
+var xWebViewDownloadUri func(uintptr, string) uintptr
+
+// Requests downloading of the specified URI string for @web_view.
+func (x *WebView) DownloadUri(UriVar string) *Download {
+	var cls *Download
+
+	cret := xWebViewDownloadUri(x.GoPointer(), UriVar)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &Download{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewEvaluateJavascript func(uintptr, string, int, string, string, uintptr, uintptr, uintptr)
+
+// Asynchronously evaluate @script in the script world with name @world_name of the main frame current context in @web_view.
+// If @world_name is %NULL, the default world is used. Any value that is not %NULL is a distinct world.
+// The @source_uri will be shown in exceptions and doesn't affect the behavior of the script.
+// When not provided, the document URL is used.
+//
+// Note that if #WebKitSettings:enable-javascript is %FALSE, this method will do nothing.
+// If you want to use this method but still prevent web content from executing its own
+// JavaScript, then use #WebKitSettings:enable-javascript-markup.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_web_view_evaluate_javascript_finish() to get the result of the operation.
+//
+// This is an example of using webkit_web_view_evaluate_javascript() with a script returning
+// a string:
+//
+// ```c
+// static void
+// web_view_javascript_finished (GObject      *object,
+//
+//	GAsyncResult *result,
+//	gpointer      user_data)
+//
+//	{
+//	    JSCValue               *value;
+//	    GError                 *error = NULL;
+//
+//	    value = webkit_web_view_evaluate_javascript_finish (WEBKIT_WEB_VIEW (object), result, &amp;error);
+//	    if (!value) {
+//	        g_warning ("Error running javascript: %s", error-&gt;message);
+//	        g_error_free (error);
+//	        return;
+//	    }
+//
+//	    if (jsc_value_is_string (value)) {
+//	        gchar        *str_value = jsc_value_to_string (value);
+//	        JSCException *exception = jsc_context_get_exception (jsc_value_get_context (value));
+//	        if (exception)
+//	            g_warning ("Error running javascript: %s", jsc_exception_get_message (exception));
+//	        else
+//	            g_print ("Script result: %s\n", str_value);
+//	        g_free (str_value);
+//	    } else {
+//	        g_warning ("Error running javascript: unexpected return value");
+//	    }
+//	    g_object_unref (value);
+//	}
+//
+// static void
+// web_view_get_link_url (WebKitWebView *web_view,
+//
+//	const gchar   *link_id)
+//
+//	{
+//	    gchar *script = g_strdup_printf ("window.document.getElementById('%s').href;", link_id);
+//	    webkit_web_view_evaluate_javascript (web_view, script, -1, NULL, NULL, NULL, web_view_javascript_finished, NULL);
+//	    g_free (script);
+//	}
+//
+// ```
+func (x *WebView) EvaluateJavascript(ScriptVar string, LengthVar int, WorldNameVar string, SourceUriVar string, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebViewEvaluateJavascript(x.GoPointer(), ScriptVar, LengthVar, WorldNameVar, SourceUriVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebViewEvaluateJavascriptFinish func(uintptr, uintptr, **glib.Error) uintptr
+
+// Finish an asynchronous operation started with webkit_web_view_evaluate_javascript().
+func (x *WebView) EvaluateJavascriptFinish(ResultVar gio.AsyncResult) (*javascriptcore.Value, error) {
+	var cls *javascriptcore.Value
+	var cerr *glib.Error
+
+	cret := xWebViewEvaluateJavascriptFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+
+	if cret == 0 {
+		return nil, cerr
+	}
+	cls = &javascriptcore.Value{}
+	cls.Ptr = cret
+	if cerr == nil {
+		return cls, nil
+	}
+	return cls, cerr
+
+}
+
+var xWebViewExecuteEditingCommand func(uintptr, string)
+
+// Request to execute the given @command for @web_view.
+//
+// You can use webkit_web_view_can_execute_editing_command() to check whether
+// it's possible to execute the command.
+func (x *WebView) ExecuteEditingCommand(CommandVar string) {
+
+	xWebViewExecuteEditingCommand(x.GoPointer(), CommandVar)
+
+}
+
+var xWebViewExecuteEditingCommandWithArgument func(uintptr, string, string)
+
+// Request to execute the given @command with @argument for @web_view.
+//
+// You can use
+// webkit_web_view_can_execute_editing_command() to check whether
+// it's possible to execute the command.
+func (x *WebView) ExecuteEditingCommandWithArgument(CommandVar string, ArgumentVar string) {
+
+	xWebViewExecuteEditingCommandWithArgument(x.GoPointer(), CommandVar, ArgumentVar)
+
+}
+
+var xWebViewGetAutomationPresentationType func(uintptr) AutomationBrowsingContextPresentation
+
+// Get the presentation type of #WebKitWebView when created for automation.
+func (x *WebView) GetAutomationPresentationType() AutomationBrowsingContextPresentation {
+
+	cret := xWebViewGetAutomationPresentationType(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetBackForwardList func(uintptr) uintptr
+
+// Obtains the #WebKitBackForwardList associated with the given #WebKitWebView.
+//
+// The #WebKitBackForwardList is owned by the #WebKitWebView.
+func (x *WebView) GetBackForwardList() *BackForwardList {
+	var cls *BackForwardList
+
+	cret := xWebViewGetBackForwardList(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &BackForwardList{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetBackgroundColor func(uintptr, *gdk.RGBA)
+
+// Gets the color that is used to draw the @web_view background.
+//
+// Gets the color that is used to draw the @web_view background before
+// the actual contents are rendered.
+// For more information see also webkit_web_view_set_background_color()
+func (x *WebView) GetBackgroundColor(RgbaVar *gdk.RGBA) {
+
+	xWebViewGetBackgroundColor(x.GoPointer(), RgbaVar)
+
+}
+
+var xWebViewGetCameraCaptureState func(uintptr) MediaCaptureState
+
+// Get the camera capture state of a #WebKitWebView.
+func (x *WebView) GetCameraCaptureState() MediaCaptureState {
+
+	cret := xWebViewGetCameraCaptureState(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetContext func(uintptr) uintptr
+
+// Gets the web context of @web_view.
+func (x *WebView) GetContext() *WebContext {
+	var cls *WebContext
+
+	cret := xWebViewGetContext(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WebContext{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetCustomCharset func(uintptr) string
+
+// Returns the current custom character encoding name of @web_view.
+func (x *WebView) GetCustomCharset() string {
+
+	cret := xWebViewGetCustomCharset(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetDefaultContentSecurityPolicy func(uintptr) string
+
+// Gets the configured default Content-Security-Policy.
+func (x *WebView) GetDefaultContentSecurityPolicy() string {
+
+	cret := xWebViewGetDefaultContentSecurityPolicy(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetDisplayCaptureState func(uintptr) MediaCaptureState
+
+// Get the display capture state of a #WebKitWebView.
+func (x *WebView) GetDisplayCaptureState() MediaCaptureState {
+
+	cret := xWebViewGetDisplayCaptureState(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetEditorState func(uintptr) uintptr
+
+// Gets the web editor state of @web_view.
+func (x *WebView) GetEditorState() *EditorState {
+	var cls *EditorState
+
+	cret := xWebViewGetEditorState(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &EditorState{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetEstimatedLoadProgress func(uintptr) float64
+
+// Gets the value of the #WebKitWebView:estimated-load-progress property.
+//
+// You can monitor the estimated progress of a load operation by
+// connecting to the notify::estimated-load-progress signal of @web_view.
+func (x *WebView) GetEstimatedLoadProgress() float64 {
+
+	cret := xWebViewGetEstimatedLoadProgress(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetFavicon func(uintptr) uintptr
+
+// Returns favicon currently associated to @web_view.
+//
+// Returns favicon currently associated to @web_view, if any. You can
+// connect to notify::favicon signal of @web_view to be notified when
+// the favicon is available.
+func (x *WebView) GetFavicon() *gdk.Texture {
+	var cls *gdk.Texture
+
+	cret := xWebViewGetFavicon(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &gdk.Texture{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetFindController func(uintptr) uintptr
+
+// Gets the #WebKitFindController.
+//
+// Gets the #WebKitFindController that will allow the caller to query
+// the #WebKitWebView for the text to look for.
+func (x *WebView) GetFindController() *FindController {
+	var cls *FindController
+
+	cret := xWebViewGetFindController(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &FindController{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetInputMethodContext func(uintptr) uintptr
+
+// Get the #WebKitInputMethodContext currently in use by @web_view.
+//
+// Get the #WebKitInputMethodContext currently in use by @web_view, or %NULL if no input method is being used.
+func (x *WebView) GetInputMethodContext() *InputMethodContext {
+	var cls *InputMethodContext
+
+	cret := xWebViewGetInputMethodContext(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &InputMethodContext{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetInspector func(uintptr) uintptr
+
+// Get the #WebKitWebInspector associated to @web_view
+func (x *WebView) GetInspector() *WebInspector {
+	var cls *WebInspector
+
+	cret := xWebViewGetInspector(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WebInspector{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetIsMuted func(uintptr) bool
+
+// Gets the mute state of @web_view.
+func (x *WebView) GetIsMuted() bool {
+
+	cret := xWebViewGetIsMuted(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetIsWebProcessResponsive func(uintptr) bool
+
+// Get whether the current web process of a #WebKitWebView is responsive.
+func (x *WebView) GetIsWebProcessResponsive() bool {
+
+	cret := xWebViewGetIsWebProcessResponsive(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetMainResource func(uintptr) uintptr
+
+// Return the main resource of @web_view.
+func (x *WebView) GetMainResource() *WebResource {
+	var cls *WebResource
+
+	cret := xWebViewGetMainResource(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WebResource{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetMicrophoneCaptureState func(uintptr) MediaCaptureState
+
+// Get the microphone capture state of a #WebKitWebView.
+func (x *WebView) GetMicrophoneCaptureState() MediaCaptureState {
+
+	cret := xWebViewGetMicrophoneCaptureState(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetNetworkSession func(uintptr) uintptr
+
+// Get the #WebKitNetworkSession associated to @web_view.
+func (x *WebView) GetNetworkSession() *NetworkSession {
+	var cls *NetworkSession
+
+	cret := xWebViewGetNetworkSession(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &NetworkSession{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetPageId func(uintptr) uint64
+
+// Get the identifier of the #WebKitWebPage corresponding to
+// the #WebKitWebView
+func (x *WebView) GetPageId() uint64 {
+
+	cret := xWebViewGetPageId(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetSessionState func(uintptr) *WebViewSessionState
+
+// Gets the current session state of @web_view
+func (x *WebView) GetSessionState() *WebViewSessionState {
+
+	cret := xWebViewGetSessionState(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetSettings func(uintptr) uintptr
+
+// Gets the #WebKitSettings currently applied to @web_view.
+//
+// If no other #WebKitSettings have been explicitly applied to
+// @web_view with webkit_web_view_set_settings(), the default
+// #WebKitSettings will be returned. This method always returns
+// a valid #WebKitSettings object.
+// To modify any of the @web_view settings, you can either create
+// a new #WebKitSettings object with webkit_settings_new(), setting
+// the desired preferences, and then replace the existing @web_view
+// settings with webkit_web_view_set_settings() or get the existing
+// @web_view settings and update it directly. #WebKitSettings objects
+// can be shared by multiple #WebKitWebView&lt;!-- --&gt;s, so modifying
+// the settings of a #WebKitWebView would affect other
+// #WebKitWebView&lt;!-- --&gt;s using the same #WebKitSettings.
+func (x *WebView) GetSettings() *Settings {
+	var cls *Settings
+
+	cret := xWebViewGetSettings(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &Settings{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetSnapshot func(uintptr, SnapshotRegion, SnapshotOptions, uintptr, uintptr, uintptr)
+
+// Asynchronously retrieves a snapshot of @web_view for @region.
+//
+// @options specifies how the snapshot should be rendered.
+//
+// When the operation is finished, @callback will be called. You must
+// call webkit_web_view_get_snapshot_finish() to get the result of the
+// operation.
+func (x *WebView) GetSnapshot(RegionVar SnapshotRegion, OptionsVar SnapshotOptions, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebViewGetSnapshot(x.GoPointer(), RegionVar, OptionsVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebViewGetSnapshotFinish func(uintptr, uintptr, **glib.Error) uintptr
+
+// Finishes an asynchronous operation started with webkit_web_view_get_snapshot().
+func (x *WebView) GetSnapshotFinish(ResultVar gio.AsyncResult) (*gdk.Texture, error) {
+	var cls *gdk.Texture
+	var cerr *glib.Error
+
+	cret := xWebViewGetSnapshotFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+
+	if cret == 0 {
+		return nil, cerr
+	}
+	cls = &gdk.Texture{}
+	cls.Ptr = cret
+	if cerr == nil {
+		return cls, nil
+	}
+	return cls, cerr
+
+}
+
+var xWebViewGetThemeColor func(uintptr, *gdk.RGBA) bool
+
+// Gets the theme color that is specified by the content in the @web_view.
+// If the @web_view doesn't have a theme color it will fill the @rgba
+// with transparent black content.
+func (x *WebView) GetThemeColor(RgbaVar *gdk.RGBA) bool {
+
+	cret := xWebViewGetThemeColor(x.GoPointer(), RgbaVar)
+	return cret
+}
+
+var xWebViewGetTitle func(uintptr) string
+
+// Gets the value of the #WebKitWebView:title property.
+//
+// You can connect to notify::title signal of @web_view to
+// be notified when the title has been received.
+func (x *WebView) GetTitle() string {
+
+	cret := xWebViewGetTitle(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetTlsInfo func(uintptr, **gio.TlsCertificate, *gio.TlsCertificateFlags) bool
+
+// Retrieves the #GTlsCertificate associated with the main resource of @web_view.
+//
+// Retrieves the #GTlsCertificate associated with the main resource of @web_view,
+// and the #GTlsCertificateFlags showing what problems, if any, have been found
+// with that certificate.
+// If the connection is not HTTPS, this function returns %FALSE.
+// This function should be called after a response has been received from the
+// server, so you can connect to #WebKitWebView::load-changed and call this function
+// when it's emitted with %WEBKIT_LOAD_COMMITTED event.
+//
+// Note that this function provides no information about the security of the web
+// page if the current #WebKitTLSErrorsPolicy is %WEBKIT_TLS_ERRORS_POLICY_IGNORE,
+// as subresources of the page may be controlled by an attacker. This function
+// may safely be used to determine the security status of the current page only
+// if the current #WebKitTLSErrorsPolicy is %WEBKIT_TLS_ERRORS_POLICY_FAIL, in
+// which case subresources that fail certificate verification will be blocked.
+func (x *WebView) GetTlsInfo(CertificateVar **gio.TlsCertificate, ErrorsVar *gio.TlsCertificateFlags) bool {
+
+	cret := xWebViewGetTlsInfo(x.GoPointer(), CertificateVar, ErrorsVar)
+	return cret
+}
+
+var xWebViewGetUri func(uintptr) string
+
+// Returns the current active URI of @web_view.
+//
+// The active URI might change during
+// a load operation:
+//
+// &lt;orderedlist&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	When nothing has been loaded yet on @web_view the active URI is %NULL.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	When a new load operation starts the active URI is the requested URI:
+//	&lt;itemizedlist&gt;
+//	&lt;listitem&gt;&lt;para&gt;
+//	  If the load operation was started by webkit_web_view_load_uri(),
+//	  the requested URI is the given one.
+//	&lt;/para&gt;&lt;/listitem&gt;
+//	&lt;listitem&gt;&lt;para&gt;
+//	  If the load operation was started by webkit_web_view_load_html(),
+//	  the requested URI is "about:blank".
+//	&lt;/para&gt;&lt;/listitem&gt;
+//	&lt;listitem&gt;&lt;para&gt;
+//	  If the load operation was started by webkit_web_view_load_alternate_html(),
+//	  the requested URI is content URI provided.
+//	&lt;/para&gt;&lt;/listitem&gt;
+//	&lt;listitem&gt;&lt;para&gt;
+//	  If the load operation was started by webkit_web_view_go_back() or
+//	  webkit_web_view_go_forward(), the requested URI is the original URI
+//	  of the previous/next item in the #WebKitBackForwardList of @web_view.
+//	&lt;/para&gt;&lt;/listitem&gt;
+//	&lt;listitem&gt;&lt;para&gt;
+//	  If the load operation was started by
+//	  webkit_web_view_go_to_back_forward_list_item(), the requested URI
+//	  is the opriginal URI of the given #WebKitBackForwardListItem.
+//	&lt;/para&gt;&lt;/listitem&gt;
+//	&lt;/itemizedlist&gt;
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	If there is a server redirection during the load operation,
+//	the active URI is the redirected URI. When the signal
+//	#WebKitWebView::load-changed is emitted with %WEBKIT_LOAD_REDIRECTED
+//	event, the active URI is already updated to the redirected URI.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	When the signal #WebKitWebView::load-changed is emitted
+//	with %WEBKIT_LOAD_COMMITTED event, the active URI is the final
+//	one and it will not change unless a new load operation is started
+//	or a navigation action within the same page is performed.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;/orderedlist&gt;
+//
+// You can monitor the active URI by connecting to the notify::uri
+// signal of @web_view.
+func (x *WebView) GetUri() string {
+
+	cret := xWebViewGetUri(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetUserContentManager func(uintptr) uintptr
+
+// Gets the user content manager associated to @web_view.
+func (x *WebView) GetUserContentManager() *UserContentManager {
+	var cls *UserContentManager
+
+	cret := xWebViewGetUserContentManager(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &UserContentManager{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetWebExtensionMode func(uintptr) WebExtensionMode
+
+// Get the view's #WebKitWebExtensionMode.
+func (x *WebView) GetWebExtensionMode() WebExtensionMode {
+
+	cret := xWebViewGetWebExtensionMode(x.GoPointer())
+	return cret
+}
+
+var xWebViewGetWebsitePolicies func(uintptr) uintptr
+
+// Gets the default website policies.
+//
+// Gets the default website policies set on construction in the
+// @web_view. These can be overridden on a per-origin basis via the
+// #WebKitWebView::decide-policy signal handler.
+//
+// See also webkit_policy_decision_use_with_policies().
+func (x *WebView) GetWebsitePolicies() *WebsitePolicies {
+	var cls *WebsitePolicies
+
+	cret := xWebViewGetWebsitePolicies(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WebsitePolicies{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetWindowProperties func(uintptr) uintptr
+
+// Get the #WebKitWindowProperties object.
+//
+// Get the #WebKitWindowProperties object containing the properties
+// that the window containing @web_view should have.
+func (x *WebView) GetWindowProperties() *WindowProperties {
+	var cls *WindowProperties
+
+	cret := xWebViewGetWindowProperties(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &WindowProperties{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebViewGetZoomLevel func(uintptr) float64
+
+// Set the zoom level of @web_view.
+//
+// Get the zoom level of @web_view, i.e. the factor by which the
+// view contents are scaled with respect to their original size.
+func (x *WebView) GetZoomLevel() float64 {
+
+	cret := xWebViewGetZoomLevel(x.GoPointer())
+	return cret
+}
+
+var xWebViewGoBack func(uintptr)
+
+// Loads the previous history item.
+//
+// You can monitor the load operation by connecting to
+// #WebKitWebView::load-changed signal.
+func (x *WebView) GoBack() {
+
+	xWebViewGoBack(x.GoPointer())
+
+}
+
+var xWebViewGoForward func(uintptr)
+
+// Loads the next history item.
+//
+// You can monitor the load operation by connecting to
+// #WebKitWebView::load-changed signal.
+func (x *WebView) GoForward() {
+
+	xWebViewGoForward(x.GoPointer())
+
+}
+
+var xWebViewGoToBackForwardListItem func(uintptr, uintptr)
+
+// Loads the specific history item @list_item.
+//
+// You can monitor the load operation by connecting to
+// #WebKitWebView::load-changed signal.
+func (x *WebView) GoToBackForwardListItem(ListItemVar *BackForwardListItem) {
+
+	xWebViewGoToBackForwardListItem(x.GoPointer(), ListItemVar.GoPointer())
+
+}
+
+var xWebViewIsControlledByAutomation func(uintptr) bool
+
+// Get whether a #WebKitWebView was created with #WebKitWebView:is-controlled-by-automation
+// property enabled.
+//
+// Only #WebKitWebView&lt;!-- --&gt;s controlled by automation can be used in an
+// automation session.
+func (x *WebView) IsControlledByAutomation() bool {
+
+	cret := xWebViewIsControlledByAutomation(x.GoPointer())
+	return cret
+}
+
+var xWebViewIsEditable func(uintptr) bool
+
+// Gets whether the user is allowed to edit the HTML document.
+//
+// When @web_view is not editable an element in the HTML document can only be edited if the
+// CONTENTEDITABLE attribute has been set on the element or one of its parent
+// elements. By default a #WebKitWebView is not editable.
+func (x *WebView) IsEditable() bool {
+
+	cret := xWebViewIsEditable(x.GoPointer())
+	return cret
+}
+
+var xWebViewIsLoading func(uintptr) bool
+
+// Gets the value of the #WebKitWebView:is-loading property.
+//
+// You can monitor when a #WebKitWebView is loading a page by connecting to
+// notify::is-loading signal of @web_view. This is useful when you are
+// interesting in knowing when the view is loading something but not in the
+// details about the status of the load operation, for example to start a spinner
+// when the view is loading a page and stop it when it finishes.
+func (x *WebView) IsLoading() bool {
+
+	cret := xWebViewIsLoading(x.GoPointer())
+	return cret
+}
+
+var xWebViewIsPlayingAudio func(uintptr) bool
+
+// Gets the value of the #WebKitWebView:is-playing-audio property.
+//
+// You can monitor when a page in a #WebKitWebView is playing audio by
+// connecting to the notify::is-playing-audio signal of @web_view. This
+// is useful when the application wants to provide visual feedback when a
+// page is producing sound.
+func (x *WebView) IsPlayingAudio() bool {
+
+	cret := xWebViewIsPlayingAudio(x.GoPointer())
+	return cret
+}
+
+var xWebViewLoadAlternateHtml func(uintptr, string, string, string)
+
+// Load the given @content string for the URI @content_uri.
+//
+// This allows clients to display page-loading errors in the #WebKitWebView itself.
+// When this method is called from #WebKitWebView::load-failed signal to show an
+// error page, then the back-forward list is maintained appropriately.
+// For everything else this method works the same way as webkit_web_view_load_html().
+func (x *WebView) LoadAlternateHtml(ContentVar string, ContentUriVar string, BaseUriVar string) {
+
+	xWebViewLoadAlternateHtml(x.GoPointer(), ContentVar, ContentUriVar, BaseUriVar)
+
+}
+
+var xWebViewLoadBytes func(uintptr, *glib.Bytes, string, string, string)
+
+// Load the specified @bytes into @web_view using the given @mime_type and @encoding.
+//
+// When @mime_type is %NULL, it defaults to "text/html".
+// When @encoding is %NULL, it defaults to "UTF-8".
+// When @base_uri is %NULL, it defaults to "about:blank".
+// You can monitor the load operation by connecting to #WebKitWebView::load-changed signal.
+func (x *WebView) LoadBytes(BytesVar *glib.Bytes, MimeTypeVar string, EncodingVar string, BaseUriVar string) {
+
+	xWebViewLoadBytes(x.GoPointer(), BytesVar, MimeTypeVar, EncodingVar, BaseUriVar)
+
+}
+
+var xWebViewLoadHtml func(uintptr, string, string)
+
+// Load the given @content string with the specified @base_uri.
+//
+// If @base_uri is not %NULL, relative URLs in the @content will be
+// resolved against @base_uri and absolute local paths must be children of the @base_uri.
+// For security reasons absolute local paths that are not children of @base_uri
+// will cause the web process to terminate.
+// If you need to include URLs in @content that are local paths in a different
+// directory than @base_uri you can build a data URI for them. When @base_uri is %NULL,
+// it defaults to "about:blank". The mime type of the document will be "text/html".
+// You can monitor the load operation by connecting to #WebKitWebView::load-changed signal.
+func (x *WebView) LoadHtml(ContentVar string, BaseUriVar string) {
+
+	xWebViewLoadHtml(x.GoPointer(), ContentVar, BaseUriVar)
+
+}
+
+var xWebViewLoadPlainText func(uintptr, string)
+
+// Load the specified @plain_text string into @web_view.
+//
+// The mime type of document will be "text/plain". You can monitor the load
+// operation by connecting to #WebKitWebView::load-changed signal.
+func (x *WebView) LoadPlainText(PlainTextVar string) {
+
+	xWebViewLoadPlainText(x.GoPointer(), PlainTextVar)
+
+}
+
+var xWebViewLoadRequest func(uintptr, uintptr)
+
+// Requests loading of the specified #WebKitURIRequest.
+//
+// You can monitor the load operation by connecting to
+// #WebKitWebView::load-changed signal.
+func (x *WebView) LoadRequest(RequestVar *URIRequest) {
+
+	xWebViewLoadRequest(x.GoPointer(), RequestVar.GoPointer())
+
+}
+
+var xWebViewLoadUri func(uintptr, string)
+
+// Requests loading of the specified URI string.
+//
+// You can monitor the load operation by connecting to
+// #WebKitWebView::load-changed signal.
+func (x *WebView) LoadUri(UriVar string) {
+
+	xWebViewLoadUri(x.GoPointer(), UriVar)
+
+}
+
+var xWebViewReload func(uintptr)
+
+// Reloads the current contents of @web_view.
+//
+// See also webkit_web_view_reload_bypass_cache().
+func (x *WebView) Reload() {
+
+	xWebViewReload(x.GoPointer())
+
+}
+
+var xWebViewReloadBypassCache func(uintptr)
+
+// Reloads the current contents of @web_view without
+// using any cached data.
+func (x *WebView) ReloadBypassCache() {
+
+	xWebViewReloadBypassCache(x.GoPointer())
+
+}
+
+var xWebViewRestoreSessionState func(uintptr, *WebViewSessionState)
+
+// Restore the @web_view session state from @state
+func (x *WebView) RestoreSessionState(StateVar *WebViewSessionState) {
+
+	xWebViewRestoreSessionState(x.GoPointer(), StateVar)
+
+}
+
+var xWebViewSave func(uintptr, SaveMode, uintptr, uintptr, uintptr)
+
+// Asynchronously save the current web page.
+//
+// Asynchronously save the current web page associated to the
+// #WebKitWebView into a self-contained format using the mode
+// specified in @save_mode.
+//
+// When the operation is finished, @callback will be called. You can
+// then call webkit_web_view_save_finish() to get the result of the
+// operation.
+func (x *WebView) Save(SaveModeVar SaveMode, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebViewSave(x.GoPointer(), SaveModeVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebViewSaveFinish func(uintptr, uintptr, **glib.Error) uintptr
+
+// Finish an asynchronous operation started with webkit_web_view_save().
+func (x *WebView) SaveFinish(ResultVar gio.AsyncResult) (*gio.InputStream, error) {
+	var cls *gio.InputStream
+	var cerr *glib.Error
+
+	cret := xWebViewSaveFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+
+	if cret == 0 {
+		return nil, cerr
+	}
+	cls = &gio.InputStream{}
+	cls.Ptr = cret
+	if cerr == nil {
+		return cls, nil
+	}
+	return cls, cerr
+
+}
+
+var xWebViewSaveToFile func(uintptr, uintptr, SaveMode, uintptr, uintptr, uintptr)
+
+// Asynchronously save the current web page.
+//
+// Asynchronously save the current web page associated to the
+// #WebKitWebView into a self-contained format using the mode
+// specified in @save_mode and writing it to @file.
+//
+// When the operation is finished, @callback will be called. You can
+// then call webkit_web_view_save_to_file_finish() to get the result of the
+// operation.
+func (x *WebView) SaveToFile(FileVar gio.File, SaveModeVar SaveMode, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebViewSaveToFile(x.GoPointer(), FileVar.GoPointer(), SaveModeVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebViewSaveToFileFinish func(uintptr, uintptr, **glib.Error) bool
+
+// Finish an asynchronous operation started with webkit_web_view_save_to_file().
+func (x *WebView) SaveToFileFinish(ResultVar gio.AsyncResult) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xWebViewSaveToFileFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebViewSendMessageToPage func(uintptr, uintptr, uintptr, uintptr, uintptr)
+
+// Send @message to the #WebKitWebPage corresponding to @web_view.
+//
+// If @message is floating, it's consumed.
+// If you don't expect any reply, or you simply want to ignore it, you can pass %NULL as @callback.
+// When the operation is finished, @callback will be called. You can then call
+// webkit_web_view_send_message_to_page_finish() to get the message reply.
+func (x *WebView) SendMessageToPage(MessageVar *UserMessage, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebViewSendMessageToPage(x.GoPointer(), MessageVar.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebViewSendMessageToPageFinish func(uintptr, uintptr, **glib.Error) uintptr
+
+// Finish an asynchronous operation started with webkit_web_view_send_message_to_page().
+func (x *WebView) SendMessageToPageFinish(ResultVar gio.AsyncResult) (*UserMessage, error) {
+	var cls *UserMessage
+	var cerr *glib.Error
+
+	cret := xWebViewSendMessageToPageFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+
+	if cret == 0 {
+		return nil, cerr
+	}
+	cls = &UserMessage{}
+	cls.Ptr = cret
+	if cerr == nil {
+		return cls, nil
+	}
+	return cls, cerr
+
+}
+
+var xWebViewSetBackgroundColor func(uintptr, *gdk.RGBA)
+
+// Sets the color that will be used to draw the @web_view background.
+//
+// Sets the color that will be used to draw the @web_view background before
+// the actual contents are rendered. Note that if the web page loaded in @web_view
+// specifies a background color, it will take precedence over the @rgba color.
+// By default the @web_view background color is opaque white.
+func (x *WebView) SetBackgroundColor(RgbaVar *gdk.RGBA) {
+
+	xWebViewSetBackgroundColor(x.GoPointer(), RgbaVar)
+
+}
+
+var xWebViewSetCameraCaptureState func(uintptr, MediaCaptureState)
+
+// Set the camera capture state of a #WebKitWebView.
+//
+// If #WebKitSettings:enable-mediastream is %FALSE, this method will have no visible effect. Once the
+// state of the device has been set to %WEBKIT_MEDIA_CAPTURE_STATE_NONE it cannot be changed
+// anymore. The page can however request capture again using the mediaDevices API.
+func (x *WebView) SetCameraCaptureState(StateVar MediaCaptureState) {
+
+	xWebViewSetCameraCaptureState(x.GoPointer(), StateVar)
+
+}
+
+var xWebViewSetCorsAllowlist func(uintptr, []string)
+
+// Sets the @allowlist for CORS.
+//
+// Sets the @allowlist for which
+// [Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
+// checks are disabled in @web_view. URI patterns must be of the form
+// `[protocol]://[host]/[path]`, each component may contain the wildcard
+// character (`*`) to represent zero or more other characters. All three
+// components are required and must not be omitted from the URI
+// patterns.
+//
+// Disabling CORS checks permits resources from other origins to load
+// allowlisted resources. It does not permit the allowlisted resources
+// to load resources from other origins.
+//
+// If this function is called multiple times, only the allowlist set by
+// the most recent call will be effective.
+func (x *WebView) SetCorsAllowlist(AllowlistVar []string) {
+
+	xWebViewSetCorsAllowlist(x.GoPointer(), AllowlistVar)
+
+}
+
+var xWebViewSetCustomCharset func(uintptr, string)
+
+// Sets the current custom character encoding override of @web_view.
+//
+// The custom character encoding will override any text encoding detected via HTTP headers or
+// META tags. Calling this method will stop any current load operation and reload the
+// current page. Setting the custom character encoding to %NULL removes the character
+// encoding override.
+func (x *WebView) SetCustomCharset(CharsetVar string) {
+
+	xWebViewSetCustomCharset(x.GoPointer(), CharsetVar)
+
+}
+
+var xWebViewSetDisplayCaptureState func(uintptr, MediaCaptureState)
+
+// Set the display capture state of a #WebKitWebView.
+//
+// If #WebKitSettings:enable-mediastream is %FALSE, this method will have no visible effect. Once the
+// state of the device has been set to %WEBKIT_MEDIA_CAPTURE_STATE_NONE it cannot be changed
+// anymore. The page can however request capture again using the mediaDevices API.
+func (x *WebView) SetDisplayCaptureState(StateVar MediaCaptureState) {
+
+	xWebViewSetDisplayCaptureState(x.GoPointer(), StateVar)
+
+}
+
+var xWebViewSetEditable func(uintptr, bool)
+
+// Sets whether the user is allowed to edit the HTML document.
+//
+// If @editable is %TRUE, @web_view allows the user to edit the HTML document. If
+// @editable is %FALSE, an element in @web_view's document can only be edited if the
+// CONTENTEDITABLE attribute has been set on the element or one of its parent
+// elements. By default a #WebKitWebView is not editable.
+//
+// Normally, a HTML document is not editable unless the elements within the
+// document are editable. This function provides a way to make the contents
+// of a #WebKitWebView editable without altering the document or DOM structure.
+func (x *WebView) SetEditable(EditableVar bool) {
+
+	xWebViewSetEditable(x.GoPointer(), EditableVar)
+
+}
+
+var xWebViewSetInputMethodContext func(uintptr, uintptr)
+
+// Set the #WebKitInputMethodContext to be used by @web_view.
+//
+// Set the #WebKitInputMethodContext to be used by @web_view, or %NULL to not use any input method.
+// Note that the same #WebKitInputMethodContext can't be set on more than one #WebKitWebView at the same time.
+func (x *WebView) SetInputMethodContext(ContextVar *InputMethodContext) {
+
+	xWebViewSetInputMethodContext(x.GoPointer(), ContextVar.GoPointer())
+
+}
+
+var xWebViewSetIsMuted func(uintptr, bool)
+
+// Sets the mute state of @web_view.
+func (x *WebView) SetIsMuted(MutedVar bool) {
+
+	xWebViewSetIsMuted(x.GoPointer(), MutedVar)
+
+}
+
+var xWebViewSetMicrophoneCaptureState func(uintptr, MediaCaptureState)
+
+// Set the microphone capture state of a #WebKitWebView.
+//
+// If #WebKitSettings:enable-mediastream is %FALSE, this method will have no visible effect. Once the
+// state of the device has been set to %WEBKIT_MEDIA_CAPTURE_STATE_NONE it cannot be changed
+// anymore. The page can however request capture again using the mediaDevices API.
+func (x *WebView) SetMicrophoneCaptureState(StateVar MediaCaptureState) {
+
+	xWebViewSetMicrophoneCaptureState(x.GoPointer(), StateVar)
+
+}
+
+var xWebViewSetSettings func(uintptr, uintptr)
+
+// Sets the #WebKitSettings to be applied to @web_view.
+//
+// The
+// existing #WebKitSettings of @web_view will be replaced by
+// @settings. New settings are applied immediately on @web_view.
+// The same #WebKitSettings object can be shared
+// by multiple #WebKitWebView&lt;!-- --&gt;s.
+func (x *WebView) SetSettings(SettingsVar *Settings) {
+
+	xWebViewSetSettings(x.GoPointer(), SettingsVar.GoPointer())
+
+}
+
+var xWebViewSetZoomLevel func(uintptr, float64)
+
+// Set the zoom level of @web_view.
+//
+// Set the zoom level of @web_view, i.e. the factor by which the
+// view contents are scaled with respect to their original size.
+func (x *WebView) SetZoomLevel(ZoomLevelVar float64) {
+
+	xWebViewSetZoomLevel(x.GoPointer(), ZoomLevelVar)
+
+}
+
+var xWebViewStopLoading func(uintptr)
+
+// Stops any ongoing loading operation in @web_view.
+//
+// This method does nothing if no content is being loaded.
+// If there is a loading operation in progress, it will be cancelled and
+// #WebKitWebView::load-failed signal will be emitted with
+// %WEBKIT_NETWORK_ERROR_CANCELLED error.
+func (x *WebView) StopLoading() {
+
+	xWebViewStopLoading(x.GoPointer())
+
+}
+
+var xWebViewTerminateWebProcess func(uintptr)
+
+// Terminates the web process associated to @web_view.
+//
+// When the web process gets terminated
+// using this method, the #WebKitWebView::web-process-terminated signal is emitted with
+// %WEBKIT_WEB_PROCESS_TERMINATED_BY_API as the reason for termination.
+func (x *WebView) TerminateWebProcess() {
+
+	xWebViewTerminateWebProcess(x.GoPointer())
+
+}
+
+var xWebViewTryClose func(uintptr)
+
+// Tries to close the @web_view.
+//
+// This will fire the onbeforeunload event
+// to ask the user for confirmation to close the page. If there isn't an
+// onbeforeunload event handler or the user confirms to close the page,
+// the #WebKitWebView::close signal is emitted, otherwise nothing happens.
+func (x *WebView) TryClose() {
+
+	xWebViewTryClose(x.GoPointer())
+
+}
+
+func (c *WebView) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebView) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyDefaultContentSecurityPolicy sets the "default-content-security-policy" property.
+// The default Content-Security-Policy used by the webview as if it were set
+// by an HTTP header.
+//
+// This applies to all content loaded including through navigation or via the various
+// webkit_web_view_load_\* APIs. However do note that many WebKit APIs bypass
+// Content-Security-Policy in general such as #WebKitUserContentManager and
+// webkit_web_view_run_javascript().
+//
+// Policies are additive so if a website sets its own policy it still applies
+// on top of the policy set here.
+func (x *WebView) SetPropertyDefaultContentSecurityPolicy(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("default-content-security-policy", &v)
+}
+
+// GetPropertyDefaultContentSecurityPolicy gets the "default-content-security-policy" property.
+// The default Content-Security-Policy used by the webview as if it were set
+// by an HTTP header.
+//
+// This applies to all content loaded including through navigation or via the various
+// webkit_web_view_load_\* APIs. However do note that many WebKit APIs bypass
+// Content-Security-Policy in general such as #WebKitUserContentManager and
+// webkit_web_view_run_javascript().
+//
+// Policies are additive so if a website sets its own policy it still applies
+// on top of the policy set here.
+func (x *WebView) GetPropertyDefaultContentSecurityPolicy() string {
+	var v gobject.Value
+	x.GetProperty("default-content-security-policy", &v)
+	return v.GetString()
+}
+
+// SetPropertyEditable sets the "editable" property.
+// Whether the pages loaded inside #WebKitWebView are editable. For more
+// information see webkit_web_view_set_editable().
+func (x *WebView) SetPropertyEditable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("editable", &v)
+}
+
+// GetPropertyEditable gets the "editable" property.
+// Whether the pages loaded inside #WebKitWebView are editable. For more
+// information see webkit_web_view_set_editable().
+func (x *WebView) GetPropertyEditable() bool {
+	var v gobject.Value
+	x.GetProperty("editable", &v)
+	return v.GetBoolean()
+}
+
+// GetPropertyEstimatedLoadProgress gets the "estimated-load-progress" property.
+// An estimate of the percent completion for the current loading operation.
+// This value will range from 0.0 to 1.0 and, once a load completes,
+// will remain at 1.0 until a new load starts, at which point it
+// will be reset to 0.0.
+// The value is an estimate based on the total number of bytes expected
+// to be received for a document, including all its possible subresources
+// and child documents.
+func (x *WebView) GetPropertyEstimatedLoadProgress() float64 {
+	var v gobject.Value
+	x.GetProperty("estimated-load-progress", &v)
+	return v.GetDouble()
+}
+
+// SetPropertyIsControlledByAutomation sets the "is-controlled-by-automation" property.
+// Whether the #WebKitWebView is controlled by automation tools (e.g. WebDriver, Selenium). This is
+// required for views returned as a response to #WebKitAutomationSession::create-web-view signal,
+// alongside any view you want to control during an automation session.
+//
+// As a %G_PARAM_CONSTRUCT_ONLY, you need to set it during construction and it can't be modified.
+//
+// If #WebKitWebView:related-view is also passed during construction, #WebKitWebView:is-controlled-by-automation
+// ignores its own parameter and inherits directly from the related view #WebKitWebView:is-controlled-by-automation
+// property. This is the recommended way when creating new views as a response to the #WebKitWebView::create
+// signal. For example, as response to JavaScript `window.open()` calls during an automation session.
+func (x *WebView) SetPropertyIsControlledByAutomation(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-controlled-by-automation", &v)
+}
+
+// GetPropertyIsControlledByAutomation gets the "is-controlled-by-automation" property.
+// Whether the #WebKitWebView is controlled by automation tools (e.g. WebDriver, Selenium). This is
+// required for views returned as a response to #WebKitAutomationSession::create-web-view signal,
+// alongside any view you want to control during an automation session.
+//
+// As a %G_PARAM_CONSTRUCT_ONLY, you need to set it during construction and it can't be modified.
+//
+// If #WebKitWebView:related-view is also passed during construction, #WebKitWebView:is-controlled-by-automation
+// ignores its own parameter and inherits directly from the related view #WebKitWebView:is-controlled-by-automation
+// property. This is the recommended way when creating new views as a response to the #WebKitWebView::create
+// signal. For example, as response to JavaScript `window.open()` calls during an automation session.
+func (x *WebView) GetPropertyIsControlledByAutomation() bool {
+	var v gobject.Value
+	x.GetProperty("is-controlled-by-automation", &v)
+	return v.GetBoolean()
+}
+
+// GetPropertyIsLoading gets the "is-loading" property.
+// Whether the #WebKitWebView is currently loading a page. This property becomes
+// %TRUE as soon as a new load operation is requested and before the
+// #WebKitWebView::load-changed signal is emitted with %WEBKIT_LOAD_STARTED and
+// at that point the active URI is the requested one.
+// When the load operation finishes the property is set to %FALSE before
+// #WebKitWebView::load-changed is emitted with %WEBKIT_LOAD_FINISHED.
+func (x *WebView) GetPropertyIsLoading() bool {
+	var v gobject.Value
+	x.GetProperty("is-loading", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyIsMuted sets the "is-muted" property.
+// Whether the #WebKitWebView audio is muted. When %TRUE, audio is silenced.
+// It may still be playing, i.e. #WebKitWebView:is-playing-audio may be %TRUE.
+func (x *WebView) SetPropertyIsMuted(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-muted", &v)
+}
+
+// GetPropertyIsMuted gets the "is-muted" property.
+// Whether the #WebKitWebView audio is muted. When %TRUE, audio is silenced.
+// It may still be playing, i.e. #WebKitWebView:is-playing-audio may be %TRUE.
+func (x *WebView) GetPropertyIsMuted() bool {
+	var v gobject.Value
+	x.GetProperty("is-muted", &v)
+	return v.GetBoolean()
+}
+
+// GetPropertyIsPlayingAudio gets the "is-playing-audio" property.
+// Whether the #WebKitWebView is currently playing audio from a page.
+// This property becomes %TRUE as soon as web content starts playing any
+// kind of audio. When a page is no longer playing any kind of sound,
+// the property is set back to %FALSE.
+func (x *WebView) GetPropertyIsPlayingAudio() bool {
+	var v gobject.Value
+	x.GetProperty("is-playing-audio", &v)
+	return v.GetBoolean()
+}
+
+// GetPropertyIsWebProcessResponsive gets the "is-web-process-responsive" property.
+// Whether the web process currently associated to the #WebKitWebView is responsive.
+func (x *WebView) GetPropertyIsWebProcessResponsive() bool {
+	var v gobject.Value
+	x.GetProperty("is-web-process-responsive", &v)
+	return v.GetBoolean()
+}
+
+// GetPropertyPageId gets the "page-id" property.
+// The identifier of the #WebKitWebPage corresponding to the #WebKitWebView.
+func (x *WebView) GetPropertyPageId() uint64 {
+	var v gobject.Value
+	x.GetProperty("page-id", &v)
+	return v.GetUint64()
+}
+
+// GetPropertyThemeColor gets the "theme-color" property.
+// The theme color of the WebView's current page.
+func (x *WebView) GetPropertyThemeColor() uintptr {
+	var v gobject.Value
+	x.GetProperty("theme-color", &v)
+	return v.GetPointer()
+}
+
+// GetPropertyTitle gets the "title" property.
+// The main frame document title of this #WebKitWebView. If
+// the title has not been received yet, it will be %NULL.
+func (x *WebView) GetPropertyTitle() string {
+	var v gobject.Value
+	x.GetProperty("title", &v)
+	return v.GetString()
+}
+
+// GetPropertyUri gets the "uri" property.
+// The current active URI of the #WebKitWebView.
+// See webkit_web_view_get_uri() for more details.
+func (x *WebView) GetPropertyUri() string {
+	var v gobject.Value
+	x.GetProperty("uri", &v)
+	return v.GetString()
+}
+
+// SetPropertyZoomLevel sets the "zoom-level" property.
+// The zoom level of the #WebKitWebView content.
+// See webkit_web_view_set_zoom_level() for more details.
+func (x *WebView) SetPropertyZoomLevel(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("zoom-level", &v)
+}
+
+// GetPropertyZoomLevel gets the "zoom-level" property.
+// The zoom level of the #WebKitWebView content.
+// See webkit_web_view_set_zoom_level() for more details.
+func (x *WebView) GetPropertyZoomLevel() float64 {
+	var v gobject.Value
+	x.GetProperty("zoom-level", &v)
+	return v.GetDouble()
+}
+
+// This signal is emitted when the user is challenged with HTTP
+// authentication. To let the  application access or supply
+// the credentials as well as to allow the client application
+// to either cancel the request or perform the authentication,
+// the signal will pass an instance of the
+// #WebKitAuthenticationRequest in the @request argument.
+// To handle this signal asynchronously you should keep a ref
+// of the request and return %TRUE. To disable HTTP authentication
+// entirely, connect to this signal and simply return %TRUE.
+//
+// The default signal handler will run a default authentication
+// dialog asynchronously for the user to interact with.
+func (x *WebView) ConnectAuthenticate(cb *func(WebView, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "authenticate", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, RequestVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, RequestVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "authenticate", cbRefPtr)
+}
+
+// Emitted when closing a #WebKitWebView is requested. This occurs when a
+// call is made from JavaScript's &lt;function&gt;window.close&lt;/function&gt; function or
+// after trying to close the @web_view with webkit_web_view_try_close().
+// It is the owner's responsibility to handle this signal to hide or
+// destroy the #WebKitWebView, if necessary.
+func (x *WebView) ConnectClose(cb *func(WebView)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "close", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "close", cbRefPtr)
+}
+
+// Emitted when a context menu is about to be displayed to give the application
+// a chance to customize the proposed menu, prevent the menu from being displayed,
+// or build its own context menu.
+// &lt;itemizedlist&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	To customize the proposed menu you can use webkit_context_menu_prepend(),
+//	webkit_context_menu_append() or webkit_context_menu_insert() to add new
+//	#WebKitContextMenuItem&lt;!-- --&gt;s to @context_menu, webkit_context_menu_move_item()
+//	to reorder existing items, or webkit_context_menu_remove() to remove an
+//	existing item. The signal handler should return %FALSE, and the menu represented
+//	by @context_menu will be shown.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	To prevent the menu from being displayed you can just connect to this signal
+//	and return %TRUE so that the proposed menu will not be shown.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	To build your own menu, you can remove all items from the proposed menu with
+//	webkit_context_menu_remove_all(), add your own items and return %FALSE so
+//	that the menu will be shown. You can also ignore the proposed #WebKitContextMenu,
+//	build your own #GtkMenu and return %TRUE to prevent the proposed menu from being shown.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	If you just want the default menu to be shown always, simply don't connect to this
+//	signal because showing the proposed context menu is the default behaviour.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;/itemizedlist&gt;
+//
+// If the signal handler returns %FALSE the context menu represented by @context_menu
+// will be shown, if it return %TRUE the context menu will not be shown.
+//
+// The proposed #WebKitContextMenu passed in @context_menu argument is only valid
+// during the signal emission.
+func (x *WebView) ConnectContextMenu(cb *func(WebView, uintptr, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "context-menu", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ContextMenuVarp uintptr, HitTestResultVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, ContextMenuVarp, HitTestResultVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "context-menu", cbRefPtr)
+}
+
+// Emitted after #WebKitWebView::context-menu signal, if the context menu is shown,
+// to notify that the context menu is dismissed.
+func (x *WebView) ConnectContextMenuDismissed(cb *func(WebView)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "context-menu-dismissed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "context-menu-dismissed", cbRefPtr)
+}
+
+// Emitted when the creation of a new #WebKitWebView is requested.
+// If this signal is handled the signal handler should return the
+// newly created #WebKitWebView.
+//
+// The #WebKitNavigationAction parameter contains information about the
+// navigation action that triggered this signal.
+//
+// The new #WebKitWebView must be related to @web_view, see
+// #WebKitWebView:related-view for more details.
+//
+// The new #WebKitWebView should not be displayed to the user
+// until the #WebKitWebView::ready-to-show signal is emitted.
+//
+// For creating views as response to automation tools requests, see the
+// #WebKitAutomationSession::create-web-view signal.
+func (x *WebView) ConnectCreate(cb *func(WebView, uintptr) gtk.Widget) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "create", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, NavigationActionVarp uintptr) uintptr {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		CreateCls := cbFn(fa, NavigationActionVarp)
+		return CreateCls.Ptr
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "create", cbRefPtr)
+}
+
+// This signal is emitted when WebKit is requesting the client to decide a policy
+// decision, such as whether to navigate to a page, open a new window or whether or
+// not to download a resource. The #WebKitNavigationPolicyDecision passed in the
+// @decision argument is a generic type, but should be casted to a more
+// specific type when making the decision. For example:
+//
+// ```c
+// static gboolean
+// decide_policy_cb (WebKitWebView *web_view,
+//
+//	WebKitPolicyDecision *decision,
+//	WebKitPolicyDecisionType type)
+//
+//	{
+//	    switch (type) {
+//	    case WEBKIT_POLICY_DECISION_TYPE_NAVIGATION_ACTION: {
+//	        WebKitNavigationPolicyDecision *navigation_decision = WEBKIT_NAVIGATION_POLICY_DECISION (decision);
+//	        // Make a policy decision here
+//	        break;
+//	    }
+//	    case WEBKIT_POLICY_DECISION_TYPE_NEW_WINDOW_ACTION: {
+//	        WebKitNavigationPolicyDecision *navigation_decision = WEBKIT_NAVIGATION_POLICY_DECISION (decision);
+//	        // Make a policy decision here
+//	        break;
+//	    }
+//	    case WEBKIT_POLICY_DECISION_TYPE_RESPONSE:
+//	        WebKitResponsePolicyDecision *response = WEBKIT_RESPONSE_POLICY_DECISION (decision);
+//	        // Make a policy decision here
+//	        break;
+//	    default:
+//	        // Making no decision results in webkit_policy_decision_use()
+//	        return FALSE;
+//	    }
+//	    return TRUE;
+//	}
+//
+// ```
+//
+// It is possible to make policy decision asynchronously, by simply calling g_object_ref()
+// on the @decision argument and returning %TRUE to block the default signal handler.
+// If the last reference is removed on a #WebKitPolicyDecision and no decision has been
+// made explicitly, webkit_policy_decision_use() will be the default policy decision. The
+// default signal handler will simply call webkit_policy_decision_use(). Only the first
+// policy decision chosen for a given #WebKitPolicyDecision will have any affect.
+func (x *WebView) ConnectDecidePolicy(cb *func(WebView, uintptr, PolicyDecisionType) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "decide-policy", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, DecisionVarp uintptr, DecisionTypeVarp PolicyDecisionType) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, DecisionVarp, DecisionTypeVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "decide-policy", cbRefPtr)
+}
+
+// Emitted when JavaScript code calls
+// &lt;function&gt;element.webkitRequestFullScreen&lt;/function&gt;. If the
+// signal is not handled the #WebKitWebView will proceed to full screen
+// its top level window. This signal can be used by client code to
+// request permission to the user prior doing the full screen
+// transition and eventually prepare the top-level window
+// (e.g. hide some widgets that would otherwise be part of the
+// full screen window).
+func (x *WebView) ConnectEnterFullscreen(cb *func(WebView) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "enter-fullscreen", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "enter-fullscreen", cbRefPtr)
+}
+
+// Prior to 2.46, this signal was emitted when insecure content was
+// loaded in a secure content. Since 2.46, this signal is generally
+// no longer emitted.
+func (x *WebView) ConnectInsecureContentDetected(cb *func(WebView, InsecureContentEvent)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "insecure-content-detected", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, EventVarp InsecureContentEvent) {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, EventVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "insecure-content-detected", cbRefPtr)
+}
+
+// Emitted when the #WebKitWebView is about to restore its top level
+// window out of its full screen state. This signal can be used by
+// client code to restore widgets hidden during the
+// #WebKitWebView::enter-fullscreen stage for instance.
+func (x *WebView) ConnectLeaveFullscreen(cb *func(WebView) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "leave-fullscreen", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "leave-fullscreen", cbRefPtr)
+}
+
+// Emitted when a load operation in @web_view changes.
+// The signal is always emitted with %WEBKIT_LOAD_STARTED when a
+// new load request is made and %WEBKIT_LOAD_FINISHED when the load
+// finishes successfully or due to an error. When the ongoing load
+// operation fails #WebKitWebView::load-failed signal is emitted
+// before #WebKitWebView::load-changed is emitted with
+// %WEBKIT_LOAD_FINISHED.
+// If a redirection is received from the server, this signal is emitted
+// with %WEBKIT_LOAD_REDIRECTED after the initial emission with
+// %WEBKIT_LOAD_STARTED and before %WEBKIT_LOAD_COMMITTED.
+// When the page content starts arriving the signal is emitted with
+// %WEBKIT_LOAD_COMMITTED event.
+//
+// You can handle this signal and use a switch to track any ongoing
+// load operation.
+//
+// ```c
+// static void web_view_load_changed (WebKitWebView  *web_view,
+//
+//	WebKitLoadEvent load_event,
+//	gpointer        user_data)
+//
+//	{
+//	    switch (load_event) {
+//	    case WEBKIT_LOAD_STARTED:
+//	        // New load, we have now a provisional URI
+//	        provisional_uri = webkit_web_view_get_uri (web_view);
+//	        // Here we could start a spinner or update the
+//	        // location bar with the provisional URI
+//	        break;
+//	    case WEBKIT_LOAD_REDIRECTED:
+//	        redirected_uri = webkit_web_view_get_uri (web_view);
+//	        break;
+//	    case WEBKIT_LOAD_COMMITTED:
+//	        // The load is being performed. Current URI is
+//	        // the final one and it won't change unless a new
+//	        // load is requested or a navigation within the
+//	        // same page is performed
+//	        uri = webkit_web_view_get_uri (web_view);
+//	        break;
+//	    case WEBKIT_LOAD_FINISHED:
+//	        // Load finished, we can now stop the spinner
+//	        break;
+//	    }
+//	}
+//
+// ```
+func (x *WebView) ConnectLoadChanged(cb *func(WebView, LoadEvent)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "load-changed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, LoadEventVarp LoadEvent) {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, LoadEventVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "load-changed", cbRefPtr)
+}
+
+// Emitted when an error occurs during a load operation.
+// If the error happened when starting to load data for a page
+// @load_event will be %WEBKIT_LOAD_STARTED. If it happened while
+// loading a committed data source @load_event will be %WEBKIT_LOAD_COMMITTED.
+// Since a load error causes the load operation to finish, the signal
+// WebKitWebView::load-changed will always be emitted with
+// %WEBKIT_LOAD_FINISHED event right after this one.
+//
+// By default, if the signal is not handled, a stock error page will be displayed.
+// You need to handle the signal if you want to provide your own error page.
+func (x *WebView) ConnectLoadFailed(cb *func(WebView, LoadEvent, string, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "load-failed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, LoadEventVarp LoadEvent, FailingUriVarp string, ErrorVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, LoadEventVarp, FailingUriVarp, ErrorVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "load-failed", cbRefPtr)
+}
+
+// Emitted when a TLS error occurs during a load operation.
+// To allow an exception for this @certificate
+// and the host of @failing_uri use webkit_web_context_allow_tls_certificate_for_host().
+//
+// To handle this signal asynchronously you should call g_object_ref() on @certificate
+// and return %TRUE.
+//
+// If %FALSE is returned, #WebKitWebView::load-failed will be emitted. The load
+// will finish regardless of the returned value.
+func (x *WebView) ConnectLoadFailedWithTlsErrors(cb *func(WebView, string, uintptr, gio.TlsCertificateFlags) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "load-failed-with-tls-errors", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, FailingUriVarp string, CertificateVarp uintptr, ErrorsVarp gio.TlsCertificateFlags) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, FailingUriVarp, CertificateVarp, ErrorsVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "load-failed-with-tls-errors", cbRefPtr)
+}
+
+// This signal is emitted when the mouse cursor moves over an
+// element such as a link, image or a media element. To determine
+// what type of element the mouse cursor is over, a Hit Test is performed
+// on the current mouse coordinates and the result is passed in the
+// @hit_test_result argument. The @modifiers argument is a bitmask of
+// #GdkModifierType flags indicating the state of modifier keys.
+// The signal is emitted again when the mouse is moved out of the
+// current element with a new @hit_test_result.
+func (x *WebView) ConnectMouseTargetChanged(cb *func(WebView, uintptr, uint)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "mouse-target-changed", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, HitTestResultVarp uintptr, ModifiersVarp uint) {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, HitTestResultVarp, ModifiersVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "mouse-target-changed", cbRefPtr)
+}
+
+// This signal is emitted when WebKit is requesting the client to
+// decide about a permission request, such as allowing the browser
+// to switch to fullscreen mode, sharing its location or similar
+// operations.
+//
+// A possible way to use this signal could be through a dialog
+// allowing the user decide what to do with the request:
+//
+// ```c
+// static gboolean permission_request_cb (WebKitWebView *web_view,
+//
+//	WebKitPermissionRequest *request,
+//	GtkWindow *parent_window)
+//
+//	{
+//	    GtkWidget *dialog = gtk_message_dialog_new (parent_window,
+//	                                                GTK_DIALOG_MODAL,
+//	                                                GTK_MESSAGE_QUESTION,
+//	                                                GTK_BUTTONS_YES_NO,
+//	                                                "Allow Permission Request?");
+//	    gtk_widget_show (dialog);
+//	    gint result = gtk_dialog_run (GTK_DIALOG (dialog));
+//
+//	    switch (result) {
+//	    case GTK_RESPONSE_YES:
+//	        webkit_permission_request_allow (request);
+//	        break;
+//	    default:
+//	        webkit_permission_request_deny (request);
+//	        break;
+//	    }
+//	    gtk_widget_destroy (dialog);
+//
+//	    return TRUE;
+//	}
+//
+// ```
+//
+// It is possible to handle permission requests asynchronously, by
+// simply calling g_object_ref() on the @request argument and
+// returning %TRUE to block the default signal handler.  If the
+// last reference is removed on a #WebKitPermissionRequest and the
+// request has not been handled, webkit_permission_request_deny()
+// will be the default action.
+//
+// If the signal is not handled, the @request will be completed automatically
+// by the specific #WebKitPermissionRequest that could allow or deny it. Check the
+// documentation of classes implementing #WebKitPermissionRequest interface to know
+// their default action.
+func (x *WebView) ConnectPermissionRequest(cb *func(WebView, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "permission-request", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, RequestVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, RequestVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "permission-request", cbRefPtr)
+}
+
+// Emitted when printing is requested on @web_view, usually by a JavaScript call,
+// before the print dialog is shown. This signal can be used to set the initial
+// print settings and page setup of @print_operation to be used as default values in
+// the print dialog. You can call webkit_print_operation_set_print_settings() and
+// webkit_print_operation_set_page_setup() and then return %FALSE to propagate the
+// event so that the print dialog is shown.
+//
+// You can connect to this signal and return %TRUE to cancel the print operation
+// or implement your own print dialog.
+func (x *WebView) ConnectPrint(cb *func(WebView, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "print", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, PrintOperationVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, PrintOperationVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "print", cbRefPtr)
+}
+
+// This signal allows the User-Agent to respond to permission requests for powerful features, as
+// specified by the [Permissions W3C Specification](https://w3c.github.io/permissions/).
+// You can reply to the query using webkit_permission_state_query_finish().
+//
+// You can handle the query asynchronously by calling webkit_permission_state_query_ref() on
+// @query and returning %TRUE. If the last reference of @query is removed and the query has not
+// been handled, the query result will be set to %WEBKIT_QUERY_PERMISSION_PROMPT.
+func (x *WebView) ConnectQueryPermissionState(cb *func(WebView, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "query-permission-state", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, QueryVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, QueryVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "query-permission-state", cbRefPtr)
+}
+
+// Emitted after #WebKitWebView::create on the newly created #WebKitWebView
+// when it should be displayed to the user. When this signal is emitted
+// all the information about how the window should look, including
+// size, position, whether the location, status and scrollbars
+// should be displayed, is already set on the #WebKitWindowProperties
+// of @web_view. See also webkit_web_view_get_window_properties().
+func (x *WebView) ConnectReadyToShow(cb *func(WebView)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "ready-to-show", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "ready-to-show", cbRefPtr)
+}
+
+// Emitted when a new resource is going to be loaded. The @request parameter
+// contains the #WebKitURIRequest that will be sent to the server.
+// You can monitor the load operation by connecting to the different signals
+// of @resource.
+func (x *WebView) ConnectResourceLoadStarted(cb *func(WebView, uintptr, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "resource-load-started", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ResourceVarp uintptr, RequestVarp uintptr) {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ResourceVarp, RequestVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "resource-load-started", cbRefPtr)
+}
+
+// Emitted after #WebKitWebView::ready-to-show on the newly
+// created #WebKitWebView when JavaScript code calls
+// &lt;function&gt;window.showModalDialog&lt;/function&gt;. The purpose of
+// this signal is to allow the client application to prepare the
+// new view to behave as modal. Once the signal is emitted a new
+// main loop will be run to block user interaction in the parent
+// #WebKitWebView until the new dialog is closed.
+func (x *WebView) ConnectRunAsModal(cb *func(WebView)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "run-as-modal", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr) {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "run-as-modal", cbRefPtr)
+}
+
+// This signal is emitted when the user interacts with a &lt;input
+// type='color' /&gt; HTML element, requesting from WebKit to show
+// a dialog to select a color. To let the application know the details of
+// the color chooser, as well as to allow the client application to either
+// cancel the request or perform an actual color selection, the signal will
+// pass an instance of the #WebKitColorChooserRequest in the @request
+// argument.
+//
+// It is possible to handle this request asynchronously by increasing the
+// reference count of the request.
+//
+// The default signal handler will asynchronously run a regular
+// #GtkColorChooser for the user to interact with.
+func (x *WebView) ConnectRunColorChooser(cb *func(WebView, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "run-color-chooser", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, RequestVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, RequestVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "run-color-chooser", cbRefPtr)
+}
+
+// This signal is emitted when the user interacts with a &lt;input
+// type='file' /&gt; HTML element, requesting from WebKit to show
+// a dialog to select one or more files to be uploaded. To let the
+// application know the details of the file chooser, as well as to
+// allow the client application to either cancel the request or
+// perform an actual selection of files, the signal will pass an
+// instance of the #WebKitFileChooserRequest in the @request
+// argument.
+//
+// The default signal handler will asynchronously run a regular
+// #GtkFileChooserDialog for the user to interact with.
+func (x *WebView) ConnectRunFileChooser(cb *func(WebView, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "run-file-chooser", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, RequestVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, RequestVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "run-file-chooser", cbRefPtr)
+}
+
+// Emitted when JavaScript code calls &lt;function&gt;window.alert&lt;/function&gt;,
+// &lt;function&gt;window.confirm&lt;/function&gt; or &lt;function&gt;window.prompt&lt;/function&gt;,
+// or when &lt;function&gt;onbeforeunload&lt;/function&gt; event is fired.
+// The @dialog parameter should be used to build the dialog.
+// If the signal is not handled a different dialog will be built and shown depending
+// on the dialog type:
+// &lt;itemizedlist&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	%WEBKIT_SCRIPT_DIALOG_ALERT: message dialog with a single Close button.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	%WEBKIT_SCRIPT_DIALOG_CONFIRM: message dialog with OK and Cancel buttons.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	%WEBKIT_SCRIPT_DIALOG_PROMPT: message dialog with OK and Cancel buttons and
+//	a text entry with the default text.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;listitem&gt;&lt;para&gt;
+//
+//	%WEBKIT_SCRIPT_DIALOG_BEFORE_UNLOAD_CONFIRM: message dialog with Stay and Leave buttons.
+//
+// &lt;/para&gt;&lt;/listitem&gt;
+// &lt;/itemizedlist&gt;
+//
+// It is possible to handle the script dialog request asynchronously, by simply
+// caling webkit_script_dialog_ref() on the @dialog argument and calling
+// webkit_script_dialog_close() when done.
+// If the last reference is removed on a #WebKitScriptDialog and the dialog has not been
+// closed, webkit_script_dialog_close() will be called.
+func (x *WebView) ConnectScriptDialog(cb *func(WebView, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "script-dialog", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, DialogVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, DialogVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "script-dialog", cbRefPtr)
+}
+
+// This signal is emitted when a notification should be presented to the
+// user. The @notification is kept alive until either: 1) the web page cancels it
+// or 2) a navigation happens.
+//
+// The default handler will emit a notification using libnotify, if built with
+// support for it.
+func (x *WebView) ConnectShowNotification(cb *func(WebView, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "show-notification", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, NotificationVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, NotificationVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "show-notification", cbRefPtr)
+}
+
+// This signal is emitted when a select element in @web_view needs to display a
+// dropdown menu. This signal can be used to show a custom menu, using @menu to get
+// the details of all items that should be displayed. The area of the element in the
+// #WebKitWebView is given as @rectangle parameter, it can be used to position the
+// menu.
+// To handle this signal asynchronously you should keep a ref of the @menu.
+//
+// The default signal handler will pop up a #GtkMenu.
+func (x *WebView) ConnectShowOptionMenu(cb *func(WebView, uintptr, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "show-option-menu", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MenuVarp uintptr, RectangleVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, MenuVarp, RectangleVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "show-option-menu", cbRefPtr)
+}
+
+// This signal is emitted when a form is about to be submitted. The @request
+// argument passed contains information about the text fields of the form. This
+// is typically used to store login information that can be used later to
+// pre-fill the form.
+// The form will not be submitted until webkit_form_submission_request_submit() is called.
+//
+// It is possible to handle the form submission request asynchronously, by
+// simply calling g_object_ref() on the @request argument and calling
+// webkit_form_submission_request_submit() when done to continue with the form submission.
+// If the last reference is removed on a #WebKitFormSubmissionRequest and the
+// form has not been submitted, webkit_form_submission_request_submit() will be called.
+func (x *WebView) ConnectSubmitForm(cb *func(WebView, uintptr)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "submit-form", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, RequestVarp uintptr) {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, RequestVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "submit-form", cbRefPtr)
+}
+
+// This signal is emitted when a #WebKitUserMessage is received from the
+// #WebKitWebPage corresponding to @web_view. You can reply to the message
+// using webkit_user_message_send_reply().
+//
+// You can handle the user message asynchronously by calling g_object_ref() on
+// @message and returning %TRUE. If the last reference of @message is removed
+// and the message has not been replied to, the operation in the #WebKitWebPage will
+// finish with error %WEBKIT_USER_MESSAGE_UNHANDLED_MESSAGE.
+func (x *WebView) ConnectUserMessageReceived(cb *func(WebView, uintptr) bool) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, MessageVarp uintptr) bool {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		return cbFn(fa, MessageVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "user-message-received", cbRefPtr)
+}
+
+// This signal is emitted when the web process terminates abnormally due
+// to @reason.
+func (x *WebView) ConnectWebProcessTerminated(cb *func(WebView, WebProcessTerminationReason)) uint32 {
+	cbPtr := uintptr(unsafe.Pointer(cb))
+	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
+		return gobject.SignalConnect(x.GoPointer(), "web-process-terminated", cbRefPtr)
+	}
+
+	fcb := func(clsPtr uintptr, ReasonVarp WebProcessTerminationReason) {
+		fa := WebView{}
+		fa.Ptr = clsPtr
+		cbFn := *cb
+
+		cbFn(fa, ReasonVarp)
+
+	}
+	cbRefPtr := purego.NewCallback(fcb)
+	glib.SaveCallback(cbPtr, cbRefPtr)
+	return gobject.SignalConnect(x.GoPointer(), "web-process-terminated", cbRefPtr)
+}
+
+// Requests the user's screen reader to announce the given message.
+//
+// This kind of notification is useful for messages that
+// either have only a visual representation or that are not
+// exposed visually at all, e.g. a notification about a
+// successful operation.
+//
+// Also, by using this API, you can ensure that the message
+// does not interrupts the user's current screen reader output.
+func (x *WebView) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {
+
+	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)
+
+}
+
+// Retrieves the accessible parent for an accessible object.
+//
+// This function returns `NULL` for top level widgets.
+func (x *WebView) GetAccessibleParent() *gtk.AccessibleBase {
+	var cls *gtk.AccessibleBase
+
+	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &gtk.AccessibleBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+// Retrieves the accessible role of an accessible object.
+func (x *WebView) GetAccessibleRole() gtk.AccessibleRole {
+
+	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
+	return cret
+}
+
+// Retrieves the implementation for the given accessible object.
+func (x *WebView) GetAtContext() *gtk.ATContext {
+	var cls *gtk.ATContext
+
+	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &gtk.ATContext{}
+	cls.Ptr = cret
+	return cls
+}
+
+// Queries the coordinates and dimensions of this accessible
+//
+// This functionality can be overridden by `GtkAccessible`
+// implementations, e.g. to get the bounds from an ignored
+// child widget.
+func (x *WebView) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {
+
+	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
+	return cret
+}
+
+// Retrieves the first accessible child of an accessible object.
+func (x *WebView) GetFirstAccessibleChild() *gtk.AccessibleBase {
+	var cls *gtk.AccessibleBase
+
+	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &gtk.AccessibleBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+// Retrieves the next accessible sibling of an accessible object
+func (x *WebView) GetNextAccessibleSibling() *gtk.AccessibleBase {
+	var cls *gtk.AccessibleBase
+
+	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &gtk.AccessibleBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+// Queries a platform state, such as focus.
+//
+// This functionality can be overridden by `GtkAccessible`
+// implementations, e.g. to get platform state from an ignored
+// child widget, as is the case for `GtkText` wrappers.
+func (x *WebView) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {
+
+	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
+	return cret
+}
+
+// Resets the accessible property to its default value.
+func (x *WebView) ResetProperty(PropertyVar gtk.AccessibleProperty) {
+
+	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)
+
+}
+
+// Resets the accessible relation to its default value.
+func (x *WebView) ResetRelation(RelationVar gtk.AccessibleRelation) {
+
+	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)
+
+}
+
+// Resets the accessible state to its default value.
+func (x *WebView) ResetState(StateVar gtk.AccessibleState) {
+
+	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)
+
+}
+
+// Sets the parent and sibling of an accessible object.
+//
+// This function is meant to be used by accessible implementations that are
+// not part of the widget hierarchy, and but act as a logical bridge between
+// widgets. For instance, if a widget creates an object that holds metadata
+// for each child, and you want that object to implement the `GtkAccessible`
+// interface, you will use this function to ensure that the parent of each
+// child widget is the metadata object, and the parent of each metadata
+// object is the container widget.
+func (x *WebView) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {
+
+	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())
+
+}
+
+// Updates the next accessible sibling.
+//
+// That might be useful when a new child of a custom accessible
+// is created, and it needs to be linked to a previous child.
+func (x *WebView) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {
+
+	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())
+
+}
+
+// Informs ATs that the platform state has changed.
+//
+// This function should be used by `GtkAccessible` implementations that
+// have a platform state but are not widgets. Widgets handle platform
+// states automatically.
+func (x *WebView) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {
+
+	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)
+
+}
+
+// Updates a list of accessible properties.
+//
+// See the [enum@Gtk.AccessibleProperty] documentation for the
+// value types of accessible properties.
+//
+// This function should be called by `GtkWidget` types whenever
+// an accessible property change must be communicated to assistive
+// technologies.
+//
+// Example:
+// ```c
+// value = gtk_adjustment_get_value (adjustment);
+// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
+//
+//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
+//	-1);
+//
+// ```
+func (x *WebView) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {
+
+	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)
+
+}
+
+// Updates an array of accessible properties.
+//
+// This function should be called by `GtkWidget` types whenever an accessible
+// property change must be communicated to assistive technologies.
+//
+// This function is meant to be used by language bindings.
+func (x *WebView) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {
+
+	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)
+
+}
+
+// Updates a list of accessible relations.
+//
+// This function should be called by `GtkWidget` types whenever an accessible
+// relation change must be communicated to assistive technologies.
+//
+// If the [enum@Gtk.AccessibleRelation] requires a list of references,
+// you should pass each reference individually, followed by `NULL`, e.g.
+//
+// ```c
+// gtk_accessible_update_relation (accessible,
+//
+//	GTK_ACCESSIBLE_RELATION_CONTROLS,
+//	  ref1, NULL,
+//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
+//	  ref1, ref2, ref3, NULL,
+//	-1);
+//
+// ```
+func (x *WebView) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {
+
+	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)
+
+}
+
+// Updates an array of accessible relations.
+//
+// This function should be called by `GtkWidget` types whenever an accessible
+// relation change must be communicated to assistive technologies.
+//
+// This function is meant to be used by language bindings.
+func (x *WebView) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {
+
+	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)
+
+}
+
+// Updates a list of accessible states.
+//
+// See the [enum@Gtk.AccessibleState] documentation for the
+// value types of accessible states.
+//
+// This function should be called by `GtkWidget` types whenever
+// an accessible state change must be communicated to assistive
+// technologies.
+//
+// Example:
+//
+// ```c
+// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
+// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
+//
+//	GTK_ACCESSIBLE_STATE_CHECKED, value,
+//	-1);
+//
+// ```
+func (x *WebView) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {
+
+	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)
+
+}
+
+// Updates an array of accessible states.
+//
+// This function should be called by `GtkWidget` types whenever an accessible
+// state change must be communicated to assistive technologies.
+//
+// This function is meant to be used by language bindings.
+func (x *WebView) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {
+
+	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)
+
+}
+
+// Gets the ID of the @buildable object.
+//
+// `GtkBuilder` sets the name based on the ID attribute
+// of the `&lt;object&gt;` tag used to construct the @buildable.
+func (x *WebView) GetBuildableId() string {
+
+	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
+	return cret
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xSnapshotOptionsGLibType, libs, "webkit_snapshot_options_get_type")
+
+	core.PuregoSafeRegister(&xInsecureContentEventGLibType, libs, "webkit_insecure_content_event_get_type")
+
+	core.PuregoSafeRegister(&xLoadEventGLibType, libs, "webkit_load_event_get_type")
+
+	core.PuregoSafeRegister(&xMediaCaptureStateGLibType, libs, "webkit_media_capture_state_get_type")
+
+	core.PuregoSafeRegister(&xPolicyDecisionTypeGLibType, libs, "webkit_policy_decision_type_get_type")
+
+	core.PuregoSafeRegister(&xSaveModeGLibType, libs, "webkit_save_mode_get_type")
+
+	core.PuregoSafeRegister(&xSnapshotRegionGLibType, libs, "webkit_snapshot_region_get_type")
+
+	core.PuregoSafeRegister(&xWebExtensionModeGLibType, libs, "webkit_web_extension_mode_get_type")
+
+	core.PuregoSafeRegister(&xWebProcessTerminationReasonGLibType, libs, "webkit_web_process_termination_reason_get_type")
+
+	core.PuregoSafeRegister(&xWebViewGLibType, libs, "webkit_web_view_get_type")
+
+	core.PuregoSafeRegister(&xNewWebView, libs, "webkit_web_view_new")
+
+	core.PuregoSafeRegister(&xWebViewCallAsyncJavascriptFunction, libs, "webkit_web_view_call_async_javascript_function")
+	core.PuregoSafeRegister(&xWebViewCallAsyncJavascriptFunctionFinish, libs, "webkit_web_view_call_async_javascript_function_finish")
+	core.PuregoSafeRegister(&xWebViewCanExecuteEditingCommand, libs, "webkit_web_view_can_execute_editing_command")
+	core.PuregoSafeRegister(&xWebViewCanExecuteEditingCommandFinish, libs, "webkit_web_view_can_execute_editing_command_finish")
+	core.PuregoSafeRegister(&xWebViewCanGoBack, libs, "webkit_web_view_can_go_back")
+	core.PuregoSafeRegister(&xWebViewCanGoForward, libs, "webkit_web_view_can_go_forward")
+	core.PuregoSafeRegister(&xWebViewCanShowMimeType, libs, "webkit_web_view_can_show_mime_type")
+	core.PuregoSafeRegister(&xWebViewDownloadUri, libs, "webkit_web_view_download_uri")
+	core.PuregoSafeRegister(&xWebViewEvaluateJavascript, libs, "webkit_web_view_evaluate_javascript")
+	core.PuregoSafeRegister(&xWebViewEvaluateJavascriptFinish, libs, "webkit_web_view_evaluate_javascript_finish")
+	core.PuregoSafeRegister(&xWebViewExecuteEditingCommand, libs, "webkit_web_view_execute_editing_command")
+	core.PuregoSafeRegister(&xWebViewExecuteEditingCommandWithArgument, libs, "webkit_web_view_execute_editing_command_with_argument")
+	core.PuregoSafeRegister(&xWebViewGetAutomationPresentationType, libs, "webkit_web_view_get_automation_presentation_type")
+	core.PuregoSafeRegister(&xWebViewGetBackForwardList, libs, "webkit_web_view_get_back_forward_list")
+	core.PuregoSafeRegister(&xWebViewGetBackgroundColor, libs, "webkit_web_view_get_background_color")
+	core.PuregoSafeRegister(&xWebViewGetCameraCaptureState, libs, "webkit_web_view_get_camera_capture_state")
+	core.PuregoSafeRegister(&xWebViewGetContext, libs, "webkit_web_view_get_context")
+	core.PuregoSafeRegister(&xWebViewGetCustomCharset, libs, "webkit_web_view_get_custom_charset")
+	core.PuregoSafeRegister(&xWebViewGetDefaultContentSecurityPolicy, libs, "webkit_web_view_get_default_content_security_policy")
+	core.PuregoSafeRegister(&xWebViewGetDisplayCaptureState, libs, "webkit_web_view_get_display_capture_state")
+	core.PuregoSafeRegister(&xWebViewGetEditorState, libs, "webkit_web_view_get_editor_state")
+	core.PuregoSafeRegister(&xWebViewGetEstimatedLoadProgress, libs, "webkit_web_view_get_estimated_load_progress")
+	core.PuregoSafeRegister(&xWebViewGetFavicon, libs, "webkit_web_view_get_favicon")
+	core.PuregoSafeRegister(&xWebViewGetFindController, libs, "webkit_web_view_get_find_controller")
+	core.PuregoSafeRegister(&xWebViewGetInputMethodContext, libs, "webkit_web_view_get_input_method_context")
+	core.PuregoSafeRegister(&xWebViewGetInspector, libs, "webkit_web_view_get_inspector")
+	core.PuregoSafeRegister(&xWebViewGetIsMuted, libs, "webkit_web_view_get_is_muted")
+	core.PuregoSafeRegister(&xWebViewGetIsWebProcessResponsive, libs, "webkit_web_view_get_is_web_process_responsive")
+	core.PuregoSafeRegister(&xWebViewGetMainResource, libs, "webkit_web_view_get_main_resource")
+	core.PuregoSafeRegister(&xWebViewGetMicrophoneCaptureState, libs, "webkit_web_view_get_microphone_capture_state")
+	core.PuregoSafeRegister(&xWebViewGetNetworkSession, libs, "webkit_web_view_get_network_session")
+	core.PuregoSafeRegister(&xWebViewGetPageId, libs, "webkit_web_view_get_page_id")
+	core.PuregoSafeRegister(&xWebViewGetSessionState, libs, "webkit_web_view_get_session_state")
+	core.PuregoSafeRegister(&xWebViewGetSettings, libs, "webkit_web_view_get_settings")
+	core.PuregoSafeRegister(&xWebViewGetSnapshot, libs, "webkit_web_view_get_snapshot")
+	core.PuregoSafeRegister(&xWebViewGetSnapshotFinish, libs, "webkit_web_view_get_snapshot_finish")
+	core.PuregoSafeRegister(&xWebViewGetThemeColor, libs, "webkit_web_view_get_theme_color")
+	core.PuregoSafeRegister(&xWebViewGetTitle, libs, "webkit_web_view_get_title")
+	core.PuregoSafeRegister(&xWebViewGetTlsInfo, libs, "webkit_web_view_get_tls_info")
+	core.PuregoSafeRegister(&xWebViewGetUri, libs, "webkit_web_view_get_uri")
+	core.PuregoSafeRegister(&xWebViewGetUserContentManager, libs, "webkit_web_view_get_user_content_manager")
+	core.PuregoSafeRegister(&xWebViewGetWebExtensionMode, libs, "webkit_web_view_get_web_extension_mode")
+	core.PuregoSafeRegister(&xWebViewGetWebsitePolicies, libs, "webkit_web_view_get_website_policies")
+	core.PuregoSafeRegister(&xWebViewGetWindowProperties, libs, "webkit_web_view_get_window_properties")
+	core.PuregoSafeRegister(&xWebViewGetZoomLevel, libs, "webkit_web_view_get_zoom_level")
+	core.PuregoSafeRegister(&xWebViewGoBack, libs, "webkit_web_view_go_back")
+	core.PuregoSafeRegister(&xWebViewGoForward, libs, "webkit_web_view_go_forward")
+	core.PuregoSafeRegister(&xWebViewGoToBackForwardListItem, libs, "webkit_web_view_go_to_back_forward_list_item")
+	core.PuregoSafeRegister(&xWebViewIsControlledByAutomation, libs, "webkit_web_view_is_controlled_by_automation")
+	core.PuregoSafeRegister(&xWebViewIsEditable, libs, "webkit_web_view_is_editable")
+	core.PuregoSafeRegister(&xWebViewIsLoading, libs, "webkit_web_view_is_loading")
+	core.PuregoSafeRegister(&xWebViewIsPlayingAudio, libs, "webkit_web_view_is_playing_audio")
+	core.PuregoSafeRegister(&xWebViewLoadAlternateHtml, libs, "webkit_web_view_load_alternate_html")
+	core.PuregoSafeRegister(&xWebViewLoadBytes, libs, "webkit_web_view_load_bytes")
+	core.PuregoSafeRegister(&xWebViewLoadHtml, libs, "webkit_web_view_load_html")
+	core.PuregoSafeRegister(&xWebViewLoadPlainText, libs, "webkit_web_view_load_plain_text")
+	core.PuregoSafeRegister(&xWebViewLoadRequest, libs, "webkit_web_view_load_request")
+	core.PuregoSafeRegister(&xWebViewLoadUri, libs, "webkit_web_view_load_uri")
+	core.PuregoSafeRegister(&xWebViewReload, libs, "webkit_web_view_reload")
+	core.PuregoSafeRegister(&xWebViewReloadBypassCache, libs, "webkit_web_view_reload_bypass_cache")
+	core.PuregoSafeRegister(&xWebViewRestoreSessionState, libs, "webkit_web_view_restore_session_state")
+	core.PuregoSafeRegister(&xWebViewSave, libs, "webkit_web_view_save")
+	core.PuregoSafeRegister(&xWebViewSaveFinish, libs, "webkit_web_view_save_finish")
+	core.PuregoSafeRegister(&xWebViewSaveToFile, libs, "webkit_web_view_save_to_file")
+	core.PuregoSafeRegister(&xWebViewSaveToFileFinish, libs, "webkit_web_view_save_to_file_finish")
+	core.PuregoSafeRegister(&xWebViewSendMessageToPage, libs, "webkit_web_view_send_message_to_page")
+	core.PuregoSafeRegister(&xWebViewSendMessageToPageFinish, libs, "webkit_web_view_send_message_to_page_finish")
+	core.PuregoSafeRegister(&xWebViewSetBackgroundColor, libs, "webkit_web_view_set_background_color")
+	core.PuregoSafeRegister(&xWebViewSetCameraCaptureState, libs, "webkit_web_view_set_camera_capture_state")
+	core.PuregoSafeRegister(&xWebViewSetCorsAllowlist, libs, "webkit_web_view_set_cors_allowlist")
+	core.PuregoSafeRegister(&xWebViewSetCustomCharset, libs, "webkit_web_view_set_custom_charset")
+	core.PuregoSafeRegister(&xWebViewSetDisplayCaptureState, libs, "webkit_web_view_set_display_capture_state")
+	core.PuregoSafeRegister(&xWebViewSetEditable, libs, "webkit_web_view_set_editable")
+	core.PuregoSafeRegister(&xWebViewSetInputMethodContext, libs, "webkit_web_view_set_input_method_context")
+	core.PuregoSafeRegister(&xWebViewSetIsMuted, libs, "webkit_web_view_set_is_muted")
+	core.PuregoSafeRegister(&xWebViewSetMicrophoneCaptureState, libs, "webkit_web_view_set_microphone_capture_state")
+	core.PuregoSafeRegister(&xWebViewSetSettings, libs, "webkit_web_view_set_settings")
+	core.PuregoSafeRegister(&xWebViewSetZoomLevel, libs, "webkit_web_view_set_zoom_level")
+	core.PuregoSafeRegister(&xWebViewStopLoading, libs, "webkit_web_view_stop_loading")
+	core.PuregoSafeRegister(&xWebViewTerminateWebProcess, libs, "webkit_web_view_terminate_web_process")
+	core.PuregoSafeRegister(&xWebViewTryClose, libs, "webkit_web_view_try_close")
+
+}
diff --git a/v4/webkit/WebKitWebViewBase.go b/v4/webkit/WebKitWebViewBase.go
new file mode 100644
index 0000000000000000000000000000000000000000..38930d10feadb86d53698d72eb69b91b93e896a0
--- /dev/null
+++ b/v4/webkit/WebKitWebViewBase.go
@@ -0,0 +1,435 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+	"github.com/jwijenbergh/puregotk/v4/gtk"
+)
+
+type WebViewBaseClass struct {
+	_ structs.HostLayout
+
+	ParentClass uintptr
+
+	xWebkitReserved0 uintptr
+
+	xWebkitReserved1 uintptr
+
+	xWebkitReserved2 uintptr
+
+	xWebkitReserved3 uintptr
+}
+
+func (x *WebViewBaseClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// OverrideWebkitReserved0 sets the "_webkit_reserved0" callback function.
+func (x *WebViewBaseClass) OverrideWebkitReserved0(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved0 = 0
+	} else {
+		x.xWebkitReserved0 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved0 gets the "_webkit_reserved0" callback function.
+func (x *WebViewBaseClass) GetWebkitReserved0() func() {
+	if x.xWebkitReserved0 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved0)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved1 sets the "_webkit_reserved1" callback function.
+func (x *WebViewBaseClass) OverrideWebkitReserved1(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved1 = 0
+	} else {
+		x.xWebkitReserved1 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved1 gets the "_webkit_reserved1" callback function.
+func (x *WebViewBaseClass) GetWebkitReserved1() func() {
+	if x.xWebkitReserved1 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved1)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved2 sets the "_webkit_reserved2" callback function.
+func (x *WebViewBaseClass) OverrideWebkitReserved2(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved2 = 0
+	} else {
+		x.xWebkitReserved2 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved2 gets the "_webkit_reserved2" callback function.
+func (x *WebViewBaseClass) GetWebkitReserved2() func() {
+	if x.xWebkitReserved2 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved2)
+	return func() {
+		rawCallback()
+	}
+}
+
+// OverrideWebkitReserved3 sets the "_webkit_reserved3" callback function.
+func (x *WebViewBaseClass) OverrideWebkitReserved3(cb func()) {
+	if cb == nil {
+		x.xWebkitReserved3 = 0
+	} else {
+		x.xWebkitReserved3 = purego.NewCallback(func() {
+			cb()
+		})
+	}
+}
+
+// GetWebkitReserved3 gets the "_webkit_reserved3" callback function.
+func (x *WebViewBaseClass) GetWebkitReserved3() func() {
+	if x.xWebkitReserved3 == 0 {
+		return nil
+	}
+	var rawCallback func()
+	purego.RegisterFunc(&rawCallback, x.xWebkitReserved3)
+	return func() {
+		rawCallback()
+	}
+}
+
+type WebViewBasePrivate struct {
+	_ structs.HostLayout
+}
+
+func (x *WebViewBasePrivate) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+type WebViewBase struct {
+	gtk.Widget
+}
+
+var xWebViewBaseGLibType func() types.GType
+
+func WebViewBaseGLibType() types.GType {
+	return xWebViewBaseGLibType()
+}
+
+func WebViewBaseNewFromInternalPtr(ptr uintptr) *WebViewBase {
+	cls := &WebViewBase{}
+	cls.Ptr = ptr
+	return cls
+}
+
+func (c *WebViewBase) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebViewBase) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Requests the user's screen reader to announce the given message.
+//
+// This kind of notification is useful for messages that
+// either have only a visual representation or that are not
+// exposed visually at all, e.g. a notification about a
+// successful operation.
+//
+// Also, by using this API, you can ensure that the message
+// does not interrupts the user's current screen reader output.
+func (x *WebViewBase) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {
+
+	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)
+
+}
+
+// Retrieves the accessible parent for an accessible object.
+//
+// This function returns `NULL` for top level widgets.
+func (x *WebViewBase) GetAccessibleParent() *gtk.AccessibleBase {
+	var cls *gtk.AccessibleBase
+
+	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &gtk.AccessibleBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+// Retrieves the accessible role of an accessible object.
+func (x *WebViewBase) GetAccessibleRole() gtk.AccessibleRole {
+
+	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
+	return cret
+}
+
+// Retrieves the implementation for the given accessible object.
+func (x *WebViewBase) GetAtContext() *gtk.ATContext {
+	var cls *gtk.ATContext
+
+	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &gtk.ATContext{}
+	cls.Ptr = cret
+	return cls
+}
+
+// Queries the coordinates and dimensions of this accessible
+//
+// This functionality can be overridden by `GtkAccessible`
+// implementations, e.g. to get the bounds from an ignored
+// child widget.
+func (x *WebViewBase) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {
+
+	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
+	return cret
+}
+
+// Retrieves the first accessible child of an accessible object.
+func (x *WebViewBase) GetFirstAccessibleChild() *gtk.AccessibleBase {
+	var cls *gtk.AccessibleBase
+
+	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &gtk.AccessibleBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+// Retrieves the next accessible sibling of an accessible object
+func (x *WebViewBase) GetNextAccessibleSibling() *gtk.AccessibleBase {
+	var cls *gtk.AccessibleBase
+
+	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &gtk.AccessibleBase{}
+	cls.Ptr = cret
+	return cls
+}
+
+// Queries a platform state, such as focus.
+//
+// This functionality can be overridden by `GtkAccessible`
+// implementations, e.g. to get platform state from an ignored
+// child widget, as is the case for `GtkText` wrappers.
+func (x *WebViewBase) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {
+
+	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
+	return cret
+}
+
+// Resets the accessible property to its default value.
+func (x *WebViewBase) ResetProperty(PropertyVar gtk.AccessibleProperty) {
+
+	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)
+
+}
+
+// Resets the accessible relation to its default value.
+func (x *WebViewBase) ResetRelation(RelationVar gtk.AccessibleRelation) {
+
+	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)
+
+}
+
+// Resets the accessible state to its default value.
+func (x *WebViewBase) ResetState(StateVar gtk.AccessibleState) {
+
+	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)
+
+}
+
+// Sets the parent and sibling of an accessible object.
+//
+// This function is meant to be used by accessible implementations that are
+// not part of the widget hierarchy, and but act as a logical bridge between
+// widgets. For instance, if a widget creates an object that holds metadata
+// for each child, and you want that object to implement the `GtkAccessible`
+// interface, you will use this function to ensure that the parent of each
+// child widget is the metadata object, and the parent of each metadata
+// object is the container widget.
+func (x *WebViewBase) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {
+
+	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())
+
+}
+
+// Updates the next accessible sibling.
+//
+// That might be useful when a new child of a custom accessible
+// is created, and it needs to be linked to a previous child.
+func (x *WebViewBase) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {
+
+	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())
+
+}
+
+// Informs ATs that the platform state has changed.
+//
+// This function should be used by `GtkAccessible` implementations that
+// have a platform state but are not widgets. Widgets handle platform
+// states automatically.
+func (x *WebViewBase) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {
+
+	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)
+
+}
+
+// Updates a list of accessible properties.
+//
+// See the [enum@Gtk.AccessibleProperty] documentation for the
+// value types of accessible properties.
+//
+// This function should be called by `GtkWidget` types whenever
+// an accessible property change must be communicated to assistive
+// technologies.
+//
+// Example:
+// ```c
+// value = gtk_adjustment_get_value (adjustment);
+// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
+//
+//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
+//	-1);
+//
+// ```
+func (x *WebViewBase) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {
+
+	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)
+
+}
+
+// Updates an array of accessible properties.
+//
+// This function should be called by `GtkWidget` types whenever an accessible
+// property change must be communicated to assistive technologies.
+//
+// This function is meant to be used by language bindings.
+func (x *WebViewBase) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {
+
+	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)
+
+}
+
+// Updates a list of accessible relations.
+//
+// This function should be called by `GtkWidget` types whenever an accessible
+// relation change must be communicated to assistive technologies.
+//
+// If the [enum@Gtk.AccessibleRelation] requires a list of references,
+// you should pass each reference individually, followed by `NULL`, e.g.
+//
+// ```c
+// gtk_accessible_update_relation (accessible,
+//
+//	GTK_ACCESSIBLE_RELATION_CONTROLS,
+//	  ref1, NULL,
+//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
+//	  ref1, ref2, ref3, NULL,
+//	-1);
+//
+// ```
+func (x *WebViewBase) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {
+
+	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)
+
+}
+
+// Updates an array of accessible relations.
+//
+// This function should be called by `GtkWidget` types whenever an accessible
+// relation change must be communicated to assistive technologies.
+//
+// This function is meant to be used by language bindings.
+func (x *WebViewBase) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {
+
+	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)
+
+}
+
+// Updates a list of accessible states.
+//
+// See the [enum@Gtk.AccessibleState] documentation for the
+// value types of accessible states.
+//
+// This function should be called by `GtkWidget` types whenever
+// an accessible state change must be communicated to assistive
+// technologies.
+//
+// Example:
+//
+// ```c
+// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
+// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
+//
+//	GTK_ACCESSIBLE_STATE_CHECKED, value,
+//	-1);
+//
+// ```
+func (x *WebViewBase) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {
+
+	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)
+
+}
+
+// Updates an array of accessible states.
+//
+// This function should be called by `GtkWidget` types whenever an accessible
+// state change must be communicated to assistive technologies.
+//
+// This function is meant to be used by language bindings.
+func (x *WebViewBase) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {
+
+	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)
+
+}
+
+// Gets the ID of the @buildable object.
+//
+// `GtkBuilder` sets the name based on the ID attribute
+// of the `&lt;object&gt;` tag used to construct the @buildable.
+func (x *WebViewBase) GetBuildableId() string {
+
+	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
+	return cret
+}
diff --git a/v4/webkit/WebKitWebViewGtk4.go b/v4/webkit/WebKitWebViewGtk4.go
new file mode 100644
index 0000000000000000000000000000000000000000..a65207ca0229fab057378273207a51f6181a910c
--- /dev/null
+++ b/v4/webkit/WebKitWebViewGtk4.go
@@ -0,0 +1,43 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import "github.com/jwijenbergh/puregotk/v4/gobject/types"
+
+// Enum values with flags representing types of Website data.
+type WebsiteDataTypes int
+
+var xWebsiteDataTypesGLibType func() types.GType
+
+func WebsiteDataTypesGLibType() types.GType {
+	return xWebsiteDataTypesGLibType()
+}
+
+const (
+
+	// Memory cache.
+	WebsiteDataMemoryCacheValue WebsiteDataTypes = 1
+	// HTTP disk cache.
+	WebsiteDataDiskCacheValue WebsiteDataTypes = 2
+	// Offline web application cache.
+	WebsiteDataOfflineApplicationCacheValue WebsiteDataTypes = 4
+	// Session storage data.
+	WebsiteDataSessionStorageValue WebsiteDataTypes = 8
+	// Local storage data.
+	WebsiteDataLocalStorageValue WebsiteDataTypes = 16
+	// IndexedDB databases.
+	WebsiteDataIndexeddbDatabasesValue WebsiteDataTypes = 32
+	// Cookies.
+	WebsiteDataCookiesValue WebsiteDataTypes = 64
+	// Hash salt used to generate the device ids used by webpages.
+	WebsiteDataDeviceIdHashSaltValue WebsiteDataTypes = 128
+	// HSTS cache.
+	WebsiteDataHstsCacheValue WebsiteDataTypes = 256
+	// Intelligent Tracking Prevention data.
+	WebsiteDataItpValue WebsiteDataTypes = 512
+	// Service worker registrations.
+	WebsiteDataServiceWorkerRegistrationsValue WebsiteDataTypes = 1024
+	// DOM (CacheStorage) cache.
+	WebsiteDataDomCacheValue WebsiteDataTypes = 2048
+	// All types.
+	WebsiteDataAllValue WebsiteDataTypes = 4095
+)
diff --git a/v4/webkit/WebKitWebViewSessionState.go b/v4/webkit/WebKitWebViewSessionState.go
new file mode 100644
index 0000000000000000000000000000000000000000..9b3ab36292af632fc8aebaea0970f63521dcbbf6
--- /dev/null
+++ b/v4/webkit/WebKitWebViewSessionState.go
@@ -0,0 +1,92 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Handles serialization of a web view's browsing state.
+type WebViewSessionState struct {
+	_ structs.HostLayout
+}
+
+var xWebViewSessionStateGLibType func() types.GType
+
+func WebViewSessionStateGLibType() types.GType {
+	return xWebViewSessionStateGLibType()
+}
+
+func (x *WebViewSessionState) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xNewWebViewSessionState func(*glib.Bytes) *WebViewSessionState
+
+// Creates a new #WebKitWebViewSessionState from serialized data.
+func NewWebViewSessionState(DataVar *glib.Bytes) *WebViewSessionState {
+
+	cret := xNewWebViewSessionState(DataVar)
+	return cret
+}
+
+var xWebViewSessionStateRef func(uintptr) *WebViewSessionState
+
+// Atomically increments the reference count of @state by one.
+//
+// This
+// function is MT-safe and may be called from any thread.
+func (x *WebViewSessionState) Ref() *WebViewSessionState {
+
+	cret := xWebViewSessionStateRef(x.GoPointer())
+	return cret
+}
+
+var xWebViewSessionStateSerialize func(uintptr) *glib.Bytes
+
+// Serializes a #WebKitWebViewSessionState.
+func (x *WebViewSessionState) Serialize() *glib.Bytes {
+
+	cret := xWebViewSessionStateSerialize(x.GoPointer())
+	return cret
+}
+
+var xWebViewSessionStateUnref func(uintptr)
+
+// Atomically decrements the reference count of @state by one.
+//
+// If the
+// reference count drops to 0, all memory allocated by the #WebKitWebViewSessionState is
+// released. This function is MT-safe and may be called from any thread.
+func (x *WebViewSessionState) Unref() {
+
+	xWebViewSessionStateUnref(x.GoPointer())
+
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xWebViewSessionStateGLibType, libs, "webkit_web_view_session_state_get_type")
+
+	core.PuregoSafeRegister(&xNewWebViewSessionState, libs, "webkit_web_view_session_state_new")
+
+	core.PuregoSafeRegister(&xWebViewSessionStateRef, libs, "webkit_web_view_session_state_ref")
+	core.PuregoSafeRegister(&xWebViewSessionStateSerialize, libs, "webkit_web_view_session_state_serialize")
+	core.PuregoSafeRegister(&xWebViewSessionStateUnref, libs, "webkit_web_view_session_state_unref")
+
+}
diff --git a/v4/webkit/WebKitWebsiteData.go b/v4/webkit/WebKitWebsiteData.go
new file mode 100644
index 0000000000000000000000000000000000000000..ed9c5da5b99e02a39daa1bc480d024259dc686ac
--- /dev/null
+++ b/v4/webkit/WebKitWebsiteData.go
@@ -0,0 +1,123 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Data stored locally by a web site.
+//
+// WebKitWebsiteData represents data stored in the client by a particular website.
+// A website is normally a set of URLs grouped by domain name. You can get the website name,
+// which is usually the domain, with webkit_website_data_get_name().
+// Documents loaded from the file system, like file:// URIs, are all grouped in the same WebKitWebsiteData
+// with the name "Local files".
+//
+// A website can store different types of data in the client side. #WebKitWebsiteDataTypes is an enum containing
+// all the possible data types; use webkit_website_data_get_types() to get the bitmask of data types.
+// It's also possible to know the size of the data stored for some of the #WebKitWebsiteDataTypes by using
+// webkit_website_data_get_size().
+//
+// A list of WebKitWebsiteData can be retrieved with webkit_website_data_manager_fetch(). See #WebKitWebsiteDataManager
+// for more information.
+type WebsiteData struct {
+	_ structs.HostLayout
+}
+
+var xWebsiteDataGLibType func() types.GType
+
+func WebsiteDataGLibType() types.GType {
+	return xWebsiteDataGLibType()
+}
+
+func (x *WebsiteData) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xWebsiteDataGetName func(uintptr) string
+
+// Gets the name of #WebKitWebsiteData.
+//
+// This is the website name, normally represented by
+// a domain or host name. All local documents are grouped in the same #WebKitWebsiteData using
+// the name "Local files".
+func (x *WebsiteData) GetName() string {
+
+	cret := xWebsiteDataGetName(x.GoPointer())
+	return cret
+}
+
+var xWebsiteDataGetSize func(uintptr, WebsiteDataTypes) uint64
+
+// Gets the size of the data of types @types in a #WebKitWebsiteData.
+//
+// Note that currently the data size is only known for %WEBKIT_WEBSITE_DATA_DISK_CACHE data type
+// so for all other types 0 will be returned.
+func (x *WebsiteData) GetSize(TypesVar WebsiteDataTypes) uint64 {
+
+	cret := xWebsiteDataGetSize(x.GoPointer(), TypesVar)
+	return cret
+}
+
+var xWebsiteDataGetTypes func(uintptr) WebsiteDataTypes
+
+// Gets the types of data stored in the client for a #WebKitWebsiteData.
+//
+// These are the
+// types actually present, not the types queried with webkit_website_data_manager_fetch().
+func (x *WebsiteData) GetTypes() WebsiteDataTypes {
+
+	cret := xWebsiteDataGetTypes(x.GoPointer())
+	return cret
+}
+
+var xWebsiteDataRef func(uintptr) *WebsiteData
+
+// Atomically increments the reference count of @website_data by one.
+//
+// This function is MT-safe and may be called from any thread.
+func (x *WebsiteData) Ref() *WebsiteData {
+
+	cret := xWebsiteDataRef(x.GoPointer())
+	return cret
+}
+
+var xWebsiteDataUnref func(uintptr)
+
+// Atomically decrements the reference count of @website_data by one.
+//
+// If the reference count drops to 0, all memory allocated by
+// #WebKitWebsiteData is released. This function is MT-safe and may be
+// called from any thread.
+func (x *WebsiteData) Unref() {
+
+	xWebsiteDataUnref(x.GoPointer())
+
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xWebsiteDataGLibType, libs, "webkit_website_data_get_type")
+
+	core.PuregoSafeRegister(&xWebsiteDataGetName, libs, "webkit_website_data_get_name")
+	core.PuregoSafeRegister(&xWebsiteDataGetSize, libs, "webkit_website_data_get_size")
+	core.PuregoSafeRegister(&xWebsiteDataGetTypes, libs, "webkit_website_data_get_types")
+	core.PuregoSafeRegister(&xWebsiteDataRef, libs, "webkit_website_data_ref")
+	core.PuregoSafeRegister(&xWebsiteDataUnref, libs, "webkit_website_data_unref")
+
+}
diff --git a/v4/webkit/WebKitWebsiteDataAccessPermissionRequest.go b/v4/webkit/WebKitWebsiteDataAccessPermissionRequest.go
new file mode 100644
index 0000000000000000000000000000000000000000..645dfe0501dab41e55ea32cd33aa938b31ac7ccf
--- /dev/null
+++ b/v4/webkit/WebKitWebsiteDataAccessPermissionRequest.go
@@ -0,0 +1,107 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type WebsiteDataAccessPermissionRequestClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *WebsiteDataAccessPermissionRequestClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// A permission request for accessing website data from third-party domains.
+//
+// WebKitWebsiteDataAccessPermissionRequest represents a request for
+// permission to allow a third-party domain access its cookies.
+//
+// When a WebKitWebsiteDataAccessPermissionRequest is not handled by the user,
+// it is denied by default.
+type WebsiteDataAccessPermissionRequest struct {
+	gobject.Object
+}
+
+var xWebsiteDataAccessPermissionRequestGLibType func() types.GType
+
+func WebsiteDataAccessPermissionRequestGLibType() types.GType {
+	return xWebsiteDataAccessPermissionRequestGLibType()
+}
+
+func WebsiteDataAccessPermissionRequestNewFromInternalPtr(ptr uintptr) *WebsiteDataAccessPermissionRequest {
+	cls := &WebsiteDataAccessPermissionRequest{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xWebsiteDataAccessPermissionRequestGetCurrentDomain func(uintptr) string
+
+// Get the current domain being browsed.
+func (x *WebsiteDataAccessPermissionRequest) GetCurrentDomain() string {
+
+	cret := xWebsiteDataAccessPermissionRequestGetCurrentDomain(x.GoPointer())
+	return cret
+}
+
+var xWebsiteDataAccessPermissionRequestGetRequestingDomain func(uintptr) string
+
+// Get the domain requesting permission to access its cookies while browsing the current domain.
+func (x *WebsiteDataAccessPermissionRequest) GetRequestingDomain() string {
+
+	cret := xWebsiteDataAccessPermissionRequestGetRequestingDomain(x.GoPointer())
+	return cret
+}
+
+func (c *WebsiteDataAccessPermissionRequest) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebsiteDataAccessPermissionRequest) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// Allow the action which triggered this request.
+func (x *WebsiteDataAccessPermissionRequest) Allow() {
+
+	XWebkitPermissionRequestAllow(x.GoPointer())
+
+}
+
+// Deny the action which triggered this request.
+func (x *WebsiteDataAccessPermissionRequest) Deny() {
+
+	XWebkitPermissionRequestDeny(x.GoPointer())
+
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xWebsiteDataAccessPermissionRequestGLibType, libs, "webkit_website_data_access_permission_request_get_type")
+
+	core.PuregoSafeRegister(&xWebsiteDataAccessPermissionRequestGetCurrentDomain, libs, "webkit_website_data_access_permission_request_get_current_domain")
+	core.PuregoSafeRegister(&xWebsiteDataAccessPermissionRequestGetRequestingDomain, libs, "webkit_website_data_access_permission_request_get_requesting_domain")
+
+}
diff --git a/v4/webkit/WebKitWebsiteDataManager.go b/v4/webkit/WebKitWebsiteDataManager.go
new file mode 100644
index 0000000000000000000000000000000000000000..53108dfa362161a24812aa151f285a1e3de557fe
--- /dev/null
+++ b/v4/webkit/WebKitWebsiteDataManager.go
@@ -0,0 +1,527 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gio"
+	"github.com/jwijenbergh/puregotk/v4/glib"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+// Describes a first party origin.
+type ITPFirstParty struct {
+	_ structs.HostLayout
+}
+
+var xITPFirstPartyGLibType func() types.GType
+
+func ITPFirstPartyGLibType() types.GType {
+	return xITPFirstPartyGLibType()
+}
+
+func (x *ITPFirstParty) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xITPFirstPartyGetDomain func(uintptr) string
+
+// Get the domain name of @itp_first_party.
+func (x *ITPFirstParty) GetDomain() string {
+
+	cret := xITPFirstPartyGetDomain(x.GoPointer())
+	return cret
+}
+
+var xITPFirstPartyGetLastUpdateTime func(uintptr) *glib.DateTime
+
+// Get the last time a #WebKitITPThirdParty has been seen under @itp_first_party.
+//
+// Each @WebKitITPFirstParty is created by webkit_itp_third_party_get_first_parties() and
+// therefore corresponds to exactly one #WebKitITPThirdParty.
+func (x *ITPFirstParty) GetLastUpdateTime() *glib.DateTime {
+
+	cret := xITPFirstPartyGetLastUpdateTime(x.GoPointer())
+	return cret
+}
+
+var xITPFirstPartyGetWebsiteDataAccessAllowed func(uintptr) bool
+
+// Get whether @itp_first_party has granted website data access to its #WebKitITPThirdParty.
+//
+// Each @WebKitITPFirstParty is created by webkit_itp_third_party_get_first_parties() and
+// therefore corresponds to exactly one #WebKitITPThirdParty.
+func (x *ITPFirstParty) GetWebsiteDataAccessAllowed() bool {
+
+	cret := xITPFirstPartyGetWebsiteDataAccessAllowed(x.GoPointer())
+	return cret
+}
+
+var xITPFirstPartyRef func(uintptr) *ITPFirstParty
+
+// Atomically increments the reference count of @itp_first_party by one.
+//
+// This function is MT-safe and may be called from any thread.
+func (x *ITPFirstParty) Ref() *ITPFirstParty {
+
+	cret := xITPFirstPartyRef(x.GoPointer())
+	return cret
+}
+
+var xITPFirstPartyUnref func(uintptr)
+
+// Atomically decrements the reference count of @itp_first_party by one.
+//
+// If the reference count drops to 0, all memory allocated by
+// #WebKitITPFirstParty is released. This function is MT-safe and may be
+// called from any thread.
+func (x *ITPFirstParty) Unref() {
+
+	xITPFirstPartyUnref(x.GoPointer())
+
+}
+
+// Describes a third party origin.
+type ITPThirdParty struct {
+	_ structs.HostLayout
+}
+
+var xITPThirdPartyGLibType func() types.GType
+
+func ITPThirdPartyGLibType() types.GType {
+	return xITPThirdPartyGLibType()
+}
+
+func (x *ITPThirdParty) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+var xITPThirdPartyGetDomain func(uintptr) string
+
+// Get the domain name of @itp_third_party.
+func (x *ITPThirdParty) GetDomain() string {
+
+	cret := xITPThirdPartyGetDomain(x.GoPointer())
+	return cret
+}
+
+var xITPThirdPartyGetFirstParties func(uintptr) *glib.List
+
+// Get the list of #WebKitITPFirstParty under which @itp_third_party has been seen.
+func (x *ITPThirdParty) GetFirstParties() *glib.List {
+
+	cret := xITPThirdPartyGetFirstParties(x.GoPointer())
+	return cret
+}
+
+var xITPThirdPartyRef func(uintptr) *ITPThirdParty
+
+// Atomically increments the reference count of @itp_third_party by one.
+//
+// This function is MT-safe and may be called from any thread.
+func (x *ITPThirdParty) Ref() *ITPThirdParty {
+
+	cret := xITPThirdPartyRef(x.GoPointer())
+	return cret
+}
+
+var xITPThirdPartyUnref func(uintptr)
+
+// Atomically decrements the reference count of @itp_third_party by one.
+//
+// If the reference count drops to 0, all memory allocated by
+// #WebKitITPThirdParty is released. This function is MT-safe and may be
+// called from any thread.
+func (x *ITPThirdParty) Unref() {
+
+	xITPThirdPartyUnref(x.GoPointer())
+
+}
+
+type WebsiteDataManagerClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *WebsiteDataManagerClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values used to denote the TLS errors policy.
+type TLSErrorsPolicy int
+
+var xTLSErrorsPolicyGLibType func() types.GType
+
+func TLSErrorsPolicyGLibType() types.GType {
+	return xTLSErrorsPolicyGLibType()
+}
+
+const (
+
+	// Ignore TLS errors.
+	TlsErrorsPolicyIgnoreValue TLSErrorsPolicy = 0
+	// TLS errors will emit
+	//   #WebKitWebView::load-failed-with-tls-errors and, if the signal is handled,
+	//   finish the load. In case the signal is not handled,
+	//   #WebKitWebView::load-failed is emitted before the load finishes.
+	TlsErrorsPolicyFailValue TLSErrorsPolicy = 1
+)
+
+// Manages data stored locally by web sites.
+//
+// You can use WebKitWebsiteDataManager to configure the local directories
+// where website data will be stored. Use #WebKitWebsiteDataManager:base-data-directory
+// and #WebKitWebsiteDataManager:base-cache-directory set a common base directory for all
+// website data and caches.
+//
+// A WebKitWebsiteDataManager can be ephemeral, in which case all the directory configuration
+// is not needed because website data will never persist. You can create an ephemeral WebKitWebsiteDataManager
+// with webkit_website_data_manager_new_ephemeral().
+//
+// WebKitWebsiteDataManager can also be used to fetch website data, remove data
+// stored by particular websites, or clear data for all websites modified since a given
+// period of time.
+type WebsiteDataManager struct {
+	gobject.Object
+}
+
+var xWebsiteDataManagerGLibType func() types.GType
+
+func WebsiteDataManagerGLibType() types.GType {
+	return xWebsiteDataManagerGLibType()
+}
+
+func WebsiteDataManagerNewFromInternalPtr(ptr uintptr) *WebsiteDataManager {
+	cls := &WebsiteDataManager{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xWebsiteDataManagerClear func(uintptr, WebsiteDataTypes, glib.TimeSpan, uintptr, uintptr, uintptr)
+
+// Asynchronously clear the website data of the given @types modified in the past @timespan.
+//
+// If @timespan is 0, all website data will be removed.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_website_data_manager_clear_finish() to get the result of the operation.
+//
+// Due to implementation limitations, this function does not currently delete
+// any stored cookies if @timespan is nonzero. This behavior may change in the
+// future.
+func (x *WebsiteDataManager) Clear(TypesVar WebsiteDataTypes, TimespanVar glib.TimeSpan, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebsiteDataManagerClear(x.GoPointer(), TypesVar, TimespanVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebsiteDataManagerClearFinish func(uintptr, uintptr, **glib.Error) bool
+
+// Finish an asynchronous operation started with webkit_website_data_manager_clear()
+func (x *WebsiteDataManager) ClearFinish(ResultVar gio.AsyncResult) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xWebsiteDataManagerClearFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebsiteDataManagerFetch func(uintptr, WebsiteDataTypes, uintptr, uintptr, uintptr)
+
+// Asynchronously get the list of #WebKitWebsiteData for the given @types.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_website_data_manager_fetch_finish() to get the result of the operation.
+func (x *WebsiteDataManager) Fetch(TypesVar WebsiteDataTypes, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebsiteDataManagerFetch(x.GoPointer(), TypesVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebsiteDataManagerFetchFinish func(uintptr, uintptr, **glib.Error) *glib.List
+
+// Finish an asynchronous operation started with webkit_website_data_manager_fetch().
+func (x *WebsiteDataManager) FetchFinish(ResultVar gio.AsyncResult) (*glib.List, error) {
+	var cerr *glib.Error
+
+	cret := xWebsiteDataManagerFetchFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebsiteDataManagerGetBaseCacheDirectory func(uintptr) string
+
+// Get the #WebKitWebsiteDataManager:base-cache-directory property.
+func (x *WebsiteDataManager) GetBaseCacheDirectory() string {
+
+	cret := xWebsiteDataManagerGetBaseCacheDirectory(x.GoPointer())
+	return cret
+}
+
+var xWebsiteDataManagerGetBaseDataDirectory func(uintptr) string
+
+// Get the #WebKitWebsiteDataManager:base-data-directory property.
+func (x *WebsiteDataManager) GetBaseDataDirectory() string {
+
+	cret := xWebsiteDataManagerGetBaseDataDirectory(x.GoPointer())
+	return cret
+}
+
+var xWebsiteDataManagerGetFaviconDatabase func(uintptr) uintptr
+
+// Get the #WebKitFaviconDatabase of @manager.
+func (x *WebsiteDataManager) GetFaviconDatabase() *FaviconDatabase {
+	var cls *FaviconDatabase
+
+	cret := xWebsiteDataManagerGetFaviconDatabase(x.GoPointer())
+
+	if cret == 0 {
+		return nil
+	}
+	gobject.IncreaseRef(cret)
+	cls = &FaviconDatabase{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebsiteDataManagerGetFaviconsEnabled func(uintptr) bool
+
+// Get whether website icons are enabled.
+func (x *WebsiteDataManager) GetFaviconsEnabled() bool {
+
+	cret := xWebsiteDataManagerGetFaviconsEnabled(x.GoPointer())
+	return cret
+}
+
+var xWebsiteDataManagerGetItpSummary func(uintptr, uintptr, uintptr, uintptr)
+
+// Asynchronously get the list of #WebKitITPThirdParty seen for @manager.
+//
+// Every #WebKitITPThirdParty
+// contains the list of #WebKitITPFirstParty under which it has been seen.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_website_data_manager_get_itp_summary_finish() to get the result of the operation.
+func (x *WebsiteDataManager) GetItpSummary(CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebsiteDataManagerGetItpSummary(x.GoPointer(), CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebsiteDataManagerGetItpSummaryFinish func(uintptr, uintptr, **glib.Error) *glib.List
+
+// Finish an asynchronous operation started with webkit_website_data_manager_get_itp_summary().
+func (x *WebsiteDataManager) GetItpSummaryFinish(ResultVar gio.AsyncResult) (*glib.List, error) {
+	var cerr *glib.Error
+
+	cret := xWebsiteDataManagerGetItpSummaryFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebsiteDataManagerIsEphemeral func(uintptr) bool
+
+// Get whether a #WebKitWebsiteDataManager is ephemeral.
+//
+// See #WebKitWebsiteDataManager:is-ephemeral for more details.
+func (x *WebsiteDataManager) IsEphemeral() bool {
+
+	cret := xWebsiteDataManagerIsEphemeral(x.GoPointer())
+	return cret
+}
+
+var xWebsiteDataManagerRemove func(uintptr, WebsiteDataTypes, *glib.List, uintptr, uintptr, uintptr)
+
+// Asynchronously removes the website data in the given @website_data list.
+//
+// Asynchronously removes the website data of the given @types for websites in the given @website_data list.
+// Use webkit_website_data_manager_clear() if you want to remove the website data for all sites.
+//
+// When the operation is finished, @callback will be called. You can then call
+// webkit_website_data_manager_remove_finish() to get the result of the operation.
+func (x *WebsiteDataManager) Remove(TypesVar WebsiteDataTypes, WebsiteDataVar *glib.List, CancellableVar *gio.Cancellable, CallbackVar *gio.AsyncReadyCallback, UserDataVar uintptr) {
+
+	xWebsiteDataManagerRemove(x.GoPointer(), TypesVar, WebsiteDataVar, CancellableVar.GoPointer(), glib.NewCallbackNullable(CallbackVar), UserDataVar)
+
+}
+
+var xWebsiteDataManagerRemoveFinish func(uintptr, uintptr, **glib.Error) bool
+
+// Finish an asynchronous operation started with webkit_website_data_manager_remove().
+func (x *WebsiteDataManager) RemoveFinish(ResultVar gio.AsyncResult) (bool, error) {
+	var cerr *glib.Error
+
+	cret := xWebsiteDataManagerRemoveFinish(x.GoPointer(), ResultVar.GoPointer(), &cerr)
+	if cerr == nil {
+		return cret, nil
+	}
+	return cret, cerr
+
+}
+
+var xWebsiteDataManagerSetFaviconsEnabled func(uintptr, bool)
+
+// Set whether website icons are enabled. Website icons are disabled by default.
+// When website icons are disabled, the #WebKitFaviconDatabase of @manager is closed and
+// its reference removed, so webkit_website_data_manager_get_favicon_database() will
+// return %NULL. If website icons are enabled again, a new #WebKitFaviconDatabase will
+// be created.
+func (x *WebsiteDataManager) SetFaviconsEnabled(EnabledVar bool) {
+
+	xWebsiteDataManagerSetFaviconsEnabled(x.GoPointer(), EnabledVar)
+
+}
+
+func (c *WebsiteDataManager) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebsiteDataManager) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyBaseCacheDirectory sets the "base-cache-directory" property.
+// The base directory for caches. If %NULL, a default location will be used.
+func (x *WebsiteDataManager) SetPropertyBaseCacheDirectory(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("base-cache-directory", &v)
+}
+
+// GetPropertyBaseCacheDirectory gets the "base-cache-directory" property.
+// The base directory for caches. If %NULL, a default location will be used.
+func (x *WebsiteDataManager) GetPropertyBaseCacheDirectory() string {
+	var v gobject.Value
+	x.GetProperty("base-cache-directory", &v)
+	return v.GetString()
+}
+
+// SetPropertyBaseDataDirectory sets the "base-data-directory" property.
+// The base directory for website data. If %NULL, a default location will be used.
+func (x *WebsiteDataManager) SetPropertyBaseDataDirectory(value string) {
+	var v gobject.Value
+	v.Init(gobject.TypeStringVal)
+	v.SetString(value)
+	x.SetProperty("base-data-directory", &v)
+}
+
+// GetPropertyBaseDataDirectory gets the "base-data-directory" property.
+// The base directory for website data. If %NULL, a default location will be used.
+func (x *WebsiteDataManager) GetPropertyBaseDataDirectory() string {
+	var v gobject.Value
+	x.GetProperty("base-data-directory", &v)
+	return v.GetString()
+}
+
+// SetPropertyIsEphemeral sets the "is-ephemeral" property.
+// Whether the #WebKitWebsiteDataManager is ephemeral. An ephemeral #WebKitWebsiteDataManager
+// handles all websites data as non-persistent, and nothing will be written to the client
+// storage. Note that if you create an ephemeral #WebKitWebsiteDataManager all other construction
+// parameters to configure data directories will be ignored.
+func (x *WebsiteDataManager) SetPropertyIsEphemeral(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("is-ephemeral", &v)
+}
+
+// GetPropertyIsEphemeral gets the "is-ephemeral" property.
+// Whether the #WebKitWebsiteDataManager is ephemeral. An ephemeral #WebKitWebsiteDataManager
+// handles all websites data as non-persistent, and nothing will be written to the client
+// storage. Note that if you create an ephemeral #WebKitWebsiteDataManager all other construction
+// parameters to configure data directories will be ignored.
+func (x *WebsiteDataManager) GetPropertyIsEphemeral() bool {
+	var v gobject.Value
+	x.GetProperty("is-ephemeral", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyOriginStorageRatio sets the "origin-storage-ratio" property.
+// The percentage of volume space that can be used for data storage for every domain.
+// If the maximum storage is reached the storage request will fail with a QuotaExceededError exception.
+// A value of 0.0 means that data storage is not allowed. A value of -1.0, which is the default,
+// means WebKit will use the default quota (1 GiB).
+func (x *WebsiteDataManager) SetPropertyOriginStorageRatio(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("origin-storage-ratio", &v)
+}
+
+// SetPropertyTotalStorageRatio sets the "total-storage-ratio" property.
+// The percentage of volume space that can be used for data storage for all domains.
+// If the maximum storage is reached the eviction will happen.
+// A value of 0.0 means that data storage is not allowed. A value of -1.0, which is the default,
+// means there's no limit for the total storage.
+func (x *WebsiteDataManager) SetPropertyTotalStorageRatio(value float64) {
+	var v gobject.Value
+	v.Init(gobject.TypeDoubleVal)
+	v.SetDouble(value)
+	x.SetProperty("total-storage-ratio", &v)
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xTLSErrorsPolicyGLibType, libs, "webkit_tls_errors_policy_get_type")
+
+	core.PuregoSafeRegister(&xITPFirstPartyGLibType, libs, "webkit_itp_first_party_get_type")
+
+	core.PuregoSafeRegister(&xITPFirstPartyGetDomain, libs, "webkit_itp_first_party_get_domain")
+	core.PuregoSafeRegister(&xITPFirstPartyGetLastUpdateTime, libs, "webkit_itp_first_party_get_last_update_time")
+	core.PuregoSafeRegister(&xITPFirstPartyGetWebsiteDataAccessAllowed, libs, "webkit_itp_first_party_get_website_data_access_allowed")
+	core.PuregoSafeRegister(&xITPFirstPartyRef, libs, "webkit_itp_first_party_ref")
+	core.PuregoSafeRegister(&xITPFirstPartyUnref, libs, "webkit_itp_first_party_unref")
+
+	core.PuregoSafeRegister(&xITPThirdPartyGLibType, libs, "webkit_itp_third_party_get_type")
+
+	core.PuregoSafeRegister(&xITPThirdPartyGetDomain, libs, "webkit_itp_third_party_get_domain")
+	core.PuregoSafeRegister(&xITPThirdPartyGetFirstParties, libs, "webkit_itp_third_party_get_first_parties")
+	core.PuregoSafeRegister(&xITPThirdPartyRef, libs, "webkit_itp_third_party_ref")
+	core.PuregoSafeRegister(&xITPThirdPartyUnref, libs, "webkit_itp_third_party_unref")
+
+	core.PuregoSafeRegister(&xWebsiteDataManagerGLibType, libs, "webkit_website_data_manager_get_type")
+
+	core.PuregoSafeRegister(&xWebsiteDataManagerClear, libs, "webkit_website_data_manager_clear")
+	core.PuregoSafeRegister(&xWebsiteDataManagerClearFinish, libs, "webkit_website_data_manager_clear_finish")
+	core.PuregoSafeRegister(&xWebsiteDataManagerFetch, libs, "webkit_website_data_manager_fetch")
+	core.PuregoSafeRegister(&xWebsiteDataManagerFetchFinish, libs, "webkit_website_data_manager_fetch_finish")
+	core.PuregoSafeRegister(&xWebsiteDataManagerGetBaseCacheDirectory, libs, "webkit_website_data_manager_get_base_cache_directory")
+	core.PuregoSafeRegister(&xWebsiteDataManagerGetBaseDataDirectory, libs, "webkit_website_data_manager_get_base_data_directory")
+	core.PuregoSafeRegister(&xWebsiteDataManagerGetFaviconDatabase, libs, "webkit_website_data_manager_get_favicon_database")
+	core.PuregoSafeRegister(&xWebsiteDataManagerGetFaviconsEnabled, libs, "webkit_website_data_manager_get_favicons_enabled")
+	core.PuregoSafeRegister(&xWebsiteDataManagerGetItpSummary, libs, "webkit_website_data_manager_get_itp_summary")
+	core.PuregoSafeRegister(&xWebsiteDataManagerGetItpSummaryFinish, libs, "webkit_website_data_manager_get_itp_summary_finish")
+	core.PuregoSafeRegister(&xWebsiteDataManagerIsEphemeral, libs, "webkit_website_data_manager_is_ephemeral")
+	core.PuregoSafeRegister(&xWebsiteDataManagerRemove, libs, "webkit_website_data_manager_remove")
+	core.PuregoSafeRegister(&xWebsiteDataManagerRemoveFinish, libs, "webkit_website_data_manager_remove_finish")
+	core.PuregoSafeRegister(&xWebsiteDataManagerSetFaviconsEnabled, libs, "webkit_website_data_manager_set_favicons_enabled")
+
+}
diff --git a/v4/webkit/WebKitWebsitePolicies.go b/v4/webkit/WebKitWebsitePolicies.go
new file mode 100644
index 0000000000000000000000000000000000000000..e7ff279654aa2d198c3dd200a4aa8b8fbecc08f1
--- /dev/null
+++ b/v4/webkit/WebKitWebsitePolicies.go
@@ -0,0 +1,140 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type WebsitePoliciesClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *WebsitePoliciesClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Enum values used to specify autoplay policies.
+type AutoplayPolicy int
+
+var xAutoplayPolicyGLibType func() types.GType
+
+func AutoplayPolicyGLibType() types.GType {
+	return xAutoplayPolicyGLibType()
+}
+
+const (
+
+	// Do not restrict autoplay.
+	AutoplayAllowValue AutoplayPolicy = 0
+	// Allow videos to autoplay if
+	//     they have no audio track, or if their audio track is muted.
+	AutoplayAllowWithoutSoundValue AutoplayPolicy = 1
+	// Never allow autoplay.
+	AutoplayDenyValue AutoplayPolicy = 2
+)
+
+// View specific website policies.
+//
+// WebKitWebsitePolicies allows you to configure per-page policies,
+// currently only autoplay policies are supported.
+type WebsitePolicies struct {
+	gobject.Object
+}
+
+var xWebsitePoliciesGLibType func() types.GType
+
+func WebsitePoliciesGLibType() types.GType {
+	return xWebsitePoliciesGLibType()
+}
+
+func WebsitePoliciesNewFromInternalPtr(ptr uintptr) *WebsitePolicies {
+	cls := &WebsitePolicies{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xNewWebsitePolicies func() uintptr
+
+// Create a new #WebKitWebsitePolicies.
+func NewWebsitePolicies() *WebsitePolicies {
+	var cls *WebsitePolicies
+
+	cret := xNewWebsitePolicies()
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &WebsitePolicies{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xNewWebsitePoliciesWithPolicies func(string, ...interface{}) uintptr
+
+// Create a new #WebKitWebsitePolicies with given policies.
+//
+// Create a new #WebKitWebsitePolicies with policies given as variadic
+// arguments.
+func NewWebsitePoliciesWithPolicies(FirstPolicyNameVar string, varArgs ...interface{}) *WebsitePolicies {
+	var cls *WebsitePolicies
+
+	cret := xNewWebsitePoliciesWithPolicies(FirstPolicyNameVar, varArgs...)
+
+	if cret == 0 {
+		return nil
+	}
+	cls = &WebsitePolicies{}
+	cls.Ptr = cret
+	return cls
+}
+
+var xWebsitePoliciesGetAutoplayPolicy func(uintptr) AutoplayPolicy
+
+// Get the #WebKitWebsitePolicies:autoplay property.
+func (x *WebsitePolicies) GetAutoplayPolicy() AutoplayPolicy {
+
+	cret := xWebsitePoliciesGetAutoplayPolicy(x.GoPointer())
+	return cret
+}
+
+func (c *WebsitePolicies) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WebsitePolicies) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xAutoplayPolicyGLibType, libs, "webkit_autoplay_policy_get_type")
+
+	core.PuregoSafeRegister(&xWebsitePoliciesGLibType, libs, "webkit_website_policies_get_type")
+
+	core.PuregoSafeRegister(&xNewWebsitePolicies, libs, "webkit_website_policies_new")
+	core.PuregoSafeRegister(&xNewWebsitePoliciesWithPolicies, libs, "webkit_website_policies_new_with_policies")
+
+	core.PuregoSafeRegister(&xWebsitePoliciesGetAutoplayPolicy, libs, "webkit_website_policies_get_autoplay_policy")
+
+}
diff --git a/v4/webkit/WebKitWindowProperties.go b/v4/webkit/WebKitWindowProperties.go
new file mode 100644
index 0000000000000000000000000000000000000000..ec59e85d3d7d507b70dbbd23c444f4efdba9de3d
--- /dev/null
+++ b/v4/webkit/WebKitWindowProperties.go
@@ -0,0 +1,339 @@
+// Package webkit was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
+package webkit
+
+import (
+	"structs"
+	"unsafe"
+
+	"github.com/jwijenbergh/purego"
+	"github.com/jwijenbergh/puregotk/pkg/core"
+	"github.com/jwijenbergh/puregotk/v4/gdk"
+	"github.com/jwijenbergh/puregotk/v4/gobject"
+	"github.com/jwijenbergh/puregotk/v4/gobject/types"
+)
+
+type WindowPropertiesClass struct {
+	_ structs.HostLayout
+
+	ParentClass gobject.ObjectClass
+}
+
+func (x *WindowPropertiesClass) GoPointer() uintptr {
+	return uintptr(unsafe.Pointer(x))
+}
+
+// Window properties of a #WebKitWebView.
+//
+// The content of a #WebKitWebView can request to change certain
+// properties of the window containing the view. This can include the x, y position
+// of the window, the width and height but also if a toolbar,
+// scrollbar, statusbar, locationbar should be visible to the user,
+// and the request to show the #WebKitWebView fullscreen.
+//
+// The #WebKitWebView::ready-to-show signal handler is the proper place
+// to apply the initial window properties. Then you can monitor the
+// #WebKitWindowProperties by connecting to ::notify signal.
+//
+// ```c
+// static void ready_to_show_cb (WebKitWebView *web_view, gpointer user_data)
+//
+//	{
+//	    GtkWidget *window;
+//	    WebKitWindowProperties *window_properties;
+//	    gboolean visible;
+//
+//	    // Create the window to contain the WebKitWebView.
+//	    window = browser_window_new ();
+//	    gtk_container_add (GTK_CONTAINER (window), GTK_WIDGET (web_view));
+//	    gtk_widget_show (GTK_WIDGET (web_view));
+//
+//	    // Get the WebKitWindowProperties of the web view and monitor it.
+//	    window_properties = webkit_web_view_get_window_properties (web_view);
+//	    g_signal_connect (window_properties, "notify::geometry",
+//	                      G_CALLBACK (window_geometry_changed), window);
+//	    g_signal_connect (window_properties, "notify::toolbar-visible",
+//	                      G_CALLBACK (window_toolbar_visibility_changed), window);
+//	    g_signal_connect (window_properties, "notify::menubar-visible",
+//	                      G_CALLBACK (window_menubar_visibility_changed), window);
+//
+//	    // Apply the window properties before showing the window.
+//	    visible = webkit_window_properties_get_toolbar_visible (window_properties);
+//	    browser_window_set_toolbar_visible (BROWSER_WINDOW (window), visible);
+//	    visible = webkit_window_properties_get_menubar_visible (window_properties);
+//	    browser_window_set_menubar_visible (BROWSER_WINDOW (window), visible);
+//
+//	    if (webkit_window_properties_get_fullscreen (window_properties)) {
+//	        gtk_window_fullscreen (GTK_WINDOW (window));
+//	    } else {
+//	        GdkRectangle geometry;
+//
+//	        gtk_window_set_resizable (GTK_WINDOW (window),
+//	                                  webkit_window_properties_get_resizable (window_properties));
+//	        webkit_window_properties_get_geometry (window_properties, &amp;geometry);
+//	        gtk_window_move (GTK_WINDOW (window), geometry.x, geometry.y);
+//	        gtk_window_resize (GTK_WINDOW (window), geometry.width, geometry.height);
+//	    }
+//
+//	    gtk_widget_show (window);
+//	}
+//
+// ```
+type WindowProperties struct {
+	gobject.Object
+}
+
+var xWindowPropertiesGLibType func() types.GType
+
+func WindowPropertiesGLibType() types.GType {
+	return xWindowPropertiesGLibType()
+}
+
+func WindowPropertiesNewFromInternalPtr(ptr uintptr) *WindowProperties {
+	cls := &WindowProperties{}
+	cls.Ptr = ptr
+	return cls
+}
+
+var xWindowPropertiesGetFullscreen func(uintptr) bool
+
+// Get whether the window should be shown in fullscreen state or not.
+func (x *WindowProperties) GetFullscreen() bool {
+
+	cret := xWindowPropertiesGetFullscreen(x.GoPointer())
+	return cret
+}
+
+var xWindowPropertiesGetGeometry func(uintptr, *gdk.Rectangle)
+
+// Get the geometry the window should have on the screen when shown.
+func (x *WindowProperties) GetGeometry(GeometryVar *gdk.Rectangle) {
+
+	xWindowPropertiesGetGeometry(x.GoPointer(), GeometryVar)
+
+}
+
+var xWindowPropertiesGetLocationbarVisible func(uintptr) bool
+
+// Get whether the window should have the locationbar visible or not.
+func (x *WindowProperties) GetLocationbarVisible() bool {
+
+	cret := xWindowPropertiesGetLocationbarVisible(x.GoPointer())
+	return cret
+}
+
+var xWindowPropertiesGetMenubarVisible func(uintptr) bool
+
+// Get whether the window should have the menubar visible or not.
+func (x *WindowProperties) GetMenubarVisible() bool {
+
+	cret := xWindowPropertiesGetMenubarVisible(x.GoPointer())
+	return cret
+}
+
+var xWindowPropertiesGetResizable func(uintptr) bool
+
+// Get whether the window should be resizable by the user or not.
+func (x *WindowProperties) GetResizable() bool {
+
+	cret := xWindowPropertiesGetResizable(x.GoPointer())
+	return cret
+}
+
+var xWindowPropertiesGetScrollbarsVisible func(uintptr) bool
+
+// Get whether the window should have the scrollbars visible or not.
+func (x *WindowProperties) GetScrollbarsVisible() bool {
+
+	cret := xWindowPropertiesGetScrollbarsVisible(x.GoPointer())
+	return cret
+}
+
+var xWindowPropertiesGetStatusbarVisible func(uintptr) bool
+
+// Get whether the window should have the statusbar visible or not.
+func (x *WindowProperties) GetStatusbarVisible() bool {
+
+	cret := xWindowPropertiesGetStatusbarVisible(x.GoPointer())
+	return cret
+}
+
+var xWindowPropertiesGetToolbarVisible func(uintptr) bool
+
+// Get whether the window should have the toolbar visible or not.
+func (x *WindowProperties) GetToolbarVisible() bool {
+
+	cret := xWindowPropertiesGetToolbarVisible(x.GoPointer())
+	return cret
+}
+
+func (c *WindowProperties) GoPointer() uintptr {
+	if c == nil {
+		return 0
+	}
+	return c.Ptr
+}
+
+func (c *WindowProperties) SetGoPointer(ptr uintptr) {
+	c.Ptr = ptr
+}
+
+// SetPropertyFullscreen sets the "fullscreen" property.
+// Whether window will be displayed fullscreen.
+func (x *WindowProperties) SetPropertyFullscreen(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("fullscreen", &v)
+}
+
+// GetPropertyFullscreen gets the "fullscreen" property.
+// Whether window will be displayed fullscreen.
+func (x *WindowProperties) GetPropertyFullscreen() bool {
+	var v gobject.Value
+	x.GetProperty("fullscreen", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyGeometry sets the "geometry" property.
+// The size and position of the window on the screen.
+func (x *WindowProperties) SetPropertyGeometry(value uintptr) {
+	var v gobject.Value
+	v.Init(gobject.TypePointerVal)
+	v.SetPointer(value)
+	x.SetProperty("geometry", &v)
+}
+
+// GetPropertyGeometry gets the "geometry" property.
+// The size and position of the window on the screen.
+func (x *WindowProperties) GetPropertyGeometry() uintptr {
+	var v gobject.Value
+	x.GetProperty("geometry", &v)
+	return v.GetPointer()
+}
+
+// SetPropertyLocationbarVisible sets the "locationbar-visible" property.
+// Whether the locationbar should be visible for the window.
+func (x *WindowProperties) SetPropertyLocationbarVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("locationbar-visible", &v)
+}
+
+// GetPropertyLocationbarVisible gets the "locationbar-visible" property.
+// Whether the locationbar should be visible for the window.
+func (x *WindowProperties) GetPropertyLocationbarVisible() bool {
+	var v gobject.Value
+	x.GetProperty("locationbar-visible", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyMenubarVisible sets the "menubar-visible" property.
+// Whether the menubar should be visible for the window.
+func (x *WindowProperties) SetPropertyMenubarVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("menubar-visible", &v)
+}
+
+// GetPropertyMenubarVisible gets the "menubar-visible" property.
+// Whether the menubar should be visible for the window.
+func (x *WindowProperties) GetPropertyMenubarVisible() bool {
+	var v gobject.Value
+	x.GetProperty("menubar-visible", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyResizable sets the "resizable" property.
+// Whether the window can be resized.
+func (x *WindowProperties) SetPropertyResizable(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("resizable", &v)
+}
+
+// GetPropertyResizable gets the "resizable" property.
+// Whether the window can be resized.
+func (x *WindowProperties) GetPropertyResizable() bool {
+	var v gobject.Value
+	x.GetProperty("resizable", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyScrollbarsVisible sets the "scrollbars-visible" property.
+// Whether the scrollbars should be visible for the window.
+func (x *WindowProperties) SetPropertyScrollbarsVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("scrollbars-visible", &v)
+}
+
+// GetPropertyScrollbarsVisible gets the "scrollbars-visible" property.
+// Whether the scrollbars should be visible for the window.
+func (x *WindowProperties) GetPropertyScrollbarsVisible() bool {
+	var v gobject.Value
+	x.GetProperty("scrollbars-visible", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyStatusbarVisible sets the "statusbar-visible" property.
+// Whether the statusbar should be visible for the window.
+func (x *WindowProperties) SetPropertyStatusbarVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("statusbar-visible", &v)
+}
+
+// GetPropertyStatusbarVisible gets the "statusbar-visible" property.
+// Whether the statusbar should be visible for the window.
+func (x *WindowProperties) GetPropertyStatusbarVisible() bool {
+	var v gobject.Value
+	x.GetProperty("statusbar-visible", &v)
+	return v.GetBoolean()
+}
+
+// SetPropertyToolbarVisible sets the "toolbar-visible" property.
+// Whether the toolbar should be visible for the window.
+func (x *WindowProperties) SetPropertyToolbarVisible(value bool) {
+	var v gobject.Value
+	v.Init(gobject.TypeBooleanVal)
+	v.SetBoolean(value)
+	x.SetProperty("toolbar-visible", &v)
+}
+
+// GetPropertyToolbarVisible gets the "toolbar-visible" property.
+// Whether the toolbar should be visible for the window.
+func (x *WindowProperties) GetPropertyToolbarVisible() bool {
+	var v gobject.Value
+	x.GetProperty("toolbar-visible", &v)
+	return v.GetBoolean()
+}
+
+func init() {
+	core.SetPackageName("WEBKIT", "webkitgtk-6.0")
+	core.SetSharedLibraries("WEBKIT", []string{"libwebkitgtk-6.0.so.4", "libjavascriptcoregtk-6.0.so.1"})
+	var libs []uintptr
+	for _, libPath := range core.GetPaths("WEBKIT") {
+		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
+		if err != nil {
+			panic(err)
+		}
+		libs = append(libs, lib)
+	}
+
+	core.PuregoSafeRegister(&xWindowPropertiesGLibType, libs, "webkit_window_properties_get_type")
+
+	core.PuregoSafeRegister(&xWindowPropertiesGetFullscreen, libs, "webkit_window_properties_get_fullscreen")
+	core.PuregoSafeRegister(&xWindowPropertiesGetGeometry, libs, "webkit_window_properties_get_geometry")
+	core.PuregoSafeRegister(&xWindowPropertiesGetLocationbarVisible, libs, "webkit_window_properties_get_locationbar_visible")
+	core.PuregoSafeRegister(&xWindowPropertiesGetMenubarVisible, libs, "webkit_window_properties_get_menubar_visible")
+	core.PuregoSafeRegister(&xWindowPropertiesGetResizable, libs, "webkit_window_properties_get_resizable")
+	core.PuregoSafeRegister(&xWindowPropertiesGetScrollbarsVisible, libs, "webkit_window_properties_get_scrollbars_visible")
+	core.PuregoSafeRegister(&xWindowPropertiesGetStatusbarVisible, libs, "webkit_window_properties_get_statusbar_visible")
+	core.PuregoSafeRegister(&xWindowPropertiesGetToolbarVisible, libs, "webkit_window_properties_get_toolbar_visible")
+
+}

